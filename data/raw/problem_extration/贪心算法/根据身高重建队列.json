{
  "id": "AP_39700ec3",
  "title": "根据身高重建队列",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/queue-reconstruction-by-height/",
  "description": "重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "贪心算法",
    "排序"
  ],
  "data_structure_tags": [
    "列表",
    "链表"
  ],
  "technique_tags": [
    "自定义比较器",
    "迭代器操作",
    "插入排序"
  ],
  "difficulty": null,
  "solution_approach": "首先按照身高从高到低对people数组进行排序（如果身高相同，则按k从小到大排序）。然后依次将每个人插入到结果队列的第k个位置。这样可以确保每次插入时，前面已有确切数量的人比当前人高或等高。",
  "key_insights": [
    {
      "content": "通过先安排较高的个体，保证了后续插入的较矮个体不会影响已确定的相对位置关系。"
    },
    {
      "content": "利用C++中的list容器代替vector来实现插入操作，可以显著减少因频繁插入导致的时间复杂度增加。"
    },
    {
      "content": "在处理两个维度问题时，优先解决一个维度后再处理另一个维度，能有效简化问题并避免顾此失彼的情况发生。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: static bool cmp(const vector<int>& a, const vector<int>& b) { if (a[0] == b[0]) return a[1] < b[1]; return a[0] > b[0]; } vector<vector<int>> reconstructQueue(vector<vector<int>>& people) { sort (people.begin(), people.end(), cmp); vector<vector<int>> que; for (int i = 0; i < people.size(); i++) { int position = people[i][1]; que.insert(que.begin() + position, people[i]); } return que; }};",
          "description": "C++版本一，使用vector进行插入操作。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: static bool cmp(const vector<int>& a, const vector<int>& b) { if (a[0] == b[0]) return a[1] < b[1]; return a[0] > b[0]; } vector<vector<int>> reconstructQueue(vector<vector<int>>& people) { sort (people.begin(), people.end(), cmp); list<vector<int>> que; for (int i = 0; i < people.size(); i++) { int position = people[i][1]; std::list<vector<int>>::iterator it = que.begin(); while (position--) { it++; } que.insert(it, people[i]); } return vector<vector<int>>(que.begin(), que.end()); }};",
          "description": "C++版本二，使用list提高插入效率。"
        },
        {
          "language": "java",
          "code": "class Solution { public int[][] reconstructQueue(int[][] people) { Arrays.sort(people, (a, b) -> { if (a[0] == b[0]) return a[1] - b[1]; return b[0] - a[0]; }); LinkedList<int[]> que = new LinkedList<>(); for (int[] p : people) { que.add(p[1],p); } return que.toArray(new int[people.length][]); }}",
          "description": "Java版本，使用LinkedList进行高效插入。"
        },
        {
          "language": "python",
          "code": "class Solution: def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]: people.sort(key=lambda x: (-x[0], x[1])) que = [] for p in people: que.insert(p[1], p) return que",
          "description": "Python版本，先按身高降序、k值升序排序后插入。"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "关于出现两个维度一起考虑的情况，我们已经做过两道题目了，另一道就是135. 分发糖果 (https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html)。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: static bool cmp(const vector<int>& a, const vector<int>& b) {if (a[0] == b[0]) return a[1] < b[1];return a[0] > b[0];} vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {sort (people.begin(), people.end(), cmp);vector<vector<int>> que;for (int i = 0; i < people.size(); i++) {int position = people[i][1];que.insert(que.begin() + position, people[i]);}return que;}};",
          "description": "使用C++的动态数组实现队列重建"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: static bool cmp(const vector<int>& a, const vector<int>& b) {if (a[0] == b[0]) return a[1] < b[1];return a[0] > b[0];} vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {sort (people.begin(), people.end(), cmp);list<vector<int>> que;for (int i = 0; i < people.size(); i++) {int position = people[i][1];std::list<vector<int>>::iterator it = que.begin();while (position--) {it++;}que.insert(it, people[i]);}return vector<vector<int>>(que.begin(), que.end());}};",
          "description": "使用C++的链表实现队列重建，提高插入效率"
        },
        {
          "language": "java",
          "code": "class Solution {public int[][] reconstructQueue(int[][] people) {Arrays.sort(people, (a, b) -> {if (a[0] == b[0]) return a[1] - b[1];return b[0] - a[0];});LinkedList<int[]> que = new LinkedList<>();for (int[] p : people) {que.add(p[1],p);}return que.toArray(new int[people.length][]);}}",
          "description": "Java版本的队列重建，利用链表提高插入效率"
        },
        {
          "language": "python",
          "code": "class Solution: def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]: people.sort(key=lambda x: (-x[0], x[1])) que = [] for p in people: que.insert(p[1], p) return que",
          "description": "Python版本的队列重建，简洁地实现了题目要求的功能"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "class Solution {public: static bool cmp(const vector<int>& a, const vector<int>& b) {if (a[0] == b[0]) return a[1] < b[1];return a[0] > b[0];} vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {sort (people.begin(), people.end(), cmp);vector<vector<int>> que;for (int i = 0; i < people.size(); i++) {int position = people[i][1];que.insert(que.begin() + position, people[i]);}return que;}};",
          "description": "使用C++实现的版本一，基于数组进行插入操作。"
        },
        {
          "language": "C++",
          "code": "class Solution {public: // 身高从大到小排（身高相同k小的站前面）static bool cmp(const vector<int>& a, const vector<int>& b) {if (a[0] == b[0]) return a[1] < b[1];return a[0] > b[0];}vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {sort (people.begin(), people.end(), cmp);list<vector<int>> que; // list底层是链表实现，插入效率比vector高的多for (int i = 0; i < people.size(); i++) {int position = people[i][1]; // 插入到下标为position的位置std::list<vector<int>>::iterator it = que.begin();while (position--) { // 寻找在插入位置it++;}que.insert(it, people[i]);}return vector<vector<int>>(que.begin(), que.end());}};",
          "description": "使用C++实现的版本二，基于链表进行插入操作以提高效率。"
        },
        {
          "language": "Java",
          "code": "class Solution {public int[][] reconstructQueue(int[][] people) {Arrays.sort(people, (a, b) -> {if (a[0] == b[0]) return a[1] - b[1];return b[0] - a[0];});LinkedList<int[]> que = new LinkedList<>();for (int[] p : people) {que.add(p[1],p);}return que.toArray(new int[people.length][]);}}",
          "description": "使用Java实现的解法，首先按照身高降序、k值升序排序后，再根据k值将元素插入队列。"
        },
        {
          "language": "Python",
          "code": "class Solution: def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]: people.sort(key=lambda x: (-x[0], x[1])) que = [] for p in people: que.insert(p[1], p) return que",
          "description": "使用Python实现的解法，先对people按身高降序及k值升序排序，然后根据k值将每个人插入到正确的位置。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    static bool cmp(const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) return a[1] < b[1];\n        return a[0] > b[0];\n    }\n    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n        sort (people.begin(), people.end(), cmp);\n        list<vector<int>> que; \n        for (int i = 0; i < people.size(); i++) {\n            int position = people[i][1]; \n            std::list<vector<int>>::iterator it = que.begin();\n            while (position--) { \n                it++;\n            }\n            que.insert(it, people[i]);\n        }\n        return vector<vector<int>>(que.begin(), que.end());\n    }\n};",
          "description": "C++版本的解决方案，使用链表实现队列重建。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int[][] reconstructQueue(int[][] people) {\n        Arrays.sort(people, (a, b) -> {\n            if (a[0] == b[0]) return a[1] - b[1];\n            return b[0] - a[0];\n        });\n\n        LinkedList<int[]> que = new LinkedList<>();\n\n        for (int[] p : people) {\n            que.add(p[1],p);\n        }\n\n        return que.toArray(new int[people.length][]);\n    }\n}",
          "description": "Java版本的解决方案，使用LinkedList实现队列重建。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:\n        people.sort(key=lambda x: (-x[0], x[1]))\n        que = []\n        for p in people:\n            que.insert(p[1], p)\n        return que",
          "description": "Python版本的解决方案，直接使用列表实现队列重建。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "class Solution:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: static bool cmp(const vector<int>& a, const vector<int>& b) {if (a[0] == b[0]) return a[1] < b[1];return a[0] > b[0];} vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {sort (people.begin(), people.end(), cmp);vector<vector<int>> que;for (int i = 0; i < people.size(); i++) {int position = people[i][1];que.insert(que.begin() + position, people[i]);}return que;}};",
          "description": "C++版本一，使用vector实现队列重建"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: static bool cmp(const vector<int>& a, const vector<int>& b) {if (a[0] == b[0]) return a[1] < b[1];return a[0] > b[0];} vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {sort (people.begin(), people.end(), cmp);list<vector<int>> que;for (int i = 0; i < people.size(); i++) {int position = people[i][1];std::list<vector<int>>::iterator it = que.begin();while (position--) {it++;}que.insert(it, people[i]);}return vector<vector<int>>(que.begin(), que.end());}};",
          "description": "C++版本二，使用list实现更高效的队列重建"
        },
        {
          "language": "java",
          "code": "class Solution {public int[][] reconstructQueue(int[][] people) {Arrays.sort(people, (a, b) -> {if (a[0] == b[0]) return a[1] - b[1];return b[0] - a[0];});LinkedList<int[]> que = new LinkedList<>();for (int[] p : people) {que.add(p[1],p);}return que.toArray(new int[people.length][]);}}",
          "description": "Java版本，利用LinkedList实现队列重建"
        },
        {
          "language": "python",
          "code": "class Solution: def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]: people.sort(key=lambda x: (-x[0], x[1])) que = [] for p in people: que.insert(p[1], p) return que",
          "description": "Python版本，利用列表推导和排序实现队列重建"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(nlog n + n^2)",
    "space_complexity": "O(n)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: static bool cmp(const vector<int>& a, const vector<int>& b) {if (a[0] == b[0]) return a[1] < b[1];return a[0] > b[0];} vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {sort (people.begin(), people.end(), cmp);vector<vector<int>> que;for (int i = 0; i < people.size(); i++) {int position = people[i][1];que.insert(que.begin() + position, people[i]);}return que;}};",
      "description": "使用C++实现，首先按身高降序（如果身高相同则按k升序）排序，然后根据每个人的k值插入到正确的位置。"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: static bool cmp(const vector<int>& a, const vector<int>& b) {if (a[0] == b[0]) return a[1] < b[1];return a[0] > b[0];} vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {sort (people.begin(), people.end(), cmp);list<vector<int>> que;for (int i = 0; i < people.size(); i++) {int position = people[i][1];std::list<vector<int>>::iterator it = que.begin();while (position--) {it++;}que.insert(it, people[i]);}return vector<vector<int>>(que.begin(), que.end());}};",
      "description": "使用C++的链表实现版本，优化了插入操作的时间复杂度。"
    },
    {
      "language": "java",
      "code": "class Solution {public int[][] reconstructQueue(int[][] people) {Arrays.sort(people, (a, b) -> {if (a[0] == b[0]) return a[1] - b[1];return b[0] - a[0];});LinkedList<int[]> que = new LinkedList<>();for (int[] p : people) {que.add(p[1],p);}return que.toArray(new int[people.length][]);}}",
      "description": "使用Java实现，逻辑与C++版本相似，但利用了LinkedList来提高插入效率。"
    },
    {
      "language": "python",
      "code": "class Solution: def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]: people.sort(key=lambda x: (-x[0], x[1])) que = [] for p in people: que.insert(p[1], p) return que",
      "description": "使用Python实现，通过lambda表达式进行排序，并使用list的insert方法按k值定位。"
    }
  ],
  "common_mistakes": [
    "试图同时考虑两个维度(h和k)可能导致逻辑混乱",
    "忽略在特定条件下选择合适的数据结构以优化性能",
    "没有充分理解贪心策略如何适用于此问题情境"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20201216201851982.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20201216201851982.png",
      "context": "该图片展示了按照身高从大到小排序后，如何依据k值作为下标重新插入队列的过程，以{5,2}为例具体说明了这一算法步骤。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20201216201851982.png",
      "description": "GIF展示了根据身高和另一个指定位置属性k对一组人物进行排序并重新排列的过程。",
      "context": "GIF动画展示了按照身高从大到小排序后，根据每个人对应的k值将其插入队列的过程，直观地说明了如何通过局部最优达到全局最优解。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\贪心算法\\根据身高重建队列.txt",
  "extracted_at": "2025-07-22T16:46:00.754497",
  "raw_content": "根据身高重建队列\n力扣题目链接(https://leetcode.cn/problems/queue-reconstruction-by-height/)\n\n假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。\n\n请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\n\n示例 1：\n\n输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n解释：\n编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。\n编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。\n编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。\n编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。\n编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。\n示例 2：\n\n输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]\n输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]\n提示：\n\n1 <= people.length <= 2000\n0 <= hi <= 10^6\n0 <= ki < people.length\n题目数据确保队列可以被重建\n\n\n#思路\n本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。\n\n其实如果大家认真做了135. 分发糖果 (https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html)，就会发现和此题有点点的像。\n\n在135. 分发糖果 (https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html)我就强调过一次，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。\n\n如果两个维度一起考虑一定会顾此失彼。\n\n对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还是先按照k排序呢？\n\n如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。\n\n那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。\n\n此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！\n\n那么只需要按照k为下标重新插入队列就可以了，为什么呢？\n\n以图中{5,2} 为例：\n\nhttps://file1.kamacoder.com/i/algo/20201216201851982.png\n\n按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。\n\n所以在按照身高从大到小排序后：\n\n局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性\n\n全局最优：最后都做完插入操作，整个队列满足题目队列属性\n\n局部最优可推出全局最优，找不出反例，那就试试贪心。\n\n一些同学可能也会疑惑，你怎么知道局部最优就可以推出全局最优呢？ 有数学证明么？\n\n在贪心系列开篇词关于贪心算法，你该了解这些！ (https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)中，我已经讲过了这个问题了。\n\n刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心，至于严格的数学证明，就不在讨论范围内了。\n\n如果没有读过关于贪心算法，你该了解这些！ (https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)的同学建议读一下，相信对贪心就有初步的了解了。\n\n回归本题，整个插入过程如下：\n\n排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]\n\n插入的过程：\n\n插入[7,0]：[[7,0]]\n插入[7,1]：[[7,0],[7,1]]\n插入[6,1]：[[7,0],[6,1],[7,1]]\n插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]\n插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]\n插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n此时就按照题目的要求完成了重新排列。\n\nC++代码如下：\n\n// 版本一\nclass Solution {\npublic:\n    static bool cmp(const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) return a[1] < b[1];\n        return a[0] > b[0];\n    }\n    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n        sort (people.begin(), people.end(), cmp);\n        vector<vector<int>> que;\n        for (int i = 0; i < people.size(); i++) {\n            int position = people[i][1];\n            que.insert(que.begin() + position, people[i]);\n        }\n        return que;\n    }\n};\n时间复杂度：O(nlog n + n^2)\n空间复杂度：O(n)\n但使用vector是非常费时的，C++中vector（可以理解是一个动态数组，底层是普通数组实现的）如果插入元素大于预先普通数组大小，vector底部会有一个扩容的操作，即申请两倍于原先普通数组的大小，然后把数据拷贝到另一个更大的数组上。\n\n所以使用vector（动态数组）来insert，是费时的，插入再拷贝的话，单纯一个插入的操作就是O(n^2)了，甚至可能拷贝好几次，就不止O(n^2)了。\n\n改成链表之后，C++代码如下：\n\n// 版本二\nclass Solution {\npublic:\n    // 身高从大到小排（身高相同k小的站前面）\n    static bool cmp(const vector<int>& a, const vector<int>& b) {\n        if (a[0] == b[0]) return a[1] < b[1];\n        return a[0] > b[0];\n    }\n    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n        sort (people.begin(), people.end(), cmp);\n        list<vector<int>> que; // list底层是链表实现，插入效率比vector高的多\n        for (int i = 0; i < people.size(); i++) {\n            int position = people[i][1]; // 插入到下标为position的位置\n            std::list<vector<int>>::iterator it = que.begin();\n            while (position--) { // 寻找在插入位置\n                it++;\n            }\n            que.insert(it, people[i]);\n        }\n        return vector<vector<int>>(que.begin(), que.end());\n    }\n};\n时间复杂度：O(nlog n + n^2)\n空间复杂度：O(n)\n大家可以把两个版本的代码提交一下试试，就可以发现其差别了！\n\n关于本题使用数组还是使用链表的性能差异，我在贪心算法：根据身高重建队列（续集） (https://programmercarl.com/%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97%EF%BC%88vector%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%EF%BC%89.html)中详细讲解了一波\n\n#总结\n关于出现两个维度一起考虑的情况，我们已经做过两道题目了，另一道就是135. 分发糖果 (https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html)。\n\n其技巧都是确定一边然后贪心另一边，两边一起考虑，就会顾此失彼。\n\n这道题目可以说比135. 分发糖果 (https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html)难不少，其贪心的策略也是比较巧妙。\n\n最后我给出了两个版本的代码，可以明显看是使用C++中的list（底层链表实现）比vector（数组）效率高得多。\n\n对使用某一种语言容器的使用，特性的选择都会不同程度上影响效率。\n\n所以很多人都说写算法题用什么语言都可以，主要体现在算法思维上，其实我是同意的但也不同意。\n\n对于看别人题解的同学，题解用什么语言其实影响不大，只要题解把所使用语言特性优化的点讲出来，大家都可以看懂，并使用自己语言的时候注意一下。\n\n对于写题解的同学，刷题用什么语言影响就非常大，如果自己语言没有学好而强调算法和编程语言没关系，其实是会误伤别人的。\n\n这也是我为什么统一使用C++写题解的原因\n\n#其他语言版本\n#Java\nclass Solution {\n    public int[][] reconstructQueue(int[][] people) {\n        // 身高从大到小排（身高相同k小的站前面）\n        Arrays.sort(people, (a, b) -> {\n            if (a[0] == b[0]) return a[1] - b[1];   // a - b 是升序排列，故在a[0] == b[0]的狀況下，會根據k值升序排列\n            return b[0] - a[0];   //b - a 是降序排列，在a[0] != b[0]，的狀況會根據h值降序排列\n        });\n\n        LinkedList<int[]> que = new LinkedList<>();\n\n        for (int[] p : people) {\n            que.add(p[1],p);   //Linkedlist.add(index, value)，會將value插入到指定index裡。\n        }\n\n        return que.toArray(new int[people.length][]);\n    }\n}\n#Python\nclass Solution:\n    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:\n    \t# 先按照h维度的身高顺序从高到低排序。确定第一个维度\n        # lambda返回的是一个元组：当-x[0](维度h）相同时，再根据x[1]（维度k）从小到大排序\n        people.sort(key=lambda x: (-x[0], x[1]))\n        que = []\n\t\n\t# 根据每个元素的第二个维度k，贪心算法，进行插入\n        # people已经排序过了：同一高度时k值小的排前面。\n        for p in people:\n            que.insert(p[1], p)\n        return que"
}