{
  "id": "AP_1825e308",
  "title": "完全平方数",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/perfect-squares/",
  "description": "正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n\n给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。\n\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划",
    "完全背包"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "双层循环遍历",
    "状态转移"
  ],
  "difficulty": null,
  "solution_approach": "将问题转化为完全背包问题，其中物品是所有的完全平方数，背包容量为给定的整数n。通过动态规划来找到最少数量的完全平方数，使得它们的和等于n。",
  "key_insights": [
    {
      "content": "把寻找若干个完全平方数使其和等于n的问题看作是一个完全背包问题，可以利用动态规划解决。"
    },
    {
      "content": "dp[j] = min(dp[j - i * i] + 1, dp[j])表示当前状态j可以通过之前的状态j - i * i加上一个物品i*i达到，并且选择最小值作为新的dp[j]值。"
    },
    {
      "content": "初始化dp[0]=0，非零下标元素初始化为最大值，以确保递推过程中的最小值选取不会被初始值覆盖。"
    },
    {
      "content": "遍历顺序既可以先遍历背包再遍历物品，也可以先遍历物品再遍历背包，在本题中两种方式都能得到正确结果。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "可能刚看这种题感觉没啥思路，又平方和的，又最小数的。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int numSquares(int n) {vector<int> dp(n + 1, INT_MAX);dp[0] = 0;for (int i = 0; i <= n; i++) { for (int j = 1; j * j <= i; j++) { dp[i] = min(dp[i - j * j] + 1, dp[i]); } }return dp[n];}};",
          "description": "C++版本一，先遍历背包再遍历物品"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int numSquares(int n) {vector<int> dp(n + 1, INT_MAX);dp[0] = 0;for (int i = 1; i * i <= n; i++) { for (int j = i * i; j <= n; j++) { dp[j] = min(dp[j - i * i] + 1, dp[j]); } }return dp[n];}};",
          "description": "C++版本二，先遍历物品再遍历背包"
        },
        {
          "language": "java",
          "code": "class Solution {public int numSquares(int n) {int max = Integer.MAX_VALUE;int[] dp = new int[n + 1];for (int j = 0; j <= n; j++) { dp[j] = max;}dp[0] = 0;for (int i = 1; i * i <= n; i++) { for (int j = i * i; j <= n; j++) { dp[j] = Math.min(dp[j], dp[j - i * i] + 1); }}}return dp[n];}}",
          "description": "Java版本一，先遍历物品再遍历背包"
        },
        {
          "language": "java",
          "code": "class Solution {public int numSquares(int n) {int max = Integer.MAX_VALUE;int[] dp = new int[n + 1];for (int j = 0; j <= n; j++) { dp[j] = max;}dp[0] = 0;for (int j = 1; j <= n; j++) { for (int i = 1; i * i <= j; i++) { dp[j] = Math.min(dp[j], dp[j - i * i] + 1); }}}return dp[n];}}",
          "description": "Java版本二，先遍历背包再遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for j in range(1, int(i ** 0.5) + 1): dp[i] = min(dp[i], dp[i - j * j] + 1) return dp[n]",
          "description": "Python版本一，先遍历背包再遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, int(n ** 0.5) + 1): for j in range(i * i, n + 1): dp[j] = min(dp[j - i * i] + 1, dp[j]) return dp[n]",
          "description": "Python版本二，先遍历物品再遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]",
          "description": "Python其他版本，使用while循环遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution(object): def numSquares(self, n): nums, num = [], 1 while num ** 2 <= n: nums.append(num ** 2) num += 1 dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(len(nums)): for j in range(nums[i], n+1): dp[j] = min(dp[j], dp[j-nums[i]]+1) return dp[-1]",
          "description": "Python其他版本，预先计算完全平方数"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "如果大家认真做了昨天的题目动态规划：322. 零钱兑换 (https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)，今天这道就非常简单了，一样的套路一样的味道。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int numSquares(int n) {vector<int> dp(n + 1, INT_MAX);dp[0] = 0;for (int i = 0; i <= n; i++) { for (int j = 1; j * j <= i; j++) {dp[i] = min(dp[i - j * j] + 1, dp[i]);}}}return dp[n];}};",
          "description": "C++版本一，先遍历背包再遍历物品"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int numSquares(int n) {vector<int> dp(n + 1, INT_MAX);dp[0] = 0;for (int i = 1; i * i <= n; i++) { for (int j = i * i; j <= n; j++) {dp[j] = min(dp[j - i * i] + 1, dp[j]);}}}return dp[n];}};",
          "description": "C++版本二，先遍历物品再遍历背包"
        },
        {
          "language": "java",
          "code": "class Solution {public int numSquares(int n) {int max = Integer.MAX_VALUE;int[] dp = new int[n + 1];for (int j = 0; j <= n; j++) {dp[j] = max;}dp[0] = 0;for (int i = 1; i * i <= n; i++) {for (int j = i * i; j <= n; j++) {dp[j] = Math.min(dp[j], dp[j - i * i] + 1);}}return dp[n];}}",
          "description": "Java版本一，先遍历物品再遍历背包"
        },
        {
          "language": "java",
          "code": "class Solution {public int numSquares(int n) {int max = Integer.MAX_VALUE;int[] dp = new int[n + 1];for (int j = 0; j <= n; j++) {dp[j] = max;}dp[0] = 0;for (int j = 1; j <= n; j++) {for (int i = 1; i * i <= j; i++) {dp[j] = Math.min(dp[j], dp[j - i * i] + 1);}}return dp[n];}}",
          "description": "Java版本二，先遍历背包再遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for j in range(1, int(i ** 0.5) + 1): dp[i] = min(dp[i], dp[i - j * j] + 1) return dp[n]",
          "description": "Python版本一，先遍历背包再遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, int(n ** 0.5) + 1): for j in range(i * i, n + 1): dp[j] = min(dp[j - i * i] + 1, dp[j]) return dp[n]",
          "description": "Python版本二，先遍历物品再遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]",
          "description": "另一种Python实现"
        },
        {
          "language": "python",
          "code": "class Solution(object): def numSquares(self, n): nums, num = [], 1 while num ** 2 <= n: nums.append(num ** 2) num += 1 dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(len(nums)): for j in range(nums[i], n+1): dp[j] = min(dp[j], dp[j-nums[i]]+1) return dp[-1]",
          "description": "另一种Python实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution {\n    public int numSquares(int n) {\n        int max = Integer.MAX_VALUE;\n        int[] dp = new int[n + 1];\n        for (int j = 0; j <= n; j++) {\n            dp[j] = max;\n        }\n        dp[0] = 0;\n        for (int i = 1; i * i <= n; i++) {\n            for (int j = i * i; j <= n; j++) {\n                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);\n            }\n        }\n        return dp[n];\n    }\n}",
          "description": "版本一，先遍历物品, 再遍历背包"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int numSquares(int n) {\n        int max = Integer.MAX_VALUE;\n        int[] dp = new int[n + 1];\n        for (int j = 0; j <= n; j++) {\n            dp[j] = max;\n        }\n        dp[0] = 0;\n        for (int j = 1; j <= n; j++) {\n            for (int i = 1; i * i <= j; i++) {\n                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);\n            }\n        }\n        return dp[n];\n    }\n}",
          "description": "版本二， 先遍历背包, 再遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def numSquares(self, n: int) -> int:\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            for j in range(1, int(i ** 0.5) + 1):\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\n\n        return dp[n]",
          "description": "先遍历背包, 再遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def numSquares(self, n: int) -> int:\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, int(n ** 0.5) + 1):\n            for j in range(i * i, n + 1):\n                dp[j] = min(dp[j - i * i] + 1, dp[j])\n\n        return dp[n]",
          "description": "先遍历物品, 再遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def numSquares(self, n: int) -> int:\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            j = 1\n            while j * j <= i:\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\n                j += 1\n\n        return dp[n]",
          "description": "其他版本"
        },
        {
          "language": "python",
          "code": "class Solution(object):\n    def numSquares(self, n):\n        nums, num = [], 1\n        while num ** 2 <= n:\n            nums.append(num ** 2)\n            num += 1\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        for i in range(len(nums)):\n            for j in range(nums[i], n+1):\n                dp[j] = min(dp[j], dp[j-nums[i]]+1)\n\n        return dp[-1]",
          "description": "其他版本"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int numSquares(int n) {vector<int> dp(n + 1, INT_MAX);dp[0] = 0;for (int i = 0; i <= n; i++) {for (int j = 1; j * j <= i; j++) {dp[i] = min(dp[i - j * j] + 1, dp[i]);}}return dp[n];}};",
          "description": "C++版本，先遍历背包再遍历物品"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int numSquares(int n) {vector<int> dp(n + 1, INT_MAX);dp[0] = 0;for (int i = 1; i * i <= n; i++) {for (int j = i * i; j <= n; j++) {dp[j] = min(dp[j - i * i] + 1, dp[j]);}}return dp[n];}};",
          "description": "C++版本，先遍历物品再遍历背包"
        },
        {
          "language": "java",
          "code": "class Solution {public int numSquares(int n) {int max = Integer.MAX_VALUE;int[] dp = new int[n + 1];for (int j = 0; j <= n; j++) {dp[j] = max;}dp[0] = 0;for (int i = 1; i * i <= n; i++) {for (int j = i * i; j <= n; j++) {dp[j] = Math.min(dp[j], dp[j - i * i] + 1);}}return dp[n];}}",
          "description": "Java版本，先遍历物品再遍历背包"
        },
        {
          "language": "java",
          "code": "class Solution {public int numSquares(int n) {int max = Integer.MAX_VALUE;int[] dp = new int[n + 1];for (int j = 0; j <= n; j++) {dp[j] = max;}dp[0] = 0;for (int j = 1; j <= n; j++) {for (int i = 1; i * i <= j; i++) {dp[j] = Math.min(dp[j], dp[j - i * i] + 1);}}return dp[n];}}",
          "description": "Java版本，先遍历背包再遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for j in range(1, int(i ** 0.5) + 1): dp[i] = min(dp[i], dp[i - j * j] + 1) return dp[n]",
          "description": "Python版本，先遍历背包再遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, int(n ** 0.5) + 1): for j in range(i * i, n + 1): dp[j] = min(dp[j - i * i] + 1, dp[j]) return dp[n]",
          "description": "Python版本，先遍历物品再遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]",
          "description": "Python其他版本"
        },
        {
          "language": "python",
          "code": "class Solution(object): def numSquares(self, n): nums, num = [], 1 while num ** 2 <= n: nums.append(num ** 2) num += 1 dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(len(nums)): for j in range(nums[i], n+1): dp[j] = min(dp[j], dp[j-nums[i]]+1) return dp[-1]",
          "description": "Python另一种实现方式"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "先遍历背包, 再遍历物品",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int numSquares(int n) {vector<int> dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 0; i <= n; i++) { for (int j = 1; j * j <= i; j++) { dp[i] = min(dp[i - j * j] + 1, dp[i]); } } return dp[n];}};",
          "description": "版本一，先遍历背包, 再遍历物品"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int numSquares(int n) {vector<int> dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 1; i * i <= n; i++) { for (int j = i * i; j <= n; j++) { dp[j] = min(dp[j - i * i] + 1, dp[j]); } } return dp[n];}};",
          "description": "版本二，先遍历物品, 再遍历背包"
        },
        {
          "language": "java",
          "code": "class Solution {public int numSquares(int n) {int max = Integer.MAX_VALUE; int[] dp = new int[n + 1]; for (int j = 0; j <= n; j++) {dp[j] = max;} dp[0] = 0; for (int i = 1; i * i <= n; i++) {for (int j = i * i; j <= n; j++) {dp[j] = Math.min(dp[j], dp[j - i * i] + 1);}} return dp[n];}}",
          "description": "版本一，先遍历物品, 再遍历背包"
        },
        {
          "language": "java",
          "code": "class Solution {public int numSquares(int n) {int max = Integer.MAX_VALUE; int[] dp = new int[n + 1]; for (int j = 0; j <= n; j++) {dp[j] = max;} dp[0] = 0; for (int j = 1; j <= n; j++) {for (int i = 1; i * i <= j; i++) {dp[j] = Math.min(dp[j], dp[j - i * i] + 1);}} return dp[n];}}",
          "description": "版本二，先遍历背包, 再遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for j in range(1, int(i ** 0.5) + 1): dp[i] = min(dp[i], dp[i - j * j] + 1) return dp[n]",
          "description": "先遍历背包, 再遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, int(n ** 0.5) + 1): for j in range(i * i, n + 1): dp[j] = min(dp[j - i * i] + 1, dp[j]) return dp[n]",
          "description": "先遍历物品, 再遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]",
          "description": "其他版本"
        },
        {
          "language": "python",
          "code": "class Solution(object): def numSquares(self, n): nums, num = [], 1 while num ** 2 <= n: nums.append(num ** 2) num += 1 dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(len(nums)): for j in range(nums[i], n+1): dp[j] = min(dp[j], dp[j-nums[i]]+1) return dp[-1]",
          "description": "另一种实现方式"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n * √n)",
    "space_complexity": "O(n)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int numSquares(int n) {vector<int> dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 0; i <= n; i++) { for (int j = 1; j * j <= i; j++) { dp[i] = min(dp[i - j * j] + 1, dp[i]); } } return dp[n]; }};",
      "description": "C++版本一：先遍历背包，再遍历物品"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int numSquares(int n) {vector<int> dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 1; i * i <= n; i++) { for (int j = i * i; j <= n; j++) { dp[j] = min(dp[j - i * i] + 1, dp[j]); } } return dp[n]; }};",
      "description": "C++版本二：先遍历物品，再遍历背包"
    },
    {
      "language": "java",
      "code": "class Solution {public int numSquares(int n) {int max = Integer.MAX_VALUE; int[] dp = new int[n + 1]; for (int j = 0; j <= n; j++) { dp[j] = max; } dp[0] = 0; for (int i = 1; i * i <= n; i++) { for (int j = i * i; j <= n; j++) { dp[j] = Math.min(dp[j], dp[j - i * i] + 1); } } return dp[n];}}",
      "description": "Java版本一：先遍历物品，再遍历背包"
    },
    {
      "language": "java",
      "code": "class Solution {public int numSquares(int n) {int max = Integer.MAX_VALUE; int[] dp = new int[n + 1]; for (int j = 0; j <= n; j++) { dp[j] = max; } dp[0] = 0; for (int j = 1; j <= n; j++) { for (int i = 1; i * i <= j; i++) { dp[j] = Math.min(dp[j], dp[j - i * i] + 1); } } return dp[n];}}",
      "description": "Java版本二：先遍历背包，再遍历物品"
    },
    {
      "language": "python",
      "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for j in range(1, int(i ** 0.5) + 1): dp[i] = min(dp[i], dp[i - j * j] + 1) return dp[n]",
      "description": "Python版本一：先遍历背包，再遍历物品"
    },
    {
      "language": "python",
      "code": "class Solution: def numSquares(self, n: int) -> int: dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, int(n ** 0.5) + 1): for j in range(i * i, n + 1): dp[j] = min(dp[j - i * i] + 1, dp[j]) return dp[n]",
      "description": "Python版本二：先遍历物品，再遍历背包"
    }
  ],
  "common_mistakes": [
    "初始化时非0下标的dp[j]应设为最大值，以确保递推过程中不会被初始值干扰。",
    "在遍历顺序上，无论是先遍历背包再遍历物品还是相反，都是可行的，但需要保持一致性和正确性。",
    "注意题目中定义的完全平方数是从1开始计算的，而不是从0开始。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210202112617341.jpg",
      "description": "这张图片展示了使用动态规划算法计算数组 `dp` 的过程，其中 `dp[i]` 表示到达索引 `i` 的最小步数。",
      "context": "该图片展示了当n为5时，根据给定算法推导出的dp数组状态图，直观地呈现了从dp[0]到dp[5]各状态值的变化过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210202112617341.jpg",
      "description": "GIF展示了通过动态规划方法计算给定整数n最少可以表示为多少个完全平方数之和的过程。",
      "context": "GIF动画展示了当n为5时，动态规划数组dp的状态变化过程，帮助理解算法如何逐步计算出最少数量的完全平方数之和。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\完全平方数.txt",
  "extracted_at": "2025-07-20T17:35:24.123707",
  "raw_content": "完全平方数\n力扣题目链接(https://leetcode.cn/problems/perfect-squares/)\n\n给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n\n给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。\n\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n\n示例 1：\n\n输入：n = 12\n输出：3\n解释：12 = 4 + 4 + 4\n示例 2：\n\n输入：n = 13\n输出：2\n解释：13 = 4 + 9\n提示：\n\n1 <= n <= 10^4\n\n\n#思路\n可能刚看这种题感觉没啥思路，又平方和的，又最小数的。\n\n我来把题目翻译一下：完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？\n\n感受出来了没，这么浓厚的完全背包氛围，而且和昨天的题目动态规划：322. 零钱兑换 (https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)就是一样一样的！\n\n动规五部曲分析如下：\n\n确定dp数组（dp table）以及下标的含义\ndp[j]：和为j的完全平方数的最少数量为dp[j]\n\n确定递推公式\ndp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。\n\n此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);\n\ndp数组如何初始化\ndp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。\n\n有同学问题，那0 * 0 也算是一种啊，为啥dp[0] 就是 0呢？\n\n看题目描述，找到若干个完全平方数（比如 1, 4, 9, 16, ...），题目描述中可没说要从0开始，dp[0]=0完全是为了递推公式。\n\n非0下标的dp[j]应该是多少呢？\n\n从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖。\n\n确定遍历顺序\n我们知道这是完全背包，\n\n如果求组合数就是外层for循环遍历物品，内层for遍历背包。\n\n如果求排列数就是外层for遍历背包，内层for循环遍历物品。\n\n在动态规划：322. 零钱兑换 (opens new window)中我们就深入探讨了这个问题，本题也是一样的，是求最小数！\n\n所以本题外层for遍历背包，内层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！\n\n我这里先给出外层遍历背包，内层遍历物品的代码：\n\nvector<int> dp(n + 1, INT_MAX);\ndp[0] = 0;\nfor (int i = 0; i <= n; i++) { // 遍历背包\n    for (int j = 1; j * j <= i; j++) { // 遍历物品\n        dp[i] = min(dp[i - j * j] + 1, dp[i]);\n    }\n}\n\n举例推导dp数组\n已输入n为5例，dp状态图如下：\n\nhttps://file1.kamacoder.com/i/algo/20210202112617341.jpg\n\ndp[0] = 0 dp[1] = min(dp[0] + 1) = 1 dp[2] = min(dp[1] + 1) = 2 dp[3] = min(dp[2] + 1) = 3 dp[4] = min(dp[3] + 1, dp[0] + 1) = 1 dp[5] = min(dp[4] + 1, dp[1] + 1) = 2\n\n最后的dp[n]为最终结果。\n\n以上动规五部曲分析完毕C++代码如下：\n\n// 版本一\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 0; i <= n; i++) { // 遍历背包\n            for (int j = 1; j * j <= i; j++) { // 遍历物品\n                dp[i] = min(dp[i - j * j] + 1, dp[i]);\n            }\n        }\n        return dp[n];\n    }\n};\n时间复杂度: O(n * √n)\n空间复杂度: O(n)\n同样我在给出先遍历物品，在遍历背包的代码，一样的可以AC的。\n\n// 版本二\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 1; i * i <= n; i++) { // 遍历物品\n            for (int j = i * i; j <= n; j++) { // 遍历背包\n                dp[j] = min(dp[j - i * i] + 1, dp[j]);\n            }\n        }\n        return dp[n];\n    }\n};\n同上\n#总结\n如果大家认真做了昨天的题目动态规划：322. 零钱兑换 (https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)，今天这道就非常简单了，一样的套路一样的味道。\n\n\n#其他语言版本\n#Java：\nclass Solution {\n    // 版本一，先遍历物品, 再遍历背包\n    public int numSquares(int n) {\n        int max = Integer.MAX_VALUE;\n        int[] dp = new int[n + 1];\n        //初始化\n        for (int j = 0; j <= n; j++) {\n            dp[j] = max;\n        }\n\t//如果不想要寫for-loop填充數組的話，也可以用JAVA內建的Arrays.fill()函數。\n\t//Arrays.fill(dp, Integer.MAX_VALUE);\n\t\n        //当和为0时，组合的个数为0\n        dp[0] = 0;\n        // 遍历物品\n        for (int i = 1; i * i <= n; i++) {\n            // 遍历背包\n            for (int j = i * i; j <= n; j++) {\n                //if (dp[j - i * i] != max) {\n                    dp[j] = Math.min(dp[j], dp[j - i * i] + 1);\n                //}\n\t\t//不需要這個if statement，因爲在完全平方數這一題不會有\"湊不成\"的狀況發生（ 一定可以用\"1\"來組成任何一個n），故comment掉這個if statement。\n            }\n        }\n        return dp[n];\n    }\n}\n\nclass Solution {\n    // 版本二， 先遍历背包, 再遍历物品\n    public int numSquares(int n) {\n        int max = Integer.MAX_VALUE;\n        int[] dp = new int[n + 1];\n        // 初始化\n        for (int j = 0; j <= n; j++) {\n            dp[j] = max;\n        }\n        // 当和为0时，组合的个数为0\n        dp[0] = 0;\n        // 遍历背包\n        for (int j = 1; j <= n; j++) {\n            // 遍历物品\n            for (int i = 1; i * i <= j; i++) {\n                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);\n            }\n        }\n        return dp[n];\n    }\n}\n#Python：\n先遍历背包, 再遍历物品\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, n + 1):  # 遍历背包\n            for j in range(1, int(i ** 0.5) + 1):  # 遍历物品\n                # 更新凑成数字 i 所需的最少完全平方数数量\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\n\n        return dp[n]\n\n先遍历物品, 再遍历背包\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, int(n ** 0.5) + 1):  # 遍历物品\n            for j in range(i * i, n + 1):  # 遍历背包\n                # 更新凑成数字 j 所需的最少完全平方数数量\n                dp[j] = min(dp[j - i * i] + 1, dp[j])\n\n        return dp[n]\n\n\n其他版本\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        # 创建动态规划数组，初始值为最大值\n        dp = [float('inf')] * (n + 1)\n        # 初始化已知情况\n        dp[0] = 0\n\n        # 遍历背包容量\n        for i in range(1, n + 1):\n            # 遍历完全平方数作为物品\n            j = 1\n            while j * j <= i:\n                # 更新最少完全平方数的数量\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\n                j += 1\n\n        # 返回结果\n        return dp[n]\n\nclass Solution(object):\n    def numSquares(self, n):\n        # 先把可以选的数准备好，更好理解\n        nums, num = [], 1\n        while num ** 2 <= n:\n            nums.append(num ** 2)\n            num += 1\n        # dp数组初始化\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        # 遍历准备好的完全平方数\n        for i in range(len(nums)):\n            # 遍历背包容量\n            for j in range(nums[i], n+1):\n                dp[j] = min(dp[j], dp[j-nums[i]]+1)\n        # 返回结果\n        return dp[-1]"
}