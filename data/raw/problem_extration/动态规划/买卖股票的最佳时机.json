{
  "id": "AP_ecaaeac3",
  "title": "买卖股票的最佳时机",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/",
  "description": "一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "贪心算法",
    "动态规划"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "双指针",
    "空间优化"
  ],
  "difficulty": null,
  "solution_approach": "通过遍历数组来找到最低价格和最大利润，利用贪心算法或动态规划来解决。贪心法通过记录遍历过程中的最小值（即最低购买价格）并计算当前价格与最低价格之间的差值来更新最大利润；动态规划则通过定义状态dp[i][0]为第i天持有股票的最大现金量，dp[i][1]为第i天不持有股票的最大现金量，并基于这两个状态进行递推。",
  "key_insights": [
    {
      "content": "只需考虑在历史最低点买入并在之后的最高点卖出即可获得最大收益。"
    },
    {
      "content": "使用动态规划时，关键在于正确设置状态转移方程以反映持有/不持有股票两种情况下的最优解。"
    },
    {
      "content": "贪心法中，通过持续更新最低价格和最大利润，能够在线性时间内解决问题。"
    },
    {
      "content": "动态规划版本可以通过滚动数组进一步优化空间复杂度至O(1)。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "#暴力",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int result = 0;for (int i = 0; i < prices.size(); i++) {for (int j = i + 1; j < prices.size(); j++){result = max(result, prices[j] - prices[i]);}}}return result;}};",
          "description": "暴力解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int low = INT_MAX;int result = 0;for (int i = 0; i < prices.size(); i++) {low = min(low, prices[i]);result = max(result, prices[i] - low);}return result;}};",
          "description": "贪心算法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size();if (len == 0) return 0;vector<vector<int>> dp(len, vector<int>(2));dp[0][0] -= prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++) {dp[i][0] = max(dp[i - 1][0], -prices[i]);dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);}return dp[len - 1][1];}};",
          "description": "动态规划版本一"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size();vector<vector<int>> dp(2, vector<int>(2));dp[0][0] -= prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++) {dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);}return dp[(len - 1) % 2][1];}};",
          "description": "动态规划版本二"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int low = Integer.MAX_VALUE;int res = 0;for(int i = 0; i < prices.length; i++){low = Math.min(prices[i], low);res = Math.max(prices[i] - low, res);}return res;}}",
          "description": "贪心算法"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {if (prices == null || prices.length == 0) return 0;int length = prices.length;int[][] dp = new int[length][2];dp[0][0] = -prices[0];dp[0][1] = 0;for (int i = 1; i < length; i++) {dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);}return dp[length - 1][1];}}",
          "description": "动态规划版本一"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int len = prices.length;int dp[][] = new int[2][2];dp[0][0] = - prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++){dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], - prices[i]);dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);}return dp[(len - 1) % 2][1];}}",
          "description": "动态规划版本二"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int[] dp = new int[2];dp[0] = -prices[0];dp[1] = 0;for (int i = 1; i <= prices.length; i++) {dp[0] = Math.max(dp[0], -prices[i - 1]);dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]);}return dp[1];}}",
          "description": "动态规划优化版"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: low = float(\"inf\") result = 0 for i in range(len(prices)): low = min(low, prices[i]) result = max(result, prices[i] - low) return result",
          "description": "贪心算法"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) if length == 0: return 0 dp = [[0] * 2 for _ in range(length)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i][0] = max(dp[i-1][0], -prices[i]) dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]) return dp[-1][1]",
          "description": "动态规划版本一"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp = [[0] * 2 for _ in range(2)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i % 2][0] = max(dp[(i-1) % 2][0], -prices[i]) dp[i % 2][1] = max(dp[(i-1) % 2][1], prices[i] + dp[(i-1) % 2][0]) return dp[(length-1) % 2][1]",
          "description": "动态规划版本二"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp0, dp1 = -prices[0], 0 for i in range(1, length): dp1 = max(dp1, dp0 + prices[i]) dp0 = max(dp0, -prices[i]) return dp1",
          "description": "动态规划优化版"
        }
      ],
      "subsections": []
    },
    {
      "name": "暴力",
      "text": "这道题目最直观的想法，就是暴力，找最优间距了。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int result = 0;for (int i = 0; i < prices.size(); i++) {for (int j = i + 1; j < prices.size(); j++){result = max(result, prices[j] - prices[i]);}}return result;}};",
          "description": "暴力解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int low = INT_MAX;int result = 0;for (int i = 0; i < prices.size(); i++) {low = min(low, prices[i]);result = max(result, prices[i] - low);}}return result;}};",
          "description": "贪心算法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size();if (len == 0) return 0;vector<vector<int>> dp(len, vector<int>(2));dp[0][0] -= prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++) {dp[i][0] = max(dp[i - 1][0], -prices[i]);dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);}return dp[len - 1][1];}};",
          "description": "动态规划版本一"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size();vector<vector<int>> dp(2, vector<int>(2));dp[0][0] -= prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++) {dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);}return dp[(len - 1) % 2][1];}};",
          "description": "动态规划版本二"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int low = Integer.MAX_VALUE;int res = 0;for(int i = 0; i < prices.length; i++){low = Math.min(prices[i], low);res = Math.max(prices[i] - low, res);}return res;}}",
          "description": "Java贪心算法"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {if (prices == null || prices.length == 0) return 0;int length = prices.length;int[][] dp = new int[length][2];dp[0][0] = -prices[0];dp[0][1] = 0;for (int i = 1; i < length; i++) {dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);}return dp[length - 1][1];}}",
          "description": "Java动态规划版本一"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int len = prices.length;int dp[][] = new int[2][2];dp[0][0] = - prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++){dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], - prices[i]);dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);}return dp[(len - 1) % 2][1];}}",
          "description": "Java动态规划版本二"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int[] dp = new int[2];dp[0] = -prices[0];dp[1] = 0;for (int i = 1; i <= prices.length; i++) {dp[0] = Math.max(dp[0], -prices[i - 1]);dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]);}return dp[1];}}",
          "description": "Java动态规划优化版本"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: low = float(\"inf\") result = 0 for i in range(len(prices)): low = min(low, prices[i]) result = max(result, prices[i] - low) return result",
          "description": "Python贪心算法"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) if length == 0: return 0 dp = [[0] * 2 for _ in range(length)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i][0] = max(dp[i-1][0], -prices[i]) dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]) return dp[-1][1]",
          "description": "Python动态规划版本一"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp = [[0] * 2 for _ in range(2)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i % 2][0] = max(dp[(i-1) % 2][0], -prices[i]) dp[i % 2][1] = max(dp[(i-1) % 2][1], prices[i] + dp[(i-1) % 2][0]) return dp[(length-1) % 2][1]",
          "description": "Python动态规划版本二"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp0, dp1 = -prices[0], 0 for i in range(1, length): dp1 = max(dp1, dp0 + prices[i]) dp0 = max(dp0, -prices[i]) return dp1",
          "description": "Python动态规划优化版本"
        }
      ],
      "subsections": []
    },
    {
      "name": "贪心",
      "text": "因为股票就买卖一次，那么贪心的想法很自然就是取最左最小值，取最右最大值，那么得到的差值就是最大利润。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int result = 0;for (int i = 0; i < prices.size(); i++) {for (int j = i + 1; j < prices.size(); j++){result = max(result, prices[j] - prices[i]);}}}return result;}};",
          "description": "暴力求解最大利润"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int low = INT_MAX;int result = 0;for (int i = 0; i < prices.size(); i++) {low = min(low, prices[i]);result = max(result, prices[i] - low);}return result;}};",
          "description": "贪心算法求解最大利润"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size();if (len == 0) return 0;vector<vector<int>> dp(len, vector<int>(2));dp[0][0] -= prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++) {dp[i][0] = max(dp[i - 1][0], -prices[i]);dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);}return dp[len - 1][1];}};",
          "description": "动态规划版本一求解最大利润"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size();vector<vector<int>> dp(2, vector<int>(2));dp[0][0] -= prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++) {dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);}return dp[(len - 1) % 2][1];}};",
          "description": "动态规划版本二使用滚动数组求解最大利润"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int low = Integer.MAX_VALUE;int res = 0;for(int i = 0; i < prices.length; i++){low = Math.min(prices[i], low);res = Math.max(prices[i] - low, res);}return res;}}",
          "description": "Java贪心法求解最大利润"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {if (prices == null || prices.length == 0) return 0;int length = prices.length;int[][] dp = new int[length][2];dp[0][0] = -prices[0];dp[0][1] = 0;for (int i = 1; i < length; i++) {dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);}return dp[length - 1][1];}}",
          "description": "Java动态规划版本一求解最大利润"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int len = prices.length;int dp[][] = new int[2][2];dp[0][0] = - prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++){dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], - prices[i]);dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);}return dp[(len - 1) % 2][1];}}",
          "description": "Java动态规划版本二使用二维数组求解最大利润"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int[] dp = new int[2];dp[0] = -prices[0];dp[1] = 0;for (int i = 1; i <= prices.length; i++) {dp[0] = Math.max(dp[0], -prices[i - 1]);dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]);}return dp[1];}}",
          "description": "Java动态规划版本二使用一维数组求解最大利润"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: low = float(\"inf\") result = 0 for i in range(len(prices)): low = min(low, prices[i]) result = max(result, prices[i] - low) return result",
          "description": "Python贪心法求解最大利润"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) if length == 0: return 0 dp = [[0] * 2 for _ in range(length)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i][0] = max(dp[i-1][0], -prices[i]) dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]) return dp[-1][1]",
          "description": "Python动态规划版本一求解最大利润"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp = [[0] * 2 for _ in range(2)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i % 2][0] = max(dp[(i-1) % 2][0], -prices[i]) dp[i % 2][1] = max(dp[(i-1) % 2][1], prices[i] + dp[(i-1) % 2][0]) return dp[(length-1) % 2][1]",
          "description": "Python动态规划版本二使用二维数组求解最大利润"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp0, dp1 = -prices[0], 0 for i in range(1, length): dp1 = max(dp1, dp0 + prices[i]) dp0 = max(dp0, -prices[i]) return dp1",
          "description": "Python动态规划版本三使用常量优化求解最大利润"
        }
      ],
      "subsections": []
    },
    {
      "name": "动态规划",
      "text": "动规五部曲分析如下：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int result = 0; for (int i = 0; i < prices.size(); i++) {for (int j = i + 1; j < prices.size(); j++){result = max(result, prices[j] - prices[i]);}}} return result;}};",
          "description": "暴力解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int low = INT_MAX; int result = 0; for (int i = 0; i < prices.size(); i++) {low = min(low, prices[i]); result = max(result, prices[i] - low);}} return result;}};",
          "description": "贪心算法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size(); if (len == 0) return 0; vector<vector<int>> dp(len, vector<int>(2)); dp[0][0] -= prices[0]; dp[0][1] = 0; for (int i = 1; i < len; i++) {dp[i][0] = max(dp[i - 1][0], -prices[i]); dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);} return dp[len - 1][1];}};",
          "description": "动态规划版本一"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size(); vector<vector<int>> dp(2, vector<int>(2)); dp[0][0] -= prices[0]; dp[0][1] = 0; for (int i = 1; i < len; i++) {dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]); dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);} return dp[(len - 1) % 2][1];}};",
          "description": "动态规划版本二"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int low = Integer.MAX_VALUE; int res = 0; for(int i = 0; i < prices.length; i++){low = Math.min(prices[i], low); res = Math.max(prices[i] - low, res);} return res;}}",
          "description": "贪心算法"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {if (prices == null || prices.length == 0) return 0; int length = prices.length; int[][] dp = new int[length][2]; dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i < length; i++) {dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);} return dp[length - 1][1];}}",
          "description": "动态规划版本一"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int len = prices.length; int dp[][] = new int[2][2]; dp[0][0] = - prices[0]; dp[0][1] = 0; for (int i = 1; i < len; i++){dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], - prices[i]); dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);} return dp[(len - 1) % 2][1];}}",
          "description": "动态规划版本二"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int[] dp = new int[2]; dp[0] = -prices[0]; dp[1] = 0; for (int i = 1; i <= prices.length; i++) {dp[0] = Math.max(dp[0], -prices[i - 1]); dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]);} return dp[1];}}",
          "description": "动态规划版本三"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: low = float(\"inf\") result = 0 for i in range(len(prices)): low = min(low, prices[i]) result = max(result, prices[i] - low) return result",
          "description": "贪心算法"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) if length == 0: return 0 dp = [[0] * 2 for _ in range(length)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i][0] = max(dp[i-1][0], -prices[i]) dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]) return dp[-1][1]",
          "description": "动态规划版本一"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp = [[0] * 2 for _ in range(2)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i % 2][0] = max(dp[(i-1) % 2][0], -prices[i]) dp[i % 2][1] = max(dp[(i-1) % 2][1], prices[i] + dp[(i-1) % 2][0]) return dp[(length-1) % 2][1]",
          "description": "动态规划版本二"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp0, dp1 = -prices[0], 0 for i in range(1, length): dp1 = max(dp1, dp0 + prices[i]) dp0 = max(dp0, -prices[i]) return dp1",
          "description": "动态规划版本三"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int result = 0;for (int i = 0; i < prices.size(); i++) {for (int j = i + 1; j < prices.size(); j++){result = max(result, prices[j] - prices[i]);}}}return result;}};",
          "description": "暴力解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int low = INT_MAX;int result = 0;for (int i = 0; i < prices.size(); i++) {low = min(low, prices[i]);result = max(result, prices[i] - low);}return result;}};",
          "description": "贪心算法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size();if (len == 0) return 0;vector<vector<int>> dp(len, vector<int>(2));dp[0][0] -= prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++) {dp[i][0] = max(dp[i - 1][0], -prices[i]);dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);}return dp[len - 1][1];}};",
          "description": "动态规划版本一"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size();vector<vector<int>> dp(2, vector<int>(2));dp[0][0] -= prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++) {dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);}return dp[(len - 1) % 2][1];}};",
          "description": "动态规划版本二"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int low = Integer.MAX_VALUE;int res = 0;for(int i = 0; i < prices.length; i++){low = Math.min(prices[i], low);res = Math.max(prices[i] - low, res);}return res;}}",
          "description": "Java贪心法"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {if (prices == null || prices.length == 0) return 0;int length = prices.length;int[][] dp = new int[length][2];dp[0][0] = -prices[0];dp[0][1] = 0;for (int i = 1; i < length; i++) {dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);}return dp[length - 1][1];}}",
          "description": "Java动态规划版本一"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int len = prices.length;int dp[][] = new int[2][2];dp[0][0] = - prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++){dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], - prices[i]);dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);}return dp[(len - 1) % 2][1];}}",
          "description": "Java动态规划版本二"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int[] dp = new int[2];dp[0] = -prices[0];dp[1] = 0;for (int i = 1; i <= prices.length; i++) {dp[0] = Math.max(dp[0], -prices[i - 1]);dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]);}return dp[1];}}",
          "description": "Java动态规划版本三"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: low = float('inf') result = 0 for i in range(len(prices)): low = min(low, prices[i]) result = max(result, prices[i] - low) return result",
          "description": "Python贪心法"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) if length == 0: return 0 dp = [[0] * 2 for _ in range(length)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i][0] = max(dp[i-1][0], -prices[i]) dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]) return dp[-1][1]",
          "description": "Python动态规划版本一"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp = [[0] * 2 for _ in range(2)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i % 2][0] = max(dp[(i-1) % 2][0], -prices[i]) dp[i % 2][1] = max(dp[(i-1) % 2][1], prices[i] + dp[(i-1) % 2][0]) return dp[(length-1) % 2][1]",
          "description": "Python动态规划版本二"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp0, dp1 = -prices[0], 0 for i in range(1, length): dp1 = max(dp1, dp0 + prices[i]) dp0 = max(dp0, -prices[i]) return dp1",
          "description": "Python动态规划版本三"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java:",
      "text": "贪心法：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int result = 0; for (int i = 0; i < prices.size(); i++) {for (int j = i + 1; j < prices.size(); j++){result = max(result, prices[j] - prices[i]);}}} return result;}};",
          "description": "暴力解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int low = INT_MAX; int result = 0; for (int i = 0; i < prices.size(); i++) {low = min(low, prices[i]); result = max(result, prices[i] - low);} return result;}};",
          "description": "贪心算法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size(); if (len == 0) return 0; vector<vector<int>> dp(len, vector<int>(2)); dp[0][0] -= prices[0]; dp[0][1] = 0; for (int i = 1; i < len; i++) {dp[i][0] = max(dp[i - 1][0], -prices[i]); dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);} return dp[len - 1][1];}};",
          "description": "动态规划版本一"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size(); vector<vector<int>> dp(2, vector<int>(2)); dp[0][0] -= prices[0]; dp[0][1] = 0; for (int i = 1; i < len; i++) {dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]); dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);} return dp[(len - 1) % 2][1];}};",
          "description": "动态规划版本二"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int low = Integer.MAX_VALUE; int res = 0; for(int i = 0; i < prices.length; i++){low = Math.min(prices[i], low); res = Math.max(prices[i] - low, res);} return res;}}",
          "description": "Java贪心算法"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {if (prices == null || prices.length == 0) return 0; int length = prices.length; int[][] dp = new int[length][2]; dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i < length; i++) {dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);} return dp[length - 1][1];}}",
          "description": "Java动态规划版本一"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int len = prices.length; int dp[][] = new int[2][2]; dp[0][0] = - prices[0]; dp[0][1] = 0; for (int i = 1; i < len; i++){dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], - prices[i]); dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);} return dp[(len - 1) % 2][1];}}",
          "description": "Java动态规划版本二"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int[] dp = new int[2]; dp[0] = -prices[0]; dp[1] = 0; for (int i = 1; i <= prices.length; i++) {dp[0] = Math.max(dp[0], -prices[i - 1]); dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]);} return dp[1];}}",
          "description": "Java动态规划优化版"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: low = float(\"inf\") result = 0 for i in range(len(prices)): low = min(low, prices[i]) result = max(result, prices[i] - low) return result",
          "description": "Python贪心算法"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) if length == 0: return 0 dp = [[0] * 2 for _ in range(length)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i][0] = max(dp[i-1][0], -prices[i]) dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]) return dp[-1][1]",
          "description": "Python动态规划版本一"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp = [[0] * 2 for _ in range(2)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i % 2][0] = max(dp[(i-1) % 2][0], -prices[i]) dp[i % 2][1] = max(dp[(i-1) % 2][1], prices[i] + dp[(i-1) % 2][0]) return dp[(length-1) % 2][1]",
          "description": "Python动态规划版本二"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp0, dp1 = -prices[0], 0 for i in range(1, length): dp1 = max(dp1, dp0 + prices[i]) dp0 = max(dp0, -prices[i]) return dp1",
          "description": "Python动态规划优化版"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python:",
      "text": "贪心法：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int result = 0;\n        for (int i = 0; i < prices.size(); i++) {\n            for (int j = i + 1; j < prices.size(); j++){\n                result = max(result, prices[j] - prices[i]);\n            }\n        }\n        return result;\n    }\n};",
          "description": "使用暴力法解决买卖股票的最佳时机问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int low = INT_MAX;\n        int result = 0;\n        for (int i = 0; i < prices.size(); i++) {\n            low = min(low, prices[i]);\n            result = max(result, prices[i] - low);\n        }\n        return result;\n    }\n};",
          "description": "采用贪心算法解决买卖股票的最佳时机问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        if (len == 0) return 0;\n        vector<vector<int>> dp(len, vector<int>(2));\n        dp[0][0] -= prices[0];\n        dp[0][1] = 0;\n        for (int i = 1; i < len; i++) {\n            dp[i][0] = max(dp[i - 1][0], -prices[i]);\n            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);\n        }\n        return dp[len - 1][1];\n    }\n};",
          "description": "动态规划方法一解决买卖股票的最佳时机问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        vector<vector<int>> dp(2, vector<int>(2));\n        dp[0][0] -= prices[0];\n        dp[0][1] = 0;\n        for (int i = 1; i < len; i++) {\n            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);\n            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);\n        }\n        return dp[(len - 1) % 2][1];\n    }\n};",
          "description": "动态规划方法二（优化空间）解决买卖股票的最佳时机问题"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int low = Integer.MAX_VALUE;\n        int res = 0;\n        for(int i = 0; i < prices.length; i++){\n            low = Math.min(prices[i], low);\n            res = Math.max(prices[i] - low, res);\n        }\n        return res;\n    }\n}",
          "description": "Java实现的贪心算法解决买卖股票的最佳时机问题"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length == 0) return 0;\n        int length = prices.length;\n        int[][] dp = new int[length][2];\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for (int i = 1; i < length; i++) {\n            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);\n            dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);\n        }\n        return dp[length - 1][1];\n    }\n}",
          "description": "Java实现的动态规划方法一解决买卖股票的最佳时机问题"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int len = prices.length;\n        int dp[][] = new int[2][2];\n        dp[0][0] = - prices[0];\n        dp[0][1] = 0;\n        for (int i = 1; i < len; i++){\n            dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], - prices[i]);\n            dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);\n        }\n        return dp[(len - 1) % 2][1];\n    }\n}",
          "description": "Java实现的动态规划方法二（优化空间）解决买卖股票的最佳时机问题"
        },
        {
          "language": "java",
          "code": "class Solution {\n  public int maxProfit(int[] prices) {\n    int[] dp = new int[2];\n    dp[0] = -prices[0];\n    dp[1] = 0;\n    for (int i = 1; i <= prices.length; i++) {\n      dp[0] = Math.max(dp[0], -prices[i - 1]);\n      dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]);\n    }\n    return dp[1];\n  }\n}",
          "description": "Java实现的一维数组动态规划方法解决买卖股票的最佳时机问题"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        low = float(\"inf\")\n        result = 0\n        for i in range(len(prices)):\n            low = min(low, prices[i])\n            result = max(result, prices[i] - low)\n        return result",
          "description": "Python实现的贪心算法解决买卖股票的最佳时机问题"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        length = len(prices)\n        if length == 0:\n            return 0\n        dp = [[0] * 2 for _ in range(length)]\n        dp[0][0] = -prices[0]\n        dp[0][1] = 0\n        for i in range(1, length):\n            dp[i][0] = max(dp[i-1][0], -prices[i])\n            dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0])\n        return dp[-1][1]",
          "description": "Python实现的动态规划方法一解决买卖股票的最佳时机问题"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        length = len(prices)\n        dp = [[0] * 2 for _ in range(2)]\n        dp[0][0] = -prices[0]\n        dp[0][1] = 0\n        for i in range(1, length):\n            dp[i % 2][0] = max(dp[(i-1) % 2][0], -prices[i])\n            dp[i % 2][1] = max(dp[(i-1) % 2][1], prices[i] + dp[(i-1) % 2][0])\n        return dp[(length-1) % 2][1]",
          "description": "Python实现的动态规划方法二（优化空间）解决买卖股票的最佳时机问题"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        length = len(prices)\n        dp0, dp1 = -prices[0], 0\n        for i in range(1, length):\n            dp1 = max(dp1, dp0 + prices[i])\n            dp0 = max(dp0, -prices[i])\n        return dp1",
          "description": "Python实现的一维数组动态规划方法解决买卖股票的最佳时机问题"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int maxProfit(vector<int>& prices) {int result = 0;for (int i = 0; i < prices.size(); i++) {for (int j = i + 1; j < prices.size(); j++){result = max(result, prices[j] - prices[i]);}}return result;}};",
      "description": "暴力法"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int maxProfit(vector<int>& prices) {int low = INT_MAX;int result = 0;for (int i = 0; i < prices.size(); i++) {low = min(low, prices[i]); result = max(result, prices[i] - low); }return result;}};",
      "description": "贪心法"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size();if (len == 0) return 0;vector<vector<int>> dp(len, vector<int>(2));dp[0][0] -= prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++) {dp[i][0] = max(dp[i - 1][0], -prices[i]);dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);}return dp[len - 1][1];}};",
      "description": "动态规划版本一"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int maxProfit(vector<int>& prices) {int len = prices.size();vector<vector<int>> dp(2, vector<int>(2));dp[0][0] -= prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++) {dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);}return dp[(len - 1) % 2][1];}};",
      "description": "动态规划版本二"
    },
    {
      "language": "java",
      "code": "class Solution {public int maxProfit(int[] prices) {int low = Integer.MAX_VALUE;int res = 0;for(int i = 0; i < prices.length; i++){low = Math.min(prices[i], low);res = Math.max(prices[i] - low, res);}return res;}}",
      "description": "贪心法"
    },
    {
      "language": "java",
      "code": "class Solution {public int maxProfit(int[] prices) {if (prices == null || prices.length == 0) return 0;int length = prices.length;int[][] dp = new int[length][2];dp[0][0] = -prices[0];dp[0][1] = 0;for (int i = 1; i < length; i++) {dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);}return dp[length - 1][1];}}",
      "description": "动态规划版本一"
    },
    {
      "language": "java",
      "code": "class Solution {public int maxProfit(int[] prices) {int len = prices.length;int dp[][] = new int[2][2];dp[0][0] = - prices[0];dp[0][1] = 0;for (int i = 1; i < len; i++){dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], - prices[i]);dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);}return dp[(len - 1) % 2][1];}}",
      "description": "动态规划版本二"
    },
    {
      "language": "java",
      "code": "class Solution {public int maxProfit(int[] prices) {int[] dp = new int[2];dp[0] = -prices[0];dp[1] = 0;for (int i = 1; i <= prices.length; i++) {dp[0] = Math.max(dp[0], -prices[i - 1]);dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]);}return dp[1];}}",
      "description": "动态规划版本三"
    },
    {
      "language": "python",
      "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: low = float(\"inf\") result = 0 for i in range(len(prices)): low = min(low, prices[i]) result = max(result, prices[i] - low) return result",
      "description": "贪心法"
    },
    {
      "language": "python",
      "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) if length == 0: return 0 dp = [[0] * 2 for _ in range(length)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i][0] = max(dp[i-1][0], -prices[i]) dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]) return dp[-1][1]",
      "description": "动态规划版本一"
    },
    {
      "language": "python",
      "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp = [[0] * 2 for _ in range(2)] dp[0][0] = -prices[0] dp[0][1] = 0 for i in range(1, length): dp[i % 2][0] = max(dp[(i-1) % 2][0], -prices[i]) dp[i % 2][1] = max(dp[(i-1) % 2][1], prices[i] + dp[(i-1) % 2][0]) return dp[(length-1) % 2][1]",
      "description": "动态规划版本二"
    },
    {
      "language": "python",
      "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: length = len(prices) dp0, dp1 = -prices[0], 0 for i in range(1, length): dp1 = max(dp1, dp0 + prices[i]) dp0 = max(dp0, -prices[i]) return dp1",
      "description": "动态规划版本三"
    }
  ],
  "common_mistakes": [
    "忽略只能买卖一次的限制条件，导致错误地允许多次买卖。",
    "未初始化dp数组可能导致错误结果。",
    "对于动态规划版本，容易混淆'持有'状态和'当天买入'的区别。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210224225642465.png",
      "description": "这张图片展示了使用动态规划（DP）算法解决某个问题的过程，具体表现为一个二维数组 `dp[i][j]` 的状态转移表，输入数组为 `[7,1,5,3,6,4]`。",
      "context": "该图片展示了以[7,1,5,3,6,4]为例时，dp数组的状态变化过程，帮助理解动态规划方法如何应用于解决股票买卖问题。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210224225642465.png",
      "description": "GIF展示了动态规划数组dp在每一天对于持有或不持有股票两种状态下数值变化的过程。",
      "context": "GIF动画展示了示例1中dp数组随每一天变化的状态，帮助理解动态规划算法如何计算最大利润。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\买卖股票的最佳时机.txt",
  "extracted_at": "2025-07-20T15:33:11.911123",
  "raw_content": "买卖股票的最佳时机\n力扣题目链接(https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)\n\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n示例 1：\n\n输入：[7,1,5,3,6,4]\n\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\n示例 2：\n\n输入：prices = [7,6,4,3,1]\n\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n#思路\n#暴力\n这道题目最直观的想法，就是暴力，找最优间距了。\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int result = 0;\n        for (int i = 0; i < prices.size(); i++) {\n            for (int j = i + 1; j < prices.size(); j++){\n                result = max(result, prices[j] - prices[i]);\n            }\n        }\n        return result;\n    }\n};\n时间复杂度：O(n^2)\n空间复杂度：O(1)\n当然该方法超时了。\n\n#贪心\n因为股票就买卖一次，那么贪心的想法很自然就是取最左最小值，取最右最大值，那么得到的差值就是最大利润。\n\nC++代码如下：\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int low = INT_MAX;\n        int result = 0;\n        for (int i = 0; i < prices.size(); i++) {\n            low = min(low, prices[i]);  // 取最左最小价格\n            result = max(result, prices[i] - low); // 直接取最大区间利润\n        }\n        return result;\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(1)\n#动态规划\n动规五部曲分析如下：\n\n确定dp数组（dp table）以及下标的含义\ndp[i][0] 表示第i天持有股票所得最多现金 ，这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？\n\n其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。\n\ndp[i][1] 表示第i天不持有股票所得最多现金\n\n注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态\n\n很多同学把“持有”和“买入”没区分清楚。\n\n在下面递推公式分析中，我会进一步讲解。\n\n确定递推公式\n如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来\n\n第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]\n第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]\n那么dp[i][0]应该选所得现金最大的，所以dp[i][0] = max(dp[i - 1][0], -prices[i]);\n\n如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来\n\n第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]\n第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1][0]\n同样dp[i][1]取最大的，dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);\n\n这样递推公式我们就分析完了\n\ndp数组如何初始化\n由递推公式 dp[i][0] = max(dp[i - 1][0], -prices[i]); 和 dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);可以看出\n\n其基础都是要从dp[0][0]和dp[0][1]推导出来。\n\n那么dp[0][0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0][0] -= prices[0];\n\ndp[0][1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0][1] = 0;\n\n确定遍历顺序\n从递推公式可以看出dp[i]都是由dp[i - 1]推导出来的，那么一定是从前向后遍历。\n\n举例推导dp数组\n以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：\n\nhttps://file1.kamacoder.com/i/algo/20210224225642465.png\n\ndp[5][1]就是最终结果。\n\n为什么不是dp[5][0]呢？\n\n因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！\n\n以上分析完毕，C++代码如下：\n\n// 版本一\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        if (len == 0) return 0;\n        vector<vector<int>> dp(len, vector<int>(2));\n        dp[0][0] -= prices[0];\n        dp[0][1] = 0;\n        for (int i = 1; i < len; i++) {\n            dp[i][0] = max(dp[i - 1][0], -prices[i]);\n            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);\n        }\n        return dp[len - 1][1];\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(n)\n从递推公式可以看出，dp[i]只是依赖于dp[i - 1]的状态。\n\ndp[i][0] = max(dp[i - 1][0], -prices[i]);\ndp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);\n那么我们只需要记录 当前天的dp状态和前一天的dp状态就可以了，可以使用滚动数组来节省空间，代码如下：\n\n// 版本二\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组\n        dp[0][0] -= prices[0];\n        dp[0][1] = 0;\n        for (int i = 1; i < len; i++) {\n            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);\n            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);\n        }\n        return dp[(len - 1) % 2][1];\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(1)\n这里能写出版本一就可以了，版本二虽然原理都一样，但是想直接写出版本二还是有点麻烦，容易自己给自己找bug。\n\n所以建议是先写出版本一，然后在版本一的基础上优化成版本二，而不是直接就写出版本二。\n\n#其他语言版本\n#Java:\n贪心法：\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        // 找到一个最小的购入点\n        int low = Integer.MAX_VALUE;\n        // res不断更新，直到数组循环完毕\n        int res = 0;\n        for(int i = 0; i < prices.length; i++){\n            low = Math.min(prices[i], low);\n            res = Math.max(prices[i] - low, res);\n        }\n        return res;\n    }\n}\n动态规划：版本一\n\n// 解法1\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length == 0) return 0;\n        int length = prices.length;\n        // dp[i][0]代表第i天持有股票的最大收益\n        // dp[i][1]代表第i天不持有股票的最大收益\n        int[][] dp = new int[length][2];\n        int result = 0;\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for (int i = 1; i < length; i++) {\n            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);\n            dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);\n        }\n        return dp[length - 1][1];\n    }\n}\n动态规划：版本二(使用二維數組（和卡哥思路一致），下面還有使用一維滾動數組的更優化版本)\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int len = prices.length;\n        int dp[][] = new int[2][2];\n        \n        dp[0][0] = - prices[0];\n        dp[0][1] = 0;\n\n        for (int i = 1; i < len; i++){\n            dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], - prices[i]);\n            dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);\n        }\n        return dp[(len - 1) % 2][1];\n    }\n}\n动态规划：版本二(使用一維數組)\n\nclass Solution {\n  public int maxProfit(int[] prices) {\n    int[] dp = new int[2];\n    // 记录一次交易，一次交易有买入卖出两种状态\n    // 0代表持有，1代表卖出\n    dp[0] = -prices[0];\n    dp[1] = 0;\n    // 可以参考斐波那契问题的优化方式\n    // 我们从 i=1 开始遍历数组，一共有 prices.length 天，\n    // 所以是 i<=prices.length\n    for (int i = 1; i <= prices.length; i++) {\n      // 前一天持有；或当天买入\n      dp[0] = Math.max(dp[0], -prices[i - 1]);\n      // 如果 dp[0] 被更新，那么 dp[1] 肯定会被更新为正数的 dp[1]\n      // 而不是 dp[0]+prices[i-1]==0 的0，\n      // 所以这里使用会改变的dp[0]也是可以的\n      // 当然 dp[1] 初始值为 0 ，被更新成 0 也没影响\n      // 前一天卖出；或当天卖出, 当天要卖出，得前一天持有才行\n      dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]);\n    }\n    return dp[1];\n  }\n}\n#Python:\n贪心法：\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        low = float(\"inf\")\n        result = 0\n        for i in range(len(prices)):\n            low = min(low, prices[i]) #取最左最小价格\n            result = max(result, prices[i] - low) #直接取最大区间利润\n        return result\n动态规划：版本一\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        length = len(prices)\n        if length == 0:\n            return 0\n        dp = [[0] * 2 for _ in range(length)]\n        dp[0][0] = -prices[0]\n        dp[0][1] = 0\n        for i in range(1, length):\n            dp[i][0] = max(dp[i-1][0], -prices[i])\n            dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0])\n        return dp[-1][1]\n动态规划：版本二\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        length = len(prices)\n        dp = [[0] * 2 for _ in range(2)] #注意这里只开辟了一个2 * 2大小的二维数组\n        dp[0][0] = -prices[0]\n        dp[0][1] = 0\n        for i in range(1, length):\n            dp[i % 2][0] = max(dp[(i-1) % 2][0], -prices[i])\n            dp[i % 2][1] = max(dp[(i-1) % 2][1], prices[i] + dp[(i-1) % 2][0])\n        return dp[(length-1) % 2][1]\n动态规划：版本三\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        length = len(prices)\n        dp0, dp1 = -prices[0], 0 #注意这里只维护两个常量，因为dp0的更新不受dp1的影响\n        for i in range(1, length):\n            dp1 = max(dp1, dp0 + prices[i])\n            dp0 = max(dp0, -prices[i])\n        return dp1"
}