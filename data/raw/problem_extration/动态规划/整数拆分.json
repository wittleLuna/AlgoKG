{
  "id": "AP_107480e8",
  "title": "整数拆分",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/integer-break/",
  "description": "一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "Dynamic Programming",
    "Greedy"
  ],
  "data_structure_tags": [
    "Array"
  ],
  "technique_tags": [
    "Memoization",
    "Optimization",
    "Two Loops"
  ],
  "difficulty": null,
  "solution_approach": "通过动态规划方法解决整数拆分问题，目的是找到一个正整数n拆分成至少两个正整数之和后所能获得的最大乘积。核心在于定义dp[i]表示将i拆分后的最大乘积，并利用两层循环来更新dp数组。",
  "key_insights": [
    {
      "content": "当考虑将数字n拆分为j与(i-j)时，只需让j遍历到n/2即可，因为超过n/2的情况已经通过较小的部分计算过，这样可以减少不必要的计算。"
    },
    {
      "content": "正确地初始化dp数组对于保持逻辑一致性至关重要。例如，dp[0]和dp[1]由于没有意义，不应赋予具体值；而dp[2]=1则符合题目要求。错误的初始化可能导致算法虽然能够运行但结果不准确。"
    },
    {
      "content": "贪心策略基于数学原理，即每次尽可能多地拆出3来最大化乘积，如果剩余部分为4，则直接保留4。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "看到这道题目，都会想拆成两个呢，还是三个呢，还是四个....",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int integerBreak(int n) {vector<int> dp(n + 1); dp[2] = 1; for (int i = 3; i <= n ; i++) {for (int j = 1; j <= i / 2; j++) {dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));}} return dp[n];}};",
          "description": "C++动态规划解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int integerBreak(int n) {if (n == 2) return 1;if (n == 3) return 2;if (n == 4) return 4;int result = 1;while (n > 4) {result *= 3;n -= 3;}result *= n;return result;}};",
          "description": "C++贪心算法解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int integerBreak(int n) {int[] dp = new int[n+1]; dp[2] = 1; for(int i = 3; i <= n; i++) {for(int j = 1; j <= i-j; j++) {dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));}} return dp[n];}}",
          "description": "Java动态规划解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int integerBreak(int n) {if(n == 2) return 1;if(n == 3) return 2;int result = 1;while(n > 4) {n-=3;result *=3;}return result*n;}}",
          "description": "Java贪心算法解法"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): dp = [0] * (n + 1) dp[2] = 1 for i in range(3, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j) return dp[n]",
          "description": "Python动态规划解法（版本一）"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): if n <= 3: return 1 * (n - 1) dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 dp[3] = 3 for i in range(4, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], dp[i - j] * dp[j]) return dp[n]",
          "description": "Python动态规划解法（版本二）"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): if n == 2: return 1 if n == 3: return 2 if n == 4: return 4 result = 1 while n > 4: result *= 3 n -= 3 result *= n return result",
          "description": "Python贪心算法解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "动态规划",
      "text": "动规五部曲，分析如下：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int integerBreak(int n) {vector<int> dp(n + 1);dp[2] = 1;for (int i = 3; i <= n ; i++) {for (int j = 1; j <= i / 2; j++) {dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));}}return dp[n];}};",
          "description": "C++动态规划解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int integerBreak(int n) {if (n == 2) return 1;if (n == 3) return 2;if (n == 4) return 4;int result = 1;while (n > 4) {result *= 3;n -= 3;}result *= n;return result;}};",
          "description": "C++贪心算法解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int integerBreak(int n) {int[] dp = new int[n+1];dp[2] = 1;for(int i = 3; i <= n; i++) {for(int j = 1; j <= i-j; j++) {dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));}}return dp[n];}}",
          "description": "Java动态规划解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int integerBreak(int n) {if(n == 2) return 1;if(n == 3) return 2;if(n == 4) return 4;int result = 1;while(n > 4) {n-=3;result *=3;}return result*n;}}",
          "description": "Java贪心算法解法"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): dp = [0] * (n + 1) dp[2] = 1 for i in range(3, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j) return dp[n]",
          "description": "Python动态规划解法版本一"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): if n <= 3: return 1 * (n - 1) dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 dp[3] = 3 for i in range(4, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], dp[i - j] * dp[j]) return dp[n]",
          "description": "Python动态规划解法版本二"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): if n == 2: return 1 if n == 3: return 2 if n == 4: return 4 result = 1 while n > 4: result *= 3 n -= 3 result *= n return result",
          "description": "Python贪心算法解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "贪心",
      "text": "本题也可以用贪心，每次拆成n个3，如果剩下是4，则保留4，然后相乘，但是这个结论需要数学证明其合理性！",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int integerBreak(int n) {vector<int> dp(n + 1); dp[2] = 1; for (int i = 3; i <= n ; i++) {for (int j = 1; j <= i / 2; j++) {dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));}} return dp[n];}};",
          "description": "C++动态规划解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int integerBreak(int n) {if (n == 2) return 1;if (n == 3) return 2;if (n == 4) return 4;int result = 1;while (n > 4) {result *= 3;n -= 3;}result *= n;return result;}};",
          "description": "C++贪心算法解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int integerBreak(int n) {int[] dp = new int[n+1];dp[2] = 1;for(int i = 3; i <= n; i++) {for(int j = 1; j <= i-j; j++) {dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));}}return dp[n];}}",
          "description": "Java动态规划解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int integerBreak(int n) {if(n == 2) return 1;if(n == 3) return 2;if(n == 4) return 4;int result = 1;while(n > 4) {n-=3;result *=3;}return result*n;}}",
          "description": "Java贪心算法解法"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): dp = [0] * (n + 1) dp[2] = 1 for i in range(3, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j) return dp[n]",
          "description": "Python动态规划解法"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): if n <= 3: return 1 * (n - 1) dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 dp[3] = 3 for i in range(4, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], dp[i - j] * dp[j]) return dp[n]",
          "description": "Python另一种动态规划解法"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): if n == 2: return 1 if n == 3: return 2 if n == 4: return 4 result = 1 while n > 4: result *= 3 n -= 3 result *= n return result",
          "description": "Python贪心算法解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "本题掌握其动规的方法，就可以了，贪心的解法确实简单，但需要有数学证明，如果能自圆其说也是可以的。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int integerBreak(int n) {vector<int> dp(n + 1);dp[2] = 1;for (int i = 3; i <= n ; i++) {for (int j = 1; j <= i / 2; j++) {dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));}}return dp[n];}};",
          "description": "使用动态规划解决整数拆分问题的C++实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int integerBreak(int n) {if (n == 2) return 1;if (n == 3) return 2;if (n == 4) return 4;int result = 1;while (n > 4) {result *= 3;n -= 3;}result *= n;return result;}};",
          "description": "使用贪心算法解决整数拆分问题的C++实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int integerBreak(int n) {int[] dp = new int[n+1];dp[2] = 1;for(int i = 3; i <= n; i++) {for(int j = 1; j <= i-j; j++) {dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));}}}return dp[n];}}",
          "description": "使用动态规划解决整数拆分问题的Java实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int integerBreak(int n) {if(n == 2) return 1;if(n == 3) return 2;if(n == 4) return 4;int result = 1;while(n > 4) {n-=3;result *=3;}return result*n;}}",
          "description": "使用贪心算法解决整数拆分问题的Java实现"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): dp = [0] * (n + 1) dp[2] = 1 for i in range(3, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j) return dp[n]",
          "description": "使用动态规划解决整数拆分问题的Python实现（版本一）"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): if n <= 3: return 1 * (n - 1) dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 dp[3] = 3 for i in range(4, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], dp[i - j] * dp[j]) return dp[n]",
          "description": "使用动态规划解决整数拆分问题的Python实现（版本二）"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): if n == 2: return 1 if n == 3: return 2 if n == 4: return 4 result = 1 while n > 4: result *= 3 n -= 3 result *= n return result",
          "description": "使用贪心算法解决整数拆分问题的Python实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution {\n    public int integerBreak(int n) {\n        int[] dp = new int[n+1];\n        dp[2] = 1;\n        for(int i = 3; i <= n; i++) {\n            for(int j = 1; j <= i-j; j++) {\n                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));\n            }\n        }\n        return dp[n];\n    }\n}",
          "description": "动态规划解法"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int integerBreak(int n) {\n        if(n == 2) return 1;\n        if(n == 3) return 2;\n        int result = 1;\n        while(n > 4) {\n            n-=3;\n            result *=3;\n        }\n        return result*n;\n    }\n}",
          "description": "贪心算法解法"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def integerBreak(self, n):\n        dp = [0] * (n + 1)\n        dp[2] = 1\n        for i in range(3, n + 1):\n            for j in range(1, i // 2 + 1):\n                dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j)\n        return dp[n]",
          "description": "动态规划解法（版本一）"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def integerBreak(self, n):\n        if n <= 3: return 1 * (n - 1)\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        dp[3] = 3\n        for i in range(4, n + 1):\n            for j in range(1, i // 2 + 1):\n                dp[i] = max(dp[i], dp[i - j] * dp[j])\n        return dp[n]",
          "description": "动态规划解法（版本二）"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def integerBreak(self, n):\n        if n == 2: return 1\n        if n == 3: return 2\n        if n == 4: return 4\n        result = 1\n        while n > 4:\n            result *= 3\n            n -= 3\n        result *= n\n        return result",
          "description": "贪心算法解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int integerBreak(int n) {vector<int> dp(n + 1); dp[2] = 1; for (int i = 3; i <= n ; i++) {for (int j = 1; j <= i / 2; j++) {dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));}} return dp[n];}};",
          "description": "C++ 动态规划解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int integerBreak(int n) {if (n == 2) return 1;if (n == 3) return 2;if (n == 4) return 4;int result = 1;while (n > 4) {result *= 3;n -= 3;}result *= n;return result;}};",
          "description": "C++ 贪心算法解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int integerBreak(int n) {int[] dp = new int[n+1]; dp[2] = 1;for(int i = 3; i <= n; i++) {for(int j = 1; j <= i-j; j++) {dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));}}} return dp[n];}}",
          "description": "Java 动态规划解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int integerBreak(int n) {if(n == 2) return 1;if(n == 3) return 2;int result = 1;while(n > 4) {n-=3;result *=3;}return result*n;}}",
          "description": "Java 贪心算法解法"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): dp = [0] * (n + 1) dp[2] = 1 for i in range(3, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j) return dp[n]",
          "description": "Python 动态规划解法（版本一）"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): if n <= 3: return 1 * (n - 1) dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 dp[3] = 3 for i in range(4, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], dp[i - j] * dp[j]) return dp[n]",
          "description": "Python 动态规划解法（版本二）"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): if n == 2: return 1 if n == 3: return 2 if n == 4: return 4 result = 1 while n > 4: result *= 3 n -= 3 result *= n return result",
          "description": "Python 贪心算法解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "动态规划（版本一）",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int integerBreak(int n) {vector<int> dp(n + 1); dp[2] = 1; for (int i = 3; i <= n ; i++) {for (int j = 1; j <= i / 2; j++) {dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));}} return dp[n];}};",
          "description": "C++实现的动态规划解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int integerBreak(int n) {if (n == 2) return 1;if (n == 3) return 2;if (n == 4) return 4;int result = 1;while (n > 4) {result *= 3;n -= 3;}result *= n;return result;}};",
          "description": "C++实现的贪心算法解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int integerBreak(int n) {int[] dp = new int[n+1]; dp[2] = 1; for(int i = 3; i <= n; i++) {for(int j = 1; j <= i-j; j++) {dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));}} return dp[n];}}",
          "description": "Java实现的动态规划解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int integerBreak(int n) {if(n == 2) return 1;if(n == 3) return 2;if(n == 4) return 4;int result = 1;while(n > 4) {n-=3;result *=3;}return result*n;}}",
          "description": "Java实现的贪心算法解法"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): dp = [0] * (n + 1) dp[2] = 1 for i in range(3, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j) return dp[n]",
          "description": "Python实现的动态规划解法版本一"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): if n <= 3: return 1 * (n - 1) dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 dp[3] = 3 for i in range(4, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], dp[i - j] * dp[j]) return dp[n]",
          "description": "Python实现的动态规划解法版本二"
        },
        {
          "language": "python",
          "code": "class Solution: def integerBreak(self, n): if n == 2: return 1 if n == 3: return 2 if n == 4: return 4 result = 1 while n > 4: result *= 3 n -= 3 result *= n return result",
          "description": "Python实现的贪心算法解法"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int integerBreak(int n) {vector<int> dp(n + 1); dp[2] = 1; for (int i = 3; i <= n ; i++) {for (int j = 1; j <= i / 2; j++) {dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));}} return dp[n];}};",
      "description": "C++动态规划实现"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int integerBreak(int n) {if (n == 2) return 1;if (n == 3) return 2;if (n == 4) return 4;int result = 1;while (n > 4) {result *= 3;n -= 3;}result *= n;return result;}};",
      "description": "C++贪心算法实现"
    },
    {
      "language": "java",
      "code": "class Solution {public int integerBreak(int n) {int[] dp = new int[n+1]; dp[2] = 1; for(int i = 3; i <= n; i++) {for(int j = 1; j <= i-j; j++) {dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));}} return dp[n];}}",
      "description": "Java动态规划实现"
    },
    {
      "language": "java",
      "code": "class Solution {public int integerBreak(int n) {if(n == 2) return 1;if(n == 3) return 2;if(n == 4) return 4;int result = 1;while(n > 4) {n-=3;result *=3;}return result*n;}}",
      "description": "Java贪心算法实现"
    },
    {
      "language": "python",
      "code": "class Solution: def integerBreak(self, n): dp = [0] * (n + 1) dp[2] = 1 for i in range(3, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j) return dp[n]",
      "description": "Python动态规划实现（版本一）"
    },
    {
      "language": "python",
      "code": "class Solution: def integerBreak(self, n): if n <= 3: return 1 * (n - 1) dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 dp[3] = 3 for i in range(4, n + 1): for j in range(1, i // 2 + 1): dp[i] = max(dp[i], dp[i - j] * dp[j]) return dp[n]",
      "description": "Python动态规划实现（版本二）"
    },
    {
      "language": "python",
      "code": "class Solution: def integerBreak(self, n): if n == 2: return 1 if n == 3: return 2 if n == 4: return 4 result = 1 while n > 4: result *= 3 n -= 3 result *= n return result",
      "description": "Python贪心算法实现"
    }
  ],
  "common_mistakes": [
    "忽视了dp数组正确的初始化方式，导致逻辑上的不一致。",
    "未能充分利用数学性质简化问题（如总是倾向于分解成3）以提高效率。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210104173021581.png",
      "description": "这张图片展示了一个动态规划（DP）数组的构建过程，其中 `dp[i]` 表示当 `n=i` 时的解，具体值为：`dp[2]=1, dp[3]=2, ..., dp[10]=36`。",
      "context": "该图片展示了当n为10时，根据所述算法计算得到的dp数组的具体数值情况。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210104173021581.png",
      "description": "GIF展示了将数字10拆分成不同组合以寻找最大乘积的过程，同时更新了动态规划数组dp的值。",
      "context": "该GIF动画展示了当n为10时，动态规划数组dp中各元素值的计算过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\整数拆分.txt",
  "extracted_at": "2025-07-20T18:18:17.367030",
  "raw_content": "整数拆分\n力扣题目链接(https://leetcode.cn/problems/integer-break/)\n\n给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。\n\n示例 1:\n\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1。\n示例 2:\n\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\n说明: 你可以假设 n 不小于 2 且不大于 58。\n\n\n#思路\n看到这道题目，都会想拆成两个呢，还是三个呢，还是四个....\n\n我们来看一下如何使用动规来解决。\n\n#动态规划\n动规五部曲，分析如下：\n\n确定dp数组（dp table）以及下标的含义\ndp[i]：分拆数字i，可以得到的最大乘积为dp[i]。\n\ndp[i]的定义将贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！\n\n确定递推公式\n可以想 dp[i]最大乘积是怎么得到的呢？\n\n其实可以从1遍历j，然后有两种渠道得到dp[i].\n\n一个是j * (i - j) 直接相乘。\n\n一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。\n\n那有同学问了，j怎么就不拆分呢？\n\nj是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));\n\n也可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。\n\n如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。\n\n所以递推公式：dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});\n\n那么在取最大值的时候，为什么还要比较dp[i]呢？\n\n因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。\n\ndp的初始化\n不少同学应该疑惑，dp[0] dp[1]应该初始化多少呢？\n\n有的题解里会给出dp[0] = 1，dp[1] = 1的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。\n\n严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。\n\n拆分0和拆分1的最大乘积是多少？\n\n这是无解的。\n\n这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！\n\n确定遍历顺序\n确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));\n\ndp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。\n\n所以遍历顺序为：\n\nfor (int i = 3; i <= n ; i++) {\n    for (int j = 1; j < i - 1; j++) {\n        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));\n    }\n}\n注意 枚举j的时候，是从1开始的。从0开始的话，那么让拆分一个数拆个0，求最大乘积就没有意义了。\n\nj的结束条件是 j < i - 1 ，其实 j < i 也是可以的，不过可以节省一步，例如让j = i - 1，的话，其实在 j = 1的时候，这一步就已经拆出来了，重复计算，所以 j < i - 1\n\n至于 i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。\n\n更优化一步，可以这样：\n\nfor (int i = 3; i <= n ; i++) {\n    for (int j = 1; j <= i / 2; j++) {\n        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));\n    }\n}\n因为拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。\n\n例如 6 拆成 3 * 3， 10 拆成 3 * 3 * 4。 100的话 也是拆成m个近似数组的子数 相乘才是最大的。\n\n只不过我们不知道m究竟是多少而已，但可以明确的是m一定大于等于2，既然m大于等于2，也就是 最差也应该是拆成两个相同的 可能是最大值。\n\n那么 j 遍历，只需要遍历到 n/2 就可以，后面就没有必要遍历了，一定不是最大值。\n\n至于 “拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的” 这个我就不去做数学证明了，感兴趣的同学，可以自己证明。\n\n举例推导dp数组\n举例当n为10 的时候，dp数组里的数值，如下：\n\nhttps://file1.kamacoder.com/i/algo/20210104173021581.png\n\n以上动规五部曲分析完毕，C++代码如下：\n\nclass Solution {\npublic:\n    int integerBreak(int n) {\n        vector<int> dp(n + 1);\n        dp[2] = 1;\n        for (int i = 3; i <= n ; i++) {\n            for (int j = 1; j <= i / 2; j++) {\n                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));\n            }\n        }\n        return dp[n];\n    }\n};\n时间复杂度：O(n^2)\n空间复杂度：O(n)\n#贪心\n本题也可以用贪心，每次拆成n个3，如果剩下是4，则保留4，然后相乘，但是这个结论需要数学证明其合理性！\n\n我没有证明，而是直接用了结论。感兴趣的同学可以自己再去研究研究数学证明哈。\n\n给出我的C++代码如下：\n\nclass Solution {\npublic:\n    int integerBreak(int n) {\n        if (n == 2) return 1;\n        if (n == 3) return 2;\n        if (n == 4) return 4;\n        int result = 1;\n        while (n > 4) {\n            result *= 3;\n            n -= 3;\n        }\n        result *= n;\n        return result;\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(1)\n#总结\n本题掌握其动规的方法，就可以了，贪心的解法确实简单，但需要有数学证明，如果能自圆其说也是可以的。\n\n其实这道题目的递推公式并不好想，而且初始化的地方也很有讲究，我在写本题的时候一开始写的代码是这样的：\n\nclass Solution {\npublic:\n    int integerBreak(int n) {\n        if (n <= 3) return 1 * (n - 1);\n        vector<int> dp(n + 1, 0);\n        dp[1] = 1;\n        dp[2] = 2;\n        dp[3] = 3;\n        for (int i = 4; i <= n ; i++) {\n            for (int j = 1; j <= i / 2; j++) {\n                dp[i] = max(dp[i], dp[i - j] * dp[j]);\n            }\n        }\n        return dp[n];\n    }\n};\n这个代码也是可以过的！\n\n在解释递推公式的时候，也可以解释通，dp[i] 就等于 拆解i - j的最大乘积 * 拆解j的最大乘积。 看起来没毛病！\n\n但是在解释初始化的时候，就发现自相矛盾了，dp[1]为什么一定是1呢？根据dp[i]的定义，dp[2]也不应该是2啊。\n\n但如果递归公式是 dp[i] = max(dp[i], dp[i - j] * dp[j]);，就一定要这么初始化。递推公式没毛病，但初始化解释不通！\n\n虽然代码在初始位置有一个判断if (n <= 3) return 1 * (n - 1);，保证n<=3 结果是正确的，但代码后面又要给dp[1]赋值1 和 dp[2] 赋值 2，这其实就是自相矛盾的代码，违背了dp[i]的定义！\n\n我举这个例子，其实就说做题的严谨性，上面这个代码也可以AC，大体上一看好像也没有毛病，递推公式也说得过去，但是仅仅是恰巧过了而已。\n\n#其他语言版本\n#Java\nclass Solution {\n    public int integerBreak(int n) {\n        //dp[i] 为正整数 i 拆分后的结果的最大乘积\n        int[] dp = new int[n+1];\n        dp[2] = 1;\n        for(int i = 3; i <= n; i++) {\n            for(int j = 1; j <= i-j; j++) {\n                // 这里的 j 其实最大值为 i-j,再大只不过是重复而已，\n                //并且，在本题中，我们分析 dp[0], dp[1]都是无意义的，\n                //j 最大到 i-j,就不会用到 dp[0]与dp[1]\n                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));\n                // j * (i - j) 是单纯的把整数 i 拆分为两个数 也就是 i,i-j ，再相乘\n                //而j * dp[i - j]是将 i 拆分成两个以及两个以上的个数,再相乘。\n            }\n        }\n        return dp[n];\n    }\n}\n贪心\n\nclass Solution {\n    public int integerBreak(int n) {\n        // with 贪心\n        // 通过数学原理拆出更多的3乘积越大，则\n        /**\n         @Param: an int, the integer we need to break.\n         @Return: an int, the maximum integer after breaking\n         @Method: Using math principle to solve this problem\n         @Time complexity: O(1)\n        **/\n        if(n == 2) return 1;\n        if(n == 3) return 2;\n        int result = 1;\n        while(n > 4) {\n            n-=3;\n            result *=3;\n        }\n        return result*n;\n    }\n}\n#Python\n动态规划（版本一）\n\nclass Solution:\n         # 假设对正整数 i 拆分出的第一个正整数是 j（1 <= j < i），则有以下两种方案：\n        # 1) 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j * (i-j)\n        # 2) 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j * dp[i-j]\n    def integerBreak(self, n):\n        dp = [0] * (n + 1)   # 创建一个大小为n+1的数组来存储计算结果\n        dp[2] = 1  # 初始化dp[2]为1，因为当n=2时，只有一个切割方式1+1=2，乘积为1\n       \n        # 从3开始计算，直到n\n        for i in range(3, n + 1):\n            # 遍历所有可能的切割点\n            for j in range(1, i // 2 + 1):\n\n                # 计算切割点j和剩余部分(i-j)的乘积，并与之前的结果进行比较取较大值\n                \n                dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j)\n        \n        return dp[n]  # 返回最终的计算结果\n\n\n动态规划（版本二）\n\nclass Solution:\n    def integerBreak(self, n):\n        if n <= 3:\n            return 1 * (n - 1)  # 对于n小于等于3的情况，返回1 * (n - 1)\n\n        dp = [0] * (n + 1)  # 创建一个大小为n+1的数组来存储最大乘积结果\n        dp[1] = 1  # 当n等于1时，最大乘积为1\n        dp[2] = 2  # 当n等于2时，最大乘积为2\n        dp[3] = 3  # 当n等于3时，最大乘积为3\n\n        # 从4开始计算，直到n\n        for i in range(4, n + 1):\n            # 遍历所有可能的切割点\n            for j in range(1, i // 2 + 1):\n                # 计算切割点j和剩余部分(i - j)的乘积，并与之前的结果进行比较取较大值\n                dp[i] = max(dp[i], dp[i - j] * dp[j])\n\n        return dp[n]  # 返回整数拆分的最大乘积结果\n\n贪心\n\nclass Solution:\n    def integerBreak(self, n):\n        if n == 2:  # 当n等于2时，只有一种拆分方式：1+1=2，乘积为1\n            return 1\n        if n == 3:  # 当n等于3时，只有一种拆分方式：2+1=3，乘积为2\n            return 2\n        if n == 4:  # 当n等于4时，有两种拆分方式：2+2=4和1+1+1+1=4，乘积都为4\n            return 4\n        result = 1\n        while n > 4:\n            result *= 3  # 每次乘以3，因为3的乘积比其他数字更大\n            n -= 3  # 每次减去3\n        result *= n  # 将剩余的n乘以最后的结果\n        return result"
}