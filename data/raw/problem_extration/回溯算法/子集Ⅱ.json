{
  "id": "AP_9ee8a119",
  "title": "子集II",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/subsets-ii/",
  "description": "一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n说明：解集不能包含重复的子集。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "回溯",
    "组合问题"
  ],
  "data_structure_tags": [
    "数组",
    "集合"
  ],
  "technique_tags": [
    "递归",
    "剪枝"
  ],
  "difficulty": null,
  "solution_approach": "通过回溯法生成所有子集，并采用特定条件来避免重复子集的出现。关键在于对输入数组先进行排序，然后在递归过程中跳过同一树层上已经处理过的元素，从而实现去重。",
  "key_insights": [
    {
      "content": "在同一树层上遇到相同的元素时需要跳过以避免生成重复子集；而在同一树枝上则可以接受重复元素，因为这代表了不同顺序的选择。"
    },
    {
      "content": "首先对原数组进行排序，使得相同值的元素相邻排列。然后，在回溯过程中利用一个布尔型数组（used）记录每个位置是否被访问过，以此来区分是树层还是树枝上的重复，进而决定是否跳过当前元素。"
    },
    {
      "content": "除了使用used数组外，还可以通过比较当前元素与其前一个元素是否相等，并且当前索引大于起始索引来判断是否跳过该元素，从而达到去重的目的。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "做本题之前一定要先做78.子集 (https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) { result.push_back(path); for (int i = startIndex; i < nums.size(); i++) { if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) { continue; } path.push_back(nums[i]); used[i] = true; backtracking(nums, i + 1, used); used[i] = false; path.pop_back(); } } public: vector<vector<int>> subsetsWithDup(vector<int>& nums) { result.clear(); path.clear(); vector<bool> used(nums.size(), false); sort(nums.begin(), nums.end()); backtracking(nums, 0, used); return result; } };",
          "description": "使用used数组去重"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) { result.push_back(path); unordered_set<int> uset; for (int i = startIndex; i < nums.size(); i++) { if (uset.find(nums[i]) != uset.end()) { continue; } uset.insert(nums[i]); path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } } public: vector<vector<int>> subsetsWithDup(vector<int>& nums) { result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, 0); return result; } };",
          "description": "使用set去重"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) { result.push_back(path); for (int i = startIndex; i < nums.size(); i++) { if (i > startIndex && nums[i] == nums[i - 1]) { continue; } path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } } public: vector<vector<int>> subsetsWithDup(vector<int>& nums) { result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, 0); return result; } };",
          "description": "利用递归的下一个startIndex是i+1而不是0去重"
        },
        {
          "language": "java",
          "code": "class Solution { List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); boolean[] used; public List<List<Integer>> subsetsWithDup(int[] nums) { if (nums.length == 0){ result.add(path); return result; } Arrays.sort(nums); used = new boolean[nums.length]; subsetsWithDupHelper(nums, 0); return result; } private void subsetsWithDupHelper(int[] nums, int startIndex){ result.add(new ArrayList<>(path)); if (startIndex >= nums.length){ return; } for (int i = startIndex; i < nums.length; i++){ if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]){ continue; } path.add(nums[i]); used[i] = true; subsetsWithDupHelper(nums, i + 1); path.removeLast(); used[i] = false; } } }",
          "description": "Java版本使用used数组去重"
        },
        {
          "language": "java",
          "code": "class Solution { List<List<Integer>> res = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); public List<List<Integer>> subsetsWithDup( int[] nums ) { Arrays.sort( nums ); subsetsWithDupHelper( nums, 0 ); return res; } private void subsetsWithDupHelper( int[] nums, int start ) { res.add( new ArrayList<>( path ) ); for ( int i = start; i < nums.length; i++ ) { if ( i > start && nums[i - 1] == nums[i] ) { continue; } path.add( nums[i] ); subsetsWithDupHelper( nums, i + 1 ); path.removeLast(); } } }",
          "description": "Java版本不使用used数组去重"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] used = [False] * len(nums) nums.sort() self.backtracking(nums, 0, used, path, result) return result def backtracking(self, nums, startIndex, used, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]: continue path.append(nums[i]) used[i] = True self.backtracking(nums, i + 1, used, path, result) used[i] = False path.pop()",
          "description": "Python版本利用used数组去重"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] nums.sort() self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) uset = set() for i in range(startIndex, len(nums)): if nums[i] in uset: continue uset.add(nums[i]) path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "Python版本利用集合去重"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] nums.sort() self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): if i > startIndex and nums[i] == nums[i - 1]: continue path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "Python版本利用递归的时候下一个startIndex是i+1而不是0去重"
        }
      ],
      "subsections": []
    },
    {
      "name": "补充",
      "text": "本题也可以不使用used数组来去重，因为递归的时候下一个startIndex是i+1而不是0。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {result.push_back(path); for (int i = startIndex; i < nums.size(); i++) {if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {continue;} path.push_back(nums[i]); used[i] = true; backtracking(nums, i + 1, used); used[i] = false; path.pop_back();}} public: vector<vector<int>> subsetsWithDup(vector<int>& nums) {result.clear(); path.clear(); vector<bool> used(nums.size(), false); sort(nums.begin(), nums.end()); backtracking(nums, 0, used); return result;}};",
          "description": "C++实现，使用used数组去重"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) {result.push_back(path); unordered_set<int> uset; for (int i = startIndex; i < nums.size(); i++) {if (uset.find(nums[i]) != uset.end()) {continue;} uset.insert(nums[i]); path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back();}} public: vector<vector<int>> subsetsWithDup(vector<int>& nums) {result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, 0); return result;}};",
          "description": "C++实现，使用集合去重"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) {result.push_back(path); for (int i = startIndex; i < nums.size(); i++) {if (i > startIndex && nums[i] == nums[i - 1]) {continue;} path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back();}} public: vector<vector<int>> subsetsWithDup(vector<int>& nums) {result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, 0); return result;}};",
          "description": "C++实现，不使用额外数组或集合去重"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); boolean[] used; public List<List<Integer>> subsetsWithDup(int[] nums) {if (nums.length == 0){result.add(path); return result;} Arrays.sort(nums); used = new boolean[nums.length]; subsetsWithDupHelper(nums, 0); return result;} private void subsetsWithDupHelper(int[] nums, int startIndex){result.add(new ArrayList<>(path)); if (startIndex >= nums.length){return;} for (int i = startIndex; i < nums.length; i++){if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]){continue;} path.add(nums[i]); used[i] = true; subsetsWithDupHelper(nums, i + 1); path.removeLast(); used[i] = false;}}}",
          "description": "Java实现，使用used数组去重"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> res = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); public List<List<Integer>> subsetsWithDup(int[] nums ) {Arrays.sort( nums ); subsetsWithDupHelper( nums, 0 ); return res;} private void subsetsWithDupHelper( int[] nums, int start ) {res.add( new ArrayList<>( path ) ); for ( int i = start; i < nums.length; i++ ) {if ( i > start && nums[i - 1] == nums[i] ) {continue;} path.add( nums[i] ); subsetsWithDupHelper( nums, i + 1 ); path.removeLast();}}}",
          "description": "Java实现，不使用额外数组去重"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] used = [False] * len(nums) nums.sort() self.backtracking(nums, 0, used, path, result) return result def backtracking(self, nums, startIndex, used, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]: continue path.append(nums[i]) used[i] = True self.backtracking(nums, i + 1, used, path, result) used[i] = False path.pop()",
          "description": "Python3实现，使用used数组去重"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] nums.sort() self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) uset = set() for i in range(startIndex, len(nums)): if nums[i] in uset: continue uset.add(nums[i]) path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "Python3实现，使用集合去重"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] nums.sort() self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): if i > startIndex and nums[i] == nums[i - 1]: continue path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "Python3实现，不使用额外数据结构去重"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "其实这道题目的知识点，我们之前都讲过了，如果之前讲过的子集问题和去重问题都掌握的好，这道题目应该分分钟AC。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {result.push_back(path); for (int i = startIndex; i < nums.size(); i++) {if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {continue;} path.push_back(nums[i]); used[i] = true; backtracking(nums, i + 1, used); used[i] = false; path.pop_back();}} public: vector<vector<int>> subsetsWithDup(vector<int>& nums) {result.clear(); path.clear(); vector<bool> used(nums.size(), false); sort(nums.begin(), nums.end()); backtracking(nums, 0, used); return result;}};",
          "description": "使用used数组去重的C++解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) {result.push_back(path); unordered_set<int> uset; for (int i = startIndex; i < nums.size(); i++) {if (uset.find(nums[i]) != uset.end()) {continue;} uset.insert(nums[i]); path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back();}} public: vector<vector<int>> subsetsWithDup(vector<int>& nums) {result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, 0); return result;}};",
          "description": "使用set去重的C++解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) {result.push_back(path); for (int i = startIndex; i < nums.size(); i++) {if (i > startIndex && nums[i] == nums[i - 1]) {continue;} path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back();}} public: vector<vector<int>> subsetsWithDup(vector<int>& nums) {result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, 0); return result;}};",
          "description": "不使用used数组去重的C++解法"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); boolean[] used; public List<List<Integer>> subsetsWithDup(int[] nums) {if (nums.length == 0){result.add(path); return result;} Arrays.sort(nums); used = new boolean[nums.length]; subsetsWithDupHelper(nums, 0); return result;} private void subsetsWithDupHelper(int[] nums, int startIndex){result.add(new ArrayList<>(path)); if (startIndex >= nums.length){return;} for (int i = startIndex; i < nums.length; i++){if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]){continue;} path.add(nums[i]); used[i] = true; subsetsWithDupHelper(nums, i + 1); path.removeLast(); used[i] = false;}}}",
          "description": "使用used数组去重的Java解法"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> res = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); public List<List<Integer>> subsetsWithDup(int[] nums) {Arrays.sort(nums); subsetsWithDupHelper(nums, 0); return res;} private void subsetsWithDupHelper(int[] nums, int start) {res.add(new ArrayList<>(path)); for (int i = start; i < nums.length; i++) {if (i > start && nums[i - 1] == nums[i]) {continue;} path.add(nums[i]); subsetsWithDupHelper(nums, i + 1); path.removeLast();}}}",
          "description": "不使用used数组去重的Java解法"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] used = [False] * len(nums) nums.sort() self.backtracking(nums, 0, used, path, result) return result def backtracking(self, nums, startIndex, used, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]: continue path.append(nums[i]) used[i] = True self.backtracking(nums, i + 1, used, path, result) used[i] = False path.pop()",
          "description": "利用used数组去重的Python解法"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] nums.sort() self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) uset = set() for i in range(startIndex, len(nums)): if nums[i] in uset: continue uset.add(nums[i]) path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "利用集合去重的Python解法"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] nums.sort() self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): if i > startIndex and nums[i] == nums[i - 1]: continue path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "利用递归的时候下一个startIndex是i+1而不是0去重的Python解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {result.push_back(path); for (int i = startIndex; i < nums.size(); i++) {if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {continue;} path.push_back(nums[i]); used[i] = true; backtracking(nums, i + 1, used); used[i] = false; path.pop_back();}} public: vector<vector<int>> subsetsWithDup(vector<int>& nums) {result.clear(); path.clear(); vector<bool> used(nums.size(), false); sort(nums.begin(), nums.end()); backtracking(nums, 0, used); return result;}};",
          "description": "C++版本，使用used数组去重"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) {result.push_back(path); unordered_set<int> uset; for (int i = startIndex; i < nums.size(); i++) {if (uset.find(nums[i]) != uset.end()) {continue;} uset.insert(nums[i]); path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back();}} public: vector<vector<int>> subsetsWithDup(vector<int>& nums) {result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, 0); return result;}};",
          "description": "C++版本，利用集合去重"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) {result.push_back(path); for (int i = startIndex; i < nums.size(); i++) {if (i > startIndex && nums[i] == nums[i - 1]) {continue;} path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back();}} public: vector<vector<int>> subsetsWithDup(vector<int>& nums) {result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, 0); return result;}};",
          "description": "C++版本，通过递归时控制startIndex去重"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); boolean[] used; public List<List<Integer>> subsetsWithDup(int[] nums) {if (nums.length == 0){result.add(path); return result;} Arrays.sort(nums); used = new boolean[nums.length]; subsetsWithDupHelper(nums, 0); return result;} private void subsetsWithDupHelper(int[] nums, int startIndex){result.add(new ArrayList<>(path)); if (startIndex >= nums.length){return;} for (int i = startIndex; i < nums.length; i++){if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]){continue;} path.add(nums[i]); used[i] = true; subsetsWithDupHelper(nums, i + 1); path.removeLast(); used[i] = false;}}}",
          "description": "Java版本，使用used数组去重"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> res = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); public List<List<Integer>> subsetsWithDup( int[] nums ) {Arrays.sort( nums ); subsetsWithDupHelper( nums, 0 ); return res;} private void subsetsWithDupHelper( int[] nums, int start ) {res.add( new ArrayList<>( path ) ); for ( int i = start; i < nums.length; i++ ) {if ( i > start && nums[i - 1] == nums[i] ) {continue;} path.add( nums[i] ); subsetsWithDupHelper( nums, i + 1 ); path.removeLast();}}}",
          "description": "Java版本，不使用used数组去重"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] used = [False] * len(nums) nums.sort() self.backtracking(nums, 0, used, path, result) return result def backtracking(self, nums, startIndex, used, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]: continue path.append(nums[i]) used[i] = True self.backtracking(nums, i + 1, used, path, result) used[i] = False path.pop()",
          "description": "Python版本，利用used数组去重"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] nums.sort() self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) uset = set() for i in range(startIndex, len(nums)): if nums[i] in uset: continue uset.add(nums[i]) path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "Python版本，利用集合去重"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] nums.sort() self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): if i > startIndex and nums[i] == nums[i - 1]: continue path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "Python版本，通过递归时控制startIndex去重"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "使用used数组",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {\n        result.push_back(path);\n        for (int i = startIndex; i < nums.size(); i++) {\n            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {\n                continue;\n            }\n            path.push_back(nums[i]);\n            used[i] = true;\n            backtracking(nums, i + 1, used);\n            used[i] = false;\n            path.pop_back();\n        }\n    }\n\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        vector<bool> used(nums.size(), false);\n        sort(nums.begin(), nums.end()); \n        backtracking(nums, 0, used);\n        return result;\n    }\n};",
          "description": "使用used数组实现子集去重"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex) {\n        result.push_back(path);\n        unordered_set<int> uset;\n        for (int i = startIndex; i < nums.size(); i++) {\n            if (uset.find(nums[i]) != uset.end()) {\n                continue;\n            }\n            uset.insert(nums[i]);\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\n\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end()); \n        backtracking(nums, 0);\n        return result;\n    }\n};",
          "description": "使用set去重的版本"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex) {\n        result.push_back(path);\n        for (int i = startIndex; i < nums.size(); i++) {\n            if (i > startIndex && nums[i] == nums[i - 1]) { \n                continue;\n            }\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\n\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end()); \n        backtracking(nums, 0);\n        return result;\n    }\n};",
          "description": "不使用used数组实现去重"
        },
        {
          "language": "java",
          "code": "class Solution {\n   List<List<Integer>> result = new ArrayList<>();\n   LinkedList<Integer> path = new LinkedList<>();\n   boolean[] used;\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        if (nums.length == 0){\n            result.add(path);\n            return result;\n        }\n        Arrays.sort(nums);\n        used = new boolean[nums.length];\n        subsetsWithDupHelper(nums, 0);\n        return result;\n    }\n\n    private void subsetsWithDupHelper(int[] nums, int startIndex){\n        result.add(new ArrayList<>(path));\n        if (startIndex >= nums.length){\n            return;\n        }\n        for (int i = startIndex; i < nums.length; i++){\n            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]){\n                continue;\n            }\n            path.add(nums[i]);\n            used[i] = true;\n            subsetsWithDupHelper(nums, i + 1);\n            path.removeLast();\n            used[i] = false;\n        }\n    }\n}",
          "description": "Java版使用used数组实现子集去重"
        },
        {
          "language": "java",
          "code": "class Solution {\n\n  List<List<Integer>> res = new ArrayList<>();\n  LinkedList<Integer> path = new LinkedList<>();\n  \n  public List<List<Integer>> subsetsWithDup( int[] nums ) {\n    Arrays.sort( nums );\n    subsetsWithDupHelper( nums, 0 );\n    return res;\n  }\n\n  private void subsetsWithDupHelper( int[] nums, int start ) {\n    res.add( new ArrayList<>( path ) );\n\n    for ( int i = start; i < nums.length; i++ ) {\n      if ( i > start && nums[i - 1] == nums[i] ) {\n        continue;\n      }\n      path.add( nums[i] );\n      subsetsWithDupHelper( nums, i + 1 );\n      path.removeLast();\n    }\n  }\n}",
          "description": "Java版不使用used数组实现去重"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def subsetsWithDup(self, nums):\n        result = []\n        path = []\n        used = [False] * len(nums)\n        nums.sort()\n        self.backtracking(nums, 0, used, path, result)\n        return result\n\n    def backtracking(self, nums, startIndex, used, path, result):\n        result.append(path[:])\n        for i in range(startIndex, len(nums)):\n            if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                continue\n            path.append(nums[i])\n            used[i] = True\n            self.backtracking(nums, i + 1, used, path, result)\n            used[i] = False\n            path.pop()",
          "description": "Python3版使用used数组实现子集去重"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def subsetsWithDup(self, nums):\n        result = []\n        path = []\n        nums.sort()\n        self.backtracking(nums, 0, path, result)\n        return result\n\n    def backtracking(self, nums, startIndex, path, result):\n        result.append(path[:])\n        uset = set()\n        for i in range(startIndex, len(nums)):\n            if nums[i] in uset:\n                continue\n            uset.add(nums[i])\n            path.append(nums[i])\n            self.backtracking(nums, i + 1, path, result)\n            path.pop()",
          "description": "Python3版使用集合去重"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def subsetsWithDup(self, nums):\n        result = []\n        path = []\n        nums.sort()\n        self.backtracking(nums, 0, path, result)\n        return result\n\n    def backtracking(self, nums, startIndex, path, result):\n        result.append(path[:])\n        for i in range(startIndex, len(nums)):\n            if i > startIndex and nums[i] == nums[i - 1]:\n                continue\n            path.append(nums[i])\n            self.backtracking(nums, i + 1, path, result)\n            path.pop()",
          "description": "Python3版不使用used数组实现去重"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python3",
      "text": "回溯 利用used数组去重",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {result.push_back(path); for (int i = startIndex; i < nums.size(); i++) {if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {continue;} path.push_back(nums[i]); used[i] = true; backtracking(nums, i + 1, used); used[i] = false; path.pop_back();}} public: vector<vector<int>> subsetsWithDup(vector<int>& nums) {result.clear(); path.clear(); vector<bool> used(nums.size(), false); sort(nums.begin(), nums.end()); backtracking(nums, 0, used); return result;}};",
          "description": "C++实现，使用used数组去重"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) {result.push_back(path); unordered_set<int> uset; for (int i = startIndex; i < nums.size(); i++) {if (uset.find(nums[i]) != uset.end()) {continue;} uset.insert(nums[i]); path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back();}} public: vector<vector<int>> subsetsWithDup(vector<int>& nums) {result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, 0); return result;}};",
          "description": "C++实现，使用集合去重"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) {result.push_back(path); for (int i = startIndex; i < nums.size(); i++) {if (i > startIndex && nums[i] == nums[i - 1]) {continue;} path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back();}} public: vector<vector<int>> subsetsWithDup(vector<int>& nums) {result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, 0); return result;}};",
          "description": "C++实现，利用递归下一个startIndex是i+1去重"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); boolean[] used; public List<List<Integer>> subsetsWithDup(int[] nums) {if (nums.length == 0){result.add(path); return result;} Arrays.sort(nums); used = new boolean[nums.length]; subsetsWithDupHelper(nums, 0); return result;} private void subsetsWithDupHelper(int[] nums, int startIndex){result.add(new ArrayList<>(path)); if (startIndex >= nums.length){return;} for (int i = startIndex; i < nums.length; i++){if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]){continue;} path.add(nums[i]); used[i] = true; subsetsWithDupHelper(nums, i + 1); path.removeLast(); used[i] = false;}}}",
          "description": "Java实现，使用used数组去重"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> res = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); public List<List<Integer>> subsetsWithDup( int[] nums ) {Arrays.sort( nums ); subsetsWithDupHelper( nums, 0 ); return res;} private void subsetsWithDupHelper( int[] nums, int start ) {res.add( new ArrayList<>( path ) ); for ( int i = start; i < nums.length; i++ ) {if ( i > start && nums[i - 1] == nums[i] ) {continue;} path.add( nums[i] ); subsetsWithDupHelper( nums, i + 1 ); path.removeLast();}}}",
          "description": "Java实现，不使用used数组去重"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] used = [False] * len(nums) nums.sort() self.backtracking(nums, 0, used, path, result) return result def backtracking(self, nums, startIndex, used, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]: continue path.append(nums[i]) used[i] = True self.backtracking(nums, i + 1, used, path, result) used[i] = False path.pop()",
          "description": "Python3实现，利用used数组去重"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] nums.sort() self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) uset = set() for i in range(startIndex, len(nums)): if nums[i] in uset: continue uset.add(nums[i]) path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "Python3实现，利用集合去重"
        },
        {
          "language": "python",
          "code": "class Solution: def subsetsWithDup(self, nums): result = [] path = [] nums.sort() self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): if i > startIndex and nums[i] == nums[i - 1]: continue path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "Python3实现，利用递归下一个startIndex是i+1去重"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n * 2^n)",
    "space_complexity": "O(n)",
    "explanation": null
  },
  "code_solutions": [],
  "common_mistakes": [
    "未对原始数组进行排序就直接开始回溯过程，导致难以有效地区分并去除重复子集。",
    "误解了如何正确地应用‘树层去重’策略，可能错误地忽略了某些应该跳过的重复情况或过度限制了选择范围。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20201124195411977.png",
      "description": "这张图片展示了使用回溯算法在含有重复元素的数组中生成所有唯一子集的过程，强调了如何通过`used`数组和条件判断来避免重复选取元素。",
      "context": "该图展示了如何通过对集合[1, 2, 2]进行排序并应用“树层去重”和“树枝去重”的方法来避免在生成子集时出现重复，强调了在同一树层上不能重复选取相同元素而同一树枝上可以的原则。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20201124195411977.png",
      "description": "GIF展示了在处理含有重复元素的数组时，通过回溯法生成所有唯一子集的过程，特别强调了如何在同一树层上去重。",
      "context": "GIF动画展示了如何通过回溯算法在处理[1, 2, 2]这样的数组时，有效地进行树层去重与树枝不去重的过程，以避免生成重复的子集。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\回溯算法\\子集Ⅱ.txt",
  "extracted_at": "2025-07-21T11:10:25.645336",
  "raw_content": "子集II\n力扣题目链接(https://leetcode.cn/problems/subsets-ii/)\n\n给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n说明：解集不能包含重复的子集。\n\n示例:\n\n输入: [1,2,2]\n输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]\n\n\n#思路\n做本题之前一定要先做78.子集 (https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)。\n\n这道题目和78.子集 (https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)区别就是集合里有重复元素了，而且求取的子集要去重。\n\n那么关于回溯算法中的去重问题，在40.组合总和II (https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html)中已经详细讲解过了，和本题是一个套路。\n\n剧透一下，后期要讲解的排列问题里去重也是这个套路，所以理解“树层去重”和“树枝去重”非常重要。\n\n用示例中的[1, 2, 2] 来举例，如图所示： （注意去重需要先对集合排序）\n\nhttps://file1.kamacoder.com/i/algo/20201124195411977.png\n\n从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！\n\n本题就是其实就是回溯算法：求子集问题！ (https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)的基础上加上了去重，去重我们在回溯算法：求组合总和（三） (https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html)也讲过了，所以我就直接给出代码了：\n\nC++代码如下：\n\nclass Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {\n        result.push_back(path);\n        for (int i = startIndex; i < nums.size(); i++) {\n            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过\n            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过\n            // 而我们要对同一树层使用过的元素进行跳过\n            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {\n                continue;\n            }\n            path.push_back(nums[i]);\n            used[i] = true;\n            backtracking(nums, i + 1, used);\n            used[i] = false;\n            path.pop_back();\n        }\n    }\n\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        vector<bool> used(nums.size(), false);\n        sort(nums.begin(), nums.end()); // 去重需要排序\n        backtracking(nums, 0, used);\n        return result;\n    }\n};\n时间复杂度: O(n * 2^n)\n空间复杂度: O(n)\n使用set去重的版本。\n\nclass Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex) {\n        result.push_back(path);\n        unordered_set<int> uset;\n        for (int i = startIndex; i < nums.size(); i++) {\n            if (uset.find(nums[i]) != uset.end()) {\n                continue;\n            }\n            uset.insert(nums[i]);\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\n\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end()); // 去重需要排序\n        backtracking(nums, 0);\n        return result;\n    }\n};\n#补充\n本题也可以不使用used数组来去重，因为递归的时候下一个startIndex是i+1而不是0。\n\n如果要是全排列的话，每次要从0开始遍历，为了跳过已入栈的元素，需要使用used。\n\n代码如下：\n\nclass Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex) {\n        result.push_back(path);\n        for (int i = startIndex; i < nums.size(); i++) {\n            // 而我们要对同一树层使用过的元素进行跳过\n            if (i > startIndex && nums[i] == nums[i - 1] ) { // 注意这里使用i > startIndex\n                continue;\n            }\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\n\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end()); // 去重需要排序\n        backtracking(nums, 0);\n        return result;\n    }\n};\n#总结\n其实这道题目的知识点，我们之前都讲过了，如果之前讲过的子集问题和去重问题都掌握的好，这道题目应该分分钟AC。\n\n#其他语言版本\n#Java\n使用used数组\n\nclass Solution {\n   List<List<Integer>> result = new ArrayList<>();// 存放符合条件结果的集合\n   LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果\n   boolean[] used;\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        if (nums.length == 0){\n            result.add(path);\n            return result;\n        }\n        Arrays.sort(nums);\n        used = new boolean[nums.length];\n        subsetsWithDupHelper(nums, 0);\n        return result;\n    }\n    \n    private void subsetsWithDupHelper(int[] nums, int startIndex){\n        result.add(new ArrayList<>(path));\n        if (startIndex >= nums.length){\n            return;\n        }\n        for (int i = startIndex; i < nums.length; i++){\n            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]){\n                continue;\n            }\n            path.add(nums[i]);\n            used[i] = true;\n            subsetsWithDupHelper(nums, i + 1);\n            path.removeLast();\n            used[i] = false;\n        }\n    }\n}\n不使用used数组\n\nclass Solution {\n\n  List<List<Integer>> res = new ArrayList<>();\n  LinkedList<Integer> path = new LinkedList<>();\n  \n  public List<List<Integer>> subsetsWithDup( int[] nums ) {\n    Arrays.sort( nums );\n    subsetsWithDupHelper( nums, 0 );\n    return res;\n  }\n\n\n  private void subsetsWithDupHelper( int[] nums, int start ) {\n    res.add( new ArrayList<>( path ) );\n\n    for ( int i = start; i < nums.length; i++ ) {\n        // 跳过当前树层使用过的、相同的元素\n      if ( i > start && nums[i - 1] == nums[i] ) {\n        continue;\n      }\n      path.add( nums[i] );\n      subsetsWithDupHelper( nums, i + 1 );\n      path.removeLast();\n    }\n  }\n\n}\n#Python3\n回溯 利用used数组去重\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        result = []\n        path = []\n        used = [False] * len(nums)\n        nums.sort()  # 去重需要排序\n        self.backtracking(nums, 0, used, path, result)\n        return result\n\n    def backtracking(self, nums, startIndex, used, path, result):\n        result.append(path[:])  # 收集子集\n        for i in range(startIndex, len(nums)):\n            # used[i - 1] == True，说明同一树枝 nums[i - 1] 使用过\n            # used[i - 1] == False，说明同一树层 nums[i - 1] 使用过\n            # 而我们要对同一树层使用过的元素进行跳过\n            if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                continue\n            path.append(nums[i])\n            used[i] = True\n            self.backtracking(nums, i + 1, used, path, result)\n            used[i] = False\n            path.pop()\n\n回溯 利用集合去重\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        result = []\n        path = []\n        nums.sort()  # 去重需要排序\n        self.backtracking(nums, 0, path, result)\n        return result\n\n    def backtracking(self, nums, startIndex, path, result):\n        result.append(path[:])  # 收集子集\n        uset = set()\n        for i in range(startIndex, len(nums)):\n            if nums[i] in uset:\n                continue\n            uset.add(nums[i])\n            path.append(nums[i])\n            self.backtracking(nums, i + 1, path, result)\n            path.pop()\n\n回溯 利用递归的时候下一个startIndex是i+1而不是0去重\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        result = []\n        path = []\n        nums.sort()  # 去重需要排序\n        self.backtracking(nums, 0, path, result)\n        return result\n\n    def backtracking(self, nums, startIndex, path, result):\n        result.append(path[:])  # 收集子集\n        for i in range(startIndex, len(nums)):\n            # 而我们要对同一树层使用过的元素进行跳过\n            if i > startIndex and nums[i] == nums[i - 1]:\n                continue\n            path.append(nums[i])\n            self.backtracking(nums, i + 1, path, result)\n            path.pop()"
}