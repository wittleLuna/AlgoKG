{
  "id": "AP_3716c36c",
  "title": "子集",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/subsets/",
  "description": "一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n说明：解集不能包含重复的子集。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "回溯",
    "递归"
  ],
  "data_structure_tags": [
    "数组",
    "列表"
  ],
  "technique_tags": [
    "深度优先搜索"
  ],
  "difficulty": null,
  "solution_approach": "采用回溯法遍历所有可能的子集。通过从startIndex开始递归地选择元素来构建子集，并在每一步添加当前路径到结果集中，以收集所有节点而非仅叶子节点。",
  "key_insights": [
    {
      "content": "子集问题是要求获取树的所有节点作为结果，而组合或分割问题是只关心特定条件下的叶子节点。这意味着对于子集问题，每次递归调用都需要保存当前path为一种有效答案。"
    },
    {
      "content": "由于子集中的元素是无序的，一旦一个元素被选取后，在后续的选择中不应再考虑该元素之前的位置。因此，在for循环中从`startIndex`开始而不是0，确保了每个元素只被考虑一次。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "求子集问题和77.组合 (https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)和131.分割回文串 (https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)又不一样了。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex) {\n        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己\n        if (startIndex >= nums.size()) { // 终止条件可以不加\n            return;\n        }\n        for (int i = startIndex; i < nums.size(); i++) {\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        backtracking(nums, 0);\n        return result;\n    }\n};",
          "description": "C++实现求一个整数数组的所有子集"
        },
        {
          "language": "java",
          "code": "class Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    LinkedList<Integer> path = new LinkedList<>();\n    public List<List<Integer>> subsets(int[] nums) {\n        subsetsHelper(nums, 0);\n        return result;\n    }\n\n    private void subsetsHelper(int[] nums, int startIndex){\n        result.add(new ArrayList<>(path));\n        if (startIndex >= nums.length){ \n            return;\n        }\n        for (int i = startIndex; i < nums.length; i++){\n            path.add(nums[i]);\n            subsetsHelper(nums, i + 1);\n            path.removeLast();\n        }\n    }\n}",
          "description": "Java实现求一个整数数组的所有子集"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def subsets(self, nums):\n        result = []\n        path = []\n        self.backtracking(nums, 0, path, result)\n        return result\n\n    def backtracking(self, nums, startIndex, path, result):\n        result.append(path[:])  \n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            self.backtracking(nums, i + 1, path, result)\n            path.pop()",
          "description": "Python实现求一个整数数组的所有子集"
        }
      ],
      "subsections": []
    },
    {
      "name": "回溯三部曲",
      "text": "递归函数参数",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) { result.push_back(path); if (startIndex >= nums.size()) { return; } for (int i = startIndex; i < nums.size(); i++) { path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } } public: vector<vector<int>> subsets(vector<int>& nums) { result.clear(); path.clear(); backtracking(nums, 0); return result; }};",
          "description": "C++实现的子集问题解决方案"
        },
        {
          "language": "java",
          "code": "class Solution { List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); public List<List<Integer>> subsets(int[] nums) { subsetsHelper(nums, 0); return result; } private void subsetsHelper(int[] nums, int startIndex){ result.add(new ArrayList<>(path)); if (startIndex >= nums.length){ return; } for (int i = startIndex; i < nums.length; i++){ path.add(nums[i]); subsetsHelper(nums, i + 1); path.removeLast(); } }}",
          "description": "Java实现的子集问题解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def subsets(self, nums): result = [] path = [] self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "Python实现的子集问题解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "相信大家经过了",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) { result.push_back(path); if (startIndex >= nums.size()) { return; } for (int i = startIndex; i < nums.size(); i++) { path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); }} public: vector<vector<int>> subsets(vector<int>& nums) { result.clear(); path.clear(); backtracking(nums, 0); return result; }};",
          "description": "C++实现的子集问题回溯算法"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); public List<List<Integer>> subsets(int[] nums) {subsetsHelper(nums, 0); return result;} private void subsetsHelper(int[] nums, int startIndex){result.add(new ArrayList<>(path)); if (startIndex >= nums.length){ return; } for (int i = startIndex; i < nums.length; i++){ path.add(nums[i]); subsetsHelper(nums, i + 1); path.removeLast();}}}",
          "description": "Java实现的子集问题回溯算法"
        },
        {
          "language": "python",
          "code": "class Solution: def subsets(self, nums): result = [] path = [] self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "Python实现的子集问题回溯算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    LinkedList<Integer> path = new LinkedList<>();\n    public List<List<Integer>> subsets(int[] nums) {\n        subsetsHelper(nums, 0);\n        return result;\n    }\n\n    private void subsetsHelper(int[] nums, int startIndex){\n        result.add(new ArrayList<>(path));\n        if (startIndex >= nums.length){\n            return;\n        }\n        for (int i = startIndex; i < nums.length; i++){\n            path.add(nums[i]);\n            subsetsHelper(nums, i + 1);\n            path.removeLast();\n        }\n    }\n}",
          "description": "Java实现子集问题的解法"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def subsets(self, nums):\n        result = []\n        path = []\n        self.backtracking(nums, 0, path, result)\n        return result\n\n    def backtracking(self, nums, startIndex, path, result):\n        result.append(path[:])\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            self.backtracking(nums, i + 1, path, result)\n            path.pop()",
          "description": "Python实现子集问题的解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex) {\n        result.push_back(path);\n        if (startIndex >= nums.size()) {\n            return;\n        }\n        for (int i = startIndex; i < nums.size(); i++) {\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        backtracking(nums, 0);\n        return result;\n    }\n};",
          "description": "C++实现子集问题的解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex) {\n        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己\n        if (startIndex >= nums.size()) { // 终止条件可以不加\n            return;\n        }\n        for (int i = startIndex; i < nums.size(); i++) {\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        backtracking(nums, 0);\n        return result;\n    }\n};",
          "description": "C++实现求解给定数组的所有子集"
        },
        {
          "language": "java",
          "code": "class Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    LinkedList<Integer> path = new LinkedList<>();\n    public List<List<Integer>> subsets(int[] nums) {\n        subsetsHelper(nums, 0);\n        return result;\n    }\n\n    private void subsetsHelper(int[] nums, int startIndex){\n        result.add(new ArrayList<>(path));\n        if (startIndex >= nums.length){ \n            return;\n        }\n        for (int i = startIndex; i < nums.length; i++){\n            path.add(nums[i]);\n            subsetsHelper(nums, i + 1);\n            path.removeLast();\n        }\n    }\n}",
          "description": "Java实现求解给定数组的所有子集"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def subsets(self, nums):\n        result = []\n        path = []\n        self.backtracking(nums, 0, path, result)\n        return result\n\n    def backtracking(self, nums, startIndex, path, result):\n        result.append(path[:])  # 收集子集，要放在终止添加的上面，否则会漏掉自己\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            self.backtracking(nums, i + 1, path, result)\n            path.pop()",
          "description": "Python实现求解给定数组的所有子集"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "class Solution:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) { result.push_back(path); if (startIndex >= nums.size()) { return; } for (int i = startIndex; i < nums.size(); i++) { path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } } public: vector<vector<int>> subsets(vector<int>& nums) { result.clear(); path.clear(); backtracking(nums, 0); return result; }};",
          "description": "C++实现的子集问题解决方案"
        },
        {
          "language": "java",
          "code": "class Solution { List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); public List<List<Integer>> subsets(int[] nums) { subsetsHelper(nums, 0); return result; } private void subsetsHelper(int[] nums, int startIndex){ result.add(new ArrayList<>(path)); if (startIndex >= nums.length){ return; } for (int i = startIndex; i < nums.length; i++){ path.add(nums[i]); subsetsHelper(nums, i + 1); path.removeLast(); } }}",
          "description": "Java实现的子集问题解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def subsets(self, nums): result = [] path = [] self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
          "description": "Python实现的子集问题解决方案"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n * 2^n)",
    "space_complexity": "O(n)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& nums, int startIndex) { result.push_back(path); if (startIndex >= nums.size()) { return; } for (int i = startIndex; i < nums.size(); i++) { path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } } public: vector<vector<int>> subsets(vector<int>& nums) { result.clear(); path.clear(); backtracking(nums, 0); return result; }};",
      "description": "C++实现的子集问题求解算法"
    },
    {
      "language": "java",
      "code": "class Solution { List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); public List<List<Integer>> subsets(int[] nums) { subsetsHelper(nums, 0); return result; } private void subsetsHelper(int[] nums, int startIndex){ result.add(new ArrayList<>(path)); if (startIndex >= nums.length){ return; } for (int i = startIndex; i < nums.length; i++){ path.add(nums[i]); subsetsHelper(nums, i + 1); path.removeLast(); } }}",
      "description": "Java实现的子集问题求解算法"
    },
    {
      "language": "python",
      "code": "class Solution: def subsets(self, nums): result = [] path = [] self.backtracking(nums, 0, path, result) return result def backtracking(self, nums, startIndex, path, result): result.append(path[:]) for i in range(startIndex, len(nums)): path.append(nums[i]) self.backtracking(nums, i + 1, path, result) path.pop()",
      "description": "Python实现的子集问题求解算法"
    }
  ],
  "common_mistakes": [
    "忘记在回溯算法前向结果集合添加当前路径，导致某些子集丢失。",
    "错误地将for循环起始位置设置为0而非`startIndex`，造成重复计算相同的子集。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/78.%E5%AD%90%E9%9B%86.png",
      "description": "这张图片展示了通过递归和横向遍历生成集合 {1, 2, 3} 的所有子集的算法过程。",
      "context": "该图片展示了一个以nums = [1,2,3]为例的子集问题被抽象成树形结构的过程，其中红线部分标识了遍历过程中记录的所有节点，这些节点构成了所需的子集集合。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/78.%E5%AD%90%E9%9B%86.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/78.%E5%AD%90%E9%9B%86.png",
      "context": "该图片展示了以nums = [1,2,3]为例，将求子集问题抽象成的树型结构，通过遍历这棵树并记录所有节点来获取所有的子集。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/78.%E5%AD%90%E9%9B%86.png",
      "description": "GIF展示了通过回溯算法求解子集问题时树形结构的遍历过程。",
      "context": "GIF动画展示了以nums = [1,2,3]为例，通过树型结构遍历求解所有子集的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\回溯算法\\子集.txt",
  "extracted_at": "2025-07-21T10:53:57.711632",
  "raw_content": "子集\n力扣题目链接(https://leetcode.cn/problems/subsets/)\n\n给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n说明：解集不能包含重复的子集。\n\n示例: 输入: nums = [1,2,3] 输出: [ [3],   [1],   [2],   [1,2,3],   [1,3],   [2,3],   [1,2],   [] ]\n\n\n#思路\n求子集问题和77.组合 (https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)和131.分割回文串 (https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)又不一样了。\n\n如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！\n\n其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。\n\n那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！\n\n有同学问了，什么时候for可以从0开始呢？\n\n求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。\n\n以示例中nums = [1,2,3]为例把求子集抽象为树型结构，如下：\n\nhttps://file1.kamacoder.com/i/algo/78.%E5%AD%90%E9%9B%86.png\n从图中红线部分，可以看出遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合。\n\n#回溯三部曲\n递归函数参数\n全局变量数组path为子集收集元素，二维数组result存放子集组合。（也可以放到递归函数参数里）\n\n递归函数参数在上面讲到了，需要startIndex。\n\n代码如下：\n\nvector<vector<int>> result;\nvector<int> path;\nvoid backtracking(vector<int>& nums, int startIndex) {\n递归终止条件\n\n从图中可以看出：\n\nhttps://file1.kamacoder.com/i/algo/78.%E5%AD%90%E9%9B%86.png\n\n剩余集合为空的时候，就是叶子节点。\n\n那么什么时候剩余集合为空呢？\n\n就是startIndex已经大于数组的长度了，就终止了，因为没有元素可取了，代码如下:\n\nif (startIndex >= nums.size()) {\n    return;\n}\n其实可以不需要加终止条件，因为startIndex >= nums.size()，本层for循环本来也结束了。\n\n单层搜索逻辑\n求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树。\n\n那么单层递归逻辑代码如下：\n\nfor (int i = startIndex; i < nums.size(); i++) {\n    path.push_back(nums[i]);    // 子集收集元素\n    backtracking(nums, i + 1);  // 注意从i+1开始，元素不重复取\n    path.pop_back();            // 回溯\n}\n根据关于回溯算法，你该了解这些！ (https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)给出的回溯算法模板：\n\nvoid backtracking(参数) {\n    if (终止条件) {\n        存放结果;\n        return;\n    }\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\n        处理节点;\n        backtracking(路径，选择列表); // 递归\n        回溯，撤销处理结果\n    }\n}\n可以写出如下回溯算法C++代码：\n\nclass Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int startIndex) {\n        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己\n        if (startIndex >= nums.size()) { // 终止条件可以不加\n            return;\n        }\n        for (int i = startIndex; i < nums.size(); i++) {\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        backtracking(nums, 0);\n        return result;\n    }\n};\n\n时间复杂度: O(n * 2^n)\n空间复杂度: O(n)\n在注释中，可以发现可以不写终止条件，因为本来我们就要遍历整棵树。\n\n有的同学可能担心不写终止条件会不会无限递归？\n\n并不会，因为每次递归的下一层就是从i+1开始的。\n\n#总结\n相信大家经过了\n\n组合问题：\n77.组合(https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)\n回溯算法：组合问题再剪剪枝(https://programmercarl.com/0077.%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96.html)\n216.组合总和III(https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html)\n17.电话号码的字母组合(https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html)\n39.组合总和(https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)\n40.组合总和II(https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html)\n分割问题：\n131.分割回文串(https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)\n93.复原IP地址(https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html)\n洗礼之后，发现子集问题还真的有点简单了，其实这就是一道标准的模板题。\n\n但是要清楚子集问题和组合问题、分割问题的的区别，子集是收集树形结构中树的所有节点的结果。\n\n而组合问题、分割问题是收集树形结构中叶子节点的结果。\n\n#其他语言版本\n#Java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();// 存放符合条件结果的集合\n    LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果\n    public List<List<Integer>> subsets(int[] nums) {\n        subsetsHelper(nums, 0);\n        return result;\n    }\n\n    private void subsetsHelper(int[] nums, int startIndex){\n        result.add(new ArrayList<>(path));//「遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合」。\n        if (startIndex >= nums.length){ //终止条件可不加\n            return;\n        }\n        for (int i = startIndex; i < nums.length; i++){\n            path.add(nums[i]);\n            subsetsHelper(nums, i + 1);\n            path.removeLast();\n        }\n    }\n}\n#Python\nclass Solution:\n    def subsets(self, nums):\n        result = []\n        path = []\n        self.backtracking(nums, 0, path, result)\n        return result\n\n    def backtracking(self, nums, startIndex, path, result):\n        result.append(path[:])  # 收集子集，要放在终止添加的上面，否则会漏掉自己\n        # if startIndex >= len(nums):  # 终止条件可以不加\n        #     return\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            self.backtracking(nums, i + 1, path, result)\n            path.pop()"
}