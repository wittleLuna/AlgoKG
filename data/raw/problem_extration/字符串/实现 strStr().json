{
  "id": "AP_00764266",
  "title": "实现 strStr()",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/",
  "description": "一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "字符串处理",
    "KMP"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "模式匹配",
    "前缀表"
  ],
  "difficulty": null,
  "solution_approach": "采用KMP算法来实现字符串匹配。通过构建一个next数组（或称前缀表），记录模式串中每个位置之前的最大相同前后缀长度，从而在遇到不匹配时能够快速跳过已知不可能匹配的部分，直接从下一个可能的位置开始比较，显著提高了匹配效率。",
  "key_insights": [
    {
      "content": "前缀表记录了到当前位置为止的子串内最长相同前缀后缀的长度，这使得当出现不匹配时，可以依据此值决定下一步匹配的位置，避免了不必要的重复对比。"
    },
    {
      "content": "利用前缀表中的信息，在字符不匹配发生时，可以直接跳跃至下一个潜在匹配起点，而不是简单地回溯到模式串开头重新开始，这样大大减少了总的比较次数，优化了时间复杂度。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "KMP有什么用",
      "text": "KMP主要应用在字符串匹配上。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: void getNext(int* next, const string& s) { int j = -1; next[0] = j; for(int i = 1; i < s.size(); i++) { while (j >= 0 && s[i] != s[j + 1]) { j = next[j]; } if (s[i] == s[j + 1]) { j++; } next[i] = j; }} int strStr(string haystack, string needle) { if (needle.size() == 0) { return 0; } vector<int> next(needle.size()); getNext(&next[0], needle); int j = -1; for (int i = 0; i < haystack.size(); i++) { while(j >= 0 && haystack[i] != needle[j + 1]) { j = next[j]; } if (haystack[i] == needle[j + 1]) { j++; } if (j == (needle.size() - 1) ) { return (i - needle.size() + 1); }}} return -1;}};",
          "description": "KMP算法的C++实现，使用前缀表统一减一的方法。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: void getNext(int* next, const string& s) { int j = 0; next[0] = 0; for(int i = 1; i < s.size(); i++) { while (j > 0 && s[i] != s[j]) { j = next[j - 1]; } if (s[i] == s[j]) { j++; } next[i] = j; }} int strStr(string haystack, string needle) { if (needle.size() == 0) { return 0; } vector<int> next(needle.size()); getNext(&next[0], needle); int j = 0; for (int i = 0; i < haystack.size(); i++) { while(j > 0 && haystack[i] != needle[j]) { j = next[j - 1]; } if (haystack[i] == needle[j]) { j++; } if (j == needle.size() ) { return (i - needle.size() + 1); }}} return -1;}};",
          "description": "KMP算法的C++实现，直接使用前缀表作为next数组。"
        },
        {
          "language": "java",
          "code": "class Solution {public int strStr(String haystack, String needle) { int m = needle.length(); if (m == 0) { return 0; } int n = haystack.length(); if (n < m) { return -1; } int i = 0, j = 0; while (i < n - m + 1) { while (i < n && haystack.charAt(i) != needle.charAt(j)) { i++; } if (i == n) { return -1; } i++; j++; while (i < n && j < m && haystack.charAt(i) == needle.charAt(j)) { i++; j++; } if (j == m) { return i - j; } else { i -= j - 1; j = 0; }}} return -1;}}",
          "description": "基于窗口滑动的字符串匹配Java实现。"
        },
        {
          "language": "java",
          "code": "class Solution {public void getNext(int[] next, String s){ int j = -1; next[0] = j; for (int i = 1; i < s.length(); i++){ while(j >= 0 && s.charAt(i) != s.charAt(j+1)){ j=next[j]; } if(s.charAt(i) == s.charAt(j+1)){ j++; } next[i] = j; }} public int strStr(String haystack, String needle) { if(needle.length()==0){ return 0; } int[] next = new int[needle.length()]; getNext(next, needle); int j = -1; for(int i = 0; i < haystack.length(); i++){ while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){ j = next[j]; } if(haystack.charAt(i) == needle.charAt(j+1)){ j++; } if(j == needle.length()-1){ return (i-needle.length()+1); }}} return -1;}}",
          "description": "KMP算法的Java实现，使用前缀表统一减一的方法。"
        },
        {
          "language": "java",
          "code": "class Solution {public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; int[] next = new int[needle.length()]; getNext(next, needle); int j = 0; for (int i = 0; i < haystack.length(); i++) { while (j > 0 && needle.charAt(j) != haystack.charAt(i)) j = next[j - 1]; if (needle.charAt(j) == haystack.charAt(i)) j++; if (j == needle.length()) return i - needle.length() + 1; } return -1;} private void getNext(int[] next, String s) { int j = 0; next[0] = 0; for (int i = 1; i < s.length(); i++) { while (j > 0 && s.charAt(j) != s.charAt(i)) j = next[j - 1]; if (s.charAt(j) == s.charAt(i)) j++; next[i] = j;}}}",
          "description": "KMP算法的Java实现，直接使用前缀表作为next数组。"
        },
        {
          "language": "python",
          "code": "class Solution: def getNext(self, next, s): j = -1 next[0] = j for i in range(1, len(s)): while j >= 0 and s[i] != s[j+1]: j = next[j] if s[i] == s[j+1]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if not needle: return 0 next = [0] * len(needle) self.getNext(next, needle) j = -1 for i in range(len(haystack)): while j >= 0 and haystack[i] != needle[j+1]: j = next[j] if haystack[i] == needle[j+1]: j += 1 if j == len(needle) - 1: return i - len(needle) + 1 return -1",
          "description": "KMP算法的Python实现，使用前缀表统一减一的方法。"
        },
        {
          "language": "python",
          "code": "class Solution: def getNext(self, next: List[int], s: str) -> None: j = 0 next[0] = 0 for i in range(1, len(s)): while j > 0 and s[i] != s[j]: j = next[j - 1] if s[i] == s[j]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if len(needle) == 0: return 0 next = [0] * len(needle) self.getNext(next, needle) j = 0 for i in range(len(haystack)): while j > 0 and haystack[i] != needle[j]: j = next[j - 1] if haystack[i] == needle[j]: j += 1 if j == len(needle): return i - len(needle) + 1 return -1",
          "description": "KMP算法的Python实现，直接使用前缀表作为next数组。"
        }
      ],
      "subsections": []
    },
    {
      "name": "什么是前缀表",
      "text": "写过KMP的同学，一定都写过next数组，那么这个next数组究竟是个啥呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: void getNext(int* next, const string& s) { int j = -1; next[0] = j; for(int i = 1; i < s.size(); i++) { while (j >= 0 && s[i] != s[j + 1]) { j = next[j]; } if (s[i] == s[j + 1]) { j++; } next[i] = j; }} int strStr(string haystack, string needle) { if (needle.size() == 0) { return 0; } vector<int> next(needle.size()); getNext(&next[0], needle); int j = -1; for (int i = 0; i < haystack.size(); i++) { while(j >= 0 && haystack[i] != needle[j + 1]) { j = next[j]; } if (haystack[i] == needle[j + 1]) { j++; } if (j == (needle.size() - 1)) { return (i - needle.size() + 1); }}} return -1;}};",
          "description": "KMP算法实现，使用前缀表减一的方式"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: void getNext(int* next, const string& s) { int j = 0; next[0] = 0; for(int i = 1; i < s.size(); i++) { while (j > 0 && s[i] != s[j]) { j = next[j - 1]; } if (s[i] == s[j]) { j++; } next[i] = j; }} int strStr(string haystack, string needle) { if (needle.size() == 0) { return 0; } vector<int> next(needle.size()); getNext(&next[0], needle); int j = 0; for (int i = 0; i < haystack.size(); i++) { while(j > 0 && haystack[i] != needle[j]) { j = next[j - 1]; } if (haystack[i] == needle[j]) { j++; } if (j == needle.size()) { return (i - needle.size() + 1); }}} return -1;}};",
          "description": "KMP算法实现，直接使用前缀表"
        },
        {
          "language": "java",
          "code": "class Solution { public void getNext(int[] next, String s){ int j = -1; next[0] = j; for (int i = 1; i < s.length(); i++){ while(j >= 0 && s.charAt(i) != s.charAt(j+1)){ j=next[j]; } if(s.charAt(i) == s.charAt(j+1)){ j++; } next[i] = j; } } public int strStr(String haystack, String needle) { if(needle.length()==0){ return 0; } int[] next = new int[needle.length()]; getNext(next, needle); int j = -1; for(int i = 0; i < haystack.length(); i++){ while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){ j = next[j]; } if(haystack.charAt(i) == needle.charAt(j+1)){ j++; } if(j == needle.length()-1){ return (i-needle.length()+1); } } return -1; }}",
          "description": "Java版本的KMP算法实现，使用前缀表减一的方式"
        },
        {
          "language": "java",
          "code": "class Solution { public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; int[] next = new int[needle.length()]; getNext(next, needle); int j = 0; for (int i = 0; i < haystack.length(); i++) { while (j > 0 && needle.charAt(j) != haystack.charAt(i)) j = next[j - 1]; if (needle.charAt(j) == haystack.charAt(i)) j++; if (j == needle.length()) return i - needle.length() + 1; } return -1; } private void getNext(int[] next, String s) { int j = 0; next[0] = 0; for (int i = 1; i < s.length(); i++) { while (j > 0 && s.charAt(j) != s.charAt(i)) j = next[j - 1]; if (s.charAt(j) == s.charAt(i)) j++; next[i] = j; }}}",
          "description": "Java版本的KMP算法实现，直接使用前缀表"
        },
        {
          "language": "python",
          "code": "class Solution: def getNext(self, next, s): j = -1 next[0] = j for i in range(1, len(s)): while j >= 0 and s[i] != s[j+1]: j = next[j] if s[i] == s[j+1]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if not needle: return 0 next = [0] * len(needle) self.getNext(next, needle) j = -1 for i in range(len(haystack)): while j >= 0 and haystack[i] != needle[j+1]: j = next[j] if haystack[i] == needle[j+1]: j += 1 if j == len(needle) - 1: return i - len(needle) + 1 return -1",
          "description": "Python版本的KMP算法实现，使用前缀表减一的方式"
        },
        {
          "language": "python",
          "code": "class Solution: def getNext(self, next: List[int], s: str) -> None: j = 0 next[0] = 0 for i in range(1, len(s)): while j > 0 and s[i] != s[j]: j = next[j - 1] if s[i] == s[j]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if len(needle) == 0: return 0 next = [0] * len(needle) self.getNext(next, needle) j = 0 for i in range(len(haystack)): while j > 0 and haystack[i] != needle[j]: j = next[j - 1] if haystack[i] == needle[j]: j += 1 if j == len(needle): return i - len(needle) + 1 return -1",
          "description": "Python版本的KMP算法实现，直接使用前缀表"
        }
      ],
      "subsections": []
    },
    {
      "name": "最长公共前后缀",
      "text": "文章中字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void getNext(int* next, const string& s) {\n        int j = -1;\n        next[0] = j;\n        for(int i = 1; i < s.size(); i++) { \n            while (j >= 0 && s[i] != s[j + 1]) { \n                j = next[j]; \n            }\n            if (s[i] == s[j + 1]) { \n                j++;\n            }\n            next[i] = j; \n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0) {\n            return 0;\n        }\n\tvector<int> next(needle.size());\n\tgetNext(&next[0], needle);\n        int j = -1; \n        for (int i = 0; i < haystack.size(); i++) { \n            while(j >= 0 && haystack[i] != needle[j + 1]) { \n                j = next[j]; \n            }\n            if (haystack[i] == needle[j + 1]) { \n                j++; \n            }\n            if (j == (needle.size() - 1) ) { \n                return (i - needle.size() + 1);\n            }\n        }\n        return -1;\n    }\n};",
          "description": "KMP算法实现strStr功能，使用前缀表统一减一后的next数组。"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void getNext(int* next, const string& s) {\n        int j = 0;\n        next[0] = 0;\n        for(int i = 1; i < s.size(); i++) {\n            while (j > 0 && s[i] != s[j]) {\n                j = next[j - 1];\n            }\n            if (s[i] == s[j]) {\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0) {\n            return 0;\n        }\n        vector<int> next(needle.size());\n        getNext(&next[0], needle);\n        int j = 0;\n        for (int i = 0; i < haystack.size(); i++) {\n            while(j > 0 && haystack[i] != needle[j]) {\n                j = next[j - 1];\n            }\n            if (haystack[i] == needle[j]) {\n                j++;\n            }\n            if (j == needle.size() ) {\n                return (i - needle.size() + 1);\n            }\n        }\n        return -1;\n    }\n};",
          "description": "KMP算法实现strStr功能，直接使用前缀表作为next数组。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        int n = haystack.length(), m = needle.length();\n        char[] s = haystack.toCharArray(), p = needle.toCharArray();\n\n        for (int i = 0; i < n - m + 1; i++) {\n            int a = i, b = 0;\n            while (b < m && s[a] == p[b]) {\n                a++;\n                b++;\n            }\n            if (b == m) return i;\n        }\n\n        return -1;\n    }\n}",
          "description": "暴力法实现strStr功能，时间复杂度为O(n*m)。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        int m = needle.length();\n        if (m == 0) {\n            return 0;\n        }\n        int n = haystack.length();\n        if (n < m) {\n            return -1;\n        }\n        int i = 0, j = 0;\n        while (i < n - m + 1) {\n            while (i < n && haystack.charAt(i) != needle.charAt(j)) {\n                i++;\n            }\n            if (i == n) {\n                return -1;\n            }\n            i++;\n            j++;\n            while (i < n && j < m && haystack.charAt(i) == needle.charAt(j)) {\n                i++;\n                j++;\n            }\n            if (j == m) {\n                return i - j;\n            } else {\n                i -= j - 1;\n                j = 0;\n            }\n        }\n        return -1;\n    }\n}",
          "description": "基于窗口滑动的算法实现strStr功能，时间复杂度为O(m*n)。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public void getNext(int[] next, String s){\n        int j = -1;\n        next[0] = j;\n        for (int i = 1; i < s.length(); i++){\n            while(j >= 0 && s.charAt(i) != s.charAt(j+1)){\n                j=next[j];\n            }\n\n            if(s.charAt(i) == s.charAt(j+1)){\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    public int strStr(String haystack, String needle) {\n        if(needle.length()==0){\n            return 0;\n        }\n\n        int[] next = new int[needle.length()];\n        getNext(next, needle);\n        int j = -1;\n        for(int i = 0; i < haystack.length(); i++){\n            while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){\n                j = next[j];\n            }\n            if(haystack.charAt(i) == needle.charAt(j+1)){\n                j++;\n            }\n            if(j == needle.length()-1){\n                return (i-needle.length()+1);\n            }\n        }\n\n        return -1;\n    }\n}",
          "description": "Java版本的KMP算法实现strStr功能，使用前缀表统一减一后的next数组。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        int[] next = new int[needle.length()];\n        getNext(next, needle);\n\n        int j = 0;\n        for (int i = 0; i < haystack.length(); i++) {\n            while (j > 0 && needle.charAt(j) != haystack.charAt(i)) \n                j = next[j - 1];\n            if (needle.charAt(j) == haystack.charAt(i)) \n                j++;\n            if (j == needle.length()) \n                return i - needle.length() + 1;\n        }\n        return -1;\n    }\n    private void getNext(int[] next, String s) {\n        int j = 0;\n        next[0] = 0;\n        for (int i = 1; i < s.length(); i++) {\n            while (j > 0 && s.charAt(j) != s.charAt(i)) \n                j = next[j - 1];\n            if (s.charAt(j) == s.charAt(i)) \n                j++;\n            next[i] = j; \n        }\n    }\n}",
          "description": "Java版本的KMP算法实现strStr功能，直接使用前缀表作为next数组。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def getNext(self, next, s):\n        j = -1\n        next[0] = j\n        for i in range(1, len(s)):\n            while j >= 0 and s[i] != s[j+1]:\n                j = next[j]\n            if s[i] == s[j+1]:\n                j += 1\n            next[i] = j\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        next = [0] * len(needle)\n        self.getNext(next, needle)\n        j = -1\n        for i in range(len(haystack)):\n            while j >= 0 and haystack[i] != needle[j+1]:\n                j = next[j]\n            if haystack[i] == needle[j+1]:\n                j += 1\n            if j == len(needle) - 1:\n                return i - len(needle) + 1\n        return -1",
          "description": "Python版本的KMP算法实现strStr功能，使用前缀表统一减一后的next数组。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def getNext(self, next: List[int], s: str) -> None:\n        j = 0\n        next[0] = 0\n        for i in range(1, len(s)):\n            while j > 0 and s[i] != s[j]:\n                j = next[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            next[i] = j\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if len(needle) == 0:\n            return 0\n        next = [0] * len(needle)\n        self.getNext(next, needle)\n        j = 0\n        for i in range(len(haystack)):\n            while j > 0 and haystack[i] != needle[j]:\n                j = next[j - 1]\n            if haystack[i] == needle[j]:\n                j += 1\n            if j == len(needle):\n                return i - len(needle) + 1\n        return -1",
          "description": "Python版本的KMP算法实现strStr功能，直接使用前缀表作为next数组。"
        },
        {
          "language": "python",
          "code": "class Solution(object):\n    def strStr(self, haystack, needle):\n        m, n = len(haystack), len(needle)\n        for i in range(m):\n            if haystack[i:i+n] == needle:\n                return i\n        return -1",
          "description": "暴力法实现strStr功能，适用于Python。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        try:\n            return haystack.index(needle)\n        except ValueError:\n            return -1",
          "description": "使用Python内置函数index实现strStr功能。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        return haystack.find(needle)",
          "description": "使用Python内置函数find实现strStr功能。"
        }
      ],
      "subsections": []
    },
    {
      "name": "为什么一定要用前缀表",
      "text": "这就是前缀表，那为啥就能告诉我们 上次匹配的位置，并跳过去呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void getNext(int* next, const string& s) {\n        int j = -1;\n        next[0] = j;\n        for(int i = 1; i < s.size(); i++) { // 注意i从1开始\n            while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了\n                j = next[j]; // 向前回退\n            }\n            if (s[i] == s[j + 1]) { // 找到相同的前后缀\n                j++;\n            }\n            next[i] = j; // 将j（前缀的长度）赋给next[i]\n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0) {\n            return 0;\n        }\n\tvector<int> next(needle.size());\n\tgetNext(&next[0], needle);\n        int j = -1; // // 因为next数组里记录的起始位置为-1\n        for (int i = 0; i < haystack.size(); i++) { // 注意i就从0开始\n            while(j >= 0 && haystack[i] != needle[j + 1]) { // 不匹配\n                j = next[j]; // j 寻找之前匹配的位置\n            }\n            if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动\n                j++; // i的增加在for循环里\n            }\n            if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t\n                return (i - needle.size() + 1);\n            }\n        }\n        return -1;\n    }\n};",
          "description": "KMP算法实现，使用前缀表统一减一后的next数组"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void getNext(int* next, const string& s) {\n        int j = 0;\n        next[0] = 0;\n        for(int i = 1; i < s.size(); i++) {\n            while (j > 0 && s[i] != s[j]) {\n                j = next[j - 1];\n            }\n            if (s[i] == s[j]) {\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0) {\n            return 0;\n        }\n        vector<int> next(needle.size());\n        getNext(&next[0], needle);\n        int j = 0;\n        for (int i = 0; i < haystack.size(); i++) {\n            while(j > 0 && haystack[i] != needle[j]) {\n                j = next[j - 1];\n            }\n            if (haystack[i] == needle[j]) {\n                j++;\n            }\n            if (j == needle.size() ) {\n                return (i - needle.size() + 1);\n            }\n        }\n        return -1;\n    }\n};",
          "description": "KMP算法实现，直接使用前缀表作为next数组"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public void getNext(int[] next, String s){\n        int j = -1;\n        next[0] = j;\n        for (int i = 1; i < s.length(); i++){\n            while(j >= 0 && s.charAt(i) != s.charAt(j+1)){\n                j=next[j];\n            }\n            if(s.charAt(i) == s.charAt(j+1)){\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    public int strStr(String haystack, String needle) {\n        if(needle.length()==0){\n            return 0;\n        }\n        int[] next = new int[needle.length()];\n        getNext(next, needle);\n        int j = -1;\n        for(int i = 0; i < haystack.length(); i++){\n            while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){\n                j = next[j];\n            }\n            if(haystack.charAt(i) == needle.charAt(j+1)){\n                j++;\n            }\n            if(j == needle.length()-1){\n                return (i-needle.length()+1);\n            }\n        }\n        return -1;\n    }\n}",
          "description": "Java版本KMP算法实现，使用前缀表统一减一后的next数组"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        int[] next = new int[needle.length()];\n        getNext(next, needle);\n        int j = 0;\n        for (int i = 0; i < haystack.length(); i++) {\n            while (j > 0 && needle.charAt(j) != haystack.charAt(i)) \n                j = next[j - 1];\n            if (needle.charAt(j) == haystack.charAt(i)) \n                j++;\n            if (j == needle.length()) \n                return i - needle.length() + 1;\n        }\n        return -1;\n    }\n    private void getNext(int[] next, String s) {\n        int j = 0;\n        next[0] = 0;\n        for (int i = 1; i < s.length(); i++) {\n            while (j > 0 && s.charAt(j) != s.charAt(i)) \n                j = next[j - 1];\n            if (s.charAt(j) == s.charAt(i)) \n                j++;\n            next[i] = j; \n        }\n    }\n}",
          "description": "Java版本KMP算法实现，直接使用前缀表作为next数组"
        },
        {
          "language": "python3",
          "code": "class Solution:\n    def getNext(self, next, s):\n        j = -1\n        next[0] = j\n        for i in range(1, len(s)):\n            while j >= 0 and s[i] != s[j+1]:\n                j = next[j]\n            if s[i] == s[j+1]:\n                j += 1\n            next[i] = j\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        next = [0] * len(needle)\n        self.getNext(next, needle)\n        j = -1\n        for i in range(len(haystack)):\n            while j >= 0 and haystack[i] != needle[j+1]:\n                j = next[j]\n            if haystack[i] == needle[j+1]:\n                j += 1\n            if j == len(needle) - 1:\n                return i - len(needle) + 1\n        return -1",
          "description": "Python3版本KMP算法实现，使用前缀表统一减一后的next数组"
        },
        {
          "language": "python3",
          "code": "class Solution:\n    def getNext(self, next: List[int], s: str) -> None:\n        j = 0\n        next[0] = 0\n        for i in range(1, len(s)):\n            while j > 0 and s[i] != s[j]:\n                j = next[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            next[i] = j\n    def strStr(self, haystack: str, needle: str) -> int:\n        if len(needle) == 0:\n            return 0\n        next = [0] * len(needle)\n        self.getNext(next, needle)\n        j = 0\n        for i in range(len(haystack)):\n            while j > 0 and haystack[i] != needle[j]:\n                j = next[j - 1]\n            if haystack[i] == needle[j]:\n                j += 1\n            if j == len(needle):\n                return i - len(needle) + 1\n        return -1",
          "description": "Python3版本KMP算法实现，直接使用前缀表作为next数组"
        }
      ],
      "subsections": []
    },
    {
      "name": "如何计算前缀表",
      "text": "接下来就要说一说怎么计算前缀表。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "void getNext(int* next, const string& s) {\n    int j = -1;\n    next[0] = j;\n    for(int i = 1; i < s.size(); i++) {\n        while (j >= 0 && s[i] != s[j + 1]) {\n            j = next[j];\n        }\n        if (s[i] == s[j + 1]) {\n            j++;\n        }\n        next[i] = j;\n    }\n}\nint strStr(string haystack, string needle) {\n    if (needle.size() == 0) {\n        return 0;\n    }\n    vector<int> next(needle.size());\n    getNext(&next[0], needle);\n    int j = -1;\n    for (int i = 0; i < haystack.size(); i++) {\n        while(j >= 0 && haystack[i] != needle[j + 1]) {\n            j = next[j];\n        }\n        if (haystack[i] == needle[j + 1]) {\n            j++;\n        }\n        if (j == (needle.size() - 1)) {\n            return (i - needle.size() + 1);\n        }\n    }\n    return -1;\n}",
          "description": "KMP算法的C++实现，采用前缀表统一减一的方式。"
        },
        {
          "language": "cpp",
          "code": "void getNext(int* next, const string& s) {\n    int j = 0;\n    next[0] = 0;\n    for(int i = 1; i < s.size(); i++) {\n        while (j > 0 && s[i] != s[j]) {\n            j = next[j - 1];\n        }\n        if (s[i] == s[j]) {\n            j++;\n        }\n        next[i] = j;\n    }\n}\nint strStr(string haystack, string needle) {\n    if (needle.size() == 0) {\n        return 0;\n    }\n    vector<int> next(needle.size());\n    getNext(&next[0], needle);\n    int j = 0;\n    for (int i = 0; i < haystack.size(); i++) {\n        while(j > 0 && haystack[i] != needle[j]) {\n            j = next[j - 1];\n        }\n        if (haystack[i] == needle[j]) {\n            j++;\n        }\n        if (j == needle.size()) {\n            return (i - needle.size() + 1);\n        }\n    }\n    return -1;\n}",
          "description": "KMP算法的C++实现，直接使用前缀表作为next数组。"
        },
        {
          "language": "java",
          "code": "public void getNext(int[] next, String s){\n    int j = -1;\n    next[0] = j;\n    for (int i = 1; i < s.length(); i++){\n        while(j >= 0 && s.charAt(i) != s.charAt(j+1)){\n            j=next[j];\n        }\n\n        if(s.charAt(i) == s.charAt(j+1)){\n            j++;\n        }\n        next[i] = j;\n    }\n}\npublic int strStr(String haystack, String needle) {\n    if(needle.length()==0){\n        return 0;\n    }\n\n    int[] next = new int[needle.length()];\n    getNext(next, needle);\n    int j = -1;\n    for(int i = 0; i < haystack.length(); i++){\n        while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){\n            j = next[j];\n        }\n        if(haystack.charAt(i) == needle.charAt(j+1)){\n            j++;\n        }\n        if(j == needle.length()-1){\n            return (i-needle.length()+1);\n        }\n    }\n\n    return -1;\n}",
          "description": "KMP算法的Java实现，采用前缀表统一减一的方式。"
        },
        {
          "language": "java",
          "code": "public int strStr(String haystack, String needle) {\n    if (needle.length() == 0) return 0;\n    int[] next = new int[needle.length()];\n    getNext(next, needle);\n\n    int j = 0;\n    for (int i = 0; i < haystack.length(); i++) {\n        while (j > 0 && needle.charAt(j) != haystack.charAt(i)) \n            j = next[j - 1];\n        if (needle.charAt(j) == haystack.charAt(i)) \n            j++;\n        if (j == needle.length()) \n            return i - needle.length() + 1;\n    }\n    return -1;\n}\nprivate void getNext(int[] next, String s) {\n    int j = 0;\n    next[0] = 0;\n    for (int i = 1; i < s.length(); i++) {\n        while (j > 0 && s.charAt(j) != s.charAt(i)) \n            j = next[j - 1];\n        if (s.charAt(j) == s.charAt(i)) \n            j++;\n        next[i] = j; \n    }\n}",
          "description": "KMP算法的Java实现，直接使用前缀表作为next数组。"
        },
        {
          "language": "python",
          "code": "def getNext(self, next, s):\n    j = -1\n    next[0] = j\n    for i in range(1, len(s)):\n        while j >= 0 and s[i] != s[j+1]:\n            j = next[j]\n        if s[i] == s[j+1]:\n            j += 1\n        next[i] = j\ndef strStr(self, haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    next = [0] * len(needle)\n    self.getNext(next, needle)\n    j = -1\n    for i in range(len(haystack)):\n        while j >= 0 and haystack[i] != needle[j+1]:\n            j = next[j]\n        if haystack[i] == needle[j+1]:\n            j += 1\n        if j == len(needle) - 1:\n            return i - len(needle) + 1\n    return -1",
          "description": "KMP算法的Python实现，采用前缀表统一减一的方式。"
        },
        {
          "language": "python",
          "code": "def getNext(self, next: List[int], s: str) -> None:\n    j = 0\n    next[0] = 0\n    for i in range(1, len(s)):\n        while j > 0 and s[i] != s[j]:\n            j = next[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        next[i] = j\ndef strStr(self, haystack: str, needle: str) -> int:\n    if len(needle) == 0:\n        return 0\n    next = [0] * len(needle)\n    self.getNext(next, needle)\n    j = 0\n    for i in range(len(haystack)):\n        while j > 0 and haystack[i] != needle[j]:\n            j = next[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == len(needle):\n            return i - len(needle) + 1\n    return -1",
          "description": "KMP算法的Python实现，直接使用前缀表作为next数组。"
        }
      ],
      "subsections": []
    },
    {
      "name": "前缀表与next数组",
      "text": "很多KMP算法的实现都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: void getNext(int* next, const string& s) {int j = -1;next[0] = j;for(int i = 1; i < s.size(); i++) {while (j >= 0 && s[i] != s[j + 1]) {j = next[j];}if (s[i] == s[j + 1]) {j++;}next[i] = j;}} int strStr(string haystack, string needle) {if (needle.size() == 0) {return 0;}vector<int> next(needle.size());getNext(&next[0], needle);int j = -1;for (int i = 0; i < haystack.size(); i++) {while(j >= 0 && haystack[i] != needle[j + 1]) {j = next[j];}if (haystack[i] == needle[j + 1]) {j++;}if (j == (needle.size() - 1) ) {return (i - needle.size() + 1);}}return -1;}};",
          "description": "KMP算法实现，使用前缀表减一的next数组进行字符串匹配"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: void getNext(int* next, const string& s) {int j = 0;next[0] = 0;for(int i = 1; i < s.size(); i++) {while (j > 0 && s[i] != s[j]) {j = next[j - 1];}if (s[i] == s[j]) {j++;}next[i] = j;}} int strStr(string haystack, string needle) {if (needle.size() == 0) {return 0;}vector<int> next(needle.size());getNext(&next[0], needle);int j = 0;for (int i = 0; i < haystack.size(); i++) {while(j > 0 && haystack[i] != needle[j]) {j = next[j - 1];}if (haystack[i] == needle[j]) {j++;}if (j == needle.size()) {return (i - needle.size() + 1);}}return -1;}};",
          "description": "KMP算法实现，直接使用前缀表作为next数组进行字符串匹配"
        },
        {
          "language": "java",
          "code": "class Solution {public int strStr(String haystack, String needle) {if (needle.length() == 0) return 0;int[] next = new int[needle.length()];getNext(next, needle);int j = -1;for (int i = 0; i < haystack.length(); i++) {while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){j = next[j];}if(haystack.charAt(i) == needle.charAt(j+1)){j++;}if(j == needle.length()-1){return (i-needle.length()+1);}}return -1;} public void getNext(int[] next, String s){int j = -1;next[0] = j;for (int i = 1; i < s.length(); i++){while(j >= 0 && s.charAt(i) != s.charAt(j+1)){j=next[j];}if(s.charAt(i) == s.charAt(j+1)){j++;}next[i] = j;}}}",
          "description": "Java实现的KMP算法，使用前缀表减一的next数组进行字符串匹配"
        },
        {
          "language": "java",
          "code": "class Solution {public int strStr(String haystack, String needle) {if (needle.length() == 0) return 0;int[] next = new int[needle.length()];getNext(next, needle);int j = 0;for (int i = 0; i < haystack.length(); i++) {while (j > 0 && needle.charAt(j) != haystack.charAt(i))j = next[j - 1];if (needle.charAt(j) == haystack.charAt(i))j++;if (j == needle.length())return i - needle.length() + 1;}return -1;} private void getNext(int[] next, String s) {int j = 0;next[0] = 0;for (int i = 1; i < s.length(); i++) {while (j > 0 && s.charAt(j) != s.charAt(i))j = next[j - 1];if (s.charAt(j) == s.charAt(i))j++;next[i] = j;}}}",
          "description": "Java实现的KMP算法，直接使用前缀表作为next数组进行字符串匹配"
        },
        {
          "language": "python",
          "code": "class Solution: def getNext(self, next, s): j = -1 next[0] = j for i in range(1, len(s)): while j >= 0 and s[i] != s[j+1]: j = next[j] if s[i] == s[j+1]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if not needle: return 0 next = [0] * len(needle) self.getNext(next, needle) j = -1 for i in range(len(haystack)): while j >= 0 and haystack[i] != needle[j+1]: j = next[j] if haystack[i] == needle[j+1]: j += 1 if j == len(needle) - 1: return i - len(needle) + 1 return -1",
          "description": "Python实现的KMP算法，使用前缀表减一的next数组进行字符串匹配"
        },
        {
          "language": "python",
          "code": "class Solution: def getNext(self, next: List[int], s: str) -> None: j = 0 next[0] = 0 for i in range(1, len(s)): while j > 0 and s[i] != s[j]: j = next[j - 1] if s[i] == s[j]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if len(needle) == 0: return 0 next = [0] * len(needle) self.getNext(next, needle) j = 0 for i in range(len(haystack)): while j > 0 and haystack[i] != needle[j]: j = next[j - 1] if haystack[i] == needle[j]: j += 1 if j == len(needle): return i - len(needle) + 1 return -1",
          "description": "Python实现的KMP算法，直接使用前缀表作为next数组进行字符串匹配"
        }
      ],
      "subsections": []
    },
    {
      "name": "使用next数组来匹配",
      "text": "以下我们以前缀表统一减一之后的next数组来做演示。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void getNext(int* next, const string& s) {\n        int j = -1;\n        next[0] = j;\n        for(int i = 1; i < s.size(); i++) { \n            while (j >= 0 && s[i] != s[j + 1]) { \n                j = next[j]; \n            }\n            if (s[i] == s[j + 1]) { \n                j++;\n            }\n            next[i] = j; \n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0) {\n            return 0;\n        }\n\tvector<int> next(needle.size());\n\tgetNext(&next[0], needle);\n        int j = -1; \n        for (int i = 0; i < haystack.size(); i++) { \n            while(j >= 0 && haystack[i] != needle[j + 1]) { \n                j = next[j]; \n            }\n            if (haystack[i] == needle[j + 1]) { \n                j++; \n            }\n            if (j == (needle.size() - 1) ) { \n                return (i - needle.size() + 1);\n            }\n        }\n        return -1;\n    }\n};",
          "description": "C++实现的KMP算法，使用前缀表统一减一的方法。"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void getNext(int* next, const string& s) {\n        int j = 0;\n        next[0] = 0;\n        for(int i = 1; i < s.size(); i++) {\n            while (j > 0 && s[i] != s[j]) {\n                j = next[j - 1];\n            }\n            if (s[i] == s[j]) {\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0) {\n            return 0;\n        }\n        vector<int> next(needle.size());\n        getNext(&next[0], needle);\n        int j = 0;\n        for (int i = 0; i < haystack.size(); i++) {\n            while(j > 0 && haystack[i] != needle[j]) {\n                j = next[j - 1];\n            }\n            if (haystack[i] == needle[j]) {\n                j++;\n            }\n            if (j == needle.size() ) {\n                return (i - needle.size() + 1);\n            }\n        }\n        return -1;\n    }\n};",
          "description": "C++实现的KMP算法，直接使用前缀表作为next数组的方法。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        int m = needle.length();\n        if (m == 0) {\n            return 0;\n        }\n        int n = haystack.length();\n        if (n < m) {\n            return -1;\n        }\n        int i = 0;\n        int j = 0;\n        while (i < n - m + 1) {\n            while (i < n && haystack.charAt(i) != needle.charAt(j)) {\n                i++;\n            }\n            if (i == n) {\n                return -1;\n            }\n            i++;\n            j++;\n            while (i < n && j < m && haystack.charAt(i) == needle.charAt(j)) {\n                i++;\n                j++;\n            }\n            if (j == m) {\n                return i - j;\n            } else {\n                i -= j - 1;\n                j = 0;\n            }\n        }\n        return -1;\n    }\n}",
          "description": "Java实现的基于窗口滑动的字符串匹配算法。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public void getNext(int[] next, String s){\n        int j = -1;\n        next[0] = j;\n        for (int i = 1; i < s.length(); i++){\n            while(j >= 0 && s.charAt(i) != s.charAt(j+1)){\n                j=next[j];\n            }\n\n            if(s.charAt(i) == s.charAt(j+1)){\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    public int strStr(String haystack, String needle) {\n        if(needle.length()==0){\n            return 0;\n        }\n\n        int[] next = new int[needle.length()];\n        getNext(next, needle);\n        int j = -1;\n        for(int i = 0; i < haystack.length(); i++){\n            while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){\n                j = next[j];\n            }\n            if(haystack.charAt(i) == needle.charAt(j+1)){\n                j++;\n            }\n            if(j == needle.length()-1){\n                return (i-needle.length()+1);\n            }\n        }\n\n        return -1;\n    }\n}",
          "description": "Java实现的KMP算法，使用前缀表统一减一的方法。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    //前缀表（不减一）Java实现\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        int[] next = new int[needle.length()];\n        getNext(next, needle);\n\n        int j = 0;\n        for (int i = 0; i < haystack.length(); i++) {\n            while (j > 0 && needle.charAt(j) != haystack.charAt(i)) \n                j = next[j - 1];\n            if (needle.charAt(j) == haystack.charAt(i)) \n                j++;\n            if (j == needle.length()) \n                return i - needle.length() + 1;\n        }\n        return -1;\n    }\n    \n    private void getNext(int[] next, String s) {\n        int j = 0;\n        next[0] = 0;\n        for (int i = 1; i < s.length(); i++) {\n            while (j > 0 && s.charAt(j) != s.charAt(i)) \n                j = next[j - 1];\n            if (s.charAt(j) == s.charAt(i)) \n                j++;\n            next[i] = j; \n        }\n    }\n}",
          "description": "Java实现的KMP算法，直接使用前缀表作为next数组的方法。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def getNext(self, next, s):\n        j = -1\n        next[0] = j\n        for i in range(1, len(s)):\n            while j >= 0 and s[i] != s[j+1]:\n                j = next[j]\n            if s[i] == s[j+1]:\n                j += 1\n            next[i] = j\n    \n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        next = [0] * len(needle)\n        self.getNext(next, needle)\n        j = -1\n        for i in range(len(haystack)):\n            while j >= 0 and haystack[i] != needle[j+1]:\n                j = next[j]\n            if haystack[i] == needle[j+1]:\n                j += 1\n            if j == len(needle) - 1:\n                return i - len(needle) + 1\n        return -1",
          "description": "Python3实现的KMP算法，使用前缀表统一减一的方法。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def getNext(self, next: List[int], s: str) -> None:\n        j = 0\n        next[0] = 0\n        for i in range(1, len(s)):\n            while j > 0 and s[i] != s[j]:\n                j = next[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            next[i] = j\n    \n    def strStr(self, haystack: str, needle: str) -> int:\n        if len(needle) == 0:\n            return 0\n        next = [0] * len(needle)\n        self.getNext(next, needle)\n        j = 0\n        for i in range(len(haystack)):\n            while j > 0 and haystack[i] != needle[j]:\n                j = next[j - 1]\n            if haystack[i] == needle[j]:\n                j += 1\n            if j == len(needle):\n                return i - len(needle) + 1\n        return -1",
          "description": "Python3实现的KMP算法，直接使用前缀表作为next数组的方法。"
        },
        {
          "language": "python",
          "code": "class Solution(object):\n    def strStr(self, haystack, needle):\n        m, n = len(haystack), len(needle)\n        for i in range(m):\n            if haystack[i:i+n] == needle:\n                return i\n        return -1",
          "description": "Python3实现的暴力法来解决字符串匹配问题。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        try:\n            return haystack.index(needle)\n        except ValueError:\n            return -1",
          "description": "Python3实现的使用index方法来解决字符串匹配问题。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        return haystack.find(needle)",
          "description": "Python3实现的使用find方法来解决字符串匹配问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "时间复杂度分析",
      "text": "其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: void getNext(int* next, const string& s) {int j = -1;next[0] = j;for(int i = 1; i < s.size(); i++) {while (j >= 0 && s[i] != s[j + 1]) {j = next[j];}if (s[i] == s[j + 1]) {j++;}next[i] = j;}} int strStr(string haystack, string needle) {if (needle.size() == 0) {return 0;}vector<int> next(needle.size());getNext(&next[0], needle);int j = -1;for (int i = 0; i < haystack.size(); i++) {while(j >= 0 && haystack[i] != needle[j + 1]) {j = next[j];}if (haystack[i] == needle[j + 1]) {j++;}if (j == (needle.size() - 1) ) {return (i - needle.size() + 1);}}}return -1;}};",
          "description": "C++实现的KMP算法，使用前缀表统一减一的方式。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: void getNext(int* next, const string& s) {int j = 0;next[0] = 0;for(int i = 1; i < s.size(); i++) {while (j > 0 && s[i] != s[j]) {j = next[j - 1];}if (s[i] == s[j]) {j++;}next[i] = j;}} int strStr(string haystack, string needle) {if (needle.size() == 0) {return 0;}vector<int> next(needle.size());getNext(&next[0], needle);int j = 0;for (int i = 0; i < haystack.size(); i++) {while(j > 0 && haystack[i] != needle[j]) {j = next[j - 1];}if (haystack[i] == needle[j]) {j++;}if (j == needle.size() ) {return (i - needle.size() + 1);}}}return -1;}};",
          "description": "C++实现的KMP算法，直接使用前缀表作为next数组。"
        },
        {
          "language": "java",
          "code": "class Solution {public int strStr(String haystack, String needle) {if (needle.length() == 0) return 0;int[] next = new int[needle.length()];getNext(next, needle);int j = 0;for (int i = 0; i < haystack.length(); i++) {while (j > 0 && needle.charAt(j) != haystack.charAt(i)) j = next[j - 1];if (needle.charAt(j) == haystack.charAt(i)) j++;if (j == needle.length()) return i - needle.length() + 1;}return -1;}private void getNext(int[] next, String s) {int j = 0;next[0] = 0;for (int i = 1; i < s.length(); i++) {while (j > 0 && s.charAt(j) != s.charAt(i)) j = next[j - 1];if (s.charAt(j) == s.charAt(i)) j++;next[i] = j;}}}",
          "description": "Java实现的KMP算法，直接使用前缀表作为next数组。"
        },
        {
          "language": "python",
          "code": "class Solution: def getNext(self, next, s): j = 0 next[0] = 0 for i in range(1, len(s)): while j > 0 and s[i] != s[j]: j = next[j - 1] if s[i] == s[j]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if len(needle) == 0: return 0 next = [0] * len(needle) self.getNext(next, needle) j = 0 for i in range(len(haystack)): while j > 0 and haystack[i] != needle[j]: j = next[j - 1] if haystack[i] == needle[j]: j += 1 if j == len(needle): return i - len(needle) + 1 return -1",
          "description": "Python实现的KMP算法，直接使用前缀表作为next数组。"
        }
      ],
      "subsections": []
    },
    {
      "name": "构造next数组",
      "text": "我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "void getNext(int* next, const string& s) {\n    int j = -1;\n    next[0] = j;\n    for(int i = 1; i < s.size(); i++) {\n        while (j >= 0 && s[i] != s[j + 1]) {\n            j = next[j];\n        }\n        if (s[i] == s[j + 1]) {\n            j++;\n        }\n        next[i] = j;\n    }\n}\nint strStr(string haystack, string needle) {\n    if (needle.size() == 0) {\n        return 0;\n    }\n    vector<int> next(needle.size());\n    getNext(&next[0], needle);\n    int j = -1;\n    for (int i = 0; i < haystack.size(); i++) {\n        while(j >= 0 && haystack[i] != needle[j + 1]) {\n            j = next[j];\n        }\n        if (haystack[i] == needle[j + 1]) {\n            j++;\n        }\n        if (j == (needle.size() - 1)) {\n            return (i - needle.size() + 1);\n        }\n    }\n    return -1;\n}",
          "description": "KMP算法实现，使用前缀表减一的next数组进行字符串匹配。"
        },
        {
          "language": "cpp",
          "code": "void getNext(int* next, const string& s) {\n    int j = 0;\n    next[0] = 0;\n    for(int i = 1; i < s.size(); i++) {\n        while (j > 0 && s[i] != s[j]) {\n            j = next[j - 1];\n        }\n        if (s[i] == s[j]) {\n            j++;\n        }\n        next[i] = j;\n    }\n}\nint strStr(string haystack, string needle) {\n    if (needle.size() == 0) {\n        return 0;\n    }\n    vector<int> next(needle.size());\n    getNext(&next[0], needle);\n    int j = 0;\n    for (int i = 0; i < haystack.size(); i++) {\n        while(j > 0 && haystack[i] != needle[j]) {\n            j = next[j - 1];\n        }\n        if (haystack[i] == needle[j]) {\n            j++;\n        }\n        if (j == needle.size()) {\n            return (i - needle.size() + 1);\n        }\n    }\n    return -1;\n}",
          "description": "KMP算法另一种实现，直接使用未减一的前缀表作为next数组进行字符串匹配。"
        },
        {
          "language": "java",
          "code": "public void getNext(int[] next, String s){\n    int j = -1;\n    next[0] = j;\n    for (int i = 1; i < s.length(); i++){\n        while(j >= 0 && s.charAt(i) != s.charAt(j+1)){\n            j=next[j];\n        }\n        if(s.charAt(i) == s.charAt(j+1)){\n            j++;\n        }\n        next[i] = j;\n    }\n}\npublic int strStr(String haystack, String needle) {\n    if(needle.length()==0){\n        return 0;\n    }\n    int[] next = new int[needle.length()];\n    getNext(next, needle);\n    int j = -1;\n    for(int i = 0; i < haystack.length(); i++){\n        while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){\n            j = next[j];\n        }\n        if(haystack.charAt(i) == needle.charAt(j+1)){\n            j++;\n        }\n        if(j == needle.length()-1){\n            return (i-needle.length()+1);\n        }\n    }\n    return -1;\n}",
          "description": "Java版KMP算法实现，使用前缀表减一的next数组进行字符串匹配。"
        },
        {
          "language": "java",
          "code": "public int strStr(String haystack, String needle) {\n    if (needle.length() == 0) return 0;\n    int[] next = new int[needle.length()];\n    getNext(next, needle);\n    int j = 0;\n    for (int i = 0; i < haystack.length(); i++) {\n        while (j > 0 && needle.charAt(j) != haystack.charAt(i)) \n            j = next[j - 1];\n        if (needle.charAt(j) == haystack.charAt(i)) \n            j++;\n        if (j == needle.length()) \n            return i - needle.length() + 1;\n    }\n    return -1;\n}\nprivate void getNext(int[] next, String s) {\n    int j = 0;\n    next[0] = 0;\n    for (int i = 1; i < s.length(); i++) {\n        while (j > 0 && s.charAt(j) != s.charAt(i)) \n            j = next[j - 1];\n        if (s.charAt(j) == s.charAt(i)) \n            j++;\n        next[i] = j; \n    }\n}",
          "description": "Java版KMP算法实现，直接使用未减一的前缀表作为next数组进行字符串匹配。"
        },
        {
          "language": "python",
          "code": "def getNext(self, next, s):\n    j = -1\n    next[0] = j\n    for i in range(1, len(s)):\n        while j >= 0 and s[i] != s[j+1]:\n            j = next[j]\n        if s[i] == s[j+1]:\n            j += 1\n        next[i] = j\ndef strStr(self, haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    next = [0] * len(needle)\n    self.getNext(next, needle)\n    j = -1\n    for i in range(len(haystack)):\n        while j >= 0 and haystack[i] != needle[j+1]:\n            j = next[j]\n        if haystack[i] == needle[j+1]:\n            j += 1\n        if j == len(needle) - 1:\n            return i - len(needle) + 1\n    return -1",
          "description": "Python版KMP算法实现，使用前缀表减一的next数组进行字符串匹配。"
        },
        {
          "language": "python",
          "code": "def getNext(self, next: List[int], s: str) -> None:\n    j = 0\n    next[0] = 0\n    for i in range(1, len(s)):\n        while j > 0 and s[i] != s[j]:\n            j = next[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        next[i] = j\ndef strStr(self, haystack: str, needle: str) -> int:\n    if len(needle) == 0:\n        return 0\n    next = [0] * len(needle)\n    self.getNext(next, needle)\n    j = 0\n    for i in range(len(haystack)):\n        while j > 0 and haystack[i] != needle[j]:\n            j = next[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == len(needle):\n            return i - len(needle) + 1\n    return -1",
          "description": "Python版KMP算法实现，直接使用未减一的前缀表作为next数组进行字符串匹配。"
        }
      ],
      "subsections": []
    },
    {
      "name": "使用next数组来做匹配",
      "text": "在文本串s里 找是否出现过模式串t。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "void getNext(int* next, const string& s) {\n    int j = -1;\n    next[0] = j;\n    for(int i = 1; i < s.size(); i++) {\n        while (j >= 0 && s[i] != s[j + 1]) {\n            j = next[j];\n        }\n        if (s[i] == s[j + 1]) {\n            j++;\n        }\n        next[i] = j;\n    }\n}\nint strStr(string haystack, string needle) {\n    if (needle.size() == 0) {\n        return 0;\n    }\n    vector<int> next(needle.size());\n    getNext(&next[0], needle);\n    int j = -1;\n    for (int i = 0; i < haystack.size(); i++) {\n        while(j >= 0 && haystack[i] != needle[j + 1]) {\n            j = next[j];\n        }\n        if (haystack[i] == needle[j + 1]) {\n            j++;\n        }\n        if (j == (needle.size() - 1)) {\n            return (i - needle.size() + 1);\n        }\n    }\n    return -1;\n}",
          "description": "KMP算法实现，使用前缀表统一减一的next数组进行字符串匹配"
        },
        {
          "language": "cpp",
          "code": "void getNext(int* next, const string& s) {\n    int j = 0;\n    next[0] = 0;\n    for(int i = 1; i < s.size(); i++) {\n        while (j > 0 && s[i] != s[j]) {\n            j = next[j - 1];\n        }\n        if (s[i] == s[j]) {\n            j++;\n        }\n        next[i] = j;\n    }\n}\nint strStr(string haystack, string needle) {\n    if (needle.size() == 0) {\n        return 0;\n    }\n    vector<int> next(needle.size());\n    getNext(&next[0], needle);\n    int j = 0;\n    for (int i = 0; i < haystack.size(); i++) {\n        while(j > 0 && haystack[i] != needle[j]) {\n            j = next[j - 1];\n        }\n        if (haystack[i] == needle[j]) {\n            j++;\n        }\n        if (j == needle.size()) {\n            return (i - needle.size() + 1);\n        }\n    }\n    return -1;\n}",
          "description": "KMP算法实现，直接使用不减一的前缀表作为next数组进行字符串匹配"
        },
        {
          "language": "java",
          "code": "public void getNext(int[] next, String s){\n    int j = -1;\n    next[0] = j;\n    for (int i = 1; i < s.length(); i++){\n        while(j >= 0 && s.charAt(i) != s.charAt(j+1)){\n            j=next[j];\n        }\n\n        if(s.charAt(i) == s.charAt(j+1)){\n            j++;\n        }\n        next[i] = j;\n    }\n}\npublic int strStr(String haystack, String needle) {\n    if(needle.length()==0){\n        return 0;\n    }\n\n    int[] next = new int[needle.length()];\n    getNext(next, needle);\n    int j = -1;\n    for(int i = 0; i < haystack.length(); i++){\n        while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){\n            j = next[j];\n        }\n        if(haystack.charAt(i) == needle.charAt(j+1)){\n            j++;\n        }\n        if(j == needle.length()-1){\n            return (i-needle.length()+1);\n        }\n    }\n\n    return -1;\n}",
          "description": "Java版本KMP算法实现，使用前缀表统一减一的next数组进行字符串匹配"
        },
        {
          "language": "java",
          "code": "public int strStr(String haystack, String needle) {\n    if (needle.length() == 0) return 0;\n    int[] next = new int[needle.length()];\n    getNext(next, needle);\n\n    int j = 0;\n    for (int i = 0; i < haystack.length(); i++) {\n        while (j > 0 && needle.charAt(j) != haystack.charAt(i)) \n            j = next[j - 1];\n        if (needle.charAt(j) == haystack.charAt(i)) \n            j++;\n        if (j == needle.length()) \n            return i - needle.length() + 1;\n    }\n    return -1;\n}\nprivate void getNext(int[] next, String s) {\n    int j = 0;\n    next[0] = 0;\n    for (int i = 1; i < s.length(); i++) {\n        while (j > 0 && s.charAt(j) != s.charAt(i)) \n            j = next[j - 1];\n        if (s.charAt(j) == s.charAt(i)) \n            j++;\n        next[i] = j; \n    }\n}",
          "description": "Java版本KMP算法实现，直接使用不减一的前缀表作为next数组进行字符串匹配"
        },
        {
          "language": "python",
          "code": "def getNext(self, next, s):\n    j = -1\n    next[0] = j\n    for i in range(1, len(s)):\n        while j >= 0 and s[i] != s[j+1]:\n            j = next[j]\n        if s[i] == s[j+1]:\n            j += 1\n        next[i] = j\n\ndef strStr(self, haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    next = [0] * len(needle)\n    self.getNext(next, needle)\n    j = -1\n    for i in range(len(haystack)):\n        while j >= 0 and haystack[i] != needle[j+1]:\n            j = next[j]\n        if haystack[i] == needle[j+1]:\n            j += 1\n        if j == len(needle) - 1:\n            return i - len(needle) + 1\n    return -1",
          "description": "Python版本KMP算法实现，使用前缀表统一减一的next数组进行字符串匹配"
        },
        {
          "language": "python",
          "code": "def getNext(self, next: List[int], s: str) -> None:\n    j = 0\n    next[0] = 0\n    for i in range(1, len(s)):\n        while j > 0 and s[i] != s[j]:\n            j = next[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        next[i] = j\n\ndef strStr(self, haystack: str, needle: str) -> int:\n    if len(needle) == 0:\n        return 0\n    next = [0] * len(needle)\n    self.getNext(next, needle)\n    j = 0\n    for i in range(len(haystack)):\n        while j > 0 and haystack[i] != needle[j]:\n            j = next[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == len(needle):\n            return i - len(needle) + 1\n    return -1",
          "description": "Python版本KMP算法实现，直接使用不减一的前缀表作为next数组进行字符串匹配"
        }
      ],
      "subsections": []
    },
    {
      "name": "前缀表统一减一 C++代码实现",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void getNext(int* next, const string& s) {\n        int j = -1;\n        next[0] = j;\n        for(int i = 1; i < s.size(); i++) {\n            while (j >= 0 && s[i] != s[j + 1]) {\n                j = next[j];\n            }\n            if (s[i] == s[j + 1]) {\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0) {\n            return 0;\n        }\n        vector<int> next(needle.size());\n        getNext(&next[0], needle);\n        int j = -1;\n        for (int i = 0; i < haystack.size(); i++) {\n            while(j >= 0 && haystack[i] != needle[j + 1]) {\n                j = next[j];\n            }\n            if (haystack[i] == needle[j + 1]) {\n                j++;\n            }\n            if (j == (needle.size() - 1)) {\n                return (i - needle.size() + 1);\n            }\n        }\n        return -1;\n    }\n};",
          "description": "使用前缀表统一减一的C++实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void getNext(int* next, const string& s) {\n        int j = 0;\n        next[0] = 0;\n        for(int i = 1; i < s.size(); i++) {\n            while (j > 0 && s[i] != s[j]) {\n                j = next[j - 1];\n            }\n            if (s[i] == s[j]) {\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0) {\n            return 0;\n        }\n        vector<int> next(needle.size());\n        getNext(&next[0], needle);\n        int j = 0;\n        for (int i = 0; i < haystack.size(); i++) {\n            while(j > 0 && haystack[i] != needle[j]) {\n                j = next[j - 1];\n            }\n            if (haystack[i] == needle[j]) {\n                j++;\n            }\n            if (j == needle.size()) {\n                return (i - needle.size() + 1);\n            }\n        }\n        return -1;\n    }\n};",
          "description": "直接使用前缀表作为next数组的C++实现"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        int n = haystack.length(), m = needle.length();\n        char[] s = haystack.toCharArray(), p = needle.toCharArray();\n        for (int i = 0; i < n - m + 1; i++) {\n            int a = i, b = 0;\n            while (b < m && s[a] == p[b]) {\n                a++;\n                b++;\n            }\n            if (b == m) return i;\n        }\n        return -1;\n    }\n}",
          "description": "Java暴力法实现strStr"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        int m = needle.length();\n        if (haystack.length() < m) return -1;\n        int[] next = new int[m];\n        getNext(next, needle);\n        int j = -1;\n        for (int i = 0; i < haystack.length(); i++) {\n            while (j >= 0 && haystack.charAt(i) != needle.charAt(j + 1)) {\n                j = next[j];\n            }\n            if (haystack.charAt(i) == needle.charAt(j + 1)) {\n                j++;\n            }\n            if (j == m - 1) return i - m + 1;\n        }\n        return -1;\n    }\n    private void getNext(int[] next, String s) {\n        int j = -1;\n        next[0] = j;\n        for (int i = 1; i < s.length(); i++) {\n            while (j >= 0 && s.charAt(i) != s.charAt(j + 1)) {\n                j = next[j];\n            }\n            if (s.charAt(i) == s.charAt(j + 1)) {\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n}",
          "description": "Java基于KMP算法（前缀表减一）实现strStr"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        int[] next = new int[needle.length()];\n        getNext(next, needle);\n        int j = 0;\n        for (int i = 0; i < haystack.length(); i++) {\n            while (j > 0 && needle.charAt(j) != haystack.charAt(i))\n                j = next[j - 1];\n            if (needle.charAt(j) == haystack.charAt(i))\n                j++;\n            if (j == needle.length())\n                return i - needle.length() + 1;\n        }\n        return -1;\n    }\n    private void getNext(int[] next, String s) {\n        int j = 0;\n        next[0] = 0;\n        for (int i = 1; i < s.length(); i++) {\n            while (j > 0 && s.charAt(j) != s.charAt(i))\n                j = next[j - 1];\n            if (s.charAt(j) == s.charAt(i))\n                j++;\n            next[i] = j;\n        }\n    }\n}",
          "description": "Java基于KMP算法（前缀表不减一）实现strStr"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def getNext(self, next, s):\n        j = -1\n        next[0] = j\n        for i in range(1, len(s)):\n            while j >= 0 and s[i] != s[j+1]:\n                j = next[j]\n            if s[i] == s[j+1]:\n                j += 1\n            next[i] = j\n    \n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        next = [0] * len(needle)\n        self.getNext(next, needle)\n        j = -1\n        for i in range(len(haystack)):\n            while j >= 0 and haystack[i] != needle[j+1]:\n                j = next[j]\n            if haystack[i] == needle[j+1]:\n                j += 1\n            if j == len(needle) - 1:\n                return i - len(needle) + 1\n        return -1",
          "description": "Python3基于KMP算法（前缀表减一）实现strStr"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def getNext(self, next: List[int], s: str) -> None:\n        j = 0\n        next[0] = 0\n        for i in range(1, len(s)):\n            while j > 0 and s[i] != s[j]:\n                j = next[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            next[i] = j\n    \n    def strStr(self, haystack: str, needle: str) -> int:\n        if len(needle) == 0:\n            return 0\n        next = [0] * len(needle)\n        self.getNext(next, needle)\n        j = 0\n        for i in range(len(haystack)):\n            while j > 0 and haystack[i] != needle[j]:\n                j = next[j - 1]\n            if haystack[i] == needle[j]:\n                j += 1\n            if j == len(needle):\n                return i - len(needle) + 1\n        return -1",
          "description": "Python3基于KMP算法（前缀表不减一）实现strStr"
        },
        {
          "language": "python",
          "code": "class Solution(object):\n    def strStr(self, haystack, needle):\n        m, n = len(haystack), len(needle)\n        for i in range(m):\n            if haystack[i:i+n] == needle:\n                return i\n        return -1",
          "description": "Python暴力法实现strStr"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        try:\n            return haystack.index(needle)\n        except ValueError:\n            return -1",
          "description": "Python使用index方法实现strStr"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        return haystack.find(needle)",
          "description": "Python使用find方法实现strStr"
        }
      ],
      "subsections": []
    },
    {
      "name": "前缀表（不减一）C++实现",
      "text": "那么前缀表就不减一了，也不右移的，到底行不行呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "void getNext(int* next, const string& s) {int j = -1;next[0] = j;for(int i = 1; i < s.size(); i++) {while (j >= 0 && s[i] != s[j + 1]) {j = next[j];}if (s[i] == s[j + 1]) {j++;}next[i] = j;}}int strStr(string haystack, string needle) {if (needle.size() == 0) {return 0;}vector<int> next(needle.size());getNext(&next[0], needle);int j = -1;for (int i = 0; i < haystack.size(); i++) {while(j >= 0 && haystack[i] != needle[j + 1]) {j = next[j];}if (haystack[i] == needle[j + 1]) {j++;}if (j == (needle.size() - 1) ) {return (i - needle.size() + 1);}}}return -1;}",
          "description": "KMP算法中前缀表统一减一的实现"
        },
        {
          "language": "cpp",
          "code": "void getNext(int* next, const string& s) {int j = 0;next[0] = 0;for(int i = 1; i < s.size(); i++) {while (j > 0 && s[i] != s[j]) {j = next[j - 1];}if (s[i] == s[j]) {j++;}next[i] = j;}}int strStr(string haystack, string needle) {if (needle.size() == 0) {return 0;}vector<int> next(needle.size());getNext(&next[0], needle);int j = 0;for (int i = 0; i < haystack.size(); i++) {while(j > 0 && haystack[i] != needle[j]) {j = next[j - 1];}if (haystack[i] == needle[j]) {j++;}if (j == needle.size() ) {return (i - needle.size() + 1);}}}return -1;}",
          "description": "KMP算法中前缀表不减一的实现"
        },
        {
          "language": "java",
          "code": "public int strStr(String haystack, String needle) {int m = needle.length();if (m == 0) return 0;int n = haystack.length();if (n < m) return -1;int i = 0, j = 0;while (i < n - m + 1) {while (i < n && haystack.charAt(i) != needle.charAt(j)) {i++;}if (i == n) return -1;i++;j++;while (i < n && j < m && haystack.charAt(i) == needle.charAt(j)) {i++;j++;}if (j == m) return i - j;else {i -= j - 1;j = 0;}}}return -1;}",
          "description": "基于窗口滑动的字符串匹配算法"
        },
        {
          "language": "java",
          "code": "public void getNext(int[] next, String s){int j = -1;next[0] = j;for (int i = 1; i < s.length(); i++){while(j >= 0 && s.charAt(i) != s.charAt(j+1)){j=next[j];}if(s.charAt(i) == s.charAt(j+1)){j++;}next[i] = j;}}public int strStr(String haystack, String needle) {if(needle.length()==0){return 0;}int[] next = new int[needle.length()];getNext(next, needle);int j = -1;for(int i = 0; i < haystack.length(); i++){while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){j = next[j];}if(haystack.charAt(i) == needle.charAt(j+1)){j++;}if(j == needle.length()-1){return (i-needle.length()+1);}}}return -1;}",
          "description": "Java版KMP算法中前缀表统一减一的实现"
        },
        {
          "language": "java",
          "code": "public int strStr(String haystack, String needle) {if (needle.length() == 0) return 0;int[] next = new int[needle.length()];getNext(next, needle);int j = 0;for (int i = 0; i < haystack.length(); i++) {while (j > 0 && needle.charAt(j) != haystack.charAt(i)) j = next[j - 1];if (needle.charAt(j) == haystack.charAt(i)) j++;if (j == needle.length()) return i - needle.length() + 1;}return -1;}private void getNext(int[] next, String s) {int j = 0;next[0] = 0;for (int i = 1; i < s.length(); i++) {while (j > 0 && s.charAt(j) != s.charAt(i)) j = next[j - 1];if (s.charAt(j) == s.charAt(i)) j++;next[i] = j;}}",
          "description": "Java版KMP算法中前缀表不减一的实现"
        },
        {
          "language": "python",
          "code": "def getNext(self, next, s):j = -1next[0] = jfor i in range(1, len(s)):while j >= 0 and s[i] != s[j+1]:j = next[j]if s[i] == s[j+1]:j += 1next[i] = jdef strStr(self, haystack: str, needle: str) -> int:if not needle:return 0next = [0] * len(needle)self.getNext(next, needle)j = -1for i in range(len(haystack)):while j >= 0 and haystack[i] != needle[j+1]:j = next[j]if haystack[i] == needle[j+1]:j += 1if j == len(needle) - 1:return i - len(needle) + 1return -1",
          "description": "Python3版KMP算法中前缀表统一减一的实现"
        },
        {
          "language": "python",
          "code": "def getNext(self, next: List[int], s: str) -> None:j = 0next[0] = 0for i in range(1, len(s)):while j > 0 and s[i] != s[j]:j = next[j - 1]if s[i] == s[j]:j += 1next[i] = jdef strStr(self, haystack: str, needle: str) -> int:if len(needle) == 0:return 0next = [0] * len(needle)self.getNext(next, needle)j = 0for i in range(len(haystack)):while j > 0 and haystack[i] != needle[j]:j = next[j - 1]if haystack[i] == needle[j]:j += 1if j == len(needle):return i - len(needle) + 1return -1",
          "description": "Python3版KMP算法中前缀表不减一的实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "我们介绍了什么是KMP，KMP可以解决什么问题，然后分析KMP算法里的next数组，知道了next数组就是前缀表，再分析为什么要是前缀表而不是什么其他表。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: void getNext(int* next, const string& s) {int j = -1;next[0] = j;for(int i = 1; i < s.size(); i++) {while (j >= 0 && s[i] != s[j + 1]) {j = next[j];}if (s[i] == s[j + 1]) {j++;}next[i] = j;}}int strStr(string haystack, string needle) {if (needle.size() == 0) {return 0;}vector<int> next(needle.size());getNext(&next[0], needle);int j = -1;for (int i = 0; i < haystack.size(); i++) {while(j >= 0 && haystack[i] != needle[j + 1]) {j = next[j];}if (haystack[i] == needle[j + 1]) {j++;}if (j == (needle.size() - 1)) {return (i - needle.size() + 1);}}return -1;}};",
          "description": "C++实现KMP算法，使用前缀表统一减一的next数组"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: void getNext(int* next, const string& s) {int j = 0;next[0] = 0;for(int i = 1; i < s.size(); i++) {while (j > 0 && s[i] != s[j]) {j = next[j - 1];}if (s[i] == s[j]) {j++;}next[i] = j;}}int strStr(string haystack, string needle) {if (needle.size() == 0) {return 0;}vector<int> next(needle.size());getNext(&next[0], needle);int j = 0;for (int i = 0; i < haystack.size(); i++) {while(j > 0 && haystack[i] != needle[j]) {j = next[j - 1];}if (haystack[i] == needle[j]) {j++;}if (j == needle.size()) {return (i - needle.size() + 1);}}return -1;}};",
          "description": "C++实现KMP算法，直接使用前缀表作为next数组"
        },
        {
          "language": "java",
          "code": "class Solution {public int strStr(String haystack, String needle) {if (needle.length() == 0) return 0;int[] next = new int[needle.length()];getNext(next, needle);int j = 0;for (int i = 0; i < haystack.length(); i++) {while (j > 0 && needle.charAt(j) != haystack.charAt(i)) j = next[j - 1];if (needle.charAt(j) == haystack.charAt(i)) j++;if (j == needle.length()) return i - needle.length() + 1;}return -1;}private void getNext(int[] next, String s) {int j = 0;next[0] = 0;for (int i = 1; i < s.length(); i++) {while (j > 0 && s.charAt(j) != s.charAt(i)) j = next[j - 1];if (s.charAt(j) == s.charAt(i)) j++;next[i] = j;}}}",
          "description": "Java实现KMP算法，直接使用前缀表作为next数组"
        },
        {
          "language": "python",
          "code": "class Solution: def getNext(self, next, s): j = -1 next[0] = j for i in range(1, len(s)): while j >= 0 and s[i] != s[j+1]: j = next[j] if s[i] == s[j+1]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if not needle: return 0 next = [0] * len(needle) self.getNext(next, needle) j = -1 for i in range(len(haystack)): while j >= 0 and haystack[i] != needle[j+1]: j = next[j] if haystack[i] == needle[j+1]: j += 1 if j == len(needle) - 1: return i - len(needle) + 1 return -1",
          "description": "Python3实现KMP算法，使用前缀表统一减一的next数组"
        },
        {
          "language": "python",
          "code": "class Solution: def getNext(self, next: List[int], s: str) -> None: j = 0 next[0] = 0 for i in range(1, len(s)): while j > 0 and s[i] != s[j]: j = next[j - 1] if s[i] == s[j]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if len(needle) == 0: return 0 next = [0] * len(needle) self.getNext(next, needle) j = 0 for i in range(len(haystack)): while j > 0 and haystack[i] != needle[j]: j = next[j - 1] if haystack[i] == needle[j]: j += 1 if j == len(needle): return i - len(needle) + 1 return -1",
          "description": "Python3实现KMP算法，直接使用前缀表作为next数组"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "public int strStr(String haystack, String needle) { int n = haystack.length(), m = needle.length(); char[] s = haystack.toCharArray(), p = needle.toCharArray(); for (int i = 0; i < n - m + 1; i++) { int a = i, b = 0; while (b < m && s[a] == p[b]) { a++; b++; } if (b == m) return i; } return -1; }",
          "description": "暴力法实现strStr"
        },
        {
          "language": "java",
          "code": "public int strStr(String haystack, String needle) { int m = needle.length(); if (m == 0) { return 0; } int n = haystack.length(); if (n < m) { return -1; } int i = 0, j = 0; while (i < n - m + 1) { while (i < n && haystack.charAt(i) != needle.charAt(j)) { i++; } if (i == n) { return -1; } i++; j++; while (i < n && j < m && haystack.charAt(i) == needle.charAt(j)) { i++; j++; } if (j == m) { return i - j; } else { i -= j - 1; j = 0; } } return -1; }",
          "description": "基于窗口滑动的算法实现strStr"
        },
        {
          "language": "java",
          "code": "public void getNext(int[] next, String s){ int j = -1; next[0] = j; for (int i = 1; i < s.length(); i++){ while(j >= 0 && s.charAt(i) != s.charAt(j+1)){ j=next[j]; } if(s.charAt(i) == s.charAt(j+1)){ j++; } next[i] = j; } } public int strStr(String haystack, String needle) { if(needle.length()==0){ return 0; } int[] next = new int[needle.length()]; getNext(next, needle); int j = -1; for(int i = 0; i < haystack.length(); i++){ while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){ j = next[j]; } if(haystack.charAt(i) == needle.charAt(j+1)){ j++; } if(j == needle.length()-1){ return (i-needle.length()+1); } } return -1; }",
          "description": "KMP算法前缀表减一版本"
        },
        {
          "language": "java",
          "code": "public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; int[] next = new int[needle.length()]; getNext(next, needle); int j = 0; for (int i = 0; i < haystack.length(); i++) { while (j > 0 && needle.charAt(j) != haystack.charAt(i)) j = next[j - 1]; if (needle.charAt(j) == haystack.charAt(i)) j++; if (j == needle.length()) return i - needle.length() + 1; } return -1; } private void getNext(int[] next, String s) { int j = 0; next[0] = 0; for (int i = 1; i < s.length(); i++) { while (j > 0 && s.charAt(j) != s.charAt(i)) j = next[j - 1]; if (s.charAt(j) == s.charAt(i)) j++; next[i] = j; } }",
          "description": "KMP算法前缀表不减一版本"
        },
        {
          "language": "python",
          "code": "def getNext(self, next, s): j = -1 next[0] = j for i in range(1, len(s)): while j >= 0 and s[i] != s[j+1]: j = next[j] if s[i] == s[j+1]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if not needle: return 0 next = [0] * len(needle) self.getNext(next, needle) j = -1 for i in range(len(haystack)): while j >= 0 and haystack[i] != needle[j+1]: j = next[j] if haystack[i] == needle[j+1]: j += 1 if j == len(needle) - 1: return i - len(needle) + 1 return -1",
          "description": "Python KMP算法前缀表减一版本"
        },
        {
          "language": "python",
          "code": "def getNext(self, next: List[int], s: str) -> None: j = 0 next[0] = 0 for i in range(1, len(s)): while j > 0 and s[i] != s[j]: j = next[j - 1] if s[i] == s[j]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if len(needle) == 0: return 0 next = [0] * len(needle) self.getNext(next, needle) j = 0 for i in range(len(haystack)): while j > 0 and haystack[i] != needle[j]: j = next[j - 1] if haystack[i] == needle[j]: j += 1 if j == len(needle): return i - len(needle) + 1 return -1",
          "description": "Python KMP算法前缀表不减一版本"
        },
        {
          "language": "python",
          "code": "def strStr(self, haystack, needle): m, n = len(haystack), len(needle) for i in range(m): if haystack[i:i+n] == needle: return i return -1",
          "description": "Python 暴力法实现strStr"
        },
        {
          "language": "python",
          "code": "def strStr(self, haystack: str, needle: str) -> int: try: return haystack.index(needle) except ValueError: return -1",
          "description": "Python 使用index方法实现strStr"
        },
        {
          "language": "python",
          "code": "def strStr(self, haystack: str, needle: str) -> int: return haystack.find(needle)",
          "description": "Python 使用find方法实现strStr"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void getNext(int* next, const string& s) {\n        int j = -1;\n        next[0] = j;\n        for(int i = 1; i < s.size(); i++) { \n            while (j >= 0 && s[i] != s[j + 1]) { \n                j = next[j]; \n            }\n            if (s[i] == s[j + 1]) { \n                j++;\n            }\n            next[i] = j; \n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0) {\n            return 0;\n        }\n\tvector<int> next(needle.size());\n\tgetNext(&next[0], needle);\n        int j = -1; \n        for (int i = 0; i < haystack.size(); i++) { \n            while(j >= 0 && haystack[i] != needle[j + 1]) { \n                j = next[j]; \n            }\n            if (haystack[i] == needle[j + 1]) { \n                j++; \n            }\n            if (j == (needle.size() - 1) ) { \n                return (i - needle.size() + 1);\n            }\n        }\n        return -1;\n    }\n};",
          "description": "C++实现strStr函数，使用KMP算法，前缀表统一减一"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void getNext(int* next, const string& s) {\n        int j = 0;\n        next[0] = 0;\n        for(int i = 1; i < s.size(); i++) {\n            while (j > 0 && s[i] != s[j]) {\n                j = next[j - 1];\n            }\n            if (s[i] == s[j]) {\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0) {\n            return 0;\n        }\n        vector<int> next(needle.size());\n        getNext(&next[0], needle);\n        int j = 0;\n        for (int i = 0; i < haystack.size(); i++) {\n            while(j > 0 && haystack[i] != needle[j]) {\n                j = next[j - 1];\n            }\n            if (haystack[i] == needle[j]) {\n                j++;\n            }\n            if (j == needle.size() ) {\n                return (i - needle.size() + 1);\n            }\n        }\n        return -1;\n    }\n};",
          "description": "C++实现strStr函数，使用KMP算法，前缀表不减一"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public void getNext(int[] next, String s){\n        int j = -1;\n        next[0] = j;\n        for (int i = 1; i < s.length(); i++){\n            while(j >= 0 && s.charAt(i) != s.charAt(j+1)){\n                j=next[j];\n            }\n\n            if(s.charAt(i) == s.charAt(j+1)){\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    public int strStr(String haystack, String needle) {\n        if(needle.length()==0){\n            return 0;\n        }\n\n        int[] next = new int[needle.length()];\n        getNext(next, needle);\n        int j = -1;\n        for(int i = 0; i < haystack.length(); i++){\n            while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){\n                j = next[j];\n            }\n            if(haystack.charAt(i) == needle.charAt(j+1)){\n                j++;\n            }\n            if(j == needle.length()-1){\n                return (i-needle.length()+1);\n            }\n        }\n\n        return -1;\n    }\n}",
          "description": "Java实现strStr函数，使用KMP算法，前缀表统一减一"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        int[] next = new int[needle.length()];\n        getNext(next, needle);\n\n        int j = 0;\n        for (int i = 0; i < haystack.length(); i++) {\n            while (j > 0 && needle.charAt(j) != haystack.charAt(i)) \n                j = next[j - 1];\n            if (needle.charAt(j) == haystack.charAt(i)) \n                j++;\n            if (j == needle.length()) \n                return i - needle.length() + 1;\n        }\n        return -1;\n    }\n    private void getNext(int[] next, String s) {\n        int j = 0;\n        next[0] = 0;\n        for (int i = 1; i < s.length(); i++) {\n            while (j > 0 && s.charAt(j) != s.charAt(i)) \n                j = next[j - 1];\n            if (s.charAt(j) == s.charAt(i)) \n                j++;\n            next[i] = j; \n        }\n    }\n}",
          "description": "Java实现strStr函数，使用KMP算法，前缀表不减一"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def getNext(self, next, s):\n        j = -1\n        next[0] = j\n        for i in range(1, len(s)):\n            while j >= 0 and s[i] != s[j+1]:\n                j = next[j]\n            if s[i] == s[j+1]:\n                j += 1\n            next[i] = j\n    \n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        next = [0] * len(needle)\n        self.getNext(next, needle)\n        j = -1\n        for i in range(len(haystack)):\n            while j >= 0 and haystack[i] != needle[j+1]:\n                j = next[j]\n            if haystack[i] == needle[j+1]:\n                j += 1\n            if j == len(needle) - 1:\n                return i - len(needle) + 1\n        return -1",
          "description": "Python实现strStr函数，使用KMP算法，前缀表统一减一"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def getNext(self, next: List[int], s: str) -> None:\n        j = 0\n        next[0] = 0\n        for i in range(1, len(s)):\n            while j > 0 and s[i] != s[j]:\n                j = next[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            next[i] = j\n    \n    def strStr(self, haystack: str, needle: str) -> int:\n        if len(needle) == 0:\n            return 0\n        next = [0] * len(needle)\n        self.getNext(next, needle)\n        j = 0\n        for i in range(len(haystack)):\n            while j > 0 and haystack[i] != needle[j]:\n                j = next[j - 1]\n            if haystack[i] == needle[j]:\n                j += 1\n            if j == len(needle):\n                return i - len(needle) + 1\n        return -1",
          "description": "Python实现strStr函数，使用KMP算法，前缀表不减一"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python3：",
      "text": "（版本一）前缀表（减一）",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: void getNext(int* next, const string& s) {int j = -1;next[0] = j;for(int i = 1; i < s.size(); i++) {while (j >= 0 && s[i] != s[j + 1]) {j = next[j];}if (s[i] == s[j + 1]) {j++;}next[i] = j;}} int strStr(string haystack, string needle) {if (needle.size() == 0) {return 0;}vector<int> next(needle.size());getNext(&next[0], needle);int j = -1;for (int i = 0; i < haystack.size(); i++) {while(j >= 0 && haystack[i] != needle[j + 1]) {j = next[j];}if (haystack[i] == needle[j + 1]) {j++;}if (j == (needle.size() - 1) ) {return (i - needle.size() + 1);}}}return -1;}};",
          "description": "KMP算法的C++实现，前缀表减一"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: void getNext(int* next, const string& s) {int j = 0;next[0] = 0;for(int i = 1; i < s.size(); i++) {while (j > 0 && s[i] != s[j]) {j = next[j - 1];}if (s[i] == s[j]) {j++;}next[i] = j;}} int strStr(string haystack, string needle) {if (needle.size() == 0) {return 0;}vector<int> next(needle.size());getNext(&next[0], needle);int j = 0;for (int i = 0; i < haystack.size(); i++) {while(j > 0 && haystack[i] != needle[j]) {j = next[j - 1];}if (haystack[i] == needle[j]) {j++;}if (j == needle.size() ) {return (i - needle.size() + 1);}}}return -1;}};",
          "description": "KMP算法的C++实现，前缀表不减一"
        },
        {
          "language": "java",
          "code": "class Solution {public int strStr(String haystack, String needle) {int m = needle.length();if (m == 0) {return 0;}int n = haystack.length();if (n < m) {return -1;}int i = 0, j = 0;while (i < n - m + 1) {while (i < n && haystack.charAt(i) != needle.charAt(j)) {i++;}if (i == n) {return -1;}i++;j++;while (i < n && j < m && haystack.charAt(i) == needle.charAt(j)) {i++;j++;}if (j == m) {return i - j;} else {i -= j - 1;j = 0;}}}return -1;}}",
          "description": "基于窗口滑动的Java实现"
        },
        {
          "language": "java",
          "code": "class Solution {public void getNext(int[] next, String s){int j = -1;next[0] = j;for (int i = 1; i < s.length(); i++){while(j >= 0 && s.charAt(i) != s.charAt(j+1)){j=next[j];}if(s.charAt(i) == s.charAt(j+1)){j++;}next[i] = j;}} public int strStr(String haystack, String needle) {if(needle.length()==0){return 0;}int[] next = new int[needle.length()];getNext(next, needle);int j = -1;for(int i = 0; i < haystack.length(); i++){while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){j = next[j];}if(haystack.charAt(i) == needle.charAt(j+1)){j++;}if(j == needle.length()-1){return (i-needle.length()+1);}}}return -1;}}",
          "description": "KMP算法的Java实现，前缀表减一"
        },
        {
          "language": "java",
          "code": "class Solution {public int strStr(String haystack, String needle) {if (needle.length() == 0) return 0;int[] next = new int[needle.length()];getNext(next, needle);int j = 0;for (int i = 0; i < haystack.length(); i++) {while (j > 0 && needle.charAt(j) != haystack.charAt(i)) j = next[j - 1];if (needle.charAt(j) == haystack.charAt(i)) j++;if (j == needle.length()) return i - needle.length() + 1;}return -1;}private void getNext(int[] next, String s) {int j = 0;next[0] = 0;for (int i = 1; i < s.length(); i++) {while (j > 0 && s.charAt(j) != s.charAt(i)) j = next[j - 1];if (s.charAt(j) == s.charAt(i)) j++;next[i] = j;}}}",
          "description": "KMP算法的Java实现，前缀表不减一"
        },
        {
          "language": "python",
          "code": "class Solution: def getNext(self, next, s): j = -1 next[0] = j for i in range(1, len(s)): while j >= 0 and s[i] != s[j+1]: j = next[j] if s[i] == s[j+1]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if not needle: return 0 next = [0] * len(needle) self.getNext(next, needle) j = -1 for i in range(len(haystack)): while j >= 0 and haystack[i] != needle[j+1]: j = next[j] if haystack[i] == needle[j+1]: j += 1 if j == len(needle) - 1: return i - len(needle) + 1 return -1",
          "description": "KMP算法的Python实现，前缀表减一"
        },
        {
          "language": "python",
          "code": "class Solution: def getNext(self, next: List[int], s: str) -> None: j = 0 next[0] = 0 for i in range(1, len(s)): while j > 0 and s[i] != s[j]: j = next[j - 1] if s[i] == s[j]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if len(needle) == 0: return 0 next = [0] * len(needle) self.getNext(next, needle) j = 0 for i in range(len(haystack)): while j > 0 and haystack[i] != needle[j]: j = next[j - 1] if haystack[i] == needle[j]: j += 1 if j == len(needle): return i - len(needle) + 1 return -1",
          "description": "KMP算法的Python实现，前缀表不减一"
        },
        {
          "language": "python",
          "code": "class Solution(object): def strStr(self, haystack, needle): m, n = len(haystack), len(needle) for i in range(m): if haystack[i:i+n] == needle: return i return -1",
          "description": "暴力法的Python实现"
        },
        {
          "language": "python",
          "code": "class Solution: def strStr(self, haystack: str, needle: str) -> int: try: return haystack.index(needle) except ValueError: return -1",
          "description": "使用index方法的Python实现"
        },
        {
          "language": "python",
          "code": "class Solution: def strStr(self, haystack: str, needle: str) -> int: return haystack.find(needle)",
          "description": "使用find方法的Python实现"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n + m)",
    "space_complexity": "O(m)",
    "explanation": "m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。"
  },
  "code_solutions": [
    {
      "language": "C++",
      "code": "class Solution {public: void getNext(int* next, const string& s) { int j = -1; next[0] = j; for(int i = 1; i < s.size(); i++) { while (j >= 0 && s[i] != s[j + 1]) { j = next[j]; } if (s[i] == s[j + 1]) { j++; } next[i] = j; }} int strStr(string haystack, string needle) { if (needle.size() == 0) { return 0; } vector<int> next(needle.size()); getNext(&next[0], needle); int j = -1; for (int i = 0; i < haystack.size(); i++) { while(j >= 0 && haystack[i] != needle[j + 1]) { j = next[j]; } if (haystack[i] == needle[j + 1]) { j++; } if (j == (needle.size() - 1) ) { return (i - needle.size() + 1); }} return -1;}};",
      "description": "使用前缀表统一减一的KMP算法实现"
    },
    {
      "language": "C++",
      "code": "class Solution {public: void getNext(int* next, const string& s) { int j = 0; next[0] = 0; for(int i = 1; i < s.size(); i++) { while (j > 0 && s[i] != s[j]) { j = next[j - 1]; } if (s[i] == s[j]) { j++; } next[i] = j; }} int strStr(string haystack, string needle) { if (needle.size() == 0) { return 0; } vector<int> next(needle.size()); getNext(&next[0], needle); int j = 0; for (int i = 0; i < haystack.size(); i++) { while(j > 0 && haystack[i] != needle[j]) { j = next[j - 1]; } if (haystack[i] == needle[j]) { j++; } if (j == needle.size() ) { return (i - needle.size() + 1); }} return -1;}};",
      "description": "直接使用前缀表作为next数组的KMP算法实现"
    },
    {
      "language": "Java",
      "code": "class Solution { public void getNext(int[] next, String s){ int j = -1; next[0] = j; for (int i = 1; i < s.length(); i++){ while(j >= 0 && s.charAt(i) != s.charAt(j+1)){ j=next[j]; } if(s.charAt(i) == s.charAt(j+1)){ j++; } next[i] = j; } } public int strStr(String haystack, String needle) { if(needle.length()==0){ return 0; } int[] next = new int[needle.length()]; getNext(next, needle); int j = -1; for(int i = 0; i < haystack.length(); i++){ while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){ j = next[j]; } if(haystack.charAt(i) == needle.charAt(j+1)){ j++; } if(j == needle.length()-1){ return (i-needle.length()+1); } } return -1; }}",
      "description": "基于KMP算法，使用前缀表统一减一的Java实现"
    },
    {
      "language": "Java",
      "code": "class Solution { public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; int[] next = new int[needle.length()]; getNext(next, needle); int j = 0; for (int i = 0; i < haystack.length(); i++) { while (j > 0 && needle.charAt(j) != haystack.charAt(i)) j = next[j - 1]; if (needle.charAt(j) == haystack.charAt(i)) j++; if (j == needle.length()) return i - needle.length() + 1; } return -1; } private void getNext(int[] next, String s) { int j = 0; next[0] = 0; for (int i = 1; i < s.length(); i++) { while (j > 0 && s.charAt(j) != s.charAt(i)) j = next[j - 1]; if (s.charAt(j) == s.charAt(i)) j++; next[i] = j; } }}",
      "description": "直接使用前缀表作为next数组的Java KMP实现"
    },
    {
      "language": "Python",
      "code": "class Solution: def getNext(self, next, s): j = -1 next[0] = j for i in range(1, len(s)): while j >= 0 and s[i] != s[j+1]: j = next[j] if s[i] == s[j+1]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if not needle: return 0 next = [0] * len(needle) self.getNext(next, needle) j = -1 for i in range(len(haystack)): while j >= 0 and haystack[i] != needle[j+1]: j = next[j] if haystack[i] == needle[j+1]: j += 1 if j == len(needle) - 1: return i - len(needle) + 1 return -1",
      "description": "基于KMP算法，使用前缀表统一减一的Python实现"
    },
    {
      "language": "Python",
      "code": "class Solution: def getNext(self, next: List[int], s: str) -> None: j = 0 next[0] = 0 for i in range(1, len(s)): while j > 0 and s[i] != s[j]: j = next[j - 1] if s[i] == s[j]: j += 1 next[i] = j def strStr(self, haystack: str, needle: str) -> int: if len(needle) == 0: return 0 next = [0] * len(needle) self.getNext(next, needle) j = 0 for i in range(len(haystack)): while j > 0 and haystack[i] != needle[j]: j = next[j - 1] if haystack[i] == needle[j]: j += 1 if j == len(needle): return i - len(needle) + 1 return -1",
      "description": "直接使用前缀表作为next数组的Python KMP实现"
    }
  ],
  "common_mistakes": [
    "忽视对空字符串情况的处理。",
    "混淆最长公共前后缀与最长相等前后缀的概念。",
    "未能正确理解next数组与前缀表之间的转换关系及其实际应用方式。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B21.gif",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B21.gif",
      "context": "该动画展示了在文本串aabaabaafa中查找模式串aabaaf的过程，特别标注了子串aa，并演示了当字符不匹配时如何利用前缀表避免从头开始匹配。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B21.png",
      "description": "该图展示了一个模式串 \"aa b a a f\" 的部分匹配过程，红色框标示了当前匹配的位置，箭头指示下一步操作，体现了字符串匹配算法中的状态转移。",
      "context": "图片展示了在KMP算法中，当匹配过程在下标5处遇到不匹配时，模式串与文本串的对齐情况。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B22.png",
      "description": "该图展示了一个模式串 \"aabaaaf\" 的部分匹配表构建过程，红色框标出了相等的前缀和后缀，箭头指向需要处理的字符 'b'。",
      "context": "该图片展示了在KMP算法中，当匹配失败后根据前缀表找到新的匹配起点（下标2处的b字符）继续进行匹配的过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B22.gif",
      "description": "这张图片展示了KMP算法中模式串的前缀表构建过程及其与文本串的匹配示例。",
      "context": "该动画展示了在KMP算法中，当字符不匹配时，如何利用前缀表来确定指针应移动到的位置，以便继续进行模式串与文本串的匹配过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B23.gif",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B23.gif",
      "context": "该动画展示了根据KMP算法构建next数组的过程，用于说明如何通过比较字符并调整指针位置来确定模式串中各位置的最长相同前后缀长度。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B24.gif",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B24.gif",
      "context": "该动画展示了使用前缀表统一减一后的next数组进行文本串s与模式串t匹配的过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B25.png",
      "description": "该图展示了一个模式串 \"aabaaaf\" 的前缀表构建过程，当前关注位置为索引 0 处的字符 'a'。",
      "context": "该图展示了长度为1的子串\"a\"，其最长相同前后缀长度为0，帮助理解前缀表中每个位置值的具体含义。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B26.png",
      "description": "该图片展示了一个模式串 \"aabaaaf\" 的前缀表构建过程，红色框标出了当前比较的前缀 \"aa\"。",
      "context": "该图展示了长度为前2个字符的子串\"aa\"，其最长相同前后缀的长度为1，用于说明如何计算前缀表的过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B27.png",
      "description": "该图片展示了一个模式串 \"a a b a a f\" 的前缀部分（\"a a b\"），可能用于字符串匹配算法（如KMP算法）的分析。",
      "context": "该图展示了长度为前2个字符的子串\"aa\"，其最长相同前后缀的长度为1，用于解释KMP算法中前缀表的构建过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B28.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B28.png",
      "context": "该图展示了模式串与其对应的前缀表，其中每个位置的数值表示该位置之前（含该位置）字符串中相同前后缀的最大长度。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B21.gif",
      "description": "GIF展示了在文本串aabaabaafa中使用KMP算法查找模式串aabaaf的过程，特别标注了子串aa，并演示了当字符不匹配时如何利用前缀表避免从头开始匹配。",
      "context": "GIF动画展示了在文本串\"aabaabaafa\"中查找模式串\"aabaaf\"时，如何利用前缀表实现从已匹配部分继续搜索而非重新开始的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B22.gif",
      "description": "GIF展示了KMP算法中当字符不匹配时，利用前缀表（或next数组）确定指针应回退位置的过程。",
      "context": "该GIF动画展示了在KMP算法中，当字符不匹配时如何利用前缀表确定指针应移动到的新位置以继续匹配的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B23.gif",
      "description": "GIF展示了KMP算法中next数组的构建过程，通过指针移动来匹配字符串中的前后缀。",
      "context": "该GIF动画展示了KMP算法中构造next数组的过程，通过比较字符串中的字符来确定每个位置上的最长相同前后缀长度。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B24.gif",
      "description": "GIF展示了根据前缀表统一减一后的next数组来匹配文本串和模式串的过程。",
      "context": "该GIF动画展示了使用前缀表统一减一后的next数组来匹配文本串s和模式串t的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\字符串\\实现 strStr().txt",
  "extracted_at": "2025-07-22T21:16:14.295662",
  "raw_content": "实现 strStr()\n力扣题目链接(https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)\n\n实现 strStr() 函数。\n\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。\n\n示例 1: 输入: haystack = \"hello\", needle = \"ll\" 输出: 2\n\n示例 2: 输入: haystack = \"aaaaa\", needle = \"bba\" 输出: -1\n\n说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。\n\n\n什么是KMP\n说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。\n\n因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP\n\n#KMP有什么用\nKMP主要应用在字符串匹配上。\n\nKMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。\n\n所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。\n\n其实KMP的代码不好理解，一些同学甚至直接把KMP代码的模板背下来。\n\n没有彻底搞懂，懵懵懂懂就把代码背下来太容易忘了。\n\n不仅面试的时候可能写不出来，如果面试官问：next数组里的数字表示的是什么，为什么这么表示？\n\n估计大多数候选人都是懵逼的。\n\n下面Carl就带大家把KMP的精髓，next数组弄清楚。\n\n#什么是前缀表\n写过KMP的同学，一定都写过next数组，那么这个next数组究竟是个啥呢？\n\nnext数组就是一个前缀表（prefix table）。\n\n前缀表有什么作用呢？\n\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。\n\n为了清楚地了解前缀表的来历，我们来举一个例子：\n\n要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。\n\n请记住文本串和模式串的作用，对于理解下文很重要，要不然容易看懵。所以说三遍：\n\n要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。\n\n要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。\n\n要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。\n\n如动画所示：\n\nhttps://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B21.gif\n\n动画里，我特意把 子串aa 标记上了，这是有原因的，大家先注意一下，后面还会说到。\n\n可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。\n\n但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。\n\n此时就要问了前缀表是如何记录的呢？\n\n首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。\n\n那么什么是前缀表：记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n\n#最长公共前后缀\n文章中字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。\n\n后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。\n\n正确理解什么是前缀什么是后缀很重要!\n\n那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？\n\n我查了一遍 算法导论 和 算法4里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。\n\n因为前缀表要求的就是相同前后缀的长度。\n\n而最长公共前后缀里面的“公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。\n\n所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等.....。\n\n#为什么一定要用前缀表\n这就是前缀表，那为啥就能告诉我们 上次匹配的位置，并跳过去呢？\n\n回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图： https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B21.png\n\n然后就找到了下标2，指向b，继续匹配：如图： https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B22.png\n\n以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！\n\n下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。\n\n所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。\n\n很多介绍KMP的文章或者视频并没有把为什么要用前缀表？这个问题说清楚，而是直接默认使用前缀表。\n\n#如何计算前缀表\n接下来就要说一说怎么计算前缀表。\n\n如图：\n\nhttps://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B25.png\n\n长度为前1个字符的子串a，最长相同前后缀的长度为0。（注意字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。）\n\nhttps://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B26.png\n\n长度为前2个字符的子串aa，最长相同前后缀的长度为1。\n\nhttps://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B27.png\n\n长度为前3个字符的子串aab，最长相同前后缀的长度为0。\n\n以此类推： 长度为前4个字符的子串aaba，最长相同前后缀的长度为1。 长度为前5个字符的子串aabaa，最长相同前后缀的长度为2。 长度为前6个字符的子串aabaaf，最长相同前后缀的长度为0。\n\n那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图： https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B28.png\n\n可以看出模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n\n再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：\n\nhttps://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B22.gif\n\n找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。\n\n为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。\n\n所以要看前一位的 前缀表的数值。\n\n前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。\n\n最后就在文本串中找到了和模式串匹配的子串了。\n\n#前缀表与next数组\n很多KMP算法的实现都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？\n\nnext数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。\n\n为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。\n\n其实这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。\n\n后面我会提供两种不同的实现代码，大家就明白了。\n\n#使用next数组来匹配\n以下我们以前缀表统一减一之后的next数组来做演示。\n\n有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。\n\n注意next数组是新前缀表（旧前缀表统一减一了）。\n\n匹配过程动画如下：\n\nhttps://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B24.gif\n\n#时间复杂度分析\n其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。\n\n暴力的解法显而易见是O(n × m)，所以KMP在字符串匹配中极大地提高了搜索的效率。\n\n为了和力扣题目28.实现strStr保持一致，方便大家理解，以下文章统称haystack为文本串, needle为模式串。\n\n都知道使用KMP算法，一定要构造next数组。\n\n#构造next数组\n我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下：\n\nvoid getNext(int* next, const string& s)\n构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步：\n\n初始化\n处理前后缀不相同的情况\n处理前后缀相同的情况\n接下来我们详解一下。\n\n初始化：\n定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。\n\n然后还要对next数组进行初始化赋值，如下：\n\nint j = -1;\nnext[0] = j;\nj 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。\n\nnext[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）\n\n所以初始化next[0] = j 。\n\n处理前后缀不相同的情况\n因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。\n\n所以遍历模式串s的循环下标i 要从 1开始，代码如下：\n\nfor (int i = 1; i < s.size(); i++) {\n如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。\n\n怎么回退呢？\n\nnext[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。\n\n那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。\n\n所以，处理前后缀不相同的情况代码如下：\n\nwhile (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了\n    j = next[j]; // 向前回退\n}\n处理前后缀相同的情况\n如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。\n\n代码如下：\n\nif (s[i] == s[j + 1]) { // 找到相同的前后缀\n    j++;\n}\nnext[i] = j;\n最后整体构建next数组的函数代码如下：\n\nvoid getNext(int* next, const string& s){\n    int j = -1;\n    next[0] = j;\n    for(int i = 1; i < s.size(); i++) { // 注意i从1开始\n        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了\n            j = next[j]; // 向前回退\n        }\n        if (s[i] == s[j + 1]) { // 找到相同的前后缀\n            j++;\n        }\n        next[i] = j; // 将j（前缀的长度）赋给next[i]\n    }\n}\n代码构造next数组的逻辑流程动画如下：\n\nhttps://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B23.gif\n\n得到了next数组之后，就要用这个来做匹配了。\n\n#使用next数组来做匹配\n在文本串s里 找是否出现过模式串t。\n\n定义两个下标j 指向模式串起始位置，i指向文本串起始位置。\n\n那么j初始值依然为-1，为什么呢？ 依然因为next数组里记录的起始位置为-1。\n\ni就从0开始，遍历文本串，代码如下：\n\nfor (int i = 0; i < s.size(); i++) \n接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。\n\n如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。\n\n代码如下：\n\nwhile(j >= 0 && s[i] != t[j + 1]) {\n    j = next[j];\n}\n如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：\n\nif (s[i] == t[j + 1]) {\n    j++; // i的增加在for循环里\n}\n如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。\n\n本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。\n\n代码如下：\n\nif (j == (t.size() - 1) ) {\n    return (i - t.size() + 1);\n}\n那么使用next数组，用模式串匹配文本串的整体代码如下：\n\nint j = -1; // 因为next数组里记录的起始位置为-1\nfor (int i = 0; i < s.size(); i++) { // 注意i就从0开始\n    while(j >= 0 && s[i] != t[j + 1]) { // 不匹配\n        j = next[j]; // j 寻找之前匹配的位置\n    }\n    if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动\n        j++; // i的增加在for循环里\n    }\n    if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t\n        return (i - t.size() + 1);\n    }\n}\n此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下：\n\n#前缀表统一减一 C++代码实现\nclass Solution {\npublic:\n    void getNext(int* next, const string& s) {\n        int j = -1;\n        next[0] = j;\n        for(int i = 1; i < s.size(); i++) { // 注意i从1开始\n            while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了\n                j = next[j]; // 向前回退\n            }\n            if (s[i] == s[j + 1]) { // 找到相同的前后缀\n                j++;\n            }\n            next[i] = j; // 将j（前缀的长度）赋给next[i]\n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0) {\n            return 0;\n        }\n\t\tvector<int> next(needle.size());\n\t\tgetNext(&next[0], needle);\n        int j = -1; // // 因为next数组里记录的起始位置为-1\n        for (int i = 0; i < haystack.size(); i++) { // 注意i就从0开始\n            while(j >= 0 && haystack[i] != needle[j + 1]) { // 不匹配\n                j = next[j]; // j 寻找之前匹配的位置\n            }\n            if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动\n                j++; // i的增加在for循环里\n            }\n            if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t\n                return (i - needle.size() + 1);\n            }\n        }\n        return -1;\n    }\n};\n\n时间复杂度: O(n + m)\n空间复杂度: O(m), 只需要保存字符串needle的前缀表\n#前缀表（不减一）C++实现\n那么前缀表就不减一了，也不右移的，到底行不行呢？\n\n行！\n\n我之前说过，这仅仅是KMP算法实现上的问题，如果就直接使用前缀表可以换一种回退方式，找j=next[j-1] 来进行回退。\n\n主要就是j=next[x]这一步最为关键！\n\n我给出的getNext的实现为：（前缀表统一减一）\n\nvoid getNext(int* next, const string& s) {\n    int j = -1;\n    next[0] = j;\n    for(int i = 1; i < s.size(); i++) { // 注意i从1开始\n        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了\n            j = next[j]; // 向前回退\n        }\n        if (s[i] == s[j + 1]) { // 找到相同的前后缀\n            j++;\n        }\n        next[i] = j; // 将j（前缀的长度）赋给next[i]\n    }\n}\n\n此时如果输入的模式串为aabaaf，对应的next为-1 0 -1 0 1 -1。\n\n这里j和next[0]初始化为-1，整个next数组是以 前缀表减一之后的效果来构建的。\n\n那么前缀表不减一来构建next数组，代码如下：\n\n    void getNext(int* next, const string& s) {\n        int j = 0;\n        next[0] = 0;\n        for(int i = 1; i < s.size(); i++) {\n            while (j > 0 && s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作\n                j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了\n            }\n            if (s[i] == s[j]) {\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n\n此时如果输入的模式串为aabaaf，对应的next为 0 1 0 1 2 0，（其实这就是前缀表的数值了）。\n\n那么用这样的next数组也可以用来做匹配，代码要有所改动。\n\n实现代码如下：\n\nclass Solution {\npublic:\n    void getNext(int* next, const string& s) {\n        int j = 0;\n        next[0] = 0;\n        for(int i = 1; i < s.size(); i++) {\n            while (j > 0 && s[i] != s[j]) {\n                j = next[j - 1];\n            }\n            if (s[i] == s[j]) {\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.size() == 0) {\n            return 0;\n        }\n        vector<int> next(needle.size());\n        getNext(&next[0], needle);\n        int j = 0;\n        for (int i = 0; i < haystack.size(); i++) {\n            while(j > 0 && haystack[i] != needle[j]) {\n                j = next[j - 1];\n            }\n            if (haystack[i] == needle[j]) {\n                j++;\n            }\n            if (j == needle.size() ) {\n                return (i - needle.size() + 1);\n            }\n        }\n        return -1;\n    }\n};\n时间复杂度: O(n + m)\n空间复杂度: O(m)\n#总结\n我们介绍了什么是KMP，KMP可以解决什么问题，然后分析KMP算法里的next数组，知道了next数组就是前缀表，再分析为什么要是前缀表而不是什么其他表。\n\n接着从给出的模式串中，我们一步一步的推导出了前缀表，得出前缀表无论是统一减一还是不减一得到的next数组仅仅是kmp的实现方式的不同。\n\n其中还分析了KMP算法的时间复杂度，并且和暴力方法做了对比。\n\n然后先用前缀表统一减一得到的next数组，求得文本串s里是否出现过模式串t，并给出了具体分析代码。\n\n又给出了直接用前缀表作为next数组，来做匹配的实现代码。\n\n可以说把KMP的每一个细微的细节都扣了出来，毫无遮掩的展示给大家了！\n\n#其他语言版本\n#Java：\nclass Solution {\n    /**\n\t牺牲空间，换取最直白的暴力法\n        时间复杂度 O(n * m)\n        空间 O(n + m)\n     */\n    public int strStr(String haystack, String needle) {\n        // 获取 haystack 和 needle 的长度\n        int n = haystack.length(), m = needle.length();\n        // 将字符串转换为字符数组，方便索引操作\n        char[] s = haystack.toCharArray(), p = needle.toCharArray();\n\n        // 遍历 haystack 字符串\n        for (int i = 0; i < n - m + 1; i++) {\n            // 初始化匹配的指针\n            int a = i, b = 0;\n            // 循环检查 needle 是否在当前位置开始匹配\n            while (b < m && s[a] == p[b]) {\n                // 如果当前字符匹配，则移动指针\n                a++;\n                b++;\n            }\n            // 如果 b 等于 m，说明 needle 已经完全匹配，返回当前位置 i\n            if (b == m) return i;\n        }\n\n        // 如果遍历完毕仍未找到匹配的子串，则返回 -1\n        return -1;\n    }\n}\nclass Solution {\n    /**\n     * 基于窗口滑动的算法\n     * <p>\n     * 时间复杂度：O(m*n)\n     * 空间复杂度：O(1)\n     * 注：n为haystack的长度，m为needle的长度\n     */\n    public int strStr(String haystack, String needle) {\n        int m = needle.length();\n        // 当 needle 是空字符串时我们应当返回 0\n        if (m == 0) {\n            return 0;\n        }\n        int n = haystack.length();\n        if (n < m) {\n            return -1;\n        }\n        int i = 0;\n        int j = 0;\n        while (i < n - m + 1) {\n            // 找到首字母相等\n            while (i < n && haystack.charAt(i) != needle.charAt(j)) {\n                i++;\n            }\n            if (i == n) {// 没有首字母相等的\n                return -1;\n            }\n            // 遍历后续字符，判断是否相等\n            i++;\n            j++;\n            while (i < n && j < m && haystack.charAt(i) == needle.charAt(j)) {\n                i++;\n                j++;\n            }\n            if (j == m) {// 找到\n                return i - j;\n            } else {// 未找到\n                i -= j - 1;\n                j = 0;\n            }\n        }\n        return -1;\n    }\n}\n// 方法一\nclass Solution {\n    public void getNext(int[] next, String s){\n        int j = -1;\n        next[0] = j;\n        for (int i = 1; i < s.length(); i++){\n            while(j >= 0 && s.charAt(i) != s.charAt(j+1)){\n                j=next[j];\n            }\n\n            if(s.charAt(i) == s.charAt(j+1)){\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    public int strStr(String haystack, String needle) {\n        if(needle.length()==0){\n            return 0;\n        }\n\n        int[] next = new int[needle.length()];\n        getNext(next, needle);\n        int j = -1;\n        for(int i = 0; i < haystack.length(); i++){\n            while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){\n                j = next[j];\n            }\n            if(haystack.charAt(i) == needle.charAt(j+1)){\n                j++;\n            }\n            if(j == needle.length()-1){\n                return (i-needle.length()+1);\n            }\n        }\n\n        return -1;\n    }\n}\nclass Solution {\n    //前缀表（不减一）Java实现\n    public int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        int[] next = new int[needle.length()];\n        getNext(next, needle);\n\n        int j = 0;\n        for (int i = 0; i < haystack.length(); i++) {\n            while (j > 0 && needle.charAt(j) != haystack.charAt(i)) \n                j = next[j - 1];\n            if (needle.charAt(j) == haystack.charAt(i)) \n                j++;\n            if (j == needle.length()) \n                return i - needle.length() + 1;\n        }\n        return -1;\n\n    }\n    \n    private void getNext(int[] next, String s) {\n        int j = 0;\n        next[0] = 0;\n        for (int i = 1; i < s.length(); i++) {\n            while (j > 0 && s.charAt(j) != s.charAt(i)) \n                j = next[j - 1];\n            if (s.charAt(j) == s.charAt(i)) \n                j++;\n            next[i] = j; \n        }\n    }\n}\n#Python3：\n（版本一）前缀表（减一）\n\nclass Solution:\n    def getNext(self, next, s):\n        j = -1\n        next[0] = j\n        for i in range(1, len(s)):\n            while j >= 0 and s[i] != s[j+1]:\n                j = next[j]\n            if s[i] == s[j+1]:\n                j += 1\n            next[i] = j\n    \n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        next = [0] * len(needle)\n        self.getNext(next, needle)\n        j = -1\n        for i in range(len(haystack)):\n            while j >= 0 and haystack[i] != needle[j+1]:\n                j = next[j]\n            if haystack[i] == needle[j+1]:\n                j += 1\n            if j == len(needle) - 1:\n                return i - len(needle) + 1\n        return -1\n（版本二）前缀表（不减一）\n\nclass Solution:\n    def getNext(self, next: List[int], s: str) -> None:\n        j = 0\n        next[0] = 0\n        for i in range(1, len(s)):\n            while j > 0 and s[i] != s[j]:\n                j = next[j - 1]\n            if s[i] == s[j]:\n                j += 1\n            next[i] = j\n    \n    def strStr(self, haystack: str, needle: str) -> int:\n        if len(needle) == 0:\n            return 0\n        next = [0] * len(needle)\n        self.getNext(next, needle)\n        j = 0\n        for i in range(len(haystack)):\n            while j > 0 and haystack[i] != needle[j]:\n                j = next[j - 1]\n            if haystack[i] == needle[j]:\n                j += 1\n            if j == len(needle):\n                return i - len(needle) + 1\n        return -1\n（版本三）暴力法\n\nclass Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        m, n = len(haystack), len(needle)\n        for i in range(m):\n            if haystack[i:i+n] == needle:\n                return i\n        return -1    \n（版本四）使用 index\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        try:\n            return haystack.index(needle)\n        except ValueError:\n            return -1\n（版本五）使用 find\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        return haystack.find(needle)"
}