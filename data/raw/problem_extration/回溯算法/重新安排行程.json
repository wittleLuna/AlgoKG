{
  "id": "AP_df9c2361",
  "title": "重新安排行程",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/reconstruct-itinerary/",
  "description": "一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。\n\n提示：\n\n如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [\"JFK\", \"LGA\"] 与 [\"JFK\", \"LGB\"] 相比就更小，排序更靠前\n所有的机场都用三个大写字母表示（机场代码）。\n假定所有机票至少存在一种合理的行程。\n所有的机票必须都用一次 且 只能用一次。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "回溯",
    "深度优先搜索"
  ],
  "data_structure_tags": [
    "哈希表",
    "映射",
    "集合",
    "链表"
  ],
  "technique_tags": [
    "递归",
    "路径记录与撤销",
    "排序"
  ],
  "difficulty": null,
  "solution_approach": "采用回溯法（或深度优先搜索）来解决行程安排问题。首先构建一个映射表来存储每个出发机场到所有可能到达机场的映射关系，并确保按照字母顺序排序。通过递归遍历所有可能的路径，一旦找到一条满足条件的路径即停止搜索。",
  "key_insights": [
    {
      "content": "在处理航班时需小心避免形成循环，特别是在存在重复机场的情况下。使用map并记录航班次数来标记某个目的地是否已被访问过是关键方法之一。"
    },
    {
      "content": "面对多种可能的有效行程时，应选取自然排序最小的方案。通过预先对到达机场进行排序并在回溯过程中保持这一顺序可以实现这一点。"
    },
    {
      "content": "选择合适的数据结构对于避免迭代器失效及高效增删元素至关重要，例如使用unordered_map<string, map<string, int>>以同时保证有序性和效率。"
    },
    {
      "content": "递归函数返回值设为bool类型有助于快速确定是否找到了有效解，从而及时终止不必要的进一步探索。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "这道题目还是很难的，之前我们用回溯法解决了如下问题：组合问题 (https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)，分割问题 (https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html)，子集问题 (https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)，排列问题 (https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html)。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n// unordered_map<出发机场, map<到达机场, 航班次数>> targets\nunordered_map<string, map<string, int>> targets;\nbool backtracking(int ticketNum, vector<string>& result) {\n    if (result.size() == ticketNum + 1) {\n        return true;\n    }\n    for (pair<const string, int>& target : targets[result[result.size() - 1]]) {\n        if (target.second > 0 ) { // 记录到达机场是否飞过了\n            result.push_back(target.first);\n            target.second--;\n            if (backtracking(ticketNum, result)) return true;\n            result.pop_back();\n            target.second++;\n        }\n    }\n    return false;\n}\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        targets.clear();\n        vector<string> result;\n        for (const vector<string>& vec : tickets) {\n            targets[vec[0]][vec[1]]++; // 记录映射关系\n        }\n        result.push_back(\"JFK\"); // 起始机场\n        backtracking(tickets.size(), result);\n        return result;\n    }\n};",
          "description": "C++版本的解决方案，使用回溯法解决行程重新安排问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Solution {\n    private Deque<String> res;\n    private Map<String, Map<String, Integer>> map;\n\n    private boolean backTracking(int ticketNum){\n        if(res.size() == ticketNum + 1){\n            return true;\n        }\n        String last = res.getLast();\n        if(map.containsKey(last)){\n            for(Map.Entry<String, Integer> target : map.get(last).entrySet()){\n                int count = target.getValue();\n                if(count > 0){\n                    res.add(target.getKey());\n                    target.setValue(count - 1);\n                    if(backTracking(ticketNum)) return true;\n                    res.removeLast();\n                    target.setValue(count);\n                }\n            }\n        }\n        return false;\n    }\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        map = new HashMap<String, Map<String, Integer>>();\n        res = new LinkedList<>();\n        for(List<String> t : tickets){\n            Map<String, Integer> temp;\n            if(map.containsKey(t.get(0))){\n                temp = map.get(t.get(0));\n                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);\n            }else{\n                temp = new TreeMap<>();\n                temp.put(t.get(1), 1);\n            }\n            map.put(t.get(0), temp);\n        }\n        res.add(\"JFK\");\n        backTracking(tickets.size());\n        return new ArrayList<>(res);\n    }\n}",
          "description": "Java版本的解决方案，同样采用了回溯法来处理行程重新规划的问题。"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\nclass Solution:\n    def findItinerary(self, tickets):\n        targets = defaultdict(list)\n        for ticket in tickets:\n            targets[ticket[0]].append(ticket[1])\n        for key in targets:\n            targets[key].sort(reverse=True)\n        result = []\n        self.backtracking(\"JFK\", targets, result)\n        return result[::-1]\n    \n    def backtracking(self, airport, targets, result):\n        while targets[airport]:\n            next_airport = targets[airport].pop()\n            self.backtracking(next_airport, targets, result)\n        result.append(airport)",
          "description": "Python版本的解决方案，采用回溯方法结合字典逆序排序来找到最小字母顺序的行程路径。"
        }
      ],
      "subsections": []
    },
    {
      "name": "如何理解死循环",
      "text": "对于死循环，我来举一个有重复机场的例子：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n// unordered_map<出发机场, map<到达机场, 航班次数>> targets\nunordered_map<string, map<string, int>> targets;\nbool backtracking(int ticketNum, vector<string>& result) {\n    if (result.size() == ticketNum + 1) {\n        return true;\n    }\n    for (pair<const string, int>& target : targets[result[result.size() - 1]]) {\n        if (target.second > 0 ) { // 记录到达机场是否飞过了\n            result.push_back(target.first);\n            target.second--;\n            if (backtracking(ticketNum, result)) return true;\n            result.pop_back();\n            target.second++;\n        }\n    }\n    return false;\n}\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        targets.clear();\n        vector<string> result;\n        for (const vector<string>& vec : tickets) {\n            targets[vec[0]][vec[1]]++; // 记录映射关系\n        }\n        result.push_back(\"JFK\"); // 起始机场\n        backtracking(tickets.size(), result);\n        return result;\n    }\n};",
          "description": "C++实现的回溯法解决行程重新排序问题"
        },
        {
          "language": "java",
          "code": "class Solution {\n    private Deque<String> res;\n    private Map<String, Map<String, Integer>> map;\n\n    private boolean backTracking(int ticketNum){\n        if(res.size() == ticketNum + 1){\n            return true;\n        }\n        String last = res.getLast();\n        if(map.containsKey(last)){//防止出现null\n            for(Map.Entry<String, Integer> target : map.get(last).entrySet()){\n                int count = target.getValue();\n                if(count > 0){\n                    res.add(target.getKey());\n                    target.setValue(count - 1);\n                    if(backTracking(ticketNum)) return true;\n                    res.removeLast();\n                    target.setValue(count);\n                }\n            }\n        }\n        return false;\n    }\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        map = new HashMap<String, Map<String, Integer>>();\n        res = new LinkedList<>();\n        for(List<String> t : tickets){\n            Map<String, Integer> temp;\n            if(map.containsKey(t.get(0))){\n                temp = map.get(t.get(0));\n                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);\n            }else{\n                temp = new TreeMap<>();//升序Map\n                temp.put(t.get(1), 1);\n            }\n            map.put(t.get(0), temp);\n\n        }\n        res.add(\"JFK\");\n        backTracking(tickets.size());\n        return new ArrayList<>(res);\n    }\n}",
          "description": "Java实现的回溯法解决行程重新排序问题"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\nclass Solution:\n    def findItinerary(self, tickets):\n        targets = defaultdict(list)  # 创建默认字典，用于存储机场映射关系\n        for ticket in tickets:\n            targets[ticket[0]].append(ticket[1])  # 将机票输入到字典中\n        \n        for key in targets:\n            targets[key].sort(reverse=True)  # 对到达机场列表进行字母逆序排序\n        \n        result = []\n        self.backtracking(\"JFK\", targets, result)  # 调用回溯函数开始搜索路径\n        return result[::-1]  # 返回逆序的行程路径\n    \n    def backtracking(self, airport, targets, result):\n        while targets[airport]:  # 当机场还有可到达的机场时\n            next_airport = targets[airport].pop()  # 弹出下一个机场\n            self.backtracking(next_airport, targets, result)  # 递归调用回溯函数进行深度优先搜索\n        result.append(airport)  # 将当前机场添加到行程路径中",
          "description": "Python实现的回溯法解决行程重新排序问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "该记录映射关系",
      "text": "有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n// unordered_map<出发机场, map<到达机场, 航班次数>> targets\nunordered_map<string, map<string, int>> targets;\nbool backtracking(int ticketNum, vector<string>& result) {\n    if (result.size() == ticketNum + 1) {\n        return true;\n    }\n    for (pair<const string, int>& target : targets[result[result.size() - 1]]) {\n        if (target.second > 0 ) { // 记录到达机场是否飞过了\n            result.push_back(target.first);\n            target.second--;\n            if (backtracking(ticketNum, result)) return true;\n            result.pop_back();\n            target.second++;\n        }\n    }\n    return false;\n}\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        targets.clear();\n        vector<string> result;\n        for (const vector<string>& vec : tickets) {\n            targets[vec[0]][vec[1]]++; // 记录映射关系\n        }\n        result.push_back(\"JFK\"); // 起始机场\n        backtracking(tickets.size(), result);\n        return result;\n    }\n};",
          "description": "C++实现，使用回溯法解决行程重构问题"
        },
        {
          "language": "java",
          "code": "class Solution {\n    private Deque<String> res;\n    private Map<String, Map<String, Integer>> map;\n\n    private boolean backTracking(int ticketNum){\n        if(res.size() == ticketNum + 1){\n            return true;\n        }\n        String last = res.getLast();\n        if(map.containsKey(last)){//防止出现null\n            for(Map.Entry<String, Integer> target : map.get(last).entrySet()){\n                int count = target.getValue();\n                if(count > 0){\n                    res.add(target.getKey());\n                    target.setValue(count - 1);\n                    if(backTracking(ticketNum)) return true;\n                    res.removeLast();\n                    target.setValue(count);\n                }\n            }\n        }\n        return false;\n    }\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        map = new HashMap<String, Map<String, Integer>>();\n        res = new LinkedList<>();\n        for(List<String> t : tickets){\n            Map<String, Integer> temp;\n            if(map.containsKey(t.get(0))){\n                temp = map.get(t.get(0));\n                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);\n            }else{\n                temp = new TreeMap<>();//升序Map\n                temp.put(t.get(1), 1);\n            }\n            map.put(t.get(0), temp);\n\n        }\n        res.add(\"JFK\");\n        backTracking(tickets.size());\n        return new ArrayList<>(res);\n    }\n}",
          "description": "Java实现，同样使用回溯法，并采用TreeMap来保证字母顺序"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\nclass Solution:\n    def findItinerary(self, tickets):\n        targets = defaultdict(list)  # 创建默认字典，用于存储机场映射关系\n        for ticket in tickets:\n            targets[ticket[0]].append(ticket[1])  # 将机票输入到字典中\n        \n        for key in targets:\n            targets[key].sort(reverse=True)  # 对到达机场列表进行字母逆序排序\n        \n        result = []\n        self.backtracking(\"JFK\", targets, result)  # 调用回溯函数开始搜索路径\n        return result[::-1]  # 返回逆序的行程路径\n    \n    def backtracking(self, airport, targets, result):\n        while targets[airport]:  # 当机场还有可到达的机场时\n            next_airport = targets[airport].pop()  # 弹出下一个机场\n            self.backtracking(next_airport, targets, result)  # 递归调用回溯函数进行深度优先搜索\n        result.append(airport)  # 将当前机场添加到行程路径中",
          "description": "Python版本，利用defaultdict和回溯算法解决行程重构问题，通过逆序添加元素并最终反转结果列表来确保返回最小字典序的行程。"
        }
      ],
      "subsections": []
    },
    {
      "name": "回溯法",
      "text": "这道题目我使用回溯法，那么下面按照我总结的回溯模板来：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private:unordered_map<string, map<string, int>> targets;bool backtracking(int ticketNum, vector<string>& result) {if (result.size() == ticketNum + 1) {return true;}for (pair<const string, int>& target : targets[result[result.size() - 1]]) {if (target.second > 0 ) {result.push_back(target.first);target.second--;if (backtracking(ticketNum, result)) return true;result.pop_back();target.second++;}}return false;}public:vector<string> findItinerary(vector<vector<string>>& tickets) {targets.clear();vector<string> result;for (const vector<string>& vec : tickets) {targets[vec[0]][vec[1]]++;}result.push_back(\"JFK\");backtracking(tickets.size(), result);return result;}};",
          "description": "使用回溯法解决重新安排行程问题的C++实现"
        },
        {
          "language": "java",
          "code": "class Solution {private Deque<String> res;private Map<String, Map<String, Integer>> map;private boolean backTracking(int ticketNum){if(res.size() == ticketNum + 1){return true;}String last = res.getLast();if(map.containsKey(last)){for(Map.Entry<String, Integer> target : map.get(last).entrySet()){int count = target.getValue();if(count > 0){res.add(target.getKey());target.setValue(count - 1);if(backTracking(ticketNum)) return true;res.removeLast();target.setValue(count);}}}return false;}public List<String> findItinerary(List<List<String>> tickets) {map = new HashMap<>();res = new LinkedList<>();for(List<String> t : tickets){Map<String, Integer> temp;if(map.containsKey(t.get(0))){temp = map.get(t.get(0));temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);}else{temp = new TreeMap<>();temp.put(t.get(1), 1);}map.put(t.get(0), temp);}res.add(\"JFK\");backTracking(tickets.size());return new ArrayList<>(res);}}",
          "description": "使用回溯法解决重新安排行程问题的Java实现"
        },
        {
          "language": "python",
          "code": "from collections import defaultdictclass Solution:def findItinerary(self, tickets):targets = defaultdict(list)for ticket in tickets:targets[ticket[0]].append(ticket[1])for key in targets:targets[key].sort(reverse=True)result = []self.backtracking(\"JFK\", targets, result)return result[::-1]def backtracking(self, airport, targets, result):while targets[airport]:next_airport = targets[airport].pop()self.backtracking(next_airport, targets, result)result.append(airport)",
          "description": "使用回溯法解决重新安排行程问题的Python实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "本题其实可以算是一道hard的题目了，关于本题的难点我在文中已经列出了。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\nunordered_map<string, map<string, int>> targets;\nbool backtracking(int ticketNum, vector<string>& result) {\nif (result.size() == ticketNum + 1) {\nreturn true;\n}\nfor (pair<const string, int>& target : targets[result[result.size() - 1]]) {\nif (target.second > 0 ) {\nresult.push_back(target.first);\ntarget.second--;\nif (backtracking(ticketNum, result)) return true;\nresult.pop_back();\ntarget.second++;\n}\n}\nreturn false;\n}\npublic:\nvector<string> findItinerary(vector<vector<string>>& tickets) {\ntargets.clear();\nvector<string> result;\nfor (const vector<string>& vec : tickets) {\ntargets[vec[0]][vec[1]]++;\n}\nresult.push_back(\"JFK\");\nbacktracking(tickets.size(), result);\nreturn result;\n}\n};",
          "description": "C++实现的解决重新安排行程问题的代码"
        },
        {
          "language": "java",
          "code": "class Solution {\nprivate Deque<String> res;\nprivate Map<String, Map<String, Integer>> map;\n\nprivate boolean backTracking(int ticketNum){\nif(res.size() == ticketNum + 1){\nreturn true;\n}\nString last = res.getLast();\nif(map.containsKey(last)){\nfor(Map.Entry<String, Integer> target : map.get(last).entrySet()){\nint count = target.getValue();\nif(count > 0){\nres.add(target.getKey());\ntarget.setValue(count - 1);\nif(backTracking(ticketNum)) return true;\nres.removeLast();\ntarget.setValue(count);\n}\n}\n}\nreturn false;\n}\n\npublic List<String> findItinerary(List<List<String>> tickets) {\nmap = new HashMap<String, Map<String, Integer>>();\nres = new LinkedList<>();\nfor(List<String> t : tickets){\nMap<String, Integer> temp;\nif(map.containsKey(t.get(0))){\ntemp = map.get(t.get(0));\ntemp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);\n}else{\ntemp = new TreeMap<>();\ntemp.put(t.get(1), 1);\n}\nmap.put(t.get(0), temp);\n}\nres.add(\"JFK\");\nbackTracking(tickets.size());\nreturn new ArrayList<>(res);\n}\n}",
          "description": "Java实现的解决重新安排行程问题的代码，使用了HashMap和TreeMap来存储机场之间的映射关系。"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\nclass Solution:\ndef findItinerary(self, tickets):\ntargets = defaultdict(list)\nfor ticket in tickets:\ntargets[ticket[0]].append(ticket[1])\nfor key in targets:\ntargets[key].sort(reverse=True)\nresult = []\nself.backtracking(\"JFK\", targets, result)\nreturn result[::-1]\ndef backtracking(self, airport, targets, result):\nwhile targets[airport]:\nnext_airport = targets[airport].pop()\nself.backtracking(next_airport, targets, result)\nresult.append(airport)",
          "description": "Python实现的解决重新安排行程问题的代码，采用了默认字典来保存机场间的映射，并通过回溯法找到最小字典序的行程安排。"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution {\n    private LinkedList<String> res;\n    private LinkedList<String> path = new LinkedList<>();\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        Collections.sort(tickets, (a, b) -> a.get(1).compareTo(b.get(1)));\n        path.add(\"JFK\");\n        boolean[] used = new boolean[tickets.size()];\n        backTracking((ArrayList) tickets, used);\n        return res;\n    }\n\n    public boolean backTracking(ArrayList<List<String>> tickets, boolean[] used) {\n        if (path.size() == tickets.size() + 1) {\n            res = new LinkedList(path);\n            return true;\n        }\n\n        for (int i = 0; i < tickets.size(); i++) {\n            if (!used[i] && tickets.get(i).get(0).equals(path.getLast())) {\n                path.add(tickets.get(i).get(1));\n                used[i] = true;\n\n                if (backTracking(tickets, used)) {\n                    return true;\n                }\n\n                used[i] = false;\n                path.removeLast();\n            }\n        }\n        return false;\n    }\n}",
          "description": "使用回溯法解决行程重构问题，通过一个布尔数组记录机票是否被使用。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    private Deque<String> res;\n    private Map<String, Map<String, Integer>> map;\n\n    private boolean backTracking(int ticketNum){\n        if(res.size() == ticketNum + 1){\n            return true;\n        }\n        String last = res.getLast();\n        if(map.containsKey(last)){//防止出现null\n            for(Map.Entry<String, Integer> target : map.get(last).entrySet()){\n                int count = target.getValue();\n                if(count > 0){\n                    res.add(target.getKey());\n                    target.setValue(count - 1);\n                    if(backTracking(ticketNum)) return true;\n                    res.removeLast();\n                    target.setValue(count);\n                }\n            }\n        }\n        return false;\n    }\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        map = new HashMap<String, Map<String, Integer>>();\n        res = new LinkedList<>();\n        for(List<String> t : tickets){\n            Map<String, Integer> temp;\n            if(map.containsKey(t.get(0))){\n                temp = map.get(t.get(0));\n                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);\n            }else{\n                temp = new TreeMap<>();//升序Map\n                temp.put(t.get(1), 1);\n            }\n            map.put(t.get(0), temp);\n\n        }\n        res.add(\"JFK\");\n        backTracking(tickets.size());\n        return new ArrayList<>(res);\n    }\n}",
          "description": "利用映射关系存储每个机场到其他机场的航班次数，并使用回溯法找到符合要求的行程。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    //key为起点，value是有序的终点的列表\n    Map<String, LinkedList<String>> ticketMap = new HashMap<>();\n    LinkedList<String> result = new LinkedList<>();\n    int total;\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        total = tickets.size() + 1;\n        //遍历tickets，存入ticketMap中\n        for (List<String> ticket : tickets) {\n            addNew(ticket.get(0), ticket.get(1));\n        }\n        deal(\"JFK\");\n        return result;\n    }\n\n    boolean deal(String currentLocation) {\n        result.add(currentLocation);\n        //机票全部用完，找到最小字符路径\n        if (result.size() == total) {\n            return true;\n        }\n        //当前位置的终点列表\n        LinkedList<String> targetLocations = ticketMap.get(currentLocation);\n        //没有从当前位置出发的机票了，说明这条路走不通\n        if (targetLocations != null && !targetLocations.isEmpty()) {\n            //终点列表中遍历到的终点\n            String targetLocation;\n            //遍历从当前位置出发的机票\n            for (int i = 0; i < targetLocations.size(); i++) {\n                if(i > 0 && targetLocations.get(i).equals(targetLocations.get(i - 1))) continue;\n                targetLocation = targetLocations.get(i);\n                //删除终点列表中当前的终点\n                targetLocations.remove(i);\n                //递归\n                if (deal(targetLocation)) {\n                    return true;\n                }\n                //路线走不通，将机票重新加回去\n                targetLocations.add(i, targetLocation);\n                result.removeLast();\n            }\n        }\n        return false;\n    }\n\n    void addNew(String start, String end) {\n        LinkedList<String> startAllEnd = ticketMap.getOrDefault(start, new LinkedList<>());\n        if (!startAllEnd.isEmpty()) {\n            for (int i = 0; i < startAllEnd.size(); i++) {\n                if (end.compareTo(startAllEnd.get(i)) < 0) {\n                    startAllEnd.add(i, end);\n                    return;\n                }\n            }\n            startAllEnd.add(startAllEnd.size(), end);\n        } else {\n            startAllEnd.add(end);\n            ticketMap.put(start, startAllEnd);\n        }\n    }\n}",
          "description": "优化后的版本，使用链表存储终点以提高效率，同时保持回溯法的基本逻辑。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        self.adj = {}\n\n        # sort by the destination alphabetically\n        tickets.sort(key=lambda x:x[1])\n\n        # get all possible connection for each destination\n        for u,v in tickets:\n            if u in self.adj: self.adj[u].append(v)\n            else: self.adj[u] = [v]\n\n        # 从JFK出发\n        self.result = []\n        self.dfs(\"JFK\")  # start with JFK\n\n        return self.result[::-1]  # reverse to get the result\n\n    def dfs(self, s):\n        while s in self.adj and len(self.adj[s]) > 0:\n            v = self.adj[s][0]  # we go to the 1 choice of the city\n            self.adj[s].pop(0)  # get rid of this choice since we used it\n            self.dfs(v)  # we start from the new airport\n\n        self.result.append(s)",
          "description": "Python实现，通过字典存储机场间的连接信息，并使用深度优先搜索找到正确的行程顺序。"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\n\nclass Solution:\n    def findItinerary(self, tickets):\n        targets = defaultdict(list)  # 创建默认字典，用于存储机场映射关系\n        for ticket in tickets:\n            targets[ticket[0]].append(ticket[1])  # 将机票输入到字典中\n\n        for key in targets:\n            targets[key].sort(reverse=True)  # 对到达机场列表进行字母逆序排序\n\n        result = []\n        self.backtracking(\"JFK\", targets, result)  # 调用回溯函数开始搜索路径\n        return result[::-1]  # 返回逆序的行程路径\n\n    def backtracking(self, airport, targets, result):\n        while targets[airport]:  # 当机场还有可到达的机场时\n            next_airport = targets[airport].pop()  # 弹出下一个机场\n            self.backtracking(next_airport, targets, result)  # 递归调用回溯函数进行深度优先搜索\n        result.append(airport)  # 将当前机场添加到行程路径中",
          "description": "使用Python中的defaultdict和深度优先搜索来寻找符合条件的行程安排，最后返回逆序结果。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\nunordered_map<string, map<string, int>> targets;\nbool backtracking(int ticketNum, vector<string>& result) {\nif (result.size() == ticketNum + 1) {\nreturn true;\n}\nfor (pair<const string, int>& target : targets[result[result.size() - 1]]) {\nif (target.second > 0 ) {\nresult.push_back(target.first);\ntarget.second--;\nif (backtracking(ticketNum, result)) return true;\nresult.pop_back();\ntarget.second++;\n}\n}\nreturn false;\n}\npublic:\nvector<string> findItinerary(vector<vector<string>>& tickets) {\ntargets.clear();\nvector<string> result;\nfor (const vector<string>& vec : tickets) {\ntargets[vec[0]][vec[1]]++;\n}\nresult.push_back(\"JFK\");\nbacktracking(tickets.size(), result);\nreturn result;\n}\n};",
          "description": "C++实现的行程重排算法，使用回溯法找到最小字典序的行程组合。"
        },
        {
          "language": "java",
          "code": "class Solution {\nprivate Deque<String> res;\nprivate Map<String, Map<String, Integer>> map;\n\nprivate boolean backTracking(int ticketNum){\nif(res.size() == ticketNum + 1){\nreturn true;\n}\nString last = res.getLast();\nif(map.containsKey(last)){\nfor(Map.Entry<String, Integer> target : map.get(last).entrySet()){\nint count = target.getValue();\nif(count > 0){\nres.add(target.getKey());\ntarget.setValue(count - 1);\nif(backTracking(ticketNum)) return true;\nres.removeLast();\ntarget.setValue(count);\n}\n}\n}\nreturn false;\n}\n\npublic List<String> findItinerary(List<List<String>> tickets) {\nmap = new HashMap<>();\nres = new LinkedList<>();\nfor(List<String> t : tickets){\nMap<String, Integer> temp;\nif(map.containsKey(t.get(0))){\ntemp = map.get(t.get(0));\ntemp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);\n}else{\ntemp = new TreeMap<>();\ntemp.put(t.get(1), 1);\n}\nmap.put(t.get(0), temp);\n}\nres.add(\"JFK\");\nbackTracking(tickets.size());\nreturn new ArrayList<>(res);\n}\n}",
          "description": "Java实现的行程重排算法，使用回溯法与映射表记录机场间航班次数来寻找最优路径。"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\nclass Solution:\ndef findItinerary(self, tickets):\ntargets = defaultdict(list)\nfor ticket in tickets:\ntargets[ticket[0]].append(ticket[1])\nfor key in targets:\ntargets[key].sort(reverse=True)\nresult = []\nself.backtracking(\"JFK\", targets, result)\nreturn result[::-1]\ndef backtracking(self, airport, targets, result):\nwhile targets[airport]:\nnext_airport = targets[airport].pop()\nself.backtracking(next_airport, targets, result)\nresult.append(airport)",
          "description": "Python实现的行程重排算法，采用回溯法结合字典存储机场间的关系，并通过逆序处理结果列表以获得最终行程。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "回溯 使用字典",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\nunordered_map<string, map<string, int>> targets;\nbool backtracking(int ticketNum, vector<string>& result) {\nif (result.size() == ticketNum + 1) {\nreturn true;\n}\nfor (pair<const string, int>& target : targets[result[result.size() - 1]]) {\nif (target.second > 0 ) { \nresult.push_back(target.first);\ntarget.second--;\nif (backtracking(ticketNum, result)) return true;\nresult.pop_back();\ntarget.second++;\n}\n}\nreturn false;\n}\npublic:\nvector<string> findItinerary(vector<vector<string>>& tickets) {\ntargets.clear();\nvector<string> result;\nfor (const vector<string>& vec : tickets) {\ntargets[vec[0]][vec[1]]++; \n}\nresult.push_back(\"JFK\"); \nbacktracking(tickets.size(), result);\nreturn result;\n}\n};",
          "description": "C++版本的回溯算法解决行程重构问题"
        },
        {
          "language": "java",
          "code": "class Solution {\nprivate Deque<String> res;\nprivate Map<String, Map<String, Integer>> map;\n\nprivate boolean backTracking(int ticketNum){\nif(res.size() == ticketNum + 1){\nreturn true;\n}\nString last = res.getLast();\nif(map.containsKey(last)){\nfor(Map.Entry<String, Integer> target : map.get(last).entrySet()){\nint count = target.getValue();\nif(count > 0){\nres.add(target.getKey());\ntarget.setValue(count - 1);\nif(backTracking(ticketNum)) return true;\nres.removeLast();\ntarget.setValue(count);\n}\n}\n}\nreturn false;\n}\n\npublic List<String> findItinerary(List<List<String>> tickets) {\nmap = new HashMap<String, Map<String, Integer>>();\nres = new LinkedList<>();\nfor(List<String> t : tickets){\nMap<String, Integer> temp;\nif(map.containsKey(t.get(0))){\ntemp = map.get(t.get(0));\ntemp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);\n}else{\ntemp = new TreeMap<>();\ntemp.put(t.get(1), 1);\n}\nmap.put(t.get(0), temp);\n}\nres.add(\"JFK\");\nbackTracking(tickets.size());\nreturn new ArrayList<>(res);\n}\n}",
          "description": "Java版本使用映射和回溯法解决行程重构问题"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\nclass Solution:\ndef findItinerary(self, tickets):\ntargets = defaultdict(list)\nfor ticket in tickets:\ntargets[ticket[0]].append(ticket[1])\nfor key in targets:\ntargets[key].sort(reverse=True)\nresult = []\nself.backtracking(\"JFK\", targets, result)\nreturn result[::-1]\ndef backtracking(self, airport, targets, result):\nwhile targets[airport]:\nnext_airport = targets[airport].pop()\nself.backtracking(next_airport, targets, result)\nresult.append(airport)",
          "description": "Python版本，通过字典存储机场映射关系，并利用回溯方法找到符合条件的行程安排"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {private:unordered_map<string, map<string, int>> targets;bool backtracking(int ticketNum, vector<string>& result) {if (result.size() == ticketNum + 1) {return true;}for (pair<const string, int>& target : targets[result[result.size() - 1]]) {if (target.second > 0 ) {result.push_back(target.first);target.second--;if (backtracking(ticketNum, result)) return true;result.pop_back();target.second++;}}return false;}public:vector<string> findItinerary(vector<vector<string>>& tickets) {targets.clear();vector<string> result;for (const vector<string>& vec : tickets) {targets[vec[0]][vec[1]]++;}result.push_back(\"JFK\");backtracking(tickets.size(), result);return result;}};",
      "description": "使用C++实现的回溯法解决重新安排行程问题，通过映射关系记录航班路径。"
    },
    {
      "language": "java",
      "code": "class Solution {private Deque<String> res;private Map<String, Map<String, Integer>> map;private boolean backTracking(int ticketNum){if(res.size() == ticketNum + 1){return true;}String last = res.getLast();if(map.containsKey(last)){for(Map.Entry<String, Integer> target : map.get(last).entrySet()){int count = target.getValue();if(count > 0){res.add(target.getKey());target.setValue(count - 1);if(backTracking(ticketNum)) return true;res.removeLast();target.setValue(count);}}}return false;}public List<String> findItinerary(List<List<String>> tickets) {map = new HashMap<>();res = new LinkedList<>();for(List<String> t : tickets){Map<String, Integer> temp;if(map.containsKey(t.get(0))){temp = map.get(t.get(0));temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);}else{temp = new TreeMap<>();temp.put(t.get(1), 1);}map.put(t.get(0), temp);}res.add(\"JFK\");backTracking(tickets.size());return new ArrayList<>(res);}}",
      "description": "Java版本的解决方案，同样采用回溯法，利用HashMap和TreeMap来维护机场间的映射关系并确保按字典序访问。"
    },
    {
      "language": "python",
      "code": "from collections import defaultdictclass Solution:    def findItinerary(self, tickets):        targets = defaultdict(list)        for ticket in tickets:            targets[ticket[0]].append(ticket[1])        for key in targets:            targets[key].sort(reverse=True)        result = []        self.backtracking(\"JFK\", targets, result)        return result[::-1]    def backtracking(self, airport, targets, result):        while targets[airport]:            next_airport = targets[airport].pop()            self.backtracking(next_airport, targets, result)        result.append(airport)",
      "description": "Python版本，应用了defaultdict存储机场间的关系，并且通过对列表进行逆向排序后进行深度优先搜索找到最小行程组合。"
    }
  ],
  "common_mistakes": [
    "未正确处理重复机场导致死循环",
    "忽视了不同解决方案间需要按字典序排列的要求"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20201115180537865.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20201115180537865.png",
      "context": "该图片展示了存在重复机场情况下的行程安排示例，用于说明如果没有妥善处理集合元素，则可能导致死循环的问题。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/2020111518065555-20230310121223600.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/2020111518065555-20230310121223600.png",
      "context": "该图片展示了给定航班路径如何被抽象成一个树形结构，用于辅助理解回溯算法的应用场景。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/2020111518065555-20230310121240991.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/2020111518065555-20230310121240991.png",
      "context": "该图片展示了在使用回溯算法寻找行程时，树形结构中唯一一条通向叶子节点的路线。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20201115180537865.png",
      "description": "GIF展示了在寻找航班路径过程中可能出现的死循环情况，通过特定例子说明出发机场和到达机场重复时导致的问题。",
      "context": "该GIF动画展示了在规划航班行程时，如果没有妥善处理机场间的映射关系，可能会导致形成死循环的情况。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/2020111518065555-20230310121223600.png",
      "description": "GIF展示了使用回溯法解决航班行程问题时的递归调用过程及决策树探索情况。",
      "context": "GIF动画展示了基于给定航班路径构建的树形结构，辅助理解回溯算法如何遍历所有可能的行程安排。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/2020111518065555-20230310121240991.png",
      "description": "GIF展示了通过回溯算法寻找唯一一条从根节点到叶子节点路径的过程，代表了航班行程的构建。",
      "context": "该GIF动画展示了在树形结构中通过回溯算法寻找唯一一条通向叶子节点路线的过程，帮助理解为何函数返回值采用bool类型。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\回溯算法\\重新安排行程.txt",
  "extracted_at": "2025-07-21T13:06:59.143332",
  "raw_content": "重新安排行程\n力扣题目链接(https://leetcode.cn/problems/reconstruct-itinerary/)\n\n给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。\n\n提示：\n\n如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [\"JFK\", \"LGA\"] 与 [\"JFK\", \"LGB\"] 相比就更小，排序更靠前\n所有的机场都用三个大写字母表示（机场代码）。\n假定所有机票至少存在一种合理的行程。\n所有的机票必须都用一次 且 只能用一次。\n示例 1：\n\n输入：[[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\n输出：[\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"]\n示例 2：\n\n输入：[[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n输出：[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\n解释：另一种有效的行程是 [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"]。但是它自然排序更大更靠后。\n\n\n#思路\n这道题目还是很难的，之前我们用回溯法解决了如下问题：组合问题 (https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)，分割问题 (https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html)，子集问题 (https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)，排列问题 (https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html)。\n\n直觉上来看 这道题和回溯法没有什么关系，更像是图论中的深度优先搜索。\n\n实际上确实是深搜，但这是深搜中使用了回溯的例子，在查找路径的时候，如果不回溯，怎么能查到目标路径呢。\n\n所以我倾向于说本题应该使用回溯法，那么我也用回溯法的思路来讲解本题，其实深搜一般都使用了回溯法的思路，在图论系列中我会再详细讲解深搜。\n\n这里就是先给大家拓展一下，原来回溯法还可以这么玩！\n\n这道题目有几个难点：\n\n一个行程中，如果航班处理不好容易变成一个圈，成为死循环\n有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？\n使用回溯法（也可以说深搜） 的话，那么终止条件是什么呢？\n搜索的过程中，如何遍历一个机场所对应的所有机场。\n针对以上问题我来逐一解答！\n\n#如何理解死循环\n对于死循环，我来举一个有重复机场的例子：\nhttps://file1.kamacoder.com/i/algo/20201115180537865.png\n\n为什么要举这个例子呢，就是告诉大家，出发机场和到达机场也会重复的，如果在解题的过程中没有对集合元素处理好，就会死循环。\n\n#该记录映射关系\n有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？\n\n一个机场映射多个机场，机场之间要靠字母序排列，一个机场映射多个机场，可以使用std::unordered_map，如果让多个机场之间再有顺序的话，就是用std::map 或者std::multimap 或者 std::multiset。\n\n如果对map 和 set 的实现机制不太了解，也不清楚为什么 map、multimap就是有序的同学，可以看这篇文章关于哈希表，你该了解这些！ (https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)。\n\n这样存放映射关系可以定义为 unordered_map<string, multiset<string>> targets 或者 unordered_map<string, map<string, int>> targets。\n\n含义如下：\n\nunordered_map<string, multiset> targets：unordered_map<出发机场, 到达机场的集合> targets\n\nunordered_map<string, map<string, int>> targets：unordered_map<出发机场, map<到达机场, 航班次数>> targets\n\n这两个结构，我选择了后者，因为如果使用unordered_map<string, multiset<string>> targets 遍历multiset的时候，不能删除元素，一旦删除元素，迭代器就失效了。\n\n再说一下为什么一定要增删元素呢，正如开篇我给出的图中所示，出发机场和到达机场是会重复的，搜索的过程没及时删除目的机场就会死循环。\n\n所以搜索的过程中就是要不断的删multiset里的元素，那么推荐使用unordered_map<string, map<string, int>> targets。\n\n在遍历 unordered_map<出发机场, map<到达机场, 航班次数>> targets的过程中，可以使用\"航班次数\"这个字段的数字做相应的增减，来标记到达机场是否使用过了。\n\n如果“航班次数”大于零，说明目的地还可以飞，如果“航班次数”等于零说明目的地不能飞了，而不用对集合做删除元素或者增加元素的操作。\n\n相当于说我不删，我就做一个标记！\n\n#回溯法\n这道题目我使用回溯法，那么下面按照我总结的回溯模板来：\n\nvoid backtracking(参数) {\n    if (终止条件) {\n        存放结果;\n        return;\n    }\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\n        处理节点;\n        backtracking(路径，选择列表); // 递归\n        回溯，撤销处理结果\n    }\n}\n本题以输入：[[\"JFK\", \"KUL\"], [\"JFK\", \"NRT\"], [\"NRT\", \"JFK\"]为例，抽象为树形结构如下：\n\nhttps://file1.kamacoder.com/i/algo/2020111518065555-20230310121223600.png\n\n开始回溯三部曲讲解：\n\n递归函数参数\n在讲解映射关系的时候，已经讲过了，使用unordered_map<string, map<string, int>> targets; 来记录航班的映射关系，我定义为全局变量。\n\n当然把参数放进函数里传进去也是可以的，我是尽量控制函数里参数的长度。\n\n参数里还需要ticketNum，表示有多少个航班（终止条件会用上）。\n\n代码如下：\n\n// unordered_map<出发机场, map<到达机场, 航班次数>> targets\nunordered_map<string, map<string, int>> targets;\nbool backtracking(int ticketNum, vector<string>& result) {\n注意函数返回值我用的是bool！\n\n我们之前讲解回溯算法的时候，一般函数返回值都是void，这次为什么是bool呢？\n\n因为我们只需要找到一个行程，就是在树形结构中唯一的一条通向叶子节点的路线，如图：\n\nhttps://file1.kamacoder.com/i/algo/2020111518065555-20230310121240991.png\n\n所以找到了这个叶子节点了直接返回，这个递归函数的返回值问题我们在讲解二叉树的系列的时候，在这篇二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html)详细介绍过。\n\n当然本题的targets和result都需要初始化，代码如下：\n\nfor (const vector<string>& vec : tickets) {\n    targets[vec[0]][vec[1]]++; // 记录映射关系\n}\nresult.push_back(\"JFK\"); // 起始机场\n递归终止条件\n拿题目中的示例为例，输入: [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]] ，这是有4个航班，那么只要找出一种行程，行程里的机场个数是5就可以了。\n\n所以终止条件是：我们回溯遍历的过程中，遇到的机场个数，如果达到了（航班数量+1），那么我们就找到了一个行程，把所有航班串在一起了。\n\n代码如下：\n\nif (result.size() == ticketNum + 1) {\n    return true;\n}\n已经看习惯回溯法代码的同学，到叶子节点了习惯性的想要收集结果，但发现并不需要，本题的result相当于 回溯算法：求组合总和！ (https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html)中的path，也就是本题的result就是记录路径的（就一条），在如下单层搜索的逻辑中result就添加元素了。\n\n单层搜索的逻辑\n回溯的过程中，如何遍历一个机场所对应的所有机场呢？\n\n这里刚刚说过，在选择映射函数的时候，不能选择unordered_map<string, multiset<string>> targets， 因为一旦有元素增删multiset的迭代器就会失效，当然可能有牛逼的容器删除元素迭代器不会失效，这里就不再讨论了。\n\n可以说本题既要找到一个对数据进行排序的容器，而且还要容易增删元素，迭代器还不能失效。\n\n所以我选择了unordered_map<string, map<string, int>> targets 来做机场之间的映射。\n\n遍历过程如下：\n\nfor (pair<const string, int>& target : targets[result[result.size() - 1]]) {\n    if (target.second > 0 ) { // 记录到达机场是否飞过了\n        result.push_back(target.first);\n        target.second--;\n        if (backtracking(ticketNum, result)) return true;\n        result.pop_back();\n        target.second++;\n    }\n}\n可以看出 通过unordered_map<string, map<string, int>> targets里的int字段来判断 这个集合里的机场是否使用过，这样避免了直接去删元素。\n\n分析完毕，此时完整C++代码如下：\n\nclass Solution {\nprivate:\n// unordered_map<出发机场, map<到达机场, 航班次数>> targets\nunordered_map<string, map<string, int>> targets;\nbool backtracking(int ticketNum, vector<string>& result) {\n    if (result.size() == ticketNum + 1) {\n        return true;\n    }\n    for (pair<const string, int>& target : targets[result[result.size() - 1]]) {\n        if (target.second > 0 ) { // 记录到达机场是否飞过了\n            result.push_back(target.first);\n            target.second--;\n            if (backtracking(ticketNum, result)) return true;\n            result.pop_back();\n            target.second++;\n        }\n    }\n    return false;\n}\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        targets.clear();\n        vector<string> result;\n        for (const vector<string>& vec : tickets) {\n            targets[vec[0]][vec[1]]++; // 记录映射关系\n        }\n        result.push_back(\"JFK\"); // 起始机场\n        backtracking(tickets.size(), result);\n        return result;\n    }\n};\n一波分析之后，可以看出我就是按照回溯算法的模板来的。\n\n代码中\n\nfor (pair<const string, int>& target : targets[result[result.size() - 1]])\n一定要加上引用即 & target，因为后面有对 target.second 做减减操作，如果没有引用，单纯复制，这个结果就没记录下来，那最后的结果就不对了。\n\n加上引用之后，就必须在 string 前面加上 const，因为map中的key 是不可修改了，这就是语法规定了。\n\n#总结\n本题其实可以算是一道hard的题目了，关于本题的难点我在文中已经列出了。\n\n如果单纯的回溯搜索（深搜）并不难，难还难在容器的选择和使用上。\n\n本题其实是一道深度优先搜索的题目，但是我完全使用回溯法的思路来讲解这道题题目，算是给大家拓展一下思维方式，其实深搜和回溯也是分不开的，毕竟最终都是用递归。\n\n如果最终代码，发现照着回溯法模板画的话好像也能画出来，但难就难如何知道可以使用回溯，以及如果套进去，所以我再写了这么长的一篇来详细讲解。\n\n#其他语言版本\n#Java\nclass Solution {\n    private LinkedList<String> res;\n    private LinkedList<String> path = new LinkedList<>();\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        Collections.sort(tickets, (a, b) -> a.get(1).compareTo(b.get(1)));\n        path.add(\"JFK\");\n        boolean[] used = new boolean[tickets.size()];\n        backTracking((ArrayList) tickets, used);\n        return res;\n    }\n\n    public boolean backTracking(ArrayList<List<String>> tickets, boolean[] used) {\n        if (path.size() == tickets.size() + 1) {\n            res = new LinkedList(path);\n            return true;\n        }\n\n        for (int i = 0; i < tickets.size(); i++) {\n            if (!used[i] && tickets.get(i).get(0).equals(path.getLast())) {\n                path.add(tickets.get(i).get(1));\n                used[i] = true;\n\n                if (backTracking(tickets, used)) {\n                    return true;\n                }\n\n                used[i] = false;\n                path.removeLast();\n            }\n        }\n        return false;\n    }\n}\nclass Solution {\n    private Deque<String> res;\n    private Map<String, Map<String, Integer>> map;\n\n    private boolean backTracking(int ticketNum){\n        if(res.size() == ticketNum + 1){\n            return true;\n        }\n        String last = res.getLast();\n        if(map.containsKey(last)){//防止出现null\n            for(Map.Entry<String, Integer> target : map.get(last).entrySet()){\n                int count = target.getValue();\n                if(count > 0){\n                    res.add(target.getKey());\n                    target.setValue(count - 1);\n                    if(backTracking(ticketNum)) return true;\n                    res.removeLast();\n                    target.setValue(count);\n                }\n            }\n        }\n        return false;\n    }\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        map = new HashMap<String, Map<String, Integer>>();\n        res = new LinkedList<>();\n        for(List<String> t : tickets){\n            Map<String, Integer> temp;\n            if(map.containsKey(t.get(0))){\n                temp = map.get(t.get(0));\n                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);\n            }else{\n                temp = new TreeMap<>();//升序Map\n                temp.put(t.get(1), 1);\n            }\n            map.put(t.get(0), temp);\n\n        }\n        res.add(\"JFK\");\n        backTracking(tickets.size());\n        return new ArrayList<>(res);\n    }\n}\n/*  该方法是对第二个方法的改进，主要变化在于将某点的所有终点变更为链表的形式，优点在于\n        1.添加终点时直接在对应位置添加节点，避免了TreeMap增元素时的频繁调整\n        2.同时每次对终点进行增加删除查找时直接通过下标操作，避免hashMap反复计算hash*/\nclass Solution {\n    //key为起点，value是有序的终点的列表\n    Map<String, LinkedList<String>> ticketMap = new HashMap<>();\n    LinkedList<String> result = new LinkedList<>();\n    int total;\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        total = tickets.size() + 1;\n        //遍历tickets，存入ticketMap中\n        for (List<String> ticket : tickets) {\n            addNew(ticket.get(0), ticket.get(1));\n        }\n        deal(\"JFK\");\n        return result;\n    }\n\n    boolean deal(String currentLocation) {\n        result.add(currentLocation);\n        //机票全部用完，找到最小字符路径\n        if (result.size() == total) {\n            return true;\n        }\n        //当前位置的终点列表\n        LinkedList<String> targetLocations = ticketMap.get(currentLocation);\n        //没有从当前位置出发的机票了，说明这条路走不通\n        if (targetLocations != null && !targetLocations.isEmpty()) {\n            //终点列表中遍历到的终点\n            String targetLocation;\n            //遍历从当前位置出发的机票\n            for (int i = 0; i < targetLocations.size(); i++) {\n\t\t//去重，否则在最后一个测试用例中遇到循环时会无限递归\n                if(i > 0 && targetLocations.get(i).equals(targetLocations.get(i - 1))) continue;\n                targetLocation = targetLocations.get(i);\n                //删除终点列表中当前的终点\n                targetLocations.remove(i);\n                //递归\n                if (deal(targetLocation)) {\n                    return true;\n                }\n                //路线走不通，将机票重新加回去\n                targetLocations.add(i, targetLocation);\n                result.removeLast();\n            }\n        }\n        return false;\n    }\n\n    /**\n     * 在map中按照字典顺序添加新元素\n     *\n     * @param start 起点\n     * @param end   终点\n     */\n    void addNew(String start, String end) {\n        LinkedList<String> startAllEnd = ticketMap.getOrDefault(start, new LinkedList<>());\n        if (!startAllEnd.isEmpty()) {\n            for (int i = 0; i < startAllEnd.size(); i++) {\n                if (end.compareTo(startAllEnd.get(i)) < 0) {\n                    startAllEnd.add(i, end);\n                    return;\n                }\n            }\n            startAllEnd.add(startAllEnd.size(), end);\n        } else {\n            startAllEnd.add(end);\n            ticketMap.put(start, startAllEnd);\n        }\n    }\n}\n#Python\n回溯 使用字典\n\nclass Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        self.adj = {}\n\n        # sort by the destination alphabetically\n        # 根据航班每一站的重点字母顺序排序\n        tickets.sort(key=lambda x:x[1])\n\n        # get all possible connection for each destination\n        # 罗列每一站的下一个可选项\n        for u,v in tickets:\n            if u in self.adj: self.adj[u].append(v)\n            else: self.adj[u] = [v]\n\n        # 从JFK出发\n        self.result = []\n        self.dfs(\"JFK\")  # start with JFK\n\n        return self.result[::-1]  # reverse to get the result\n\n    def dfs(self, s):\n        # if depart city has flight and the flight can go to another city\n        while s in self.adj and len(self.adj[s]) > 0:\n            # 找到s能到哪里，选能到的第一个机场\n            v = self.adj[s][0]  # we go to the 1 choice of the city\n            # 在之后的可选项机场中去掉这个机场\n            self.adj[s].pop(0)  # get rid of this choice since we used it\n            # 从当前的新出发点开始\n            self.dfs(v)  # we start from the new airport\n\n        self.result.append(s)  # after append, it will back track to last node, thus the result list is in reversed order\n\n回溯 使用字典 逆序\n\nfrom collections import defaultdict\n\nclass Solution:\n    def findItinerary(self, tickets):\n        targets = defaultdict(list)  # 创建默认字典，用于存储机场映射关系\n        for ticket in tickets:\n            targets[ticket[0]].append(ticket[1])  # 将机票输入到字典中\n        \n        for key in targets:\n            targets[key].sort(reverse=True)  # 对到达机场列表进行字母逆序排序\n        \n        result = []\n        self.backtracking(\"JFK\", targets, result)  # 调用回溯函数开始搜索路径\n        return result[::-1]  # 返回逆序的行程路径\n    \n    def backtracking(self, airport, targets, result):\n        while targets[airport]:  # 当机场还有可到达的机场时\n            next_airport = targets[airport].pop()  # 弹出下一个机场\n            self.backtracking(next_airport, targets, result)  # 递归调用回溯函数进行深度优先搜索\n        result.append(airport)  # 将当前机场添加到行程路径中"
}