{
  "id": "AP_7eb40d3c",
  "title": "全排列",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/permutations/",
  "description": "一个 没有重复 数字的序列，返回其所有可能的全排列。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "Backtracking",
    "Recursion"
  ],
  "data_structure_tags": [
    "Array",
    "Boolean Array"
  ],
  "technique_tags": [
    "State Tracking",
    "Recursive Search"
  ],
  "difficulty": null,
  "solution_approach": "采用回溯算法来生成给定序列的所有可能全排列。通过递归调用和一个用于跟踪已使用元素的状态数组来探索所有可能的组合。",
  "key_insights": [
    {
      "content": "使用`used`布尔数组来避免在当前路径中重复选择相同的元素，确保每个元素只被选取一次。"
    },
    {
      "content": "不同于组合或子集问题，全排列在每次递归调次时都需要从头开始搜索整个数组，因为顺序不同则代表不同的排列。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "此时我们已经学习了77.组合问题 (https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)、 131.分割回文串 (https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)和78.子集问题 (https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)，接下来看一看排列问题。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public:vector<vector<int>> result;vector<int> path;void backtracking (vector<int>& nums, vector<bool>& used) {if (path.size() == nums.size()) {result.push_back(path);return;}for (int i = 0; i < nums.size(); i++) {if (used[i] == true) continue;used[i] = true;path.push_back(nums[i]);backtracking(nums, used);path.pop_back();used[i] = false;}}vector<vector<int>> permute(vector<int>& nums) {result.clear();path.clear();vector<bool> used(nums.size(), false);backtracking(nums, used);return result;}};",
          "description": "C++全排列问题解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>();LinkedList<Integer> path = new LinkedList<>();boolean[] used;public List<List<Integer>> permute(int[] nums) {if (nums.length == 0){return result;}used = new boolean[nums.length];permuteHelper(nums);return result;}private void permuteHelper(int[] nums){if (path.size() == nums.length){result.add(new ArrayList<>(path));return;}for (int i = 0; i < nums.length; i++){if (used[i]){continue;}used[i] = true;path.add(nums[i]);permuteHelper(nums);path.removeLast();used[i] = false;}}}",
          "description": "Java全排列问题解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>();LinkedList<Integer> path = new LinkedList<>();public List<List<Integer>> permute(int[] nums) {if (nums.length == 0) return result;backtrack(nums, path);return result;}public void backtrack(int[] nums, LinkedList<Integer> path) {if (path.size() == nums.length) {result.add(new ArrayList<>(path));return;}for (int i =0; i < nums.length; i++) {if (path.contains(nums[i])) {continue;}path.add(nums[i]);backtrack(nums, path);path.removeLast();}}}",
          "description": "Java另一种全排列问题解决方案，通过检查path中是否已存在元素来避免重复选择。"
        },
        {
          "language": "python",
          "code": "class Solution: def permute(self, nums): result = [] self.backtracking(nums, [], [False] * len(nums), result) return result def backtracking(self, nums, path, used, result): if len(path) == len(nums): result.append(path[:]) return for i in range(len(nums)): if used[i]: continue used[i] = True path.append(nums[i]) self.backtracking(nums, path, used, result) path.pop() used[i] = False",
          "description": "Python全排列问题解决方案，使用了回溯算法和一个used列表来跟踪已经使用的数字。"
        }
      ],
      "subsections": []
    },
    {
      "name": "回溯三部曲",
      "text": "递归函数参数",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<vector<int>> result; vector<int> path; void backtracking (vector<int>& nums, vector<bool>& used) { if (path.size() == nums.size()) { result.push_back(path); return; } for (int i = 0; i < nums.size(); i++) { if (used[i] == true) continue; used[i] = true; path.push_back(nums[i]); backtracking(nums, used); path.pop_back(); used[i] = false; }} vector<vector<int>> permute(vector<int>& nums) { result.clear(); path.clear(); vector<bool> used(nums.size(), false); backtracking(nums, used); return result;}};",
          "description": null
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>();LinkedList<Integer> path = new LinkedList<>();boolean[] used;public List<List<Integer>> permute(int[] nums) {if (nums.length == 0){return result;}used = new boolean[nums.length];permuteHelper(nums);return result;}private void permuteHelper(int[] nums){if (path.size() == nums.length){result.add(new ArrayList<>(path));return;}for (int i = 0; i < nums.length; i++){if (used[i]){continue;}used[i] = true;path.add(nums[i]);permuteHelper(nums);path.removeLast();used[i] = false;}}}",
          "description": null
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>();LinkedList<Integer> path = new LinkedList<>();public List<List<Integer>> permute(int[] nums) {if (nums.length == 0) return result;backtrack(nums, path);return result;}public void backtrack(int[] nums, LinkedList<Integer> path) {if (path.size() == nums.length) {result.add(new ArrayList<>(path));return;}for (int i =0; i < nums.length; i++) {if (path.contains(nums[i])) {continue;}path.add(nums[i]);backtrack(nums, path);path.removeLast();}}}",
          "description": null
        },
        {
          "language": "python",
          "code": "class Solution: def permute(self, nums): result = [] self.backtracking(nums, [], [False] * len(nums), result) return result def backtracking(self, nums, path, used, result): if len(path) == len(nums): result.append(path[:]) return for i in range(len(nums)): if used[i]: continue used[i] = True path.append(nums[i]) self.backtracking(nums, path, used, result) path.pop() used[i] = False",
          "description": null
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "大家此时可以感受出排列问题的不同：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<vector<int>> result; vector<int> path; void backtracking (vector<int>& nums, vector<bool>& used) {if (path.size() == nums.size()) {result.push_back(path);return;}for (int i = 0; i < nums.size(); i++) {if (used[i] == true) continue;used[i] = true;path.push_back(nums[i]);backtracking(nums, used);path.pop_back();used[i] = false;}}vector<vector<int>> permute(vector<int>& nums) {result.clear();path.clear();vector<bool> used(nums.size(), false);backtracking(nums, used);return result;}};",
          "description": "C++实现全排列问题，使用回溯法。"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>();LinkedList<Integer> path = new LinkedList<>();boolean[] used;public List<List<Integer>> permute(int[] nums) {if (nums.length == 0){return result;}used = new boolean[nums.length];permuteHelper(nums);return result;}private void permuteHelper(int[] nums){if (path.size() == nums.length){result.add(new ArrayList<>(path));return;}for (int i = 0; i < nums.length; i++){if (used[i]){continue;}used[i] = true;path.add(nums[i]);permuteHelper(nums);path.removeLast();used[i] = false;}}}",
          "description": "Java实现全排列问题，使用回溯法。"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>();LinkedList<Integer> path = new LinkedList<>();public List<List<Integer>> permute(int[] nums) {if (nums.length == 0) return result;backtrack(nums, path);return result;}public void backtrack(int[] nums, LinkedList<Integer> path) {if (path.size() == nums.length) {result.add(new ArrayList<>(path));return;}for (int i =0; i < nums.length; i++) {if (path.contains(nums[i])) {continue;}path.add(nums[i]);backtrack(nums, path);path.removeLast();}}}",
          "description": "另一种Java实现全排列的方法，不使用额外的used数组，通过检查path中是否包含当前数字来避免重复。"
        },
        {
          "language": "python",
          "code": "class Solution:def permute(self, nums):result = []self.backtracking(nums, [], [False] * len(nums), result)return resultdef backtracking(self, nums, path, used, result):if len(path) == len(nums):result.append(path[:])returnfor i in range(len(nums)):if used[i]:continueused[i] = Truepath.append(nums[i])self.backtracking(nums, path, used, result)path.pop()used[i] = False",
          "description": "Python实现全排列问题，使用回溯法，并利用一个used列表来追踪已经使用的元素。"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public:vector<vector<int>> result;vector<int> path;void backtracking (vector<int>& nums, vector<bool>& used) {if (path.size() == nums.size()) {result.push_back(path);return;}for (int i = 0; i < nums.size(); i++) {if (used[i] == true) continue;used[i] = true;path.push_back(nums[i]);backtracking(nums, used);path.pop_back();used[i] = false;}}vector<vector<int>> permute(vector<int>& nums) {result.clear();path.clear();vector<bool> used(nums.size(), false);backtracking(nums, used);return result;}};",
          "description": "C++实现的全排列算法"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>();LinkedList<Integer> path = new LinkedList<>();boolean[] used;public List<List<Integer>> permute(int[] nums) {if (nums.length == 0){return result;}used = new boolean[nums.length];permuteHelper(nums);return result;}private void permuteHelper(int[] nums){if (path.size() == nums.length){result.add(new ArrayList<>(path));return;}for (int i = 0; i < nums.length; i++){if (used[i]){continue;}used[i] = true;path.add(nums[i]);permuteHelper(nums);path.removeLast();used[i] = false;}}}",
          "description": "Java实现的第一种全排列算法"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>();LinkedList<Integer> path = new LinkedList<>();public List<List<Integer>> permute(int[] nums) {if (nums.length == 0) return result;backtrack(nums, path);return result;}public void backtrack(int[] nums, LinkedList<Integer> path) {if (path.size() == nums.length) {result.add(new ArrayList<>(path));return;}for (int i =0; i < nums.length; i++) {if (path.contains(nums[i])) {continue;}path.add(nums[i]);backtrack(nums, path);path.removeLast();}}}",
          "description": "Java实现的第二种全排列算法"
        },
        {
          "language": "python",
          "code": "class Solution:def permute(self, nums):result = []self.backtracking(nums, [], [False] * len(nums), result)return resultdef backtracking(self, nums, path, used, result):if len(path) == len(nums):result.append(path[:])returnfor i in range(len(nums)):if used[i]:continueused[i] = Truepath.append(nums[i])self.backtracking(nums, path, used, result)path.pop()used[i] = False",
          "description": "Python实现的全排列算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public:vector<vector<int>> result;vector<int> path;void backtracking (vector<int>& nums, vector<bool>& used) {if (path.size() == nums.size()) {result.push_back(path);return;}for (int i = 0; i < nums.size(); i++) {if (used[i] == true) continue;used[i] = true;path.push_back(nums[i]);backtracking(nums, used);path.pop_back();used[i] = false;}}vector<vector<int>> permute(vector<int>& nums) {result.clear();path.clear();vector<bool> used(nums.size(), false);backtracking(nums, used);return result;}};",
          "description": "C++实现全排列问题"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>();LinkedList<Integer> path = new LinkedList<>();boolean[] used;public List<List<Integer>> permute(int[] nums) {if (nums.length == 0){return result;}used = new boolean[nums.length];permuteHelper(nums);return result;}private void permuteHelper(int[] nums){if (path.size() == nums.length){result.add(new ArrayList<>(path));return;}for (int i = 0; i < nums.length; i++){if (used[i]){continue;}used[i] = true;path.add(nums[i]);permuteHelper(nums);path.removeLast();used[i] = false;}}}",
          "description": "Java实现全排列问题，使用used数组记录已访问元素"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>();LinkedList<Integer> path = new LinkedList<>();public List<List<Integer>> permute(int[] nums) {if (nums.length == 0) return result;backtrack(nums, path);return result;}public void backtrack(int[] nums, LinkedList<Integer> path) {if (path.size() == nums.length) {result.add(new ArrayList<>(path));return;}for (int i =0; i < nums.length; i++) {if (path.contains(nums[i])) {continue;}path.add(nums[i]);backtrack(nums, path);path.removeLast();}}}",
          "description": "Java实现全排列问题，通过检查path中是否存在来排除已选择的数字"
        },
        {
          "language": "python",
          "code": "class Solution:def permute(self, nums):result = []self.backtracking(nums, [], [False] * len(nums), result)return resultdef backtracking(self, nums, path, used, result):if len(path) == len(nums):result.append(path[:])returnfor i in range(len(nums)):if used[i]:continueused[i] = Truepath.append(nums[i])self.backtracking(nums, path, used, result)path.pop()used[i] = False",
          "description": "Python实现全排列问题，使用used列表追踪已使用的元素"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "回溯 使用used",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<vector<int>> result; vector<int> path; void backtracking (vector<int>& nums, vector<bool>& used) { if (path.size() == nums.size()) { result.push_back(path); return; } for (int i = 0; i < nums.size(); i++) { if (used[i] == true) continue; used[i] = true; path.push_back(nums[i]); backtracking(nums, used); path.pop_back(); used[i] = false; }} vector<vector<int>> permute(vector<int>& nums) {result.clear(); path.clear(); vector<bool> used(nums.size(), false); backtracking(nums, used); return result;}};",
          "description": "C++实现的全排列算法"
        },
        {
          "language": "java",
          "code": "class Solution {List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); boolean[] used; public List<List<Integer>> permute(int[] nums) {if (nums.length == 0){return result;} used = new boolean[nums.length]; permuteHelper(nums); return result;} private void permuteHelper(int[] nums){if (path.size() == nums.length){result.add(new ArrayList<>(path)); return;} for (int i = 0; i < nums.length; i++){if (used[i]){continue;} used[i] = true; path.add(nums[i]); permuteHelper(nums); path.removeLast(); used[i] = false;}}}",
          "description": "Java实现的全排列算法，使用了used数组来跟踪已使用的元素"
        },
        {
          "language": "python",
          "code": "class Solution: def permute(self, nums): result = [] self.backtracking(nums, [], [False] * len(nums), result) return result def backtracking(self, nums, path, used, result): if len(path) == len(nums): result.append(path[:]) return for i in range(len(nums)): if used[i]: continue used[i] = True path.append(nums[i]) self.backtracking(nums, path, used, result) path.pop() used[i] = False",
          "description": "Python实现的全排列算法，通过回溯法和used数组来避免重复选择同一个元素"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n!)",
    "space_complexity": "O(n)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: vector<vector<int>> result; vector<int> path; void backtracking (vector<int>& nums, vector<bool>& used) { if (path.size() == nums.size()) { result.push_back(path); return; } for (int i = 0; i < nums.size(); i++) { if (used[i] == true) continue; used[i] = true; path.push_back(nums[i]); backtracking(nums, used); path.pop_back(); used[i] = false; } } vector<vector<int>> permute(vector<int>& nums) { result.clear(); path.clear(); vector<bool> used(nums.size(), false); backtracking(nums, used); return result; }};",
      "description": "C++实现全排列问题"
    },
    {
      "language": "java",
      "code": "class Solution {List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); boolean[] used; public List<List<Integer>> permute(int[] nums) { if (nums.length == 0){ return result; } used = new boolean[nums.length]; permuteHelper(nums); return result; } private void permuteHelper(int[] nums){ if (path.size() == nums.length){ result.add(new ArrayList<>(path)); return; } for (int i = 0; i < nums.length; i++){ if (used[i]){ continue; } used[i] = true; path.add(nums[i]); permuteHelper(nums); path.removeLast(); used[i] = false; }}}",
      "description": "Java实现全排列问题，使用了used数组来跟踪已使用的元素"
    },
    {
      "language": "java",
      "code": "class Solution {List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); public List<List<Integer>> permute(int[] nums) { if (nums.length == 0) return result; backtrack(nums, path); return result; } public void backtrack(int[] nums, LinkedList<Integer> path) { if (path.size() == nums.length) { result.add(new ArrayList<>(path)); return; } for (int i =0; i < nums.length; i++) { if (path.contains(nums[i])) { continue; } path.add(nums[i]); backtrack(nums, path); path.removeLast(); }}}",
      "description": "另一种Java实现全排列问题的方法，通过检查path中是否存在数字来排除已经选择的数字"
    },
    {
      "language": "python",
      "code": "class Solution: def permute(self, nums): result = [] self.backtracking(nums, [], [False] * len(nums), result) return result def backtracking(self, nums, path, used, result): if len(path) == len(nums): result.append(path[:]) return for i in range(len(nums)): if used[i]: continue used[i] = True path.append(nums[i]) self.backtracking(nums, path, used, result) path.pop() used[i] = False",
      "description": "Python实现全排列问题，使用了used列表来跟踪已使用的元素"
    }
  ],
  "common_mistakes": [
    "忽略使用`used`数组导致重复元素出现在同一层级的不同位置。",
    "错误地设置递归终止条件，比如没有正确判断何时path长度等于nums长度。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240803180318.png",
      "description": "这张图片展示了使用回溯算法生成数组 `[1, 2, 3]` 的所有排列的过程，通过递归和循环遍历实现。",
      "context": "该图片展示了以[1,2,3]为例，如何将排列问题抽象成树形结构的过程，用于解释为什么在处理排列问题时需要使用一个used数组来标记已经选择过的元素。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240803180318.png",
      "description": "这张图片展示了使用回溯算法生成数组 `[1, 2, 3]` 的所有排列的过程，通过递归和状态标记（`used` 数组）来实现全排列的构建。",
      "context": "该图片展示了以[1,2,3]为例，如何将数组抽象成树形结构来解决排列问题，并通过橘黄色部分特别标记了used数组的作用。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240803180318.png",
      "description": "这张图片展示了使用回溯算法生成数组 `[1, 2, 3]` 的所有排列的过程，通过递归和循环实现对集合的遍历和选择。",
      "context": "该图片展示了以[1,2,3]为例，如何将排列问题抽象成树形结构的过程，帮助理解回溯算法在处理排列问题时的具体应用。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240803180318.png",
      "description": "GIF展示了通过回溯算法生成[1,2,3]所有排列的过程，包括使用used数组标记已选择元素的步骤。",
      "context": "GIF动画展示了如何将数组[1,2,3]抽象为树形结构来解决排列问题，通过使用used数组标记已选择的元素，形象地解释了回溯算法在处理排列时的工作原理。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\回溯算法\\全排列.txt",
  "extracted_at": "2025-07-21T04:11:09.727035",
  "raw_content": "全排列\n力扣题目链接(https://leetcode.cn/problems/permutations/)\n\n给定一个 没有重复 数字的序列，返回其所有可能的全排列。\n\n示例:\n\n输入: [1,2,3]\n输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]\n\n\n#思路\n此时我们已经学习了77.组合问题 (https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)、 131.分割回文串 (https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)和78.子集问题 (https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)，接下来看一看排列问题。\n\n相信这个排列问题就算是让你用for循环暴力把结果搜索出来，这个暴力也不是很好写。\n\n所以正如我们在关于回溯算法，你该了解这些！ (https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)所讲的为什么回溯法是暴力搜索，效率这么低，还要用它？\n\n因为一些问题能暴力搜出来就已经很不错了！\n\n我以[1,2,3]为例，抽象成树形结构如下：\n\nhttps://file1.kamacoder.com/i/algo/20240803180318.png\n\n#回溯三部曲\n递归函数参数\n首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。\n\n可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。\n\n但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:\n\nhttps://file1.kamacoder.com/i/algo/20240803180318.png\n\n代码如下：\n\nvector<vector<int>> result;\nvector<int> path;\nvoid backtracking (vector<int>& nums, vector<bool>& used)\n递归终止条件\nhttps://file1.kamacoder.com/i/algo/20240803180318.png\n\n可以看出叶子节点，就是收割结果的地方。\n\n那么什么时候，算是到达叶子节点呢？\n\n当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。\n\n代码如下：\n\n// 此时说明找到了一组\nif (path.size() == nums.size()) {\n    result.push_back(path);\n    return;\n}\n单层搜索的逻辑\n这里和77.组合问题 (https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)、131.切割问题 (https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)和78.子集问题 (https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)最大的不同就是for循环里不用startIndex了。\n\n因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。\n\n而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。\n\n代码如下：\n\nfor (int i = 0; i < nums.size(); i++) {\n    if (used[i] == true) continue; // path里已经收录的元素，直接跳过\n    used[i] = true;\n    path.push_back(nums[i]);\n    backtracking(nums, used);\n    path.pop_back();\n    used[i] = false;\n}\n整体C++代码如下：\n\nclass Solution {\npublic:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking (vector<int>& nums, vector<bool>& used) {\n        // 此时说明找到了一组\n        if (path.size() == nums.size()) {\n            result.push_back(path);\n            return;\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            if (used[i] == true) continue; // path里已经收录的元素，直接跳过\n            used[i] = true;\n            path.push_back(nums[i]);\n            backtracking(nums, used);\n            path.pop_back();\n            used[i] = false;\n        }\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        result.clear();\n        path.clear();\n        vector<bool> used(nums.size(), false);\n        backtracking(nums, used);\n        return result;\n    }\n};\n时间复杂度: O(n!)\n空间复杂度: O(n)\n#总结\n大家此时可以感受出排列问题的不同：\n\n每层都是从0开始搜索而不是startIndex\n需要used数组记录path里都放了哪些元素了\n排列问题是回溯算法解决的经典题目，大家可以好好体会体会。\n\n#其他语言版本\n#Java\nclass Solution {\n\n    List<List<Integer>> result = new ArrayList<>();// 存放符合条件结果的集合\n    LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果\n    boolean[] used;\n    public List<List<Integer>> permute(int[] nums) {\n        if (nums.length == 0){\n            return result;\n        }\n        used = new boolean[nums.length];\n        permuteHelper(nums);\n        return result;\n    }\n\n    private void permuteHelper(int[] nums){\n        if (path.size() == nums.length){\n            result.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = 0; i < nums.length; i++){\n            if (used[i]){\n                continue;\n            }\n            used[i] = true;\n            path.add(nums[i]);\n            permuteHelper(nums);\n            path.removeLast();\n            used[i] = false;\n        }\n    }\n}\n// 解法2：通过判断path中是否存在数字，排除已经选择的数字\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    LinkedList<Integer> path = new LinkedList<>();\n    public List<List<Integer>> permute(int[] nums) {\n        if (nums.length == 0) return result;\n        backtrack(nums, path);\n        return result;\n    }\n    public void backtrack(int[] nums, LinkedList<Integer> path) {\n        if (path.size() == nums.length) {\n            result.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i =0; i < nums.length; i++) {\n            // 如果path中已有，则跳过\n            if (path.contains(nums[i])) {\n                continue;\n            } \n            path.add(nums[i]);\n            backtrack(nums, path);\n            path.removeLast();\n        }\n    }\n}\n#Python\n回溯 使用used\n\nclass Solution:\n    def permute(self, nums):\n        result = []\n        self.backtracking(nums, [], [False] * len(nums), result)\n        return result\n\n    def backtracking(self, nums, path, used, result):\n        if len(path) == len(nums):\n            result.append(path[:])\n            return\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            self.backtracking(nums, path, used, result)\n            path.pop()\n            used[i] = False"
}