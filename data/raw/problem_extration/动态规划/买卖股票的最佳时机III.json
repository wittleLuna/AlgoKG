{
  "id": "AP_46622b5a",
  "title": "买卖股票的最佳时机III",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/",
  "description": "一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。",
  "examples": [
    {
      "input": "prices = [1]",
      "output": "0",
      "explanation": null,
      "image": null
    }
  ],
  "constraints": [],
  "algorithm_tags": [
    "Dynamic Programming"
  ],
  "data_structure_tags": [
    "Array"
  ],
  "technique_tags": [
    "State Transition",
    "Optimization"
  ],
  "difficulty": null,
  "solution_approach": "通过动态规划的方法来解决最多进行两次买卖股票问题。定义了五个状态，并据此构建dp数组以追踪每一天在不同操作下的最大收益。",
  "key_insights": [
    {
      "content": "将每个交易日的状态细分为五种：无操作、首次买入、首次卖出、二次买入、二次卖出。这种细分有助于清晰地表达每一天可采取的所有可能行动及其对最终利润的影响。"
    },
    {
      "content": "对于每一个状态，依据前一天的状态转移而来，确保了每一步决策都是基于之前最佳选择的基础上做出的。例如，今天是否买入取决于昨天是否已持有股票以及今日价格等因素。"
    },
    {
      "content": "初始化时考虑了第一天进行各种操作的情况，为后续状态转移提供了基础。"
    },
    {
      "content": "最终的最大利润是基于最后一天所有状态中的最大值，即最后一次卖出股票后的现金量。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "这道题目相对 121.买卖股票的最佳时机 (https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html)和 122.买卖股票的最佳时机II (https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html)难了不少。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {if (prices.size() == 0) return 0;vector<vector<int>> dp(prices.size(), vector<int>(5, 0));dp[0][1] = -prices[0];dp[0][3] = -prices[0];for (int i = 1; i < prices.size(); i++) {dp[i][0] = dp[i - 1][0];dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);}return dp[prices.size() - 1][4];}};",
          "description": "C++版本一：使用动态规划解决最多两次交易获得的最大利润问题。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {if (prices.size() == 0) return 0;vector<int> dp(5, 0);dp[1] = -prices[0];dp[3] = -prices[0];for (int i = 1; i < prices.size(); i++) {dp[1] = max(dp[1], dp[0] - prices[i]);dp[2] = max(dp[2], dp[1] + prices[i]);dp[3] = max(dp[3], dp[2] - prices[i]);dp[4] = max(dp[4], dp[3] + prices[i]);}return dp[4];}};",
          "description": "C++版本二：空间优化后的解决方案，同样基于动态规划。"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int len = prices.length;if (prices.length == 0) return 0;int[][] dp = new int[len][5];dp[0][1] = -prices[0];dp[0][3] = -prices[0];for (int i = 1; i < len; i++) {dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);}return dp[len - 1][4];}}",
          "description": "Java版本一：与C++版本一类似，但使用Java语法实现。"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int[] dp = new int[4];dp[0] = -prices[0];dp[2] = -prices[0];for(int i = 1; i <= prices.length; i++){dp[0] = Math.max(dp[0], -prices[i-1]);dp[1] = Math.max(dp[1], dp[0]+prices[i-1]);dp[2] = Math.max(dp[2], dp[1]-prices[i-1]);dp[3] = Math.max(dp[3], dp[2]+ prices[i-1]);}return dp[3];}}",
          "description": "Java版本二：空间优化后的Java实现，类似于C++版本二。"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [[0] * 5 for _ in range(len(prices))] dp[0][1] = -prices[0] dp[0][3] = -prices[0] for i in range(1, len(prices)): dp[i][0] = dp[i-1][0] dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]) dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]) dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]) return dp[-1][4]",
          "description": "Python版本一：利用二维数组进行动态规划求解最大利润。"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [0] * 5 dp[1] = -prices[0] dp[3] = -prices[0] for i in range(1, len(prices)): dp[1] = max(dp[1], dp[0] - prices[i]) dp[2] = max(dp[2], dp[1] + prices[i]) dp[3] = max(dp[3], dp[2] - prices[i]) dp[4] = max(dp[4], dp[3] + prices[i]) return dp[4]",
          "description": "Python版本二：对空间复杂度进行了优化，仅使用了一维数组。"
        }
      ],
      "subsections": []
    },
    {
      "name": "拓展",
      "text": "其实我们可以不设置，‘0. 没有操作’ 这个状态，因为没有操作，手上的现金自然就是0， 正如我们在 121.买卖股票的最佳时机 (https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html)和 122.买卖股票的最佳时机II (https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html)也没有设置这一状态是一样的。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if (prices.size() == 0) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));\n        dp[0][1] = -prices[0];\n        dp[0][3] = -prices[0];\n        for (int i = 1; i < prices.size(); i++) {\n            dp[i][0] = dp[i - 1][0];\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\n            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n        }\n        return dp[prices.size() - 1][4];\n    }\n};",
          "description": "C++版本一"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if (prices.size() == 0) return 0;\n        vector<int> dp(5, 0);\n        dp[1] = -prices[0];\n        dp[3] = -prices[0];\n        for (int i = 1; i < prices.size(); i++) {\n            dp[1] = max(dp[1], dp[0] - prices[i]);\n            dp[2] = max(dp[2], dp[1] + prices[i]);\n            dp[3] = max(dp[3], dp[2] - prices[i]);\n            dp[4] = max(dp[4], dp[3] + prices[i]);\n        }\n        return dp[4];\n    }\n};",
          "description": "C++版本二"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if (prices.size() == 0) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));\n        dp[0][1] = -prices[0];\n        dp[0][3] = -prices[0];\n        for (int i = 1; i < prices.size(); i++) {\n            dp[i][1] = max(dp[i - 1][1], 0 - prices[i]);\n            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\n            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n        }\n        return dp[prices.size() - 1][4];\n    }\n};",
          "description": "C++版本三"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int len = prices.length;\n        if (prices.length == 0) return 0;\n        int[][] dp = new int[len][5];\n        dp[0][1] = -prices[0];\n        dp[0][3] = -prices[0];\n        for (int i = 1; i < len; i++) {\n            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);\n            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\n            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n        }\n        return dp[len - 1][4];\n    }\n}",
          "description": "Java版本一"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int[] dp = new int[4]; \n        dp[0] = -prices[0];\n        dp[1] = 0;\n        dp[2] = -prices[0];\n        dp[3] = 0;\n        for(int i = 1; i <= prices.length; i++){\n            dp[0] = Math.max(dp[0], -prices[i-1]);\n            dp[1] = Math.max(dp[1], dp[0]+prices[i-1]);\n            dp[2] = Math.max(dp[2], dp[1]-prices[i-1]);\n            dp[3] = Math.max(dp[3], dp[2]+ prices[i-1]);\n        }\n        return dp[3];\n    }\n}",
          "description": "Java版本二"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) == 0:\n            return 0\n        dp = [[0] * 5 for _ in range(len(prices))]\n        dp[0][1] = -prices[0]\n        dp[0][3] = -prices[0]\n        for i in range(1, len(prices)):\n            dp[i][0] = dp[i-1][0]\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\n            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])\n            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i])\n            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])\n        return dp[-1][4]",
          "description": "Python版本一"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) == 0:\n            return 0\n        dp = [0] * 5 \n        dp[1] = -prices[0]\n        dp[3] = -prices[0]\n        for i in range(1, len(prices)):\n            dp[1] = max(dp[1], dp[0] - prices[i])\n            dp[2] = max(dp[2], dp[1] + prices[i])\n            dp[3] = max(dp[3], dp[2] - prices[i])\n            dp[4] = max(dp[4], dp[3] + prices[i])\n        return dp[4]",
          "description": "Python版本二"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java:",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int len = prices.length;\n        if (prices.length == 0) return 0;\n\n        int[][] dp = new int[len][5];\n        dp[0][1] = -prices[0];\n        dp[0][3] = -prices[0];\n\n        for (int i = 1; i < len; i++) {\n            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);\n            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\n            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n        }\n\n        return dp[len - 1][4];\n    }\n}",
          "description": "Java版本一：使用二维数组dp来记录每一天不同状态下的最大利润。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int[] dp = new int[4]; \n        dp[0] = -prices[0];\n        dp[2] = -prices[0];\n        for(int i = 1; i <= prices.length; i++){\n            dp[0] = Math.max(dp[0], -prices[i-1]);\n            dp[1] = Math.max(dp[1], dp[0]+prices[i-1]);\n            dp[2] = Math.max(dp[2], dp[1]-prices[i-1]);\n            dp[3] = Math.max(dp[3], dp[2]+ prices[i-1]);\n        }\n        return dp[3];\n    }\n}",
          "description": "Java版本二：优化空间复杂度，只使用一个一维数组dp来存储当前交易状态下的最大利润。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) == 0:\n            return 0\n        dp = [[0] * 5 for _ in range(len(prices))]\n        dp[0][1] = -prices[0]\n        dp[0][3] = -prices[0]\n        for i in range(1, len(prices)):\n            dp[i][0] = dp[i-1][0]\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\n            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])\n            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i])\n            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])\n        return dp[-1][4]",
          "description": "Python版本一：与Java版本一类似，使用二维列表dp来记录每一天不同状态下的最大利润。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) == 0:\n            return 0\n        dp = [0] * 5 \n        dp[1] = -prices[0]\n        dp[3] = -prices[0]\n        for i in range(1, len(prices)):\n            dp[1] = max(dp[1], dp[0] - prices[i])\n            dp[2] = max(dp[2], dp[1] + prices[i])\n            dp[3] = max(dp[3], dp[2] - prices[i])\n            dp[4] = max(dp[4], dp[3] + prices[i])\n        return dp[4]",
          "description": "Python版本二：与Java版本二类似，通过减少额外的空间开销，仅使用一个列表dp来追踪交易状态的最大利润。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java:",
      "text": "// 版本一",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {if (prices.size() == 0) return 0;vector<vector<int>> dp(prices.size(), vector<int>(5, 0));dp[0][1] = -prices[0];dp[0][3] = -prices[0];for (int i = 1; i < prices.size(); i++) {dp[i][0] = dp[i - 1][0];dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);}return dp[prices.size() - 1][4];}};",
          "description": "版本一的C++实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {if (prices.size() == 0) return 0;vector<int> dp(5, 0);dp[1] = -prices[0];dp[3] = -prices[0];for (int i = 1; i < prices.size(); i++) {dp[1] = max(dp[1], dp[0] - prices[i]);dp[2] = max(dp[2], dp[1] + prices[i]);dp[3] = max(dp[3], dp[2] - prices[i]);dp[4] = max(dp[4], dp[3] + prices[i]);}return dp[4];}};",
          "description": "版本二的C++实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {if (prices.size() == 0) return 0;vector<vector<int>> dp(prices.size(), vector<int>(5, 0));dp[0][1] = -prices[0];dp[0][3] = -prices[0];for (int i = 1; i < prices.size(); i++) {dp[i][1] = max(dp[i - 1][1], 0 - prices[i]);dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);}return dp[prices.size() - 1][4];}};",
          "description": "版本三的C++实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int len = prices.length;if (prices.length == 0) return 0;int[][] dp = new int[len][5];dp[0][1] = -prices[0];dp[0][3] = -prices[0];for (int i = 1; i < len; i++) {dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);}return dp[len - 1][4];}}",
          "description": "Java版本一实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int[] dp = new int[4];dp[0] = -prices[0];dp[1] = 0;dp[2] = -prices[0];dp[3] = 0;for(int i = 1; i <= prices.length; i++){dp[0] = Math.max(dp[0], -prices[i-1]);dp[1] = Math.max(dp[1], dp[0]+prices[i-1]);dp[2] = Math.max(dp[2], dp[1]-prices[i-1]);dp[3] = Math.max(dp[3], dp[2]+ prices[i-1]);}return dp[3];}}",
          "description": "Java版本二实现"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [[0] * 5 for _ in range(len(prices))] dp[0][1] = -prices[0] dp[0][3] = -prices[0] for i in range(1, len(prices)): dp[i][0] = dp[i-1][0] dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]) dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]) dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]) return dp[-1][4]",
          "description": "Python版本一实现"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [0] * 5 dp[1] = -prices[0] dp[3] = -prices[0] for i in range(1, len(prices)): dp[1] = max(dp[1], dp[0] - prices[i]) dp[2] = max(dp[2], dp[1] + prices[i]) dp[3] = max(dp[3], dp[2] - prices[i]) dp[4] = max(dp[4], dp[3] + prices[i]) return dp[4]",
          "description": "Python版本二实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python:",
      "text": "版本一：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {if (prices.size() == 0) return 0;vector<vector<int>> dp(prices.size(), vector<int>(5, 0));dp[0][1] = -prices[0];dp[0][3] = -prices[0];for (int i = 1; i < prices.size(); i++) {dp[i][0] = dp[i - 1][0];dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);}return dp[prices.size() - 1][4];}};",
          "description": "使用二维动态规划解决最多两次交易的最大利润问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {if (prices.size() == 0) return 0;vector<int> dp(5, 0);dp[1] = -prices[0];dp[3] = -prices[0];for (int i = 1; i < prices.size(); i++) {dp[1] = max(dp[1], dp[0] - prices[i]);dp[2] = max(dp[2], dp[1] + prices[i]);dp[3] = max(dp[3], dp[2] - prices[i]);dp[4] = max(dp[4], dp[3] + prices[i]);}return dp[4];}};",
          "description": "优化空间复杂度后的版本，使用一维数组实现动态规划"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(vector<int>& prices) {if (prices.size() == 0) return 0;vector<vector<int>> dp(prices.size(), vector<int>(5, 0));dp[0][1] = -prices[0];dp[0][3] = -prices[0];for (int i = 1; i < prices.size(); i++) {dp[i][1] = max(dp[i - 1][1], 0 - prices[i]);dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);}return dp[prices.size() - 1][4];}};",
          "description": "不设置'没有操作'状态的版本"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int len = prices.length;if (prices.length == 0) return 0;int[][] dp = new int[len][5];dp[0][1] = -prices[0];dp[0][3] = -prices[0];for (int i = 1; i < len; i++) {dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);}return dp[len - 1][4];}}",
          "description": "Java实现的版本一，使用二维数组进行动态规划"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int[] prices) {int[] dp = new int[4];dp[0] = -prices[0];dp[1] = 0;dp[2] = -prices[0];dp[3] = 0;for(int i = 1; i <= prices.length; i++){dp[0] = Math.max(dp[0], -prices[i-1]);dp[1] = Math.max(dp[1], dp[0]+prices[i-1]);dp[2] = Math.max(dp[2], dp[1]-prices[i-1]);dp[3] = Math.max(dp[3], dp[2]+ prices[i-1]);}return dp[3];}}",
          "description": "Java实现的空间优化版本，使用一维数组存储状态"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [[0] * 5 for _ in range(len(prices))] dp[0][1] = -prices[0] dp[0][3] = -prices[0] for i in range(1, len(prices)): dp[i][0] = dp[i-1][0] dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]) dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]) dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]) return dp[-1][4]",
          "description": "Python实现的版本一，利用二维列表作为DP表"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [0] * 5 dp[1] = -prices[0] dp[3] = -prices[0] for i in range(1, len(prices)): dp[1] = max(dp[1], dp[0] - prices[i]) dp[2] = max(dp[2], dp[1] + prices[i]) dp[3] = max(dp[3], dp[2] - prices[i]) dp[4] = max(dp[4], dp[3] + prices[i]) return dp[4]",
          "description": "Python实现的空间优化版本，用一维列表存储状态"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n)",
    "space_complexity": "O(n × 5)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int maxProfit(vector<int>& prices) {if (prices.size() == 0) return 0;vector<vector<int>> dp(prices.size(), vector<int>(5, 0));dp[0][1] = -prices[0];dp[0][3] = -prices[0];for (int i = 1; i < prices.size(); i++) {dp[i][0] = dp[i - 1][0];dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);}return dp[prices.size() - 1][4];}};",
      "description": "版本一"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int maxProfit(vector<int>& prices) {if (prices.size() == 0) return 0;vector<int> dp(5, 0);dp[1] = -prices[0];dp[3] = -prices[0];for (int i = 1; i < prices.size(); i++) {dp[1] = max(dp[1], dp[0] - prices[i]);dp[2] = max(dp[2], dp[1] + prices[i]);dp[3] = max(dp[3], dp[2] - prices[i]);dp[4] = max(dp[4], dp[3] + prices[i]);}return dp[4];}};",
      "description": "版本二"
    },
    {
      "language": "java",
      "code": "class Solution {public int maxProfit(int[] prices) {int len = prices.length;if (prices.length == 0) return 0;int[][] dp = new int[len][5];dp[0][1] = -prices[0];dp[0][3] = -prices[0];for (int i = 1; i < len; i++) {dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);}return dp[len - 1][4];}}",
      "description": "版本一"
    },
    {
      "language": "java",
      "code": "class Solution {public int maxProfit(int[] prices) {int[] dp = new int[4];dp[0] = -prices[0];dp[1] = 0;dp[2] = -prices[0];dp[3] = 0;for(int i = 1; i <= prices.length; i++){dp[0] = Math.max(dp[0], -prices[i-1]);dp[1] = Math.max(dp[1], dp[0]+prices[i-1]);dp[2] = Math.max(dp[2], dp[1]-prices[i-1]);dp[3] = Math.max(dp[3], dp[2]+ prices[i-1]);}return dp[3];}}",
      "description": "版本二：空间优化"
    },
    {
      "language": "python",
      "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [[0] * 5 for _ in range(len(prices))] dp[0][1] = -prices[0] dp[0][3] = -prices[0] for i in range(1, len(prices)): dp[i][0] = dp[i-1][0] dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]) dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]) dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]) return dp[-1][4]",
      "description": "版本一"
    },
    {
      "language": "python",
      "code": "class Solution: def maxProfit(self, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [0] * 5 dp[1] = -prices[0] dp[3] = -prices[0] for i in range(1, len(prices)): dp[1] = max(dp[1], dp[0] - prices[i]) dp[2] = max(dp[2], dp[1] + prices[i]) dp[3] = max(dp[3], dp[2] - prices[i]) dp[4] = max(dp[4], dp[3] + prices[i]) return dp[4]",
      "description": "版本二"
    }
  ],
  "common_mistakes": [
    "误认为dp[i][1]表示必须在第i天买入股票，而实际上它反映的是直到第i天为止持有股票的最佳状态。",
    "忽略初始化时某些特殊条件（如第一天就进行第二次购买）的正确设置。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20201228181724295-20230310134201291.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20201228181724295-20230310134201291.png",
      "context": "该图片展示了以[1,2,3,4,5]为例的动态规划数组dp的计算过程，特别标注了最后两次卖出状态下的现金情况，帮助理解如何通过多次买卖操作最大化利润。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20201228181724295-20230310134201291.png",
      "description": "GIF展示了动态规划数组dp在处理股票买卖问题时的状态变化过程。",
      "context": "GIF动画展示了在给定价格序列[1,2,3,4,5]下，通过两次买卖操作后，状态转移表dp数组的构建过程及其最终形态，特别是突出了最后两次卖出状态下现金的变化情况。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\买卖股票的最佳时机III.txt",
  "extracted_at": "2025-07-20T15:57:54.933402",
  "raw_content": "买卖股票的最佳时机III\n力扣题目链接(https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)\n\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例 1:\n\n输入：prices = [3,3,5,0,0,3,1,4]\n\n输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。\n\n示例 2：\n\n输入：prices = [1,2,3,4,5]\n\n输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n\n示例 3：\n\n输入：prices = [7,6,4,3,1]\n\n输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为0。\n\n示例 4：\n\n输入：prices = [1] 输出：0\n\n提示：\n\n1 <= prices.length <= 10^5\n0 <= prices[i] <= 10^5\n。\n\n#思路\n这道题目相对 121.买卖股票的最佳时机 (https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html)和 122.买卖股票的最佳时机II (https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html)难了不少。\n\n关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。\n\n接来下我用动态规划五部曲详细分析一下：\n\n确定dp数组以及下标的含义\n一天一共就有五个状态，\n\n没有操作 （其实我们也可以不设置这个状态）\n第一次持有股票\n第一次不持有股票\n第二次持有股票\n第二次不持有股票\ndp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。\n\n需要注意：dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区。\n\n例如 dp[i][1] ，并不是说 第i天一定买入股票，有可能 第 i-1天 就买入了，那么 dp[i][1] 延续买入股票的这个状态。\n\n确定递推公式\n达到dp[i][1]状态，有两个具体操作：\n\n操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]\n操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]\n那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？\n\n一定是选最大的，所以 dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);\n\n同理dp[i][2]也有两个操作：\n\n操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]\n操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]\n所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])\n\n同理可推出剩下状态部分：\n\ndp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n\ndp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n\ndp数组如何初始化\n第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;\n\n第0天做第一次买入的操作，dp[0][1] = -prices[0];\n\n第0天做第一次卖出的操作，这个初始值应该是多少呢？\n\n此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，所以dp[0][2] = 0;\n\n第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？\n\n第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。\n\n所以第二次买入操作，初始化为：dp[0][3] = -prices[0];\n\n同理第二次卖出初始化dp[0][4] = 0;\n\n确定遍历顺序\n从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。\n\n举例推导dp数组\n以输入[1,2,3,4,5]为例\n\nhttps://file1.kamacoder.com/i/algo/20201228181724295-20230310134201291.png\n\n大家可以看到红色框为最后两次卖出的状态。\n\n现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。如果想不明白的录友也可以这么理解：如果第一次卖出已经是最大值了，那么我们可以在当天立刻买入再立刻卖出。所以dp[4][4]已经包含了dp[4][2]的情况。也就是说第二次卖出手里所剩的钱一定是最多的。\n\n所以最终最大利润是dp[4][4]\n\n以上五部都分析完了，不难写出如下代码：\n\n// 版本一\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if (prices.size() == 0) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));\n        dp[0][1] = -prices[0];\n        dp[0][3] = -prices[0];\n        for (int i = 1; i < prices.size(); i++) {\n            dp[i][0] = dp[i - 1][0];\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\n            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n        }\n        return dp[prices.size() - 1][4];\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(n × 5)\n当然，大家可以看到力扣官方题解里的一种优化空间写法，我这里给出对应的C++版本：\n\n// 版本二\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if (prices.size() == 0) return 0;\n        vector<int> dp(5, 0);\n        dp[1] = -prices[0];\n        dp[3] = -prices[0];\n        for (int i = 1; i < prices.size(); i++) {\n            dp[1] = max(dp[1], dp[0] - prices[i]);\n            dp[2] = max(dp[2], dp[1] + prices[i]);\n            dp[3] = max(dp[3], dp[2] - prices[i]);\n            dp[4] = max(dp[4], dp[3] + prices[i]);\n        }\n        return dp[4];\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(1)\n大家会发现dp[2]利用的是当天的dp[1]。 但结果也是对的。\n\n我来简单解释一下：\n\ndp[1] = max(dp[1], dp[0] - prices[i]); 如果dp[1]取dp[1]，即保持买入股票的状态，那么 dp[2] = max(dp[2], dp[1] + prices[i]);中dp[1] + prices[i] 就是今天卖出。\n\n如果dp[1]取dp[0] - prices[i]，今天买入股票，那么dp[2] = max(dp[2], dp[1] + prices[i]);中的dp[1] + prices[i]相当于是今天再卖出股票，一买一卖收益为0，对所得现金没有影响。相当于今天买入股票又卖出股票，等于没有操作，保持昨天卖出股票的状态了。\n\n这种写法看上去简单，其实思路很绕，不建议大家这么写，这么思考，很容易把自己绕进去！\n\n对于本题，把版本一的写法研究明白，足以！\n\n#拓展\n其实我们可以不设置，‘0. 没有操作’ 这个状态，因为没有操作，手上的现金自然就是0， 正如我们在 121.买卖股票的最佳时机 (https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html)和 122.买卖股票的最佳时机II (https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html)也没有设置这一状态是一样的。\n\n代码如下：\n\n// 版本三 \nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if (prices.size() == 0) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));\n        dp[0][1] = -prices[0];\n        dp[0][3] = -prices[0];\n        for (int i = 1; i < prices.size(); i++) {\n            dp[i][1] = max(dp[i - 1][1], 0 - prices[i]);\n            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\n            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n        }\n        return dp[prices.size() - 1][4];\n    }\n};\n#其他语言版本\n#Java:\n// 版本一\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int len = prices.length;\n        // 边界判断, 题目中 length >= 1, 所以可省去\n        if (prices.length == 0) return 0;\n\n        /*\n         * 定义 5 种状态:\n         * 0: 没有操作, 1: 第一次买入, 2: 第一次卖出, 3: 第二次买入, 4: 第二次卖出\n         */\n        int[][] dp = new int[len][5];\n        dp[0][1] = -prices[0];\n        // 初始化第二次买入的状态是确保 最后结果是最多两次买卖的最大利润\n        dp[0][3] = -prices[0];\n\n        for (int i = 1; i < len; i++) {\n            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);\n            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\n            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n        }\n\n        return dp[len - 1][4];\n    }\n}\n\n// 版本二: 空间优化\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int[] dp = new int[4]; \n        // 存储两次交易的状态就行了\n        // dp[0]代表第一次交易的买入\n        dp[0] = -prices[0];\n        // dp[1]代表第一次交易的卖出\n        dp[1] = 0;\n        // dp[2]代表第二次交易的买入\n        dp[2] = -prices[0];\n        // dp[3]代表第二次交易的卖出\n        dp[3] = 0;\n        for(int i = 1; i <= prices.length; i++){\n            // 要么保持不变，要么没有就买，有了就卖\n            dp[0] = Math.max(dp[0], -prices[i-1]);\n            dp[1] = Math.max(dp[1], dp[0]+prices[i-1]);\n            // 这已经是第二次交易了，所以得加上前一次交易卖出去的收获\n            dp[2] = Math.max(dp[2], dp[1]-prices[i-1]);\n            dp[3] = Math.max(dp[3], dp[2]+ prices[i-1]);\n        }\n        return dp[3];\n    }\n}\n#Python:\n版本一：\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) == 0:\n            return 0\n        dp = [[0] * 5 for _ in range(len(prices))]\n        dp[0][1] = -prices[0]\n        dp[0][3] = -prices[0]\n        for i in range(1, len(prices)):\n            dp[i][0] = dp[i-1][0]\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\n            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])\n            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i])\n            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])\n        return dp[-1][4]\n版本二：\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) == 0:\n            return 0\n        dp = [0] * 5 \n        dp[1] = -prices[0]\n        dp[3] = -prices[0]\n        for i in range(1, len(prices)):\n            dp[1] = max(dp[1], dp[0] - prices[i])\n            dp[2] = max(dp[2], dp[1] + prices[i])\n            dp[3] = max(dp[3], dp[2] - prices[i])\n            dp[4] = max(dp[4], dp[3] + prices[i])\n        return dp[4]"
}