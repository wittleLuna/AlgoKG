{
  "id": "AP_7cb0ae6c",
  "title": "最长回文子序列",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/longest-palindromic-subsequence/",
  "description": "一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划"
  ],
  "data_structure_tags": [
    "二维数组"
  ],
  "technique_tags": [
    "状态转移",
    "边界条件处理"
  ],
  "difficulty": null,
  "solution_approach": "使用动态规划的方法来解决最长回文子序列问题。定义dp[i][j]为字符串s在区间[i, j]内的最长回文子序列长度。通过判断s[i]和s[j]是否相等来更新dp数组，并据此递推求解整个字符串的最长回文子序列长度。",
  "key_insights": [
    {
      "content": "回文子串要求连续，而回文子序列则不要求连续。这种区别决定了两者在算法实现上的不同。"
    },
    {
      "content": "对于单个字符而言，其本身即构成一个长度为1的回文子序列，因此需要特别设置dp[i][i] = 1；其他情况默认设为0。"
    },
    {
      "content": "为了保证每个状态都基于已经计算好的值进行更新，需要从下至上、从左至右遍历。这确保了dp[i+1][j-1], dp[i+1][j], 和dp[i][j-1]都是之前计算过的。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "我们刚刚做过了 动态规划：回文子串 (https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html)，求的是回文子串，而本题要求的是回文子序列， 要搞清楚这两者之间的区别。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int longestPalindromeSubseq(string s) { vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0)); for (int i = 0; i < s.size(); i++) dp[i][i] = 1; for (int i = s.size() - 1; i >= 0; i--) { for (int j = i + 1; j < s.size(); j++) { if (s[i] == s[j]) { dp[i][j] = dp[i + 1][j - 1] + 2; } else { dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); } } } return dp[0][s.size() - 1]; }};",
          "description": "C++实现的最长回文子序列"
        },
        {
          "language": "java",
          "code": "public class Solution { public int longestPalindromeSubseq(String s) { int len = s.length(); int[][] dp = new int[len + 1][len + 1]; for (int i = len - 1; i >= 0; i--) { dp[i][i] = 1; for (int j = i + 1; j < len; j++) { if (s.charAt(i) == s.charAt(j)) { dp[i][j] = dp[i + 1][j - 1] + 2; } else { dp[i][j] = Math.max(dp[i + 1][j], Math.max(dp[i][j], dp[i][j - 1])); } } } return dp[0][len - 1]; }}",
          "description": "Java实现的最长回文子序列"
        },
        {
          "language": "python",
          "code": "class Solution: def longestPalindromeSubseq(self, s: str) -> int: dp = [[0] * len(s) for _ in range(len(s))] for i in range(len(s)): dp[i][i] = 1 for i in range(len(s)-1, -1, -1): for j in range(i+1, len(s)): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][-1]",
          "description": "Python实现的最长回文子序列"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "public class Solution {\n    public int longestPalindromeSubseq(String s) {\n        int len = s.length();\n        int[][] dp = new int[len + 1][len + 1];\n        for (int i = len - 1; i >= 0; i--) { \n            dp[i][i] = 1; \n            for (int j = i + 1; j < len; j++) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = dp[i + 1][j - 1] + 2;\n                } else {\n                    dp[i][j] = Math.max(dp[i + 1][j], Math.max(dp[i][j], dp[i][j - 1]));\n                }\n            }\n        }\n        return dp[0][len - 1];\n    }\n}",
          "description": "Java实现的最长回文子序列算法"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        dp = [[0] * len(s) for _ in range(len(s))]\n        for i in range(len(s)):\n            dp[i][i] = 1\n        for i in range(len(s)-1, -1, -1):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i+1][j-1] + 2\n                else:\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n        return dp[0][-1]",
          "description": "Python实现的最长回文子序列算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "public class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int longestPalindromeSubseq(string s) {vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));for (int i = 0; i < s.size(); i++) dp[i][i] = 1;for (int i = s.size() - 1; i >= 0; i--) {for (int j = i + 1; j < s.size(); j++) {if (s[i] == s[j]) {dp[i][j] = dp[i + 1][j - 1] + 2;} else {dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);}}}return dp[0][s.size() - 1];}};",
          "description": "C++实现的最长回文子序列"
        },
        {
          "language": "java",
          "code": "public class Solution {public int longestPalindromeSubseq(String s) {int len = s.length();int[][] dp = new int[len + 1][len + 1];for (int i = len - 1; i >= 0; i--) {dp[i][i] = 1;for (int j = i + 1; j < len; j++) {if (s.charAt(i) == s.charAt(j)) {dp[i][j] = dp[i + 1][j - 1] + 2;} else {dp[i][j] = Math.max(dp[i + 1][j], Math.max(dp[i][j], dp[i][j - 1]));}}}return dp[0][len - 1];}}",
          "description": "Java实现的最长回文子序列"
        },
        {
          "language": "python",
          "code": "class Solution: def longestPalindromeSubseq(self, s: str) -> int: dp = [[0] * len(s) for _ in range(len(s))] for i in range(len(s)): dp[i][i] = 1 for i in range(len(s)-1, -1, -1): for j in range(i+1, len(s)): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][-1]",
          "description": "Python实现的最长回文子序列"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "class Solution:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int longestPalindromeSubseq(string s) {vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));for (int i = 0; i < s.size(); i++) dp[i][i] = 1;for (int i = s.size() - 1; i >= 0; i--) {for (int j = i + 1; j < s.size(); j++) {if (s[i] == s[j]) {dp[i][j] = dp[i + 1][j - 1] + 2;} else {dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);}}}return dp[0][s.size() - 1];}};",
          "description": "C++实现的最长回文子序列解决方案"
        },
        {
          "language": "java",
          "code": "public class Solution {public int longestPalindromeSubseq(String s) {int len = s.length();int[][] dp = new int[len + 1][len + 1];for (int i = len - 1; i >= 0; i--) {dp[i][i] = 1;for (int j = i + 1; j < len; j++) {if (s.charAt(i) == s.charAt(j)) {dp[i][j] = dp[i + 1][j - 1] + 2;} else {dp[i][j] = Math.max(dp[i + 1][j], Math.max(dp[i][j], dp[i][j - 1]));}}}return dp[0][len - 1];}}",
          "description": "Java实现的最长回文子序列解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def longestPalindromeSubseq(self, s: str) -> int: dp = [[0] * len(s) for _ in range(len(s))] for i in range(len(s)): dp[i][i] = 1 for i in range(len(s)-1, -1, -1): for j in range(i+1, len(s)): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][-1]",
          "description": "Python实现的最长回文子序列解决方案"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n^2)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int longestPalindromeSubseq(string s) { vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0)); for (int i = 0; i < s.size(); i++) dp[i][i] = 1; for (int i = s.size() - 1; i >= 0; i--) { for (int j = i + 1; j < s.size(); j++) { if (s[i] == s[j]) { dp[i][j] = dp[i + 1][j - 1] + 2; } else { dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); } } } return dp[0][s.size() - 1]; }};",
      "description": "C++实现的最长回文子序列问题解决方案"
    },
    {
      "language": "java",
      "code": "public class Solution { public int longestPalindromeSubseq(String s) { int len = s.length(); int[][] dp = new int[len + 1][len + 1]; for (int i = len - 1; i >= 0; i--) { dp[i][i] = 1; for (int j = i + 1; j < len; j++) { if (s.charAt(i) == s.charAt(j)) { dp[i][j] = dp[i + 1][j - 1] + 2; } else { dp[i][j] = Math.max(dp[i + 1][j], Math.max(dp[i][j], dp[i][j - 1])); } } } return dp[0][len - 1]; }}",
      "description": "Java实现的最长回文子序列问题解决方案"
    },
    {
      "language": "python",
      "code": "class Solution: def longestPalindromeSubseq(self, s: str) -> int: dp = [[0] * len(s) for _ in range(len(s))] for i in range(len(s)): dp[i][i] = 1 for i in range(len(s)-1, -1, -1): for j in range(i+1, len(s)): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][-1]",
      "description": "Python实现的最长回文子序列问题解决方案"
    }
  ],
  "common_mistakes": [
    "未正确初始化dp数组导致结果出错。",
    "遍历顺序错误，使得某些状态依赖尚未计算的状态。",
    "混淆回文子串与回文子序列的概念，误用求解回文子串的方法来解决问题。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210127151350563.jpg",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20210127151350563.jpg",
      "context": "该图片展示了通过动态规划方法计算字符串中特定区间内最长回文子序列长度的过程，辅助理解dp数组的构建与递推公式的应用。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210127151420476.jpg",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20210127151420476.jpg",
      "context": "该图片展示了通过动态规划方法计算字符串中最长回文子序列的过程，与文本中提到的dp数组更新规则相对应。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20230102172155.png",
      "description": "这张图片展示了动态规划（DP）中状态转移的三种路径：从 `dp[i][j-1]`、`dp[i+1][j-1]` 和 `dp[i+1][j]` 到 `dp[i][j]` 的转移。",
      "context": "该图展示了dp数组元素之间的依赖关系，帮助理解为何需要从下到上遍历i来确保计算顺序正确。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210127151521432.jpg",
      "description": "这张图片展示了使用动态规划（DP）算法解决最长回文子序列问题的过程，具体输入为字符串 \"cbbd\"，并通过二维数组 `dp[i][j]` 来记录子问题的解。",
      "context": "该图片展示了字符串\"cbbd\"作为输入时，动态规划数组dp的状态变化过程，其中红色框标记了最终结果。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210127151350563.jpg",
      "description": "GIF展示了动态规划解决回文子序列问题时，dp数组随字符串字符比较而更新的过程。",
      "context": "GIF动画展示了如何根据s[i]与s[j]是否相等来更新dp数组的过程，帮助理解最长回文子序列长度的计算方法。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210127151420476.jpg",
      "description": "GIF展示了动态规划算法中dp数组更新的过程，特别是在处理字符串回文子序列问题时，如何依据字符是否相等来决定dp值的更新方式。",
      "context": "该GIF动画展示了如何通过比较加入s[i]或s[j]后形成的回文子序列长度来更新dp数组的过程，形象地解释了当s[i]不等于s[j]时动态规划状态转移方程的执行逻辑。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20230102172155.png",
      "description": "GIF展示了动态规划算法中二维数组dp的填充过程，特别强调了从下到上、从左到右的遍历顺序来计算字符串中最长回文子序列长度。",
      "context": "GIF动画展示了在给定字符串s的情况下，如何通过从下到上、从左到右的顺序遍历二维数组dp来填充其值，以解决相关问题。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210127151521432.jpg",
      "description": "GIF展示了通过动态规划方法计算字符串\"cbbd\"中最长回文子序列时dp数组的变化过程。",
      "context": "GIF动画展示了使用动态规划方法计算字符串\"cbbd\"中最长回文子序列时，dp数组的状态变化过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\最长回文子序列.txt",
  "extracted_at": "2025-07-20T21:03:19.607135",
  "raw_content": "最长回文子序列\n力扣题目链接(https://leetcode.cn/problems/longest-palindromic-subsequence/)\n\n给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。\n\n示例 1: 输入: \"bbbab\" 输出: 4 一个可能的最长回文子序列为 \"bbbb\"。\n\n示例 2: 输入:\"cbbd\" 输出: 2 一个可能的最长回文子序列为 \"bb\"。\n\n提示：\n\n1 <= s.length <= 1000\ns 只包含小写英文字母\n\n#思路\n我们刚刚做过了 动态规划：回文子串 (https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html)，求的是回文子串，而本题要求的是回文子序列， 要搞清楚这两者之间的区别。\n\n回文子串是要连续的，回文子序列可不是连续的！ 回文子串，回文子序列都是动态规划经典题目。\n\n回文子串，可以做这两题：\n\n647.回文子串\n5.最长回文子串\n思路其实是差不多的，但本题要比求回文子串简单一点，因为情况少了一点。\n\n动规五部曲分析如下：\n\n确定dp数组（dp table）以及下标的含义\ndp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。\n\n确定递推公式\n在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。\n\n如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2;\n\nhttps://file1.kamacoder.com/i/algo/20210127151350563.jpg\n\n（如果这里看不懂，回忆一下dp[i][j]的定义）\n\n如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。\n\n加入s[j]的回文子序列长度为dp[i + 1][j]。\n\n加入s[i]的回文子序列长度为dp[i][j - 1]。\n\n那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n\nhttps://file1.kamacoder.com/i/algo/20210127151420476.jpg\n\n代码如下：\n\nif (s[i] == s[j]) {\n    dp[i][j] = dp[i + 1][j - 1] + 2;\n} else {\n    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n}\ndp数组如何初始化\n首先要考虑当i 和j 相同的情况，从递推公式：dp[i][j] = dp[i + 1][j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。\n\n所以需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1。\n\n其他情况dp[i][j]初始为0就行，这样递推公式：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); 中dp[i][j]才不会被初始值覆盖。\n\nvector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));\nfor (int i = 0; i < s.size(); i++) dp[i][i] = 1;\n确定遍历顺序\n从递归公式中，可以看出，dp[i][j] 依赖于 dp[i + 1][j - 1] ，dp[i + 1][j] 和 dp[i][j - 1]，如图：\n\nhttps://file1.kamacoder.com/i/algo/20230102172155.png\n\n所以遍历i的时候一定要从下到上遍历，这样才能保证下一行的数据是经过计算的。\n\nj的话，可以正常从左向右遍历。\n\n代码如下：\n\nfor (int i = s.size() - 1; i >= 0; i--) {\n    for (int j = i + 1; j < s.size(); j++) {\n        if (s[i] == s[j]) {\n            dp[i][j] = dp[i + 1][j - 1] + 2;\n        } else {\n            dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n        }\n    }\n}\n举例推导dp数组\n输入s:\"cbbd\" 为例，dp数组状态如图：\n\nhttps://file1.kamacoder.com/i/algo/20210127151521432.jpg\n\n红色框即：dp[0][s.size() - 1]; 为最终结果。\n\n以上分析完毕，C++代码如下：\n\nclass Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));\n        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;\n        for (int i = s.size() - 1; i >= 0; i--) {\n            for (int j = i + 1; j < s.size(); j++) {\n                if (s[i] == s[j]) {\n                    dp[i][j] = dp[i + 1][j - 1] + 2;\n                } else {\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[0][s.size() - 1];\n    }\n};\n时间复杂度: O(n^2)\n空间复杂度: O(n^2)\n#其他语言版本\n#Java：\npublic class Solution {\n    public int longestPalindromeSubseq(String s) {\n        int len = s.length();\n        int[][] dp = new int[len + 1][len + 1];\n        for (int i = len - 1; i >= 0; i--) { // 从后往前遍历 保证情况不漏\n            dp[i][i] = 1; // 初始化\n            for (int j = i + 1; j < len; j++) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = dp[i + 1][j - 1] + 2;\n                } else {\n                    dp[i][j] = Math.max(dp[i + 1][j], Math.max(dp[i][j], dp[i][j - 1]));\n                }\n            }\n        }\n        return dp[0][len - 1];\n    }\n}\n#Python：\nclass Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        dp = [[0] * len(s) for _ in range(len(s))]\n        for i in range(len(s)):\n            dp[i][i] = 1\n        for i in range(len(s)-1, -1, -1):\n            for j in range(i+1, len(s)):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i+1][j-1] + 2\n                else:\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n        return dp[0][-1]"
}