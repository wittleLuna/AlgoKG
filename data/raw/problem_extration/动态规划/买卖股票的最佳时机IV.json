{
  "id": "AP_dad9372f",
  "title": "买卖股票的最佳时机IV",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/",
  "description": "一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "状态机",
    "优化空间复杂度"
  ],
  "difficulty": null,
  "solution_approach": "通过动态规划来解决这个问题。定义一个二维dp数组，其中dp[i][j]表示第i天处于状态j时的最大现金数。根据题目要求交易次数k确定状态j的范围为2 * k + 1，涵盖了从不操作到完成k次买卖的所有可能状态。",
  "key_insights": [
    {
      "content": "对于买入和卖出状态的切换，通过前一天的状态值加上或减去当天的价格来更新当前状态值。例如，要达到持有股票的状态，可以选择继续持有昨天的股票或者今天新买；而要达到卖出股票的状态，则可以是今天卖出昨天持有的股票或是继续保持昨天卖出后的状态。"
    },
    {
      "content": "正确初始化dp数组对于后续计算至关重要。特别是对于第一天的各种买卖状态，需要合理设置其初始值以反映实际可能的操作情况。比如首次买入的成本应该是第一天的股价负值，而首次卖出则应设为0（假设当天买入当天卖出）。"
    },
    {
      "content": "通过使用二维数组模拟三维状态变化，可以简化代码并提高可读性，同时保持时间复杂度在O(n*k)级别。"
    },
    {
      "content": "当k较大时，考虑使用一维数组进一步减少空间复杂度，但需要注意保存前一日的状态信息以免覆盖。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "这道题目可以说是动态规划：123.买卖股票的最佳时机III (https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html)的进阶版，这里要求至多有k次交易。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(int k, vector<int>& prices) {if (prices.size() == 0) return 0;vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));for (int j = 1; j < 2 * k; j += 2) {dp[0][j] = -prices[0];}for (int i = 1;i < prices.size(); i++) {for (int j = 0; j < 2 * k - 1; j += 2) {dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);}}return dp[prices.size() - 1][2 * k];}};",
          "description": "C++版本的动态规划解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int k, int[] prices) {if (prices.length == 0) return 0;int len = prices.length;int[][] dp = new int[len][k*2 + 1];for (int i = 1; i < k*2; i += 2) {dp[0][i] = -prices[0];}for (int i = 1; i < len; i++) {for (int j = 0; j < k*2 - 1; j += 2) {dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);}}return dp[len - 1][k*2];}}",
          "description": "Java版本的二维DP数组解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int k, int[] prices) {if(prices.length == 0 || k == 0) return 0;int dp[] = new int [k * 2 + 1];for(int i = 1; i < 2 * k + 1; i += 2){dp[i] = -prices[0];}for(int i = 1; i < prices.length; i++){for(int j = 1; j < 2 * k + 1; j++){if(j % 2 == 1) dp[j] = Math.max(dp[j], dp[j - 1] - prices[i]);else dp[j] = Math.max(dp[j], dp[j - 1] + prices[i]);}}return dp[2 * k];}}",
          "description": "Java版本的一维DP数组解法"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, k: int, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [[0] * (2*k+1) for _ in range(len(prices))] for j in range(1, 2*k, 2): dp[0][j] = -prices[0] for i in range(1, len(prices)): for j in range(0, 2*k-1, 2): dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j] - prices[i]) dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1] + prices[i]) return dp[-1][2*k]",
          "description": "Python版本的二维DP数组解法"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, k: int, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [0] * (2*k + 1) for i in range(1,2*k,2): dp[i] = -prices[0] for i in range(1,len(prices)): for j in range(1,2*k + 1): if j % 2: dp[j] = max(dp[j],dp[j-1]-prices[i]) else: dp[j] = max(dp[j],dp[j-1]+prices[i]) return dp[2*k]",
          "description": "Python版本的一维DP数组解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java:",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution { public int maxProfit(int k, int[] prices) { if (prices.length == 0) return 0; int len = prices.length; int[][][] dp = new int[len][k + 1][2]; for (int i = 0; i <= k; i++) { dp[0][i][1] = -prices[0]; } for (int i = 1; i < len; i++) { for (int j = 1; j <= k; j++) { dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]); dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]); } } return dp[len - 1][k][0]; } }",
          "description": "使用三维数组实现买卖股票的最佳时机IV的解决方案"
        },
        {
          "language": "java",
          "code": "class Solution { public int maxProfit(int k, int[] prices) { if (prices.length == 0) return 0; int len = prices.length; int[][] dp = new int[len][k*2 + 1]; for (int i = 1; i < k*2; i += 2) { dp[0][i] = -prices[0]; } for (int i = 1; i < len; i++) { for (int j = 0; j < k*2 - 1; j += 2) { dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]); dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]); } } return dp[len - 1][k*2]; } }",
          "description": "使用二维数组实现买卖股票的最佳时机IV的解决方案"
        },
        {
          "language": "java",
          "code": "class Solution { public int maxProfit(int k, int[] prices) { if(prices.length == 0){ return 0; } if(k == 0){ return 0; } int[] dp = new int[2 * k]; for(int i = 0; i < dp.length / 2; i++){ dp[i * 2] = -prices[0]; } for(int i = 1; i <= prices.length; i++){ dp[0] = Math.max(dp[0], -prices[i - 1]); dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]); for(int j = 2; j < dp.length; j += 2){ dp[j] = Math.max(dp[j], dp[j - 1] - prices[i-1]); dp[j + 1] = Math.max(dp[j + 1], dp[j] + prices[i - 1]); } } return dp[dp.length - 1]; } }",
          "description": "使用一维数组实现买卖股票的最佳时机IV的简化版本"
        },
        {
          "language": "java",
          "code": "class Solution { public int maxProfit(int k, int[] prices) { if(prices.length == 0 || k == 0) return 0; int dp[] = new int [k * 2 + 1]; for(int i = 1; i < 2 * k + 1; i += 2){ dp[i] = -prices[0]; } for(int i = 1; i < prices.length; i++){ for(int j = 1; j < 2 * k + 1; j++){ if(j % 2 == 1) dp[j] = Math.max(dp[j], dp[j - 1] - prices[i]); else dp[j] = Math.max(dp[j], dp[j - 1] + prices[i]); } } return dp[2 * k]; } }",
          "description": "与卡哥逻辑一致的一维数组Java解法"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, k: int, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [[0] * (2*k+1) for _ in range(len(prices))] for j in range(1, 2*k, 2): dp[0][j] = -prices[0] for i in range(1, len(prices)): for j in range(0, 2*k-1, 2): dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j] - prices[i]) dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1] + prices[i]) return dp[-1][2*k]",
          "description": "Python版本，使用二维数组实现买卖股票的最佳时机IV"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, k: int, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [0] * (2*k + 1) for i in range(1,2*k,2): dp[i] = -prices[0] for i in range(1,len(prices)): for j in range(1,2*k + 1): if j % 2: dp[j] = max(dp[j],dp[j-1]-prices[i]) else: dp[j] = max(dp[j],dp[j-1]+prices[i]) return dp[2*k]",
          "description": "Python版本，使用一维数组实现买卖股票的最佳时机IV"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, k: int, prices: List[int]) -> int: dp = [0] * k * 2 for i in range(k): dp[i * 2] = -prices[0] for price in prices[1:]: dc = dp.copy() for i in range(2 * k): if i % 2 == 1: dp[i] = max(dc[i], dc[i - 1] + price) else: pre = 0 if i == 0 else dc[i - 1] dp[i] = max(dc[i], pre - price) return dp[-1]",
          "description": "Python版本，易理解的一维数组实现买卖股票的最佳时机IV"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java:",
      "text": "// 版本一: 三维 dp数组",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(int k, vector<int>& prices) {if (prices.size() == 0) return 0;vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));for (int j = 1; j < 2 * k; j += 2) {dp[0][j] = -prices[0];}for (int i = 1;i < prices.size(); i++) {for (int j = 0; j < 2 * k - 1; j += 2) {dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);}}return dp[prices.size() - 1][2 * k];}};",
          "description": "C++ 版本"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int k, int[] prices) {if (prices.length == 0) return 0;int len = prices.length;int[][] dp = new int[len][k*2 + 1];for (int i = 1; i < k*2; i += 2) {dp[0][i] = -prices[0];}for (int i = 1; i < len; i++) {for (int j = 0; j < k*2 - 1; j += 2) {dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);}}return dp[len - 1][k*2];}}",
          "description": "Java 版本"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int k, int[] prices) {if(prices.length == 0){return 0;}if(k == 0){return 0;}int[] dp = new int[2 * k];for(int i = 0; i < dp.length / 2; i++){dp[i * 2] = -prices[0];}for(int i = 1; i <= prices.length; i++){dp[0] = Math.max(dp[0], -prices[i - 1]);dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]);for(int j = 2; j < dp.length; j += 2){dp[j] = Math.max(dp[j], dp[j - 1] - prices[i-1]);dp[j + 1] = Math.max(dp[j + 1], dp[j] + prices[i - 1]);}}return dp[dp.length - 1];}}",
          "description": "Java 一维数组版本"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, k: int, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [[0] * (2*k+1) for _ in range(len(prices))] for j in range(1, 2*k, 2): dp[0][j] = -prices[0] for i in range(1, len(prices)): for j in range(0, 2*k-1, 2): dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j] - prices[i]) dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1] + prices[i]) return dp[-1][2*k]",
          "description": "Python 版本"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, k: int, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [0] * (2*k + 1) for i in range(1,2*k,2): dp[i] = -prices[0] for i in range(1,len(prices)): for j in range(1,2*k + 1): if j % 2: dp[j] = max(dp[j],dp[j-1]-prices[i]) else: dp[j] = max(dp[j],dp[j-1]+prices[i]) return dp[2*k]",
          "description": "Python 一维数组版本"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, k: int, prices: List[int]) -> int: dp = [0] * k * 2 for i in range(k): dp[i * 2] = -prices[0] for price in prices[1:]: dc = dp.copy() for i in range(2 * k): if i % 2 == 1: dp[i] = max(dc[i], dc[i - 1] + price) else: pre = 0 if i == 0 else dc[i - 1] dp[i] = max(dc[i], pre - price) return dp[-1]",
          "description": "Python 易理解的一维数组版本"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python:",
      "text": "版本一",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxProfit(int k, vector<int>& prices) {if (prices.size() == 0) return 0;vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));for (int j = 1; j < 2 * k; j += 2) {dp[0][j] = -prices[0];}for (int i = 1;i < prices.size(); i++) {for (int j = 0; j < 2 * k - 1; j += 2) {dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);}}return dp[prices.size() - 1][2 * k];}};",
          "description": "C++版本的股票买卖问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int k, int[] prices) {if (prices.length == 0) return 0;int len = prices.length;int[][] dp = new int[len][k*2 + 1];for (int i = 1; i < k*2; i += 2) {dp[0][i] = -prices[0];}for (int i = 1; i < len; i++) {for (int j = 0; j < k*2 - 1; j += 2) {dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);}}return dp[len - 1][k*2];}}",
          "description": "Java二维数组版本的股票买卖问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int maxProfit(int k, int[] prices) {if(prices.length == 0 || k == 0) return 0;int dp[] = new int [k * 2 + 1];for(int i = 1; i < 2 * k + 1; i += 2){dp[i] = -prices[0];}for(int i = 1; i < prices.length; i++){for(int j = 1; j < 2 * k + 1; j++){if(j % 2 == 1)dp[j] = Math.max(dp[j], dp[j - 1] - prices[i]);else dp[j] = Math.max(dp[j], dp[j - 1] + prices[i]);}}return dp[2 * k];}}",
          "description": "Java一维数组版本的股票买卖问题"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, k: int, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [[0] * (2*k+1) for _ in range(len(prices))] for j in range(1, 2*k, 2): dp[0][j] = -prices[0] for i in range(1, len(prices)): for j in range(0, 2*k-1, 2): dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j] - prices[i]) dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1] + prices[i]) return dp[-1][2*k]",
          "description": "Python二维数组版本的股票买卖问题"
        },
        {
          "language": "python",
          "code": "class Solution: def maxProfit(self, k: int, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [0] * (2*k + 1) for i in range(1,2*k,2): dp[i] = -prices[0] for i in range(1,len(prices)): for j in range(1,2*k + 1): if j % 2: dp[j] = max(dp[j],dp[j-1]-prices[i]) else: dp[j] = max(dp[j],dp[j-1]+prices[i]) return dp[2*k]",
          "description": "Python一维数组版本的股票买卖问题"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n * k)",
    "space_complexity": "O(n * k)",
    "explanation": "其中 n 为 prices 的长度"
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int maxProfit(int k, vector<int>& prices) {if (prices.size() == 0) return 0;vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));for (int j = 1; j < 2 * k; j += 2) {dp[0][j] = -prices[0];}for (int i = 1;i < prices.size(); i++) {for (int j = 0; j < 2 * k - 1; j += 2) {dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);}}return dp[prices.size() - 1][2 * k];}};",
      "description": "C++实现的买卖股票的最佳时机IV"
    },
    {
      "language": "java",
      "code": "class Solution {public int maxProfit(int k, int[] prices) {if (prices.length == 0) return 0;int len = prices.length;int[][] dp = new int[len][k*2 + 1];for (int i = 1; i < k*2; i += 2) {dp[0][i] = -prices[0];}for (int i = 1; i < len; i++) {for (int j = 0; j < k*2 - 1; j += 2) {dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);}}return dp[len - 1][k*2];}}",
      "description": "Java实现的二维dp数组版本的买卖股票的最佳时机IV"
    },
    {
      "language": "java",
      "code": "class Solution {public int maxProfit(int k, int[] prices) {if(prices.length == 0){return 0;}if(k == 0){return 0;}int[] dp = new int[2 * k];for(int i = 0; i < dp.length / 2; i++){dp[i * 2] = -prices[0];}for(int i = 1; i <= prices.length; i++){dp[0] = Math.max(dp[0], -prices[i - 1]);dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]);for(int j = 2; j < dp.length; j += 2){dp[j] = Math.max(dp[j], dp[j - 1] - prices[i-1]);dp[j + 1] = Math.max(dp[j + 1], dp[j] + prices[i - 1]);}}return dp[dp.length - 1];}}",
      "description": "Java实现的一维dp数组版本的买卖股票的最佳时机IV"
    },
    {
      "language": "python",
      "code": "class Solution: def maxProfit(self, k: int, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [[0] * (2*k+1) for _ in range(len(prices))] for j in range(1, 2*k, 2): dp[0][j] = -prices[0] for i in range(1, len(prices)): for j in range(0, 2*k-1, 2): dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j] - prices[i]) dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1] + prices[i]) return dp[-1][2*k]",
      "description": "Python实现的二维dp数组版本的买卖股票的最佳时机IV"
    },
    {
      "language": "python",
      "code": "class Solution: def maxProfit(self, k: int, prices: List[int]) -> int: if len(prices) == 0: return 0 dp = [0] * (2*k + 1) for i in range(1,2*k,2): dp[i] = -prices[0] for i in range(1,len(prices)): for j in range(1,2*k + 1): if j % 2: dp[j] = max(dp[j],dp[j-1]-prices[i]) else: dp[j] = max(dp[j],dp[j-1]+prices[i]) return dp[2*k]",
      "description": "Python实现的一维dp数组版本的买卖股票的最佳时机IV"
    }
  ],
  "common_mistakes": [
    "误解dp[i][j]的含义，以为它代表了必须在第i天进行特定操作的结果，而不是指截至第i天的最佳累积利润。",
    "忽视了对边界条件如k=0或价格列表为空的情况处理，导致程序可能出现逻辑错误。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20201229100358221.png",
      "description": "这张图片展示了一个动态规划问题的解法，通过二维数组记录在不同状态下（不操作、买入、卖出）的最大收益，最终得到最优解为4。",
      "context": "图片展示了以[1,2,3,4,5]为价格数组、k=2时的dp数组推导过程，帮助理解如何通过动态规划计算最大利润。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\买卖股票的最佳时机IV.txt",
  "extracted_at": "2025-07-20T16:06:34.098808",
  "raw_content": "买卖股票的最佳时机IV\n力扣题目链接(https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)\n\n给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例 1：\n\n输入：k = 2, prices = [2,4,1]\n\n输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2。\n\n示例 2：\n\n输入：k = 2, prices = [3,2,6,5,0,3]\n\n输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n\n提示：\n\n0 <= k <= 100\n0 <= prices.length <= 1000\n0 <= prices[i] <= 1000\n\n\n#思路\n这道题目可以说是动态规划：123.买卖股票的最佳时机III (https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html)的进阶版，这里要求至多有k次交易。\n\n动规五部曲，分析如下：\n\n确定dp数组以及下标的含义\n在动态规划：123.买卖股票的最佳时机III (https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html)中，我是定义了一个二维dp数组，本题其实依然可以用一个二维dp数组。\n\n使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]\n\nj的状态表示为：\n\n0 表示不操作\n1 第一次买入\n2 第一次卖出\n3 第二次买入\n4 第二次卖出\n.....\n大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入。\n\n题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。\n\n所以二维dp数组的C++定义为：\n\nvector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));\n确定递推公式\n还要强调一下：dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区。\n\n达到dp[i][1]状态，有两个具体操作：\n\n操作一：第i天买入股票了，那么dp[i][1] = dp[i - 1][0] - prices[i]\n操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]\n选最大的，所以 dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);\n\n同理dp[i][2]也有两个操作：\n\n操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]\n操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]\n所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])\n\n同理可以类比剩下的状态，代码如下：\n\nfor (int j = 0; j < 2 * k - 1; j += 2) {\n    dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);\n    dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);\n}\n本题和动态规划：123.买卖股票的最佳时机III (https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html)最大的区别就是这里要类比j为奇数是买，偶数是卖的状态。\n\ndp数组如何初始化\n第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;\n\n第0天做第一次买入的操作，dp[0][1] = -prices[0];\n\n第0天做第一次卖出的操作，这个初始值应该是多少呢？\n\n此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，所以dp[0][2] = 0;\n\n第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？\n\n第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。\n\n所以第二次买入操作，初始化为：dp[0][3] = -prices[0];\n\n第二次卖出初始化dp[0][4] = 0;\n\n所以同理可以推出dp[0][j]当j为奇数的时候都初始化为 -prices[0]\n\n代码如下：\n\nfor (int j = 1; j < 2 * k; j += 2) {\n    dp[0][j] = -prices[0];\n}\n在初始化的地方同样要类比j为偶数是卖、奇数是买的状态。\n\n确定遍历顺序\n从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。\n\n举例推导dp数组\n以输入[1,2,3,4,5]，k=2为例。\n\nhttps://file1.kamacoder.com/i/algo/20201229100358221.png\n\n最后一次卖出，一定是利润最大的，dp[prices.size() - 1][2 * k]即红色部分就是最后求解。\n\n以上分析完毕，C++代码如下：\n\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n\n        if (prices.size() == 0) return 0;\n        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));\n        for (int j = 1; j < 2 * k; j += 2) {\n            dp[0][j] = -prices[0];\n        }\n        for (int i = 1;i < prices.size(); i++) {\n            for (int j = 0; j < 2 * k - 1; j += 2) {\n                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);\n                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);\n            }\n        }\n        return dp[prices.size() - 1][2 * k];\n    }\n};\n时间复杂度: O(n * k)，其中 n 为 prices 的长度\n空间复杂度: O(n * k)\n当然有的解法是定义一个三维数组dp[i][j][k]，第i天，第j次买卖，k表示买还是卖的状态，从定义上来讲是比较直观。\n\n但感觉三维数组操作起来有些麻烦，我是直接用二维数组来模拟三维数组的情况，代码看起来也清爽一些。\n\n#其他语言版本\n#Java:\n// 版本一: 三维 dp数组\nclass Solution {\n    public int maxProfit(int k, int[] prices) {\n        if (prices.length == 0) return 0;\n\n        // [天数][交易次数][是否持有股票]\n        int len = prices.length;\n        int[][][] dp = new int[len][k + 1][2];\n        \n        // dp数组初始化\n        // 初始化所有的交易次数是为确保 最后结果是最多 k 次买卖的最大利润\n        for (int i = 0; i <= k; i++) {\n            dp[0][i][1] = -prices[0];\n        }\n\n        for (int i = 1; i < len; i++) {\n            for (int j = 1; j <= k; j++) {\n                // dp方程, 0表示不持有/卖出, 1表示持有/买入\n                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);\n                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);\n            }\n        }\n        return dp[len - 1][k][0];\n    }\n}\n\n// 版本二: 二维 dp数组\nclass Solution {\n    public int maxProfit(int k, int[] prices) {\n        if (prices.length == 0) return 0;\n\n        // [天数][股票状态]\n        // 股票状态: 奇数表示第 k 次交易持有/买入, 偶数表示第 k 次交易不持有/卖出, 0 表示没有操作\n        int len = prices.length;\n        int[][] dp = new int[len][k*2 + 1];\n        \n        // dp数组的初始化, 与版本一同理\n        for (int i = 1; i < k*2; i += 2) {\n            dp[0][i] = -prices[0];\n        }\n\n        for (int i = 1; i < len; i++) {\n            for (int j = 0; j < k*2 - 1; j += 2) {\n                dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);\n                dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);\n            }\n        }\n        return dp[len - 1][k*2];\n    }\n}\n\n//版本三：一维 dp数组 (下面有和卡哥邏輯一致的一維數組JAVA解法)\nclass Solution {\n    public int maxProfit(int k, int[] prices) {\n        if(prices.length == 0){\n            return 0;\n        }\n        if(k == 0){\n            return 0;\n        }\n        // 其实就是123题的扩展，123题只用记录2次交易的状态\n        // 这里记录k次交易的状态就行了\n        // 每次交易都有买入，卖出两个状态，所以要乘 2\n        int[] dp = new int[2 * k];\n        // 按123题解题格式那样，做一个初始化\n        for(int i = 0; i < dp.length / 2; i++){\n            dp[i * 2] = -prices[0];\n        }\n        for(int i = 1; i <= prices.length; i++){\n            dp[0] = Math.max(dp[0], -prices[i - 1]);\n            dp[1] = Math.max(dp[1], dp[0] + prices[i - 1]);\n            // 还是与123题一样，与123题对照来看\n            // 就很容易啦\n            for(int j = 2; j < dp.length; j += 2){\n                dp[j] = Math.max(dp[j], dp[j - 1] - prices[i-1]);\n                dp[j + 1] = Math.max(dp[j + 1], dp[j] + prices[i - 1]);\n            }\n        }\n        // 返回最后一次交易卖出状态的结果就行了\n        return dp[dp.length - 1];\n    }\n}\nclass Solution {\n    public int maxProfit(int k, int[] prices) {\n\n        //edge cases\n        if(prices.length == 0 || k == 0)\n            return 0;\n\n        \n        int dp[] = new int [k * 2 + 1];\n\n        //和卡哥邏輯一致，奇數天購入股票，故初始化只初始化奇數天。\n        for(int i = 1; i < 2 * k + 1; i += 2){\n            dp[i] = -prices[0];\n        }\n\n        for(int i = 1; i < prices.length; i++){ //i 從 1 開始，因爲第 i = 0 天已經透過初始化完成了。\n            for(int j = 1; j < 2 * k + 1; j++){ //j 從 1 開始，因爲第 j = 0 天已經透過初始化完成了。\n                //奇數天購買\n                if(j % 2 == 1)\n                    dp[j] = Math.max(dp[j], dp[j - 1] - prices[i]);\n                //偶數天賣出\n                else\n                    dp[j] = Math.max(dp[j], dp[j - 1] + prices[i]);\n            }\n\t    //打印DP數組\n            //for(int x : dp)\n            //    System.out.print(x +\", \");\n            //System.out.println();\n        }\n        //return 第2 * k次賣出的獲利。\n        return dp[2 * k];\n    }\n}\n#Python:\n版本一\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        if len(prices) == 0:\n            return 0\n        dp = [[0] * (2*k+1) for _ in range(len(prices))]\n        for j in range(1, 2*k, 2):\n            dp[0][j] = -prices[0]\n        for i in range(1, len(prices)):\n            for j in range(0, 2*k-1, 2):\n                dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j] - prices[i])\n                dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1] + prices[i])\n        return dp[-1][2*k]\n版本二\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        if len(prices) == 0: return 0\n        dp = [0] * (2*k + 1)\n        for i in range(1,2*k,2):\n            dp[i] = -prices[0]\n        for i in range(1,len(prices)):\n            for j in range(1,2*k + 1):\n                if j % 2:\n                    dp[j] = max(dp[j],dp[j-1]-prices[i])\n                else:\n                    dp[j] = max(dp[j],dp[j-1]+prices[i])\n        return dp[2*k]\n版本三: 一维 dp 数组(易理解版本)\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        dp = [0] * k * 2\n        for i in range(k):\n            dp[i * 2] = -prices[0]\n\n        for price in prices[1:]:\n            dc = dp.copy() # 这句话是关键，把前一天的 dp 状态保存下来，防止被覆盖掉，后面只用它，不用 dp，逻辑简单易懂\n\n            for i in range(2 * k):\n                if i % 2 == 1:\n                    dp[i] = max(dc[i], dc[i - 1] + price)\n                else:\n                    pre = 0 if i == 0 else dc[i - 1]\n                    dp[i] = max(dc[i], pre - price)\n            \n        return dp[-1]"
}