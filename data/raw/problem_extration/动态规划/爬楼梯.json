{
  "id": "AP_c34e4d83",
  "title": "爬楼梯",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/climbing-stairs/",
  "description": "n 是一个正整数。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划",
    "斐波那契"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "递归关系",
    "空间优化"
  ],
  "difficulty": null,
  "solution_approach": "使用动态规划方法解决爬楼梯问题。通过定义dp数组来记录到达每一层楼梯的方法数，并利用递推公式dp[i] = dp[i - 1] + dp[i - 2]计算从第i-1层和第i-2层到第i层的所有可能方法之和。",
  "key_insights": [
    {
      "content": "dp[i] = dp[i - 1] + dp[i - 2]，表示到达当前层的方法总数等于直接从前一层跳过来的方法数加上从前两层跳过来的方法数。"
    },
    {
      "content": "正确设置dp[1] = 1, dp[2] = 2作为基础情况，后续所有状态都基于这两个值进行推导。"
    },
    {
      "content": "讨论dp[0]的意义不大，因为题目中n是一个正整数。"
    },
    {
      "content": "该问题本质上是斐波那契数列的变种，因此可以采用类似处理斐波那契数列的方式来解决。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "本题大家如果没有接触过的话，会感觉比较难，多举几个例子，就可以发现其规律。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int climbStairs(int n) {if (n <= 1) return n; vector<int> dp(n + 1); dp[1] = 1; dp[2] = 2; for (int i = 3; i <= n; i++) {dp[i] = dp[i - 1] + dp[i - 2];} return dp[n];}};",
          "description": "C++版本一"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int climbStairs(int n) {if (n <= 1) return n; int dp[3]; dp[1] = 1; dp[2] = 2; for (int i = 3; i <= n; i++) {int sum = dp[1] + dp[2]; dp[1] = dp[2]; dp[2] = sum;} return dp[2];}};",
          "description": "C++版本二"
        },
        {
          "language": "java",
          "code": "public int climbStairs(int n) {int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i <= n; i++) {dp[i] = dp[i - 1] + dp[i - 2];} return dp[n];}",
          "description": "Java常规方式"
        },
        {
          "language": "java",
          "code": "public int climbStairs(int n) {if(n <= 2) return n; int a = 1, b = 2, sum = 0; for(int i = 3; i <= n; i++){sum = a + b; a = b; b = sum;} return b;}",
          "description": "Java用变量记录代替数组"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]",
          "description": "Python版本一"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * 3 dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): total = dp[1] + dp[2] dp[1] = dp[2] dp[2] = total return dp[2]",
          "description": "Python版本二"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n prev1 = 1 prev2 = 2 for i in range(3, n + 1): total = prev1 + prev2 prev1 = prev2 prev2 = total return prev2",
          "description": "Python版本三"
        }
      ],
      "subsections": []
    },
    {
      "name": "拓展",
      "text": "这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int climbStairs(int n) {if (n <= 1) return n;vector<int> dp(n + 1);dp[1] = 1;dp[2] = 2;for (int i = 3; i <= n; i++) {dp[i] = dp[i - 1] + dp[i - 2];}return dp[n];}};",
          "description": "C++版本一"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int climbStairs(int n) {if (n <= 1) return n;int dp[3];dp[1] = 1;dp[2] = 2;for (int i = 3; i <= n; i++) {int sum = dp[1] + dp[2];dp[1] = dp[2];dp[2] = sum;}return dp[2];}};",
          "description": "C++版本二"
        },
        {
          "language": "java",
          "code": "public int climbStairs(int n) {int[] dp = new int[n + 1];dp[0] = 1;dp[1] = 1;for (int i = 2; i <= n; i++) {dp[i] = dp[i - 1] + dp[i - 2];}return dp[n];}",
          "description": "Java常规方式"
        },
        {
          "language": "java",
          "code": "class Solution {public int climbStairs(int n) {if(n <= 2) return n;int a = 1, b = 2, sum = 0;for(int i = 3; i <= n; i++){sum = a + b;a = b;b = sum;}return b;}}",
          "description": "Java用变量记录代替数组"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]",
          "description": "Python空间复杂度为O(n)版本"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * 3 dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): total = dp[1] + dp[2] dp[1] = dp[2] dp[2] = total return dp[2]",
          "description": "Python空间复杂度为O(3)版本"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n prev1 = 1 prev2 = 2 for i in range(3, n + 1): total = prev1 + prev2 prev1 = prev2 prev2 = total return prev2",
          "description": "Python空间复杂度为O(1)版本"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "这道题目和动态规划：斐波那契数 (https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html)题目基本是一样的，但是会发现本题相比动态规划：斐波那契数 (https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html)难多了，为什么呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int climbStairs(int n) {if (n <= 1) return n; vector<int> dp(n + 1); dp[1] = 1; dp[2] = 2; for (int i = 3; i <= n; i++) {dp[i] = dp[i - 1] + dp[i - 2];} return dp[n];}};",
          "description": "C++版本一"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int climbStairs(int n) {if (n <= 1) return n; int dp[3]; dp[1] = 1; dp[2] = 2; for (int i = 3; i <= n; i++) {int sum = dp[1] + dp[2]; dp[1] = dp[2]; dp[2] = sum;} return dp[2];}};",
          "description": "C++版本二"
        },
        {
          "language": "java",
          "code": "public int climbStairs(int n) {int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i <= n; i++) {dp[i] = dp[i - 1] + dp[i - 2];} return dp[n];}",
          "description": "Java常规方式"
        },
        {
          "language": "java",
          "code": "public int climbStairs(int n) {if(n <= 2) return n; int a = 1, b = 2, sum = 0; for(int i = 3; i <= n; i++){sum = a + b; a = b; b = sum;} return b;}",
          "description": "Java用变量记录代替数组"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]",
          "description": "Python空间复杂度为O(n)版本"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * 3 dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): total = dp[1] + dp[2] dp[1] = dp[2] dp[2] = total return dp[2]",
          "description": "Python空间复杂度为O(3)版本"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n prev1 = 1 prev2 = 2 for i in range(3, n + 1): total = prev1 + prev2 prev1 = prev2 prev2 = total return prev2",
          "description": "Python空间复杂度为O(1)版本"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "public int climbStairs(int n) { int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; }",
          "description": "Java实现，使用数组记录到达每个阶梯的方法数。"
        },
        {
          "language": "java",
          "code": "class Solution { public int climbStairs(int n) { if(n <= 2) return n; int a = 1, b = 2, sum = 0; for(int i = 3; i <= n; i++){ sum = a + b; a = b; b = sum; } return b; } }",
          "description": "Java实现，通过三个变量迭代更新来减少空间复杂度。"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]",
          "description": "Python实现，使用列表存储每一步的结果，空间复杂度为O(n)。"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * 3 dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): total = dp[1] + dp[2] dp[1] = dp[2] dp[2] = total return dp[2]",
          "description": "Python实现，使用固定大小的列表优化空间复杂度至O(3)。"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n prev1 = 1 prev2 = 2 for i in range(3, n + 1): total = prev1 + prev2 prev1 = prev2 prev2 = total return prev2",
          "description": "Python实现，仅用两个变量存储前两步结果，进一步降低空间复杂度至O(1)。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "// 常规方式",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int climbStairs(int n) {if (n <= 1) return n; vector<int> dp(n + 1); dp[1] = 1; dp[2] = 2; for (int i = 3; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; }};",
          "description": "C++版本一"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int climbStairs(int n) {if (n <= 1) return n; int dp[3]; dp[1] = 1; dp[2] = 2; for (int i = 3; i <= n; i++) { int sum = dp[1] + dp[2]; dp[1] = dp[2]; dp[2] = sum; } return dp[2]; }};",
          "description": "C++版本二"
        },
        {
          "language": "java",
          "code": "public int climbStairs(int n) {int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n];}",
          "description": "Java常规方式"
        },
        {
          "language": "java",
          "code": "class Solution {public int climbStairs(int n) {if(n <= 2) return n; int a = 1, b = 2, sum = 0; for(int i = 3; i <= n; i++){ sum = a + b; a = b; b = sum; } return b;}}",
          "description": "Java变量记录代替数组"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]",
          "description": "Python空间复杂度为O(n)版本"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * 3 dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): total = dp[1] + dp[2] dp[1] = dp[2] dp[2] = total return dp[2]",
          "description": "Python空间复杂度为O(3)版本"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n prev1 = 1 prev2 = 2 for i in range(3, n + 1): total = prev1 + prev2 prev1 = prev2 prev2 = total return prev2",
          "description": "Python空间复杂度为O(1)版本"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "动态规划（版本一）",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int climbStairs(int n) {if (n <= 1) return n; vector<int> dp(n + 1); dp[1] = 1; dp[2] = 2; for (int i = 3; i <= n; i++) {dp[i] = dp[i - 1] + dp[i - 2];} return dp[n];}};",
          "description": "C++版本一"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int climbStairs(int n) {if (n <= 1) return n; int dp[3]; dp[1] = 1; dp[2] = 2; for (int i = 3; i <= n; i++) {int sum = dp[1] + dp[2]; dp[1] = dp[2]; dp[2] = sum;} return dp[2];}};",
          "description": "C++版本二"
        },
        {
          "language": "java",
          "code": "public int climbStairs(int n) {int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i <= n; i++) {dp[i] = dp[i - 1] + dp[i - 2];} return dp[n];}",
          "description": "Java常规方式"
        },
        {
          "language": "java",
          "code": "public int climbStairs(int n) {if(n <= 2) return n; int a = 1, b = 2, sum = 0; for(int i = 3; i <= n; i++){sum = a + b; a = b; b = sum;} return b;}",
          "description": "Java用变量记录代替数组"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]",
          "description": "Python空间复杂度为O(n)版本"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * 3 dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): total = dp[1] + dp[2] dp[1] = dp[2] dp[2] = total return dp[2]",
          "description": "Python空间复杂度为O(3)版本"
        },
        {
          "language": "python",
          "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n prev1 = 1 prev2 = 2 for i in range(3, n + 1): total = prev1 + prev2 prev1 = prev2 prev2 = total return prev2",
          "description": "Python空间复杂度为O(1)版本"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int climbStairs(int n) {if (n <= 1) return n; vector<int> dp(n + 1); dp[1] = 1; dp[2] = 2; for (int i = 3; i <= n; i++) {dp[i] = dp[i - 1] + dp[i - 2];} return dp[n];}};",
      "description": "C++版本一：使用动态规划解决爬楼梯问题"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int climbStairs(int n) {if (n <= 1) return n; int dp[3]; dp[1] = 1; dp[2] = 2; for (int i = 3; i <= n; i++) {int sum = dp[1] + dp[2]; dp[1] = dp[2]; dp[2] = sum;} return dp[2];}};",
      "description": "C++版本二：优化空间复杂度的动态规划解法"
    },
    {
      "language": "java",
      "code": "public int climbStairs(int n) {int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i <= n; i++) {dp[i] = dp[i - 1] + dp[i - 2];} return dp[n];}",
      "description": "Java常规方式：利用数组实现动态规划"
    },
    {
      "language": "java",
      "code": "class Solution {public int climbStairs(int n) {if(n <= 2) return n; int a = 1, b = 2, sum = 0; for(int i = 3; i <= n; i++){sum = a + b; a = b; b = sum;} return b;}}",
      "description": "Java变量记录代替数组：减少空间占用"
    },
    {
      "language": "python",
      "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]",
      "description": "Python版本一：O(n)空间复杂度的动态规划"
    },
    {
      "language": "python",
      "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n dp = [0] * 3 dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): total = dp[1] + dp[2] dp[1] = dp[2] dp[2] = total return dp[2]",
      "description": "Python版本二：优化至O(3)空间复杂度"
    },
    {
      "language": "python",
      "code": "class Solution: def climbStairs(self, n: int) -> int: if n <= 1: return n prev1 = 1 prev2 = 2 for i in range(3, n + 1): total = prev1 + prev2 prev1 = prev2 prev2 = total return prev2",
      "description": "Python版本三：进一步优化至O(1)空间复杂度"
    }
  ],
  "common_mistakes": [
    "误将dp[0]初始化为1，实际上对于本题来说这样做是不必要的，且容易引起误解。",
    "没有明确理解dp数组元素的具体含义，导致在构造递推关系时出现逻辑错误。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210105202546299.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20210105202546299.png",
      "context": "该图片展示了当n为5时，根据给定规则推导出的dp数组（动态规划表）的状态。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210105202546299.png",
      "description": "GIF展示了当n为5时，通过动态规划方法计算爬楼梯问题的过程，逐步填充dp数组直到得到最终结果。",
      "context": "GIF动画展示了当n为5时，根据递推公式计算得出的dp数组（或称dp表）的具体数值变化过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\爬楼梯.txt",
  "extracted_at": "2025-07-20T21:48:39.883901",
  "raw_content": "爬楼梯\n力扣题目链接(https://leetcode.cn/problems/climbing-stairs/)\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n注意：给定 n 是一个正整数。\n\n示例 1：\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1 阶 + 1 阶\n2 阶\n示例 2：\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1 阶 + 1 阶 + 1 阶\n1 阶 + 2 阶\n2 阶 + 1 阶\n\n\n#思路\n本题大家如果没有接触过的话，会感觉比较难，多举几个例子，就可以发现其规律。\n\n爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。\n\n那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。\n\n所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。\n\n我们来分析一下，动规五部曲：\n\n定义一个一维数组来记录不同楼层的状态\n\n确定dp数组以及下标的含义\ndp[i]： 爬到第i层楼梯，有dp[i]种方法\n\n确定递推公式\n如何可以推出dp[i]呢？\n\n从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。\n\n首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。\n\n还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。\n\n那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！\n\n所以dp[i] = dp[i - 1] + dp[i - 2] 。\n\n在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。\n\n这体现出确定dp数组以及下标的含义的重要性！\n\ndp数组如何初始化\n再回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]种方法。\n\n那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但基本都是直接奔着答案去解释的。\n\n例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。\n\n但总有点牵强的成分。\n\n那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.\n\n其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1。\n\n从dp数组定义的角度上来说，dp[0] = 0 也能说得通。\n\n需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。\n\n所以本题其实就不应该讨论dp[0]的初始化！\n\n我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。\n\n所以我的原则是：不考虑dp[0]如何初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。\n\n确定遍历顺序\n从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的\n\n举例推导dp数组\n举例当n为5的时候，dp table（dp数组）应该是这样的\n\nhttps://file1.kamacoder.com/i/algo/20210105202546299.png\n\n如果代码出问题了，就把dp table 打印出来，看看究竟是不是和自己推导的一样。\n\n此时大家应该发现了，这不就是斐波那契数列么！\n\n唯一的区别是，没有讨论dp[0]应该是什么，因为dp[0]在本题没有意义！\n\n以上五部分析完之后，C++代码如下：\n\n// 版本一\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        if (n <= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针\n        vector<int> dp(n + 1);\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) { // 注意i是从3开始的\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(n)\n当然依然也可以，优化一下空间复杂度，代码如下：\n\n// 版本二\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        if (n <= 1) return n;\n        int dp[3];\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            int sum = dp[1] + dp[2];\n            dp[1] = dp[2];\n            dp[2] = sum;\n        }\n        return dp[2];\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(1)\n后面将讲解的很多动规的题目其实都是当前状态依赖前两个，或者前三个状态，都可以做空间上的优化，但我个人认为面试中能写出版本一就够了哈，清晰明了，如果面试官要求进一步优化空间的话，我们再去优化。\n\n因为版本一才能体现出动规的思想精髓，递推的状态变化。\n\n#拓展\n这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。\n\n这又有难度了，这其实是一个完全背包问题，但力扣上没有这种题目，大家可以去卡码网去做一下 57. 爬楼梯(https://kamacoder.com/problempage.php?pid=1067)\n\n所以后续我在讲解背包问题的时候，今天这道题还会从背包问题的角度上来再讲一遍。 如果想提前看一下，可以看这篇:70.爬楼梯完全背包版本(https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html)\n\n这里我先给出本题的代码：\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) { // 把m换成2，就可以AC爬楼梯这道题\n                if (i - j >= 0) dp[i] += dp[i - j];\n            }\n        }\n        return dp[n];\n    }\n};\n代码中m表示最多可以爬m个台阶。\n\n以上代码不能运行哈，我主要是为了体现只要把m换成2，粘过去，就可以AC爬楼梯这道题，不信你就粘一下试试。\n\n此时我就发现一个绝佳的大厂面试题，第一道题就是单纯的爬楼梯，然后看候选人的代码实现，如果把dp[0]的定义成1了，就可以发难了，为什么dp[0]一定要初始化为1，此时可能候选人就要强行给dp[0]应该是1找各种理由。那这就是一个考察点了，对dp[i]的定义理解的不深入。\n\n然后可以继续发难，如果一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。这道题目leetcode上并没有原题，绝对是考察候选人算法能力的绝佳好题。\n\n这一连套问下来，候选人算法能力如何，面试官心里就有数了。\n\n其实大厂面试最喜欢的问题就是这种简单题，然后慢慢变化，在小细节上考察候选人。\n\n#总结\n这道题目和动态规划：斐波那契数 (https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html)题目基本是一样的，但是会发现本题相比动态规划：斐波那契数 (https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html)难多了，为什么呢？\n\n关键是 动态规划：斐波那契数 (https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html)题目描述就已经把动规五部曲里的递归公式和如何初始化都给出来了，剩下几部曲也自然而然的推出来了。\n\n而本题，就需要逐个分析了，大家现在应该初步感受出关于动态规划，你该了解这些！ (https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)里给出的动规五部曲了。\n\n简单题是用来掌握方法论的，例如昨天斐波那契的题目够简单了吧，但昨天和今天可以使用一套方法分析出来的，这就是方法论！\n\n所以不要轻视简单题，那种凭感觉就刷过去了，其实和没掌握区别不大，只有掌握方法论并说清一二三，才能触类旁通，举一反三哈！\n\n#其他语言版本\n#Java\n// 常规方式\npublic int climbStairs(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n// 用变量记录代替数组\nclass Solution {\n    public int climbStairs(int n) {\n        if(n <= 2) return n;\n        int a = 1, b = 2, sum = 0;\n\n        for(int i = 3; i <= n; i++){\n            sum = a + b;  // f(i - 1) + f(i - 2)\n            a = b;        // 记录f(i - 1)，即下一轮的f(i - 2)\n            b = sum;      // 记录f(i)，即下一轮的f(i - 1)\n        }\n        return b;\n    }\n}\n#Python\n动态规划（版本一）\n\n# 空间复杂度为O(n)版本\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 1:\n            return n\n        \n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        \n        return dp[n]\n\n动态规划（版本二）\n\n\n# 空间复杂度为O(3)版本\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 1:\n            return n\n        \n        dp = [0] * 3\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n + 1):\n            total = dp[1] + dp[2]\n            dp[1] = dp[2]\n            dp[2] = total\n        \n        return dp[2]\n\n动态规划（版本三）\n\n\n# 空间复杂度为O(1)版本\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 1:\n            return n\n        \n        prev1 = 1\n        prev2 = 2\n        \n        for i in range(3, n + 1):\n            total = prev1 + prev2\n            prev1 = prev2\n            prev2 = total\n        \n        return prev2"
}