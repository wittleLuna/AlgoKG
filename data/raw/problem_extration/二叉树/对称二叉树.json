{
  "id": "AP_99c0e99a",
  "title": "对称二叉树",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/symmetric-tree/",
  "description": "给定一个二叉树，检查它是否是镜像对称的。\n\nhttps://file1.kamacoder.com/i/algo/20210203144607387.png",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "递归",
    "迭代"
  ],
  "data_structure_tags": [
    "二叉树",
    "队列",
    "栈"
  ],
  "technique_tags": [
    "深度优先搜索(DFS)",
    "广度优先搜索(BFS)"
  ],
  "difficulty": null,
  "solution_approach": "通过比较二叉树根节点左右子树是否互为镜像来判断该二叉树是否对称。采用递归或迭代方法实现，其中递归方式更直观地展示了比较过程。",
  "key_insights": [
    {
      "content": "比较的是根节点的两个子树是否互为镜像，而非简单的左右孩子节点间的比较。"
    },
    {
      "content": "使用一种特殊的后序遍历（一个子树按左中右，另一个子树按右中左），以确保能够正确匹配和比较两棵树的对应部分。"
    },
    {
      "content": "在递归函数开始时就处理空指针情况，避免后续操作中的空指针异常。"
    },
    {
      "content": "迭代法中可以使用队列或栈来存储待比较的节点对，每次取出一对节点进行比较，并将它们的子节点按照特定顺序加入容器中继续比较。"
    },
    {
      "content": "迭代法不是层序遍历，而是利用队列或栈成对存放要比较的节点，确保每一步都能同时访问到左右子树对应的节点。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也是要同时遍历两棵树。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool compare(TreeNode* left, TreeNode* right) { if (left == NULL && right != NULL) return false; else if (left != NULL && right == NULL) return false; else if (left == NULL && right == NULL) return true; else if (left->val != right->val) return false; bool outside = compare(left->left, right->right); bool inside = compare(left->right, right->left); bool isSame = outside && inside; return isSame;} bool isSymmetric(TreeNode* root) { if (root == NULL) return true; return compare(root->left, root->right);}};",
          "description": "递归法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool compare(TreeNode* left, TreeNode* right) { if (left == NULL && right != NULL) return false; else if (left != NULL && right == NULL) return false; else if (left == NULL && right == NULL) return true; else if (left->val != right->val) return false; else return compare(left->left, right->right) && compare(left->right, right->left);} bool isSymmetric(TreeNode* root) { if (root == NULL) return true; return compare(root->left, root->right);}};",
          "description": "简洁版递归法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; queue<TreeNode*> que; que.push(root->left); que.push(root->right); while (!que.empty()) { TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; que.push(leftNode->left); que.push(rightNode->right); que.push(leftNode->right); que.push(rightNode->left);} return true;}};",
          "description": "迭代法，使用队列"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; stack<TreeNode*> st; st.push(root->left); st.push(root->right); while (!st.empty()) { TreeNode* rightNode = st.top(); st.pop(); TreeNode* leftNode = st.top(); st.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; st.push(leftNode->left); st.push(rightNode->right); st.push(leftNode->right); st.push(rightNode->left);} return true;}};",
          "description": "迭代法，使用栈"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric1(TreeNode root) {return compare(root.left, root.right);} private boolean compare(TreeNode left, TreeNode right) {if (left == null && right != null) return false; if (left != null && right == null) return false; if (left == null && right == null) return true; if (left.val != right.val) return false; boolean compareOutside = compare(left.left, right.right); boolean compareInside = compare(left.right, right.left); return compareOutside && compareInside;} public boolean isSymmetric2(TreeNode root) {Deque<TreeNode> deque = new LinkedList<>(); deque.offerFirst(root.left); deque.offerLast(root.right); while (!deque.isEmpty()) {TreeNode leftNode = deque.pollFirst(); TreeNode rightNode = deque.pollLast(); if (leftNode == null && rightNode == null) continue; if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false; deque.offerFirst(leftNode.left); deque.offerFirst(leftNode.right); deque.offerLast(rightNode.right); deque.offerLast(rightNode.left);} return true;} public boolean isSymmetric3(TreeNode root) {Queue<TreeNode> deque = new LinkedList<>(); deque.offer(root.left); deque.offer(root.right); while (!deque.isEmpty()) {TreeNode leftNode = deque.poll(); TreeNode rightNode = deque.poll(); if (leftNode == null && rightNode == null) continue; if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false; deque.offer(leftNode.left); deque.offer(rightNode.right); deque.offer(leftNode.right); deque.offer(rightNode.left);} return true;}",
          "description": "Java版本的递归与迭代方法"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True return self.compare(root.left, root.right) def compare(self, left, right): if left == None and right != None: return False elif left != None and right == None: return False elif left == None and right == None: return True elif left.val != right.val: return False outside = self.compare(left.left, right.right) inside = self.compare(left.right, right.left) isSame = outside and inside return isSame",
          "description": "Python版本的递归法"
        },
        {
          "language": "python",
          "code": "import collections class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque() queue.append(root.left) queue.append(root.right) while queue: leftNode = queue.popleft() rightNode = queue.popleft() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False queue.append(leftNode.left) queue.append(rightNode.right) queue.append(leftNode.right) queue.append(rightNode.left) return True",
          "description": "Python版本的迭代法，使用队列"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True st = [] st.append(root.left) st.append(root.right) while st: rightNode = st.pop() leftNode = st.pop() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False st.append(leftNode.left) st.append(rightNode.right) st.append(leftNode.right) st.append(rightNode.left) return True",
          "description": "Python版本的迭代法，使用栈"
        },
        {
          "language": "python",
          "code": "import collections class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque([root.left, root.right]) while queue: level_size = len(queue) if level_size % 2 != 0: return False level_vals = [] for i in range(level_size): node = queue.popleft() if node: level_vals.append(node.val) queue.append(node.left) queue.append(node.right) else: level_vals.append(None) if level_vals != level_vals[::-1]: return False return True",
          "description": "Python版本层次遍历"
        }
      ],
      "subsections": []
    },
    {
      "name": "递归法",
      "text": "递归三部曲",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool compare(TreeNode* left, TreeNode* right) { if (left == NULL && right != NULL) return false; else if (left != NULL && right == NULL) return false; else if (left == NULL && right == NULL) return true; else if (left->val != right->val) return false; bool outside = compare(left->left, right->right); bool inside = compare(left->right, right->left); bool isSame = outside && inside; return isSame; } bool isSymmetric(TreeNode* root) { if (root == NULL) return true; return compare(root->left, root->right); }};",
          "description": "使用递归方法检查二叉树是否对称"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; queue<TreeNode*> que; que.push(root->left); que.push(root->right); while (!que.empty()) { TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; que.push(leftNode->left); que.push(rightNode->right); que.push(leftNode->right); que.push(rightNode->left); } return true; }};",
          "description": "使用队列迭代方法检查二叉树是否对称"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; stack<TreeNode*> st; st.push(root->left); st.push(root->right); while (!st.empty()) { TreeNode* rightNode = st.top(); st.pop(); TreeNode* leftNode = st.top(); st.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; st.push(leftNode->left); st.push(rightNode->right); st.push(leftNode->right); st.push(rightNode->left); } return true; }};",
          "description": "使用栈迭代方法检查二叉树是否对称"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric1(TreeNode root) {return compare(root.left, root.right);} private boolean compare(TreeNode left, TreeNode right) {if (left == null && right != null) return false; if (left != null && right == null) return false; if (left == null && right == null) return true; if (left.val != right.val) return false; boolean compareOutside = compare(left.left, right.right); boolean compareInside = compare(left.right, right.left); return compareOutside && compareInside;} public boolean isSymmetric2(TreeNode root) {Deque<TreeNode> deque = new LinkedList<>(); deque.offerFirst(root.left); deque.offerLast(root.right); while (!deque.isEmpty()) {TreeNode leftNode = deque.pollFirst(); TreeNode rightNode = deque.pollLast(); if (leftNode == null && rightNode == null) continue; if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false; deque.offerFirst(leftNode.left); deque.offerFirst(leftNode.right); deque.offerLast(rightNode.right); deque.offerLast(rightNode.left);} return true;} public boolean isSymmetric3(TreeNode root) {Queue<TreeNode> deque = new LinkedList<>(); deque.offer(root.left); deque.offer(root.right); while (!deque.isEmpty()) {TreeNode leftNode = deque.poll(); TreeNode rightNode = deque.poll(); if (leftNode == null && rightNode == null) continue; if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false; deque.offer(leftNode.left); deque.offer(rightNode.right); deque.offer(leftNode.right); deque.offer(rightNode.left);} return true;}",
          "description": "Java版本的递归和两种迭代方法（双端队列与普通队列）来判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True return self.compare(root.left, root.right) def compare(self, left, right): if left == None and right != None: return False elif left != None and right == None: return False elif left == None and right == None: return True elif left.val != right.val: return False outside = self.compare(left.left, right.right) inside = self.compare(left.right, right.left) isSame = outside and inside return isSame import collections class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque() queue.append(root.left) queue.append(root.right) while queue: leftNode = queue.popleft() rightNode = queue.popleft() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False queue.append(leftNode.left) queue.append(rightNode.right) queue.append(leftNode.right) queue.append(rightNode.left) return True class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True st = [] st.append(root.left) st.append(root.right) while st: rightNode = st.pop() leftNode = st.pop() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False st.append(leftNode.left) st.append(rightNode.right) st.append(leftNode.right) st.append(rightNode.left) return True class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque([root.left, root.right]) while queue: level_size = len(queue) if level_size % 2 != 0: return False level_vals = [] for i in range(level_size): node = queue.popleft() if node: level_vals.append(node.val) queue.append(node.left) queue.append(node.right) else: level_vals.append(None) if level_vals != level_vals[::-1]: return False return True",
          "description": "Python版本的递归、队列迭代、栈迭代以及层次遍历方法来判断二叉树是否对称"
        }
      ],
      "subsections": []
    },
    {
      "name": "迭代法",
      "text": "这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool compare(TreeNode* left, TreeNode* right) {if (left == NULL && right != NULL) return false;else if (left != NULL && right == NULL) return false;else if (left == NULL && right == NULL) return true;else if (left->val != right->val) return false;bool outside = compare(left->left, right->right);bool inside = compare(left->right, right->left);bool isSame = outside && inside;return isSame;} bool isSymmetric(TreeNode* root) {if (root == NULL) return true;return compare(root->left, root->right);}};",
          "description": "C++递归方法判断二叉树是否对称"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) {if (root == NULL) return true;queue<TreeNode*> que;que.push(root->left);que.push(root->right);while (!que.empty()) {TreeNode* leftNode = que.front(); que.pop();TreeNode* rightNode = que.front(); que.pop();if (!leftNode && !rightNode) {continue;}if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {return false;}que.push(leftNode->left);que.push(rightNode->right);que.push(leftNode->right);que.push(rightNode->left);}return true;}};",
          "description": "C++迭代法（使用队列）判断二叉树是否对称"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) {if (root == NULL) return true;stack<TreeNode*> st;st.push(root->left);st.push(root->right);while (!st.empty()) {TreeNode* rightNode = st.top(); st.pop();TreeNode* leftNode = st.top(); st.pop();if (!leftNode && !rightNode) {continue;}if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {return false;}st.push(leftNode->left);st.push(rightNode->right);st.push(leftNode->right);st.push(rightNode->left);}return true;}};",
          "description": "C++迭代法（使用栈）判断二叉树是否对称"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric1(TreeNode root) {return compare(root.left, root.right);} private boolean compare(TreeNode left, TreeNode right) {if (left == null && right != null) {return false;}if (left != null && right == null) {return false;}if (left == null && right == null) {return true;}if (left.val != right.val) {return false;}boolean compareOutside = compare(left.left, right.right);boolean compareInside = compare(left.right, right.left);return compareOutside && compareInside;}",
          "description": "Java递归方法判断二叉树是否对称"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric2(TreeNode root) {Deque<TreeNode> deque = new LinkedList<>();deque.offerFirst(root.left);deque.offerLast(root.right);while (!deque.isEmpty()) {TreeNode leftNode = deque.pollFirst();TreeNode rightNode = deque.pollLast();if (leftNode == null && rightNode == null) {continue;}if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {return false;}deque.offerFirst(leftNode.left);deque.offerFirst(leftNode.right);deque.offerLast(rightNode.right);deque.offerLast(rightNode.left);}return true;}",
          "description": "Java迭代法（使用双端队列）判断二叉树是否对称"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric3(TreeNode root) {Queue<TreeNode> deque = new LinkedList<>();deque.offer(root.left);deque.offer(root.right);while (!deque.isEmpty()) {TreeNode leftNode = deque.poll();TreeNode rightNode = deque.poll();if (leftNode == null && rightNode == null) {continue;}if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {return false;}deque.offer(leftNode.left);deque.offer(rightNode.right);deque.offer(leftNode.right);deque.offer(rightNode.left);}return true;}",
          "description": "Java迭代法（使用普通队列）判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True return self.compare(root.left, root.right) def compare(self, left, right): if left == None and right != None: return False elif left != None and right == None: return False elif left == None and right == None: return True elif left.val != right.val: return False outside = self.compare(left.left, right.right) inside = self.compare(left.right, right.left) isSame = outside and inside return isSame",
          "description": "Python递归方法判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "import collections class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque() queue.append(root.left) queue.append(root.right) while queue: leftNode = queue.popleft() rightNode = queue.popleft() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False queue.append(leftNode.left) queue.append(rightNode.right) queue.append(leftNode.right) queue.append(rightNode.left) return True",
          "description": "Python迭代法（使用队列）判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True st = [] st.append(root.left) st.append(root.right) while st: rightNode = st.pop() leftNode = st.pop() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False st.append(leftNode.left) st.append(rightNode.right) st.append(leftNode.right) st.append(rightNode.left) return True",
          "description": "Python迭代法（使用栈）判断二叉树是否对称"
        }
      ],
      "subsections": []
    },
    {
      "name": "使用队列",
      "text": "通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool compare(TreeNode* left, TreeNode* right) { if (left == NULL && right != NULL) return false; else if (left != NULL && right == NULL) return false; else if (left == NULL && right == NULL) return true; else if (left->val != right->val) return false; bool outside = compare(left->left, right->right); bool inside = compare(left->right, right->left); bool isSame = outside && inside; return isSame; } bool isSymmetric(TreeNode* root) { if (root == NULL) return true; return compare(root->left, root->right); }};",
          "description": "使用递归法判断二叉树是否对称"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; queue<TreeNode*> que; que.push(root->left); que.push(root->right); while (!que.empty()) { TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; que.push(leftNode->left); que.push(rightNode->right); que.push(leftNode->right); que.push(rightNode->left); } return true; }};",
          "description": "使用队列进行迭代法判断二叉树是否对称"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; stack<TreeNode*> st; st.push(root->left); st.push(root->right); while (!st.empty()) { TreeNode* rightNode = st.top(); st.pop(); TreeNode* leftNode = st.top(); st.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; st.push(leftNode->left); st.push(rightNode->right); st.push(leftNode->right); st.push(rightNode->left); } return true; }};",
          "description": "使用栈进行迭代法判断二叉树是否对称"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric1(TreeNode root) {return compare(root.left, root.right);} private boolean compare(TreeNode left, TreeNode right) {if (left == null && right != null) return false;if (left != null && right == null) return false;if (left == null && right == null) return true;if (left.val != right.val) return false;boolean compareOutside = compare(left.left, right.right);boolean compareInside = compare(left.right, right.left);return compareOutside && compareInside;} public boolean isSymmetric2(TreeNode root) {Deque<TreeNode> deque = new LinkedList<>();deque.offerFirst(root.left);deque.offerLast(root.right);while (!deque.isEmpty()) {TreeNode leftNode = deque.pollFirst();TreeNode rightNode = deque.pollLast();if (leftNode == null && rightNode == null) continue;if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false;deque.offerFirst(leftNode.left);deque.offerFirst(leftNode.right);deque.offerLast(rightNode.right);deque.offerLast(rightNode.left);} return true;} public boolean isSymmetric3(TreeNode root) {Queue<TreeNode> deque = new LinkedList<>();deque.offer(root.left);deque.offer(root.right);while (!deque.isEmpty()) {TreeNode leftNode = deque.poll();TreeNode rightNode = deque.poll();if (leftNode == null && rightNode == null) continue;if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false;deque.offer(leftNode.left);deque.offer(rightNode.right);deque.offer(leftNode.right);deque.offer(rightNode.left);} return true;}",
          "description": "Java实现，包括递归和两种迭代方法（队列与双端队列）来判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True return self.compare(root.left, root.right) def compare(self, left, right): if left == None and right != None: return False elif left != None and right == None: return False elif left == None and right == None: return True elif left.val != right.val: return False outside = self.compare(left.left, right.right) inside = self.compare(left.right, right.left) isSame = outside and inside return isSame class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque() queue.append(root.left) queue.append(root.right) while queue: leftNode = queue.popleft() rightNode = queue.popleft() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False queue.append(leftNode.left) queue.append(rightNode.right) queue.append(leftNode.right) queue.append(rightNode.left) return True class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True st = [] st.append(root.left) st.append(root.right) while st: rightNode = st.pop() leftNode = st.pop() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False st.append(leftNode.left) st.append(rightNode.right) st.append(leftNode.right) st.append(rightNode.left) return True class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque([root.left, root.right]) while queue: level_size = len(queue) if level_size % 2 != 0: return False level_vals = [] for i in range(level_size): node = queue.popleft() if node: level_vals.append(node.val) queue.append(node.left) queue.append(node.right) else: level_vals.append(None) if level_vals != level_vals[::-1]: return False return True",
          "description": "Python实现，包含递归、队列迭代、栈迭代以及层次遍历等方法来判断二叉树是否对称"
        }
      ],
      "subsections": []
    },
    {
      "name": "使用栈",
      "text": "细心的话，其实可以发现，这个迭代法，其实是把左右两个子树要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较，那么其实使用栈也是可以的。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool compare(TreeNode* left, TreeNode* right) { if (left == NULL && right != NULL) return false; else if (left != NULL && right == NULL) return false; else if (left == NULL && right == NULL) return true; else if (left->val != right->val) return false; bool outside = compare(left->left, right->right); bool inside = compare(left->right, right->left); bool isSame = outside && inside; return isSame; } bool isSymmetric(TreeNode* root) { if (root == NULL) return true; return compare(root->left, root->right); }};",
          "description": "使用递归法判断二叉树是否对称"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; queue<TreeNode*> que; que.push(root->left); que.push(root->right); while (!que.empty()) { TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; que.push(leftNode->left); que.push(rightNode->right); que.push(leftNode->right); que.push(rightNode->left); } return true; }};",
          "description": "使用队列迭代法判断二叉树是否对称"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; stack<TreeNode*> st; st.push(root->left); st.push(root->right); while (!st.empty()) { TreeNode* rightNode = st.top(); st.pop(); TreeNode* leftNode = st.top(); st.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; st.push(leftNode->left); st.push(rightNode->right); st.push(leftNode->right); st.push(rightNode->left); } return true; }};",
          "description": "使用栈迭代法判断二叉树是否对称"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric1(TreeNode root) {return compare(root.left, root.right);} private boolean compare(TreeNode left, TreeNode right) {if (left == null && right != null) return false; if (left != null && right == null) return false; if (left == null && right == null) return true; if (left.val != right.val) return false; boolean compareOutside = compare(left.left, right.right); boolean compareInside = compare(left.right, right.left); return compareOutside && compareInside;} public boolean isSymmetric2(TreeNode root) {Deque<TreeNode> deque = new LinkedList<>(); deque.offerFirst(root.left); deque.offerLast(root.right); while (!deque.isEmpty()) {TreeNode leftNode = deque.pollFirst(); TreeNode rightNode = deque.pollLast(); if (leftNode == null && rightNode == null) continue; if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false; deque.offerFirst(leftNode.left); deque.offerFirst(leftNode.right); deque.offerLast(rightNode.right); deque.offerLast(rightNode.left);} return true;} public boolean isSymmetric3(TreeNode root) {Queue<TreeNode> deque = new LinkedList<>(); deque.offer(root.left); deque.offer(root.right); while (!deque.isEmpty()) {TreeNode leftNode = deque.poll(); TreeNode rightNode = deque.poll(); if (leftNode == null && rightNode == null) continue; if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false; deque.offer(leftNode.left); deque.offer(rightNode.right); deque.offer(leftNode.right); deque.offer(rightNode.left);} return true;}",
          "description": "Java版本的递归法和两种迭代法（队列和双端队列）判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True return self.compare(root.left, root.right) def compare(self, left, right): if left == None and right != None: return False elif left != None and right == None: return False elif left == None and right == None: return True elif left.val != right.val: return False outside = self.compare(left.left, right.right) inside = self.compare(left.right, right.left) isSame = outside and inside return isSame class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque() queue.append(root.left) queue.append(root.right) while queue: leftNode = queue.popleft() rightNode = queue.popleft() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False queue.append(leftNode.left) queue.append(rightNode.right) queue.append(leftNode.right) queue.append(rightNode.left) return True class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True st = [] st.append(root.left) st.append(root.right) while st: rightNode = st.pop() leftNode = st.pop() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False st.append(leftNode.left) st.append(rightNode.right) st.append(leftNode.right) st.append(rightNode.left) return True class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque([root.left, root.right]) while queue: level_size = len(queue) if level_size % 2 != 0: return False level_vals = [] for i in range(level_size): node = queue.popleft() if node: level_vals.append(node.val) queue.append(node.left) queue.append(node.right) else: level_vals.append(None) if level_vals != level_vals[::-1]: return False return True",
          "description": "Python版本的递归法、队列迭代法、栈迭代法以及层次遍历方法来判断二叉树是否对称"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "这次我们又深度剖析了一道二叉树的“简单题”，大家会发现，真正的把题目搞清楚其实并不简单，leetcode上accept了和真正掌握了还是有距离的。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool compare(TreeNode* left, TreeNode* right) { if (left == NULL && right != NULL) return false; else if (left != NULL && right == NULL) return false; else if (left == NULL && right == NULL) return true; else if (left->val != right->val) return false; bool outside = compare(left->left, right->right); bool inside = compare(left->right, right->left); bool isSame = outside && inside; return isSame; } bool isSymmetric(TreeNode* root) { if (root == NULL) return true; return compare(root->left, root->right); }};",
          "description": "C++递归法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool compare(TreeNode* left, TreeNode* right) { if (left == NULL && right != NULL) return false; else if (left != NULL && right == NULL) return false; else if (left == NULL && right == NULL) return true; else if (left->val != right->val) return false; else return compare(left->left, right->right) && compare(left->right, right->left); } bool isSymmetric(TreeNode* root) { if (root == NULL) return true; return compare(root->left, root->right); }};",
          "description": "C++简化递归法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; queue<TreeNode*> que; que.push(root->left); que.push(root->right); while (!que.empty()) { TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; que.push(leftNode->left); que.push(rightNode->right); que.push(leftNode->right); que.push(rightNode->left); } return true; }};",
          "description": "C++迭代法使用队列"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; stack<TreeNode*> st; st.push(root->left); st.push(root->right); while (!st.empty()) { TreeNode* rightNode = st.top(); st.pop(); TreeNode* leftNode = st.top(); st.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; st.push(leftNode->left); st.push(rightNode->right); st.push(leftNode->right); st.push(rightNode->left); } return true; }};",
          "description": "C++迭代法使用栈"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric1(TreeNode root) {return compare(root.left, root.right);} private boolean compare(TreeNode left, TreeNode right) {if (left == null && right != null) return false; if (left != null && right == null) return false; if (left == null && right == null) return true; if (left.val != right.val) return false; boolean compareOutside = compare(left.left, right.right); boolean compareInside = compare(left.right, right.left); return compareOutside && compareInside;} public boolean isSymmetric2(TreeNode root) {Deque<TreeNode> deque = new LinkedList<>(); deque.offerFirst(root.left); deque.offerLast(root.right); while (!deque.isEmpty()) {TreeNode leftNode = deque.pollFirst(); TreeNode rightNode = deque.pollLast(); if (leftNode == null && rightNode == null) continue; if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false; deque.offerFirst(leftNode.left); deque.offerFirst(leftNode.right); deque.offerLast(rightNode.right); deque.offerLast(rightNode.left);} return true;} public boolean isSymmetric3(TreeNode root) {Queue<TreeNode> deque = new LinkedList<>(); deque.offer(root.left); deque.offer(root.right); while (!deque.isEmpty()) {TreeNode leftNode = deque.poll(); TreeNode rightNode = deque.poll(); if (leftNode == null && rightNode == null) continue; if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false; deque.offer(leftNode.left); deque.offer(rightNode.right); deque.offer(leftNode.right); deque.offer(rightNode.left);} return true;}",
          "description": "Java版本的递归和迭代法"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True return self.compare(root.left, root.right) def compare(self, left, right): if left == None and right != None: return False elif left != None and right == None: return False elif left == None and right == None: return True elif left.val != right.val: return False outside = self.compare(left.left, right.right) inside = self.compare(left.right, right.left) isSame = outside and inside return isSame",
          "description": "Python递归法"
        },
        {
          "language": "python",
          "code": "import collections class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque() queue.append(root.left) queue.append(root.right) while queue: leftNode = queue.popleft() rightNode = queue.popleft() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False queue.append(leftNode.left) queue.append(rightNode.right) queue.append(leftNode.right) queue.append(rightNode.left) return True",
          "description": "Python迭代法使用队列"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True st = [] st.append(root.left) st.append(root.right) while st: rightNode = st.pop() leftNode = st.pop() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False st.append(leftNode.left) st.append(rightNode.right) st.append(leftNode.right) st.append(rightNode.left) return True",
          "description": "Python迭代法使用栈"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque([root.left, root.right]) while queue: level_size = len(queue) if level_size % 2 != 0: return False level_vals = [] for i in range(level_size): node = queue.popleft() if node: level_vals.append(node.val) queue.append(node.left) queue.append(node.right) else: level_vals.append(None) if level_vals != level_vals[::-1]: return False return True",
          "description": "Python层次遍历"
        }
      ],
      "subsections": []
    },
    {
      "name": "相关题目推荐",
      "text": "这两道题目基本和本题是一样的，只要稍加修改就可以AC。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool compare(TreeNode* left, TreeNode* right) { if (left == NULL && right != NULL) return false; else if (left != NULL && right == NULL) return false; else if (left == NULL && right == NULL) return true; else if (left->val != right->val) return false; bool outside = compare(left->left, right->right); bool inside = compare(left->right, right->left); bool isSame = outside && inside; return isSame; } bool isSymmetric(TreeNode* root) { if (root == NULL) return true; return compare(root->left, root->right); }};",
          "description": "C++递归法实现对称二叉树判断"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; queue<TreeNode*> que; que.push(root->left); que.push(root->right); while (!que.empty()) { TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; que.push(leftNode->left); que.push(rightNode->right); que.push(leftNode->right); que.push(rightNode->left); } return true; }};",
          "description": "C++迭代法使用队列实现对称二叉树判断"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) { if (root == NULL) return true; stack<TreeNode*> st; st.push(root->left); st.push(root->right); while (!st.empty()) { TreeNode* rightNode = st.top(); st.pop(); TreeNode* leftNode = st.top(); st.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; st.push(leftNode->left); st.push(rightNode->right); st.push(leftNode->right); st.push(rightNode->left); } return true; }};",
          "description": "C++迭代法使用栈实现对称二叉树判断"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric1(TreeNode root) {return compare(root.left, root.right);} private boolean compare(TreeNode left, TreeNode right) {if (left == null && right != null) return false;if (left != null && right == null) return false;if (left == null && right == null) return true;if (left.val != right.val) return false;boolean compareOutside = compare(left.left, right.right);boolean compareInside = compare(left.right, right.left);return compareOutside && compareInside;} public boolean isSymmetric2(TreeNode root) {Deque<TreeNode> deque = new LinkedList<>();deque.offerFirst(root.left);deque.offerLast(root.right);while (!deque.isEmpty()) {TreeNode leftNode = deque.pollFirst();TreeNode rightNode = deque.pollLast();if (leftNode == null && rightNode == null) continue;if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false;deque.offerFirst(leftNode.left);deque.offerFirst(leftNode.right);deque.offerLast(rightNode.right);deque.offerLast(rightNode.left);}return true;} public boolean isSymmetric3(TreeNode root) {Queue<TreeNode> deque = new LinkedList<>();deque.offer(root.left);deque.offer(root.right);while (!deque.isEmpty()) {TreeNode leftNode = deque.poll();TreeNode rightNode = deque.poll();if (leftNode == null && rightNode == null) continue;if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false;deque.offer(leftNode.left);deque.offer(rightNode.right);deque.offer(leftNode.right);deque.offer(rightNode.left);}return true;}",
          "description": "Java版本的递归及迭代（队列和双端队列）实现对称二叉树判断"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True return self.compare(root.left, root.right) def compare(self, left, right): if left == None and right != None: return False elif left != None and right == None: return False elif left == None and right == None: return True elif left.val != right.val: return False outside = self.compare(left.left, right.right) inside = self.compare(left.right, right.left) isSame = outside and inside return isSame class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque() queue.append(root.left) queue.append(root.right) while queue: leftNode = queue.popleft() rightNode = queue.popleft() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False queue.append(leftNode.left) queue.append(rightNode.right) queue.append(leftNode.right) queue.append(rightNode.left) return True class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True st = [] st.append(root.left) st.append(root.right) while st: rightNode = st.pop() leftNode = st.pop() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False st.append(leftNode.left) st.append(rightNode.right) st.append(leftNode.right) st.append(rightNode.left) return True class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque([root.left, root.right]) while queue: level_size = len(queue) if level_size % 2 != 0: return False level_vals = [] for i in range(level_size): node = queue.popleft() if node: level_vals.append(node.val) queue.append(node.left) queue.append(node.right) else: level_vals.append(None) if level_vals != level_vals[::-1]: return False return True",
          "description": "Python版本的递归及迭代（队列、栈以及层次遍历）实现对称二叉树判断"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool compare(TreeNode* left, TreeNode* right) {if (left == NULL && right != NULL) return false;else if (left != NULL && right == NULL) return false;else if (left == NULL && right == NULL) return true;else if (left->val != right->val) return false;bool outside = compare(left->left, right->right);bool inside = compare(left->right, right->left);bool isSame = outside && inside;return isSame;}bool isSymmetric(TreeNode* root) {if (root == NULL) return true;return compare(root->left, root->right);}};",
          "description": "C++递归法判断二叉树是否对称"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) {if (root == NULL) return true;queue<TreeNode*> que;que.push(root->left);que.push(root->right);while (!que.empty()) {TreeNode* leftNode = que.front(); que.pop();TreeNode* rightNode = que.front(); que.pop();if (!leftNode && !rightNode) {continue;}if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {return false;}que.push(leftNode->left);que.push(rightNode->right);que.push(leftNode->right);que.push(rightNode->left);}return true;}};",
          "description": "C++迭代法使用队列判断二叉树是否对称"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) {if (root == NULL) return true;stack<TreeNode*> st;st.push(root->left);st.push(root->right);while (!st.empty()) {TreeNode* rightNode = st.top(); st.pop();TreeNode* leftNode = st.top(); st.pop();if (!leftNode && !rightNode) {continue;}if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {return false;}st.push(leftNode->left);st.push(rightNode->right);st.push(leftNode->right);st.push(rightNode->left);}return true;}};",
          "description": "C++迭代法使用栈判断二叉树是否对称"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric1(TreeNode root) {return compare(root.left, root.right);}private boolean compare(TreeNode left, TreeNode right) {if (left == null && right != null) {return false;}if (left != null && right == null) {return false;}if (left == null && right == null) {return true;}if (left.val != right.val) {return false;}boolean compareOutside = compare(left.left, right.right);boolean compareInside = compare(left.right, right.left);return compareOutside && compareInside;}",
          "description": "Java递归法判断二叉树是否对称"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric2(TreeNode root) {Deque<TreeNode> deque = new LinkedList<>();deque.offerFirst(root.left);deque.offerLast(root.right);while (!deque.isEmpty()) {TreeNode leftNode = deque.pollFirst();TreeNode rightNode = deque.pollLast();if (leftNode == null && rightNode == null) {continue;}if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {return false;}deque.offerFirst(leftNode.left);deque.offerFirst(leftNode.right);deque.offerLast(rightNode.right);deque.offerLast(rightNode.left);}return true;}",
          "description": "Java迭代法使用双端队列判断二叉树是否对称"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric3(TreeNode root) {Queue<TreeNode> deque = new LinkedList<>();deque.offer(root.left);deque.offer(root.right);while (!deque.isEmpty()) {TreeNode leftNode = deque.poll();TreeNode rightNode = deque.poll();if (leftNode == null && rightNode == null) {continue;}if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {return false;}deque.offer(leftNode.left);deque.offer(rightNode.right);deque.offer(leftNode.right);deque.offer(rightNode.left);}return true;}",
          "description": "Java迭代法使用普通队列判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True return self.compare(root.left, root.right) def compare(self, left, right): if left == None and right != None: return False elif left != None and right == None: return False elif left == None and right == None: return True elif left.val != right.val: return False outside = self.compare(left.left, right.right) inside = self.compare(left.right, right.left) isSame = outside and inside return isSame",
          "description": "Python递归法判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "import collections class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque() queue.append(root.left) queue.append(root.right) while queue: leftNode = queue.popleft() rightNode = queue.popleft() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False queue.append(leftNode.left) queue.append(rightNode.right) queue.append(leftNode.right) queue.append(rightNode.left) return True",
          "description": "Python迭代法使用队列判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True st = [] st.append(root.left) st.append(root.right) while st: rightNode = st.pop() leftNode = st.pop() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False st.append(leftNode.left) st.append(rightNode.right) st.append(leftNode.right) st.append(rightNode.left) return True",
          "description": "Python迭代法使用栈判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque([root.left, root.right]) while queue: level_size = len(queue) if level_size % 2 != 0: return False level_vals = [] for i in range(level_size): node = queue.popleft() if node: level_vals.append(node.val) queue.append(node.left) queue.append(node.right) else: level_vals.append(None) if level_vals != level_vals[::-1]: return False return True",
          "description": "Python层次遍历法判断二叉树是否对称"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java:",
      "text": "/**",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool compare(TreeNode* left, TreeNode* right) {if (left == NULL && right != NULL) return false;else if (left != NULL && right == NULL) return false;else if (left == NULL && right == NULL) return true;else if (left->val != right->val) return false;bool outside = compare(left->left, right->right);bool inside = compare(left->right, right->left);bool isSame = outside && inside;return isSame;} bool isSymmetric(TreeNode* root) {if (root == NULL) return true;return compare(root->left, root->right);}};",
          "description": "C++递归法实现对称二叉树判断"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) {if (root == NULL) return true;queue<TreeNode*> que;que.push(root->left);que.push(root->right);while (!que.empty()) {TreeNode* leftNode = que.front(); que.pop();TreeNode* rightNode = que.front(); que.pop();if (!leftNode && !rightNode) continue;if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false;que.push(leftNode->left);que.push(rightNode->right);que.push(leftNode->right);que.push(rightNode->left);}return true;}};",
          "description": "C++迭代法（队列）实现对称二叉树判断"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSymmetric(TreeNode* root) {if (root == NULL) return true;stack<TreeNode*> st;st.push(root->left);st.push(root->right);while (!st.empty()) {TreeNode* rightNode = st.top(); st.pop();TreeNode* leftNode = st.top(); st.pop();if (!leftNode && !rightNode) continue;if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false;st.push(leftNode->left);st.push(rightNode->right);st.push(leftNode->right);st.push(rightNode->left);}return true;}};",
          "description": "C++迭代法（栈）实现对称二叉树判断"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric1(TreeNode root) {return compare(root.left, root.right);}private boolean compare(TreeNode left, TreeNode right) {if (left == null && right != null) return false;if (left != null && right == null) return false;if (left == null && right == null) return true;if (left.val != right.val) return false;boolean compareOutside = compare(left.left, right.right);boolean compareInside = compare(left.right, right.left);return compareOutside && compareInside;}",
          "description": "Java递归法实现对称二叉树判断"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric2(TreeNode root) {Deque<TreeNode> deque = new LinkedList<>();deque.offerFirst(root.left);deque.offerLast(root.right);while (!deque.isEmpty()) {TreeNode leftNode = deque.pollFirst();TreeNode rightNode = deque.pollLast();if (leftNode == null && rightNode == null) continue;if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false;deque.offerFirst(leftNode.left);deque.offerFirst(leftNode.right);deque.offerLast(rightNode.right);deque.offerLast(rightNode.left);}return true;}",
          "description": "Java迭代法（双端队列）实现对称二叉树判断"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric3(TreeNode root) {Queue<TreeNode> deque = new LinkedList<>();deque.offer(root.left);deque.offer(root.right);while (!deque.isEmpty()) {TreeNode leftNode = deque.poll();TreeNode rightNode = deque.poll();if (leftNode == null && rightNode == null) continue;if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false;deque.offer(leftNode.left);deque.offer(rightNode.right);deque.offer(leftNode.right);deque.offer(rightNode.left);}return true;}",
          "description": "Java迭代法（普通队列）实现对称二叉树判断"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True return self.compare(root.left, root.right) def compare(self, left, right): if left == None and right != None: return False elif left != None and right == None: return False elif left == None and right == None: return True elif left.val != right.val: return False outside = self.compare(left.left, right.right) inside = self.compare(left.right, right.left) isSame = outside and inside return isSame",
          "description": "Python递归法实现对称二叉树判断"
        },
        {
          "language": "python",
          "code": "import collections class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque() queue.append(root.left) queue.append(root.right) while queue: leftNode = queue.popleft() rightNode = queue.popleft() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False queue.append(leftNode.left) queue.append(rightNode.right) queue.append(leftNode.right) queue.append(rightNode.left) return True",
          "description": "Python迭代法（队列）实现对称二叉树判断"
        },
        {
          "language": "python",
          "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True st = [] st.append(root.left) st.append(root.right) while st: rightNode = st.pop() leftNode = st.pop() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False st.append(leftNode.left) st.append(rightNode.right) st.append(leftNode.right) st.append(rightNode.left) return True",
          "description": "Python迭代法（栈）实现对称二叉树判断"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python:",
      "text": "递归法:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    bool compare(TreeNode* left, TreeNode* right) {\n        if (left == NULL && right != NULL) return false;\n        else if (left != NULL && right == NULL) return false;\n        else if (left == NULL && right == NULL) return true;\n        else if (left->val != right->val) return false;\n        bool outside = compare(left->left, right->right);\n        bool inside = compare(left->right, right->left);\n        bool isSame = outside && inside;\n        return isSame;\n    }\n    bool isSymmetric(TreeNode* root) {\n        if (root == NULL) return true;\n        return compare(root->left, root->right);\n    }\n};",
          "description": "使用递归方法判断二叉树是否对称"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if (root == NULL) return true;\n        queue<TreeNode*> que;\n        que.push(root->left);\n        que.push(root->right);\n        while (!que.empty()) {\n            TreeNode* leftNode = que.front(); que.pop();\n            TreeNode* rightNode = que.front(); que.pop();\n            if (!leftNode && !rightNode) continue;\n            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false;\n            que.push(leftNode->left);\n            que.push(rightNode->right);\n            que.push(leftNode->right);\n            que.push(rightNode->left);\n        }\n        return true;\n    }\n};",
          "description": "使用队列迭代法判断二叉树是否对称"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if (root == NULL) return true;\n        stack<TreeNode*> st;\n        st.push(root->left);\n        st.push(root->right);\n        while (!st.empty()) {\n            TreeNode* rightNode = st.top(); st.pop();\n            TreeNode* leftNode = st.top(); st.pop();\n            if (!leftNode && !rightNode) continue;\n            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false;\n            st.push(leftNode->left);\n            st.push(rightNode->right);\n            st.push(leftNode->right);\n            st.push(rightNode->left);\n        }\n        return true;\n    }\n};",
          "description": "使用栈迭代法判断二叉树是否对称"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric1(TreeNode root) {\n    return compare(root.left, root.right);\n}\nprivate boolean compare(TreeNode left, TreeNode right) {\n    if (left == null && right != null) return false;\n    if (left != null && right == null) return false;\n    if (left == null && right == null) return true;\n    if (left.val != right.val) return false;\n    boolean compareOutside = compare(left.left, right.right);\n    boolean compareInside = compare(left.right, right.left);\n    return compareOutside && compareInside;\n}",
          "description": "Java版递归方法判断二叉树是否对称"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric2(TreeNode root) {\n    Deque<TreeNode> deque = new LinkedList<>();\n    deque.offerFirst(root.left);\n    deque.offerLast(root.right);\n    while (!deque.isEmpty()) {\n        TreeNode leftNode = deque.pollFirst();\n        TreeNode rightNode = deque.pollLast();\n        if (leftNode == null && rightNode == null) continue;\n        if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false;\n        deque.offerFirst(leftNode.left);\n        deque.offerFirst(leftNode.right);\n        deque.offerLast(rightNode.right);\n        deque.offerLast(rightNode.left);\n    }\n    return true;\n}",
          "description": "Java版使用双端队列迭代法判断二叉树是否对称"
        },
        {
          "language": "java",
          "code": "public boolean isSymmetric3(TreeNode root) {\n    Queue<TreeNode> deque = new LinkedList<>();\n    deque.offer(root.left);\n    deque.offer(root.right);\n    while (!deque.isEmpty()) {\n        TreeNode leftNode = deque.poll();\n        TreeNode rightNode = deque.poll();\n        if (leftNode == null && rightNode == null) continue;\n        if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false;\n        deque.offer(leftNode.left);\n        deque.offer(rightNode.right);\n        deque.offer(leftNode.right);\n        deque.offer(rightNode.left);\n    }\n    return true;\n}",
          "description": "Java版使用普通队列迭代法判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "def isSymmetric(self, root: TreeNode) -> bool:\n    if not root:\n        return True\n    return self.compare(root.left, root.right)\ndef compare(self, left, right):\n    if left == None and right != None: return False\n    elif left != None and right == None: return False\n    elif left == None and right == None: return True\n    elif left.val != right.val: return False\n    outside = self.compare(left.left, right.right)\n    inside = self.compare(left.right, right.left)\n    isSame = outside and inside\n    return isSame",
          "description": "Python版递归方法判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "import collections\ndef isSymmetric(self, root: TreeNode) -> bool:\n    if not root:\n        return True\n    queue = collections.deque()\n    queue.append(root.left)\n    queue.append(root.right)\n    while queue:\n        leftNode = queue.popleft()\n        rightNode = queue.popleft()\n        if not leftNode and not rightNode: continue\n        if not leftNode or not rightNode or leftNode.val != rightNode.val: return False\n        queue.append(leftNode.left)\n        queue.append(rightNode.right)\n        queue.append(leftNode.right)\n        queue.append(rightNode.left)\n    return True",
          "description": "Python版使用队列迭代法判断二叉树是否对称"
        },
        {
          "language": "python",
          "code": "def isSymmetric(self, root: TreeNode) -> bool:\n    if not root:\n        return True\n    st = []\n    st.append(root.left)\n    st.append(root.right)\n    while st:\n        rightNode = st.pop()\n        leftNode = st.pop()\n        if not leftNode and not rightNode: continue\n        if not leftNode or not rightNode or leftNode.val != rightNode.val: return False\n        st.append(leftNode.left)\n        st.append(rightNode.right)\n        st.append(leftNode.right)\n        st.append(rightNode.left)\n    return True",
          "description": "Python版使用栈迭代法判断二叉树是否对称"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: bool compare(TreeNode* left, TreeNode* right) {if (left == NULL && right != NULL) return false; else if (left != NULL && right == NULL) return false; else if (left == NULL && right == NULL) return true; else if (left->val != right->val) return false; bool outside = compare(left->left, right->right); bool inside = compare(left->right, right->left); bool isSame = outside && inside; return isSame;} bool isSymmetric(TreeNode* root) {if (root == NULL) return true; return compare(root->left, root->right);}};",
      "description": "C++递归方法实现对称二叉树的检查"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: bool isSymmetric(TreeNode* root) {if (root == NULL) return true; queue<TreeNode*> que; que.push(root->left); que.push(root->right); while (!que.empty()) {TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; que.push(leftNode->left); que.push(rightNode->right); que.push(leftNode->right); que.push(rightNode->left);} return true;}};",
      "description": "C++迭代方法（队列）实现对称二叉树的检查"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: bool isSymmetric(TreeNode* root) {if (root == NULL) return true; stack<TreeNode*> st; st.push(root->left); st.push(root->right); while (!st.empty()) {TreeNode* rightNode = st.top(); st.pop(); TreeNode* leftNode = st.top(); st.pop(); if (!leftNode && !rightNode) continue; if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) return false; st.push(leftNode->left); st.push(rightNode->right); st.push(leftNode->right); st.push(rightNode->left);} return true;}};",
      "description": "C++迭代方法（栈）实现对称二叉树的检查"
    },
    {
      "language": "java",
      "code": "public boolean isSymmetric1(TreeNode root) {return compare(root.left, root.right);} private boolean compare(TreeNode left, TreeNode right) {if (left == null && right != null) return false; if (left != null && right == null) return false; if (left == null && right == null) return true; if (left.val != right.val) return false; boolean compareOutside = compare(left.left, right.right); boolean compareInside = compare(left.right, right.left); return compareOutside && compareInside;}",
      "description": "Java递归方法实现对称二叉树的检查"
    },
    {
      "language": "java",
      "code": "public boolean isSymmetric2(TreeNode root) {Deque<TreeNode> deque = new LinkedList<>(); deque.offerFirst(root.left); deque.offerLast(root.right); while (!deque.isEmpty()) {TreeNode leftNode = deque.pollFirst(); TreeNode rightNode = deque.pollLast(); if (leftNode == null && rightNode == null) continue; if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false; deque.offerFirst(leftNode.left); deque.offerFirst(leftNode.right); deque.offerLast(rightNode.right); deque.offerLast(rightNode.left);} return true;}",
      "description": "Java迭代方法（双端队列）实现对称二叉树的检查"
    },
    {
      "language": "java",
      "code": "public boolean isSymmetric3(TreeNode root) {Queue<TreeNode> deque = new LinkedList<>(); deque.offer(root.left); deque.offer(root.right); while (!deque.isEmpty()) {TreeNode leftNode = deque.poll(); TreeNode rightNode = deque.poll(); if (leftNode == null && rightNode == null) continue; if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) return false; deque.offer(leftNode.left); deque.offer(rightNode.right); deque.offer(leftNode.right); deque.offer(rightNode.left);} return true;}",
      "description": "Java迭代方法（普通队列）实现对称二叉树的检查"
    },
    {
      "language": "python",
      "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True return self.compare(root.left, root.right) def compare(self, left, right): if left == None and right != None: return False elif left != None and right == None: return False elif left == None and right == None: return True elif left.val != right.val: return False outside = self.compare(left.left, right.right) inside = self.compare(left.right, right.left) isSame = outside and inside return isSame",
      "description": "Python递归方法实现对称二叉树的检查"
    },
    {
      "language": "python",
      "code": "import collections class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque() queue.append(root.left) queue.append(root.right) while queue: leftNode = queue.popleft() rightNode = queue.popleft() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False queue.append(leftNode.left) queue.append(rightNode.right) queue.append(leftNode.right) queue.append(rightNode.left) return True",
      "description": "Python迭代方法（队列）实现对称二叉树的检查"
    },
    {
      "language": "python",
      "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True st = [] st.append(root.left) st.append(root.right) while st: rightNode = st.pop() leftNode = st.pop() if not leftNode and not rightNode: continue if not leftNode or not rightNode or leftNode.val != rightNode.val: return False st.append(leftNode.left) st.append(rightNode.right) st.append(leftNode.right) st.append(rightNode.left) return True",
      "description": "Python迭代方法（栈）实现对称二叉树的检查"
    },
    {
      "language": "python",
      "code": "class Solution: def isSymmetric(self, root: TreeNode) -> bool: if not root: return True queue = collections.deque([root.left, root.right]) while queue: level_size = len(queue) if level_size % 2 != 0: return False level_vals = [] for i in range(level_size): node = queue.popleft() if node: level_vals.append(node.val) queue.append(node.left) queue.append(node.right) else: level_vals.append(None) if level_vals != level_vals[::-1]: return False return True",
      "description": "Python层次遍历方法实现对称二叉树的检查"
    }
  ],
  "common_mistakes": [
    "直接比较左右孩子的值而不是整个子树。",
    "忽略了空节点的各种组合情况，导致逻辑错误。",
    "没有正确理解题目要求的对称性，试图使用常规的前序、中序或后序遍历来解决问题。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210203144607387.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20210203144607387.png",
      "context": "该图片展示了如何通过比较二叉树根节点左右子树的里侧和外侧元素来判断一棵树是否为对称二叉树。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210203144624414.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20210203144624414.png",
      "context": "该图片展示了如何比较两棵子树的里侧和外侧元素以判断二叉树是否对称。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.gif",
      "description": "这张图片展示了一棵对称的二叉树，根节点为1，左右子树结构相同但节点值镜像对称，体现了二叉树的对称性检查算法。",
      "context": "该动画展示了通过队列比较二叉树根节点的左右子树是否相互翻转的过程，以判断两棵树是否对称。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.gif",
      "description": "GIF展示了使用队列来比较二叉树的左子树和右子树是否相互翻转的过程。",
      "context": "GIF动画展示了如何使用队列比较二叉树根节点的左右子树是否相互翻转，以判断该树是否为对称二叉树的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210203144607387.png",
      "description": "GIF展示了对称二叉树的后序遍历过程，用以比较其左右子树是否镜像对称。",
      "context": "GIF动画展示了如何通过比较二叉树的左右子树内外侧节点来判断该树是否为对称二叉树的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210203144624414.png",
      "description": "GIF展示了对称二叉树中左右子树节点的比较过程，通过后序遍历方式检查内外侧节点是否相等。",
      "context": "该GIF动画展示了如何通过比较二叉树根节点左右子树的里侧和外侧元素来判断二叉树是否对称的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\二叉树\\对称二叉树.txt",
  "extracted_at": "2025-07-19T21:10:55.598643",
  "raw_content": "对称二叉树\n力扣题目链接(https://leetcode.cn/problems/symmetric-tree/)\n\n给定一个二叉树，检查它是否是镜像对称的。\n\nhttps://file1.kamacoder.com/i/algo/20210203144607387.png\n\n\n#思路\n首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也是要同时遍历两棵树。\n\n那么如何比较呢？\n\n比较的是两个子树的里侧和外侧的元素是否相等。如图所示：\n\nhttps://file1.kamacoder.com/i/algo/20210203144624414.png\n\n那么遍历的顺序应该是什么样的呢？\n\n本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。\n\n正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。\n\n但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。\n\n其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。\n\n说到这大家可能感觉我有点啰嗦，哪有这么多道理，上来就干就完事了。别急，我说的这些在下面的代码讲解中都有身影。\n\n那么我们先来看看递归法的代码应该怎么写。\n\n#递归法\n递归三部曲\n\n确定递归函数的参数和返回值\n因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。\n\n返回值自然是bool类型。\n\n代码如下：\n\nbool compare(TreeNode* left, TreeNode* right)\n确定终止条件\n要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。\n\n节点为空的情况有：（注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点）\n\n左节点为空，右节点不为空，不对称，return false\n左不为空，右为空，不对称 return false\n左右都为空，对称，返回true\n此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：\n\n左右都不为空，比较节点数值，不相同就return false\n此时左右节点不为空，且数值也不相同的情况我们也处理了。\n\n代码如下：\n\nif (left == NULL && right != NULL) return false;\nelse if (left != NULL && right == NULL) return false;\nelse if (left == NULL && right == NULL) return true;\nelse if (left->val != right->val) return false; // 注意这里我没有使用else\n注意上面最后一种情况，我没有使用else，而是else if， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。\n\n确定单层递归的逻辑\n此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。\n\n比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。\n比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。\n如果左右都对称就返回true ，有一侧不对称就返回false 。\n代码如下：\n\nbool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右\nbool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左\nbool isSame = outside && inside;                    // 左子树：中、 右子树：中（逻辑处理）\nreturn isSame;\n如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。\n\n最后递归的C++整体代码如下：\n\nclass Solution {\npublic:\n    bool compare(TreeNode* left, TreeNode* right) {\n        // 首先排除空节点的情况\n        if (left == NULL && right != NULL) return false;\n        else if (left != NULL && right == NULL) return false;\n        else if (left == NULL && right == NULL) return true;\n        // 排除了空节点，再排除数值不相同的情况\n        else if (left->val != right->val) return false;\n\n        // 此时就是：左右节点都不为空，且数值相同的情况\n        // 此时才做递归，做下一层的判断\n        bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右\n        bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左\n        bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）\n        return isSame;\n\n    }\n    bool isSymmetric(TreeNode* root) {\n        if (root == NULL) return true;\n        return compare(root->left, root->right);\n    }\n};\n我给出的代码并不简洁，但是把每一步判断的逻辑都清楚的描绘出来了。\n\n如果上来就看网上各种简洁的代码，看起来真的很简单，但是很多逻辑都掩盖掉了，而题解可能也没有把掩盖掉的逻辑说清楚。\n\n盲目的照着抄，结果就是：发现这是一道“简单题”，稀里糊涂的就过了，但是真正的每一步判断逻辑未必想到清楚。\n\n当然我可以把如上代码整理如下：\n\nclass Solution {\npublic:\n    bool compare(TreeNode* left, TreeNode* right) {\n        if (left == NULL && right != NULL) return false;\n        else if (left != NULL && right == NULL) return false;\n        else if (left == NULL && right == NULL) return true;\n        else if (left->val != right->val) return false;\n        else return compare(left->left, right->right) && compare(left->right, right->left);\n\n    }\n    bool isSymmetric(TreeNode* root) {\n        if (root == NULL) return true;\n        return compare(root->left, root->right);\n    }\n};\n这个代码就很简洁了，但隐藏了很多逻辑，条理不清晰，而且递归三部曲，在这里完全体现不出来。\n\n所以建议大家做题的时候，一定要想清楚逻辑，每一步做什么。把题目所有情况想到位，相应的代码写出来之后，再去追求简洁代码的效果。\n\n#迭代法\n这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。\n\n这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（注意这不是层序遍历）\n\n#使用队列\n通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示：\n\nhttps://file1.kamacoder.com/i/algo/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.gif\n\n如下的条件判断和递归的逻辑是一样的。\n\n代码如下：\n\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if (root == NULL) return true;\n        queue<TreeNode*> que;\n        que.push(root->left);   // 将左子树头结点加入队列\n        que.push(root->right);  // 将右子树头结点加入队列\n        \n        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转\n            TreeNode* leftNode = que.front(); que.pop();\n            TreeNode* rightNode = que.front(); que.pop();\n            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的\n                continue;\n            }\n\n            // 左右一个节点不为空，或者都不为空但数值不相同，返回false\n            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {\n                return false;\n            }\n            que.push(leftNode->left);   // 加入左节点左孩子\n            que.push(rightNode->right); // 加入右节点右孩子\n            que.push(leftNode->right);  // 加入左节点右孩子\n            que.push(rightNode->left);  // 加入右节点左孩子\n        }\n        return true;\n    }\n};\n#使用栈\n细心的话，其实可以发现，这个迭代法，其实是把左右两个子树要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较，那么其实使用栈也是可以的。\n\n只要把队列原封不动的改成栈就可以了，我下面也给出了代码。\n\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if (root == NULL) return true;\n        stack<TreeNode*> st; // 这里改成了栈\n        st.push(root->left);\n        st.push(root->right);\n        while (!st.empty()) {\n            TreeNode* rightNode = st.top(); st.pop();\n            TreeNode* leftNode = st.top(); st.pop();\n            if (!leftNode && !rightNode) {\n                continue;\n            }\n            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {\n                return false;\n            }\n            st.push(leftNode->left);\n            st.push(rightNode->right);\n            st.push(leftNode->right);\n            st.push(rightNode->left);\n        }\n        return true;\n    }\n};\n#总结\n这次我们又深度剖析了一道二叉树的“简单题”，大家会发现，真正的把题目搞清楚其实并不简单，leetcode上accept了和真正掌握了还是有距离的。\n\n我们介绍了递归法和迭代法，递归依然通过递归三部曲来解决了这道题目，如果只看精简的代码根本看不出来递归三部曲是如何解题的。\n\n在迭代法中我们使用了队列，需要注意的是这不是层序遍历，而且仅仅通过一个容器来成对的存放我们要比较的元素，知道这一本质之后就发现，用队列，用栈，甚至用数组，都是可以的。\n\n如果已经做过这道题目的同学，读完文章可以再去看看这道题目，思考一下，会有不一样的发现！\n\n#相关题目推荐\n这两道题目基本和本题是一样的，只要稍加修改就可以AC。\n\n100.相同的树(https://leetcode.cn/problems/same-tree/)\n572.另一个树的子树(https://leetcode.cn/problems/subtree-of-another-tree/)\n#其他语言版本\n#Java:\n    /**\n     * 递归法\n     */\n    public boolean isSymmetric1(TreeNode root) {\n        return compare(root.left, root.right);\n    }\n\n    private boolean compare(TreeNode left, TreeNode right) {\n\n        if (left == null && right != null) {\n            return false;\n        }\n        if (left != null && right == null) {\n            return false;\n        }\n\n        if (left == null && right == null) {\n            return true;\n        }\n        if (left.val != right.val) {\n            return false;\n        }\n        // 比较外侧\n        boolean compareOutside = compare(left.left, right.right);\n        // 比较内侧\n        boolean compareInside = compare(left.right, right.left);\n        return compareOutside && compareInside;\n    }\n\n    /**\n     * 迭代法\n     * 使用双端队列，相当于两个栈\n     */\n    public boolean isSymmetric2(TreeNode root) {\n        Deque<TreeNode> deque = new LinkedList<>();\n        deque.offerFirst(root.left);\n        deque.offerLast(root.right);\n        while (!deque.isEmpty()) {\n            TreeNode leftNode = deque.pollFirst();\n            TreeNode rightNode = deque.pollLast();\n            if (leftNode == null && rightNode == null) {\n                continue;\n            }\n//            if (leftNode == null && rightNode != null) {\n//                return false;\n//            }\n//            if (leftNode != null && rightNode == null) {\n//                return false;\n//            }\n//            if (leftNode.val != rightNode.val) {\n//                return false;\n//            }\n            // 以上三个判断条件合并\n            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {\n                return false;\n            }\n            deque.offerFirst(leftNode.left);\n            deque.offerFirst(leftNode.right);\n            deque.offerLast(rightNode.right);\n            deque.offerLast(rightNode.left);\n        }\n        return true;\n    }\n\n    /**\n     * 迭代法\n     * 使用普通队列\n     */\n    public boolean isSymmetric3(TreeNode root) {\n        Queue<TreeNode> deque = new LinkedList<>();\n        deque.offer(root.left);\n        deque.offer(root.right);\n        while (!deque.isEmpty()) {\n            TreeNode leftNode = deque.poll();\n            TreeNode rightNode = deque.poll();\n            if (leftNode == null && rightNode == null) {\n                continue;\n            }\n//            if (leftNode == null && rightNode != null) {\n//                return false;\n//            }\n//            if (leftNode != null && rightNode == null) {\n//                return false;\n//            }\n//            if (leftNode.val != rightNode.val) {\n//                return false;\n//            }\n            // 以上三个判断条件合并\n            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {\n                return false;\n            }\n            // 这里顺序与使用Deque不同\n            deque.offer(leftNode.left);\n            deque.offer(rightNode.right);\n            deque.offer(leftNode.right);\n            deque.offer(rightNode.left);\n        }\n        return true;\n    }\n\n#Python:\n递归法:\n\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        return self.compare(root.left, root.right)\n        \n    def compare(self, left, right):\n        #首先排除空节点的情况\n        if left == None and right != None: return False\n        elif left != None and right == None: return False\n        elif left == None and right == None: return True\n        #排除了空节点，再排除数值不相同的情况\n        elif left.val != right.val: return False\n        \n        #此时就是：左右节点都不为空，且数值相同的情况\n        #此时才做递归，做下一层的判断\n        outside = self.compare(left.left, right.right) #左子树：左、 右子树：右\n        inside = self.compare(left.right, right.left) #左子树：右、 右子树：左\n        isSame = outside and inside #左子树：中、 右子树：中 （逻辑处理）\n        return isSame\n迭代法： 使用队列\n\nimport collections\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        queue = collections.deque()\n        queue.append(root.left) #将左子树头结点加入队列\n        queue.append(root.right) #将右子树头结点加入队列\n        while queue: #接下来就要判断这这两个树是否相互翻转\n            leftNode = queue.popleft()\n            rightNode = queue.popleft()\n            if not leftNode and not rightNode: #左节点为空、右节点为空，此时说明是对称的\n                continue\n            \n            #左右一个节点不为空，或者都不为空但数值不相同，返回false\n            if not leftNode or not rightNode or leftNode.val != rightNode.val:\n                return False\n            queue.append(leftNode.left) #加入左节点左孩子\n            queue.append(rightNode.right) #加入右节点右孩子\n            queue.append(leftNode.right) #加入左节点右孩子\n            queue.append(rightNode.left) #加入右节点左孩子\n        return True\n迭代法：使用栈\n\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        st = [] #这里改成了栈\n        st.append(root.left)\n        st.append(root.right)\n        while st:\n            rightNode = st.pop()\n            leftNode = st.pop()\n            if not leftNode and not rightNode:\n                continue\n            if not leftNode or not rightNode or leftNode.val != rightNode.val:\n                return False\n            st.append(leftNode.left)\n            st.append(rightNode.right)\n            st.append(leftNode.right)\n            st.append(rightNode.left)\n        return True\n层次遍历\n\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        \n        queue = collections.deque([root.left, root.right])\n        \n        while queue:\n            level_size = len(queue)\n            \n            if level_size % 2 != 0:\n                return False\n            \n            level_vals = []\n            for i in range(level_size):\n                node = queue.popleft()\n                if node:\n                    level_vals.append(node.val)\n                    queue.append(node.left)\n                    queue.append(node.right)\n                else:\n                    level_vals.append(None)\n                    \n            if level_vals != level_vals[::-1]:\n                return False\n            \n        return True"
}