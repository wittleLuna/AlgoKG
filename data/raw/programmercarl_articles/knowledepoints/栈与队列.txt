栈
引入
https://oi-wiki.org/ds/images/stack.svg

栈是 OI 中常用的一种线性数据结构。请注意，本文主要讲的是栈这种数据结构，而非程序运行时的系统栈/栈空间。

栈的修改与访问是按照后进先出的原则进行的，因此栈通常被称为是后进先出（last in first out）表，简称 LIFO 表。

Warning
使用数组模拟栈
我们可以方便的使用数组来模拟一个栈，如下：

实现

C++
Python
int st[N];
// 这里使用 st[0] (即 *st) 代表栈中元素数量，同时也是栈顶下标

// 压栈 ：
st[++*st] = var1;
// 取栈顶 ：
int u = st[*st];
// 弹栈 ：注意越界问题, *st == 0 时不能继续弹出
if (*st) --*st;
// 清空栈
*st = 0;

C++ STL 中的栈
C++ 中的 STL 也提供了一个容器 std::stack，使用前需要引入 stack 头文件。

STL 中对 stack 的定义
// clang-format off
template<
    class T,
    class Container = std::deque<T>
> class stack;
T 为 stack 中要存储的数据类型。

Container 为用于存储元素的底层容器类型。这个容器必须提供通常语义的下列函数：

back()
push_back()
pop_back()
STL 容器 std::vector、std::deque 和 std::list 满足这些要求。如果不指定，则默认使用 std::deque 作为底层容器。

STL 中的 stack 容器提供了一众成员函数以供调用，其中较为常用的有：

元素访问
st.top() 返回栈顶
修改
st.push() 插入传入的参数到栈顶
st.pop() 弹出栈顶
容量
st.empty() 返回是否为空
st.size() 返回元素数量
此外，std::stack 还提供了一些运算符。较为常用的是使用赋值运算符 = 为 stack 赋值，示例：


// 新建两个栈 st1 和 st2
std::stack<int> st1, st2;

// 为 st1 装入 1
st1.push(1);

// 将 st1 赋值给 st2
st2 = st1;

// 输出 st2 的栈顶元素
cout << st2.top() << endl;
// 输出: 1
使用 Python 中的 list 模拟栈
在 Python 中，你可以使用列表来模拟一个栈：

实现
st = [5, 1, 4]

# 使用 append() 向栈顶添加元素
st.append(2)
st.append(3)
# >>> st
# [5, 1, 4, 2, 3]

# 使用 pop 取出栈顶元素
st.pop()
# >>> st
# [5, 1, 4, 2]

# 使用 clear 清空栈
st.clear()



队列
本页面介绍和队列有关的数据结构及其应用。

https://oi-wiki.org/ds/images/queue.svg

引入
队列（queue）是一种具有「先进入队列的元素一定先出队列」性质的表。由于该性质，队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。

数组模拟队列
通常用一个数组模拟一个队列，用两个变量标记队列的首尾。


int q[SIZE], ql = 1, qr;
队列操作对应的代码如下：

插入元素：q[++qr] = x;
删除元素：ql++;
访问队首：q[ql]
访问队尾：q[qr]
清空队列：ql = 1; qr = 0;
双栈模拟队列
还有一种冷门的方法是使用两个 栈 来模拟一个队列。

这种方法使用两个栈 F, S 模拟一个队列，其中 F 是队尾的栈，S 代表队首的栈，支持 push（在队尾插入），pop（在队首弹出）操作：

push：插入到栈 F 中。
pop：如果 S 非空，让 S 弹栈；否则把 F 的元素倒过来压到 S 中（其实就是一个一个弹出插入，做完后是首尾颠倒的），然后再让 S 弹栈。
容易证明，每个元素只会进入/转移/弹出一次，均摊复杂度 O(1)。

C++ STL 中的队列
C++ 在 STL 中提供了一个容器 std::queue，使用前需要先引入 <queue> 头文件。

STL 中对 queue 的定义
// clang-format off
template<
    class T,
    class Container = std::deque<T>
> class queue;
T 为 queue 中要存储的数据类型。

Container 为用于存储元素的底层容器类型。这个容器必须提供通常语义的下列函数：

back()
front()
push_back()
pop_front()
STL 容器 std::deque 和 std::list 满足这些要求。如果不指定，则默认使用 std::deque 作为底层容器。

STL 中的 queue 容器提供了一众成员函数以供调用。其中较为常用的有：

元素访问
q.front() 返回队首元素
q.back() 返回队尾元素
修改
q.push() 在队尾插入元素
q.pop() 弹出队首元素
容量
q.empty() 队列是否为空
q.size() 返回队列中元素的数量
此外，queue 还提供了一些运算符。较为常用的是使用赋值运算符 = 为 queue 赋值，示例：


std::queue<int> q1, q2;

// 向 q1 的队尾插入 1
q1.push(1);

// 将 q1 赋值给 q2
q2 = q1;

// 输出 q2 的队首元素
std::cout << q2.front() << std::endl;
// 输出: 1
特殊队列
双端队列
双端队列是指一个可以在队首/队尾插入或删除元素的队列。相当于是栈与队列功能的结合。具体地，双端队列支持的操作有 4 个：

在队首插入一个元素
在队尾插入一个元素
在队首删除一个元素
在队尾删除一个元素
数组模拟双端队列的方式与普通队列相同。

C++ STL 中的双端队列
C++ 在 STL 中也提供了一个容器 std::deque，使用前需要先引入 <deque> 头文件。

STL 中对 deque 的定义
STL 中的 deque 容器提供了一众成员函数以供调用。其中较为常用的有：

元素访问
q.front() 返回队首元素
q.back() 返回队尾元素
修改
q.push_back() 在队尾插入元素
q.pop_back() 弹出队尾元素
q.push_front() 在队首插入元素
q.pop_front() 弹出队首元素
q.insert() 在指定位置前插入元素（传入迭代器和元素）
q.erase() 删除指定位置的元素（传入迭代器）
容量
q.empty() 队列是否为空
q.size() 返回队列中元素的数量
此外，deque 还提供了一些运算符。其中较为常用的有：

使用赋值运算符 = 为 deque 赋值，类似 queue。
使用 [] 访问元素，类似 vector。
<queue> 头文件中还提供了优先队列 std::priority_queue，因其与 堆 更为相似，在此不作过多介绍。

Python 中的双端队列
在 Python 中，双端队列的容器由 collections.deque 提供。

示例如下：

实现
from collections import deque

# 新建一个 deque，并初始化内容为 [1, 2, 3]
queue = deque([1, 2, 3])

# 在队尾插入元素 4
queue.append(4)

# 在队首插入元素 0
queue.appendleft(0)

# 访问队列
# >>> queue
# deque([0, 1, 2, 3, 4])
循环队列
使用数组模拟队列会导致一个问题：随着时间的推移，整个队列会向数组的尾部移动，一旦到达数组的最末端，即使数组的前端还有空闲位置，再进行入队操作也会导致溢出（这种数组里实际有空闲位置而发生了上溢的现象被称为「假溢出」）。

解决假溢出的办法是采用循环的方式来组织存放队列元素的数组，即将数组下标为 0 的位置看做是最后一个位置的后继。（数组下标为 x 的元素，它的后继为 (x + 1) % SIZE）。这样就形成了循环队列。