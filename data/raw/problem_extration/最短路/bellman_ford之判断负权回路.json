{
  "id": "AP_8e6564fa",
  "title": "bellman_ford之判断负权回路",
  "alternative_titles": [],
  "platform": "kamacoder",
  "url": "https://kamacoder.com/problempage.php?pid=1153",
  "description": "找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。同时能够检测并适当处理负权回路的存在。\n\n城市 1 到城市 n 之间可能会出现没有路径的情况\n\n【输入描述】\n\n第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。\n\n接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。\n\n【输出描述】\n\n如果没有发现负权回路，则输出一个整数，表示从城市 1 到城市 n 的最低运输成本（包括政府补贴）。\n\n如果该整数是负数，则表示实现了盈利。如果发现了负权回路的存在，则输出 \"circle\"。如果从城市 1 无法到达城市 n，则输出 \"unconnected\"。\n\n输入",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "Bellman-Ford",
    "Shortest Path"
  ],
  "data_structure_tags": [
    "Array",
    "List",
    "Queue"
  ],
  "technique_tags": [
    "Relaxation Technique",
    "Negative Cycle Detection",
    "SPFA (Shortest Path Faster Algorithm)"
  ],
  "difficulty": null,
  "solution_approach": "使用Bellman-Ford算法计算从起点到终点的最短路径，并在第n次松弛操作时检查是否存在负权回路。如果存在，则输出'circle'；如果不存在且无法到达终点，则输出'unconnected'；否则，输出最低运输成本。",
  "key_insights": [
    {
      "content": "通常，Bellman-Ford算法通过执行n-1次松弛操作来找到最短路径。若图中无负权回路，在第n次松弛时不应再有更新发生。因此，可以通过尝试进行第n次松弛并观察是否有距离被进一步减小来判断是否存在负权回路。"
    },
    {
      "content": "当图中含有负权边时，可能形成负权回路，这会导致理论上无限降低的成本或增加收益。因此，在求解最短路径之前必须先排除这种情况的存在。"
    },
    {
      "content": "除了标准的Bellman-Ford算法，还可以使用SPFA（Shortest Path Faster Algorithm）来优化性能，同时仍然能够检测负权回路的存在。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "本题是 kama94.城市间货物运输I 延伸题目。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法解决城市间货物运输问题并检测负权回路"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用SPFA算法优化版解决城市间货物运输问题并检测负权回路"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java实现基于SPFA算法的城市间货物运输问题解决方案，并处理负权回路情况"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现的Bellman-Ford算法解决城市间货物运输问题，并检测是否存在负权回路"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python中的SPFA算法版本来解决城市间货物运输问题，同时检查是否存在负权回路"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法检测负权回路并求解从起点到终点的最短路径"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点 \n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用优化后的SPFA算法（基于队列）检测负权回路并求解从起点到终点的最短路径"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java版本的SPFA算法实现，用于检测负权回路和计算最短路径"
        },
        {
          "language": "python",
          "code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于检测负权回路和计算最短路径"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法实现，用于检测负权回路和计算最短路径"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法检测负权回路并找到从起点到终点的最短路径。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用SPFA算法优化了Bellman-Ford算法来检测负权回路，并计算从起点到终点的最短路径。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        boolean[] isInQueue = new boolean[n + 1];\n\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false;\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) {\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) {\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) {\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java版本的SPFA算法实现，用于处理带有负权回路的情况以及寻找最短路径。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n\n    min_dist[1] = 0\n    count[1] = 1\n    d = deque([1])\n    flag = False\n\n    while d:\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:\n                    flag = True\n        if flag:\n            break\n\n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版SPFA算法，解决包含负权环的问题，并找出从起始城市到目标城市的最短运输成本。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <list>",
      "text": "#include <climits>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法检测负权回路并计算最短路径"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用SPFA算法优化Bellman-Ford，并检测负权回路"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        boolean[] isInQueue = new boolean[n + 1];\n\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false;\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) {\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) {\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) {\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java实现的基于SPFA方法的负权回路检测和最短路径查找"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现的Bellman-Ford算法用于检测负权回路及计算最短路径"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现的SPFA算法，用于优化Bellman-Ford算法并检测负权回路"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法检测图中是否存在负权回路，并计算从起点到终点的最小成本。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点 \n    \n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用SPFA算法优化了Bellman-Ford算法来检测图中的负权回路，并求解从起点到终点的最小成本。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        boolean[] isInQueue = new boolean[n + 1];\n\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false;\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) {\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) {\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) {\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java版本的基于SPFA方法的最短路径算法实现，用于处理含有负权回路的图。"
        },
        {
          "language": "python",
          "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本使用Bellman-Ford算法解决包含负权回路的最短路径问题。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本使用SPFA算法优化的Bellman-Ford算法来解决含有负权回路的最短路径问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "拓展",
      "text": "本题可不可 使用 队列优化版的bellman_ford（SPFA）呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法求解从城市1到城市n的最低运输成本，并检测是否存在负权回路。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点 \n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用SPFA（Shortest Path Faster Algorithm）优化的Bellman-Ford算法来解决同样的问题，同时检测是否存在负权回路。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java实现的SPFA算法版本，用于查找从城市1到城市n的最短路径，并检查是否有负权回路。"
        },
        {
          "language": "python",
          "code": "import sys\nfrom collections import deque\nfrom math import inf\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本使用Bellman-Ford算法求解从城市1到城市n的最小运输成本，并检测是否存在负权回路。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现的SPFA算法，用于寻找从城市1到城市n的最短路径，并且能够检测图中是否存在负权回路。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法解决货物运输问题并检测负权回路。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点 \n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用SPFA算法优化版的Bellman-Ford解决货物运输问题，并且能够更高效地检测负权回路。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java版本的SPFA算法实现，用于处理城市间货物运输问题并检测负权回路。"
        },
        {
          "language": "python",
          "code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    import sys\n    main()",
          "description": "Python版本使用Bellman-Ford算法解决城市间货物运输问题并检测是否存在负权回路。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法实现，用于解决城市间货物运输问题并检测是否存在负权回路。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "C++版本的Bellman-Ford算法实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "C++版本SPFA算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java版本的SPFA算法实现"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <queue>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "C++实现的Bellman-Ford算法用于检测负权回路并计算从起点到终点的最短路径。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点 \n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "C++实现的SPFA算法用于检测负权回路，并优化了队列处理以提高效率。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java实现的SPFA算法用于解决含有负权回路的最短路径问题。"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现的Bellman-Ford算法来检测负权回路和计算最短路径。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n        \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n            \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现的SPFA算法用于检测负权回路并优化了队列处理以提高效率。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <list>",
      "text": "#include <climits>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法解决城市间货物运输问题，并检测负权回路。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点 \n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用SPFA算法优化后的Bellman-Ford算法来解决城市间货物运输问题，并检测负权回路。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java版本基于Bellman-Ford和SPFA算法解决城市间货物运输问题，并检测负权回路。"
        },
        {
          "language": "python",
          "code": "import sys\nfrom collections import deque\nfrom math import inf\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()\n\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本基于Bellman-Ford和SPFA算法解决城市间货物运输问题，并检测负权回路。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法检测负权回路并计算最短路径"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点 \n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用SPFA算法优化版的Bellman-Ford来检测负权回路和计算最短路径"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        boolean[] isInQueue = new boolean[n + 1];\n\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; \n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) {\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) {\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) {\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java版本基于SPFA方法实现的负权回路检测及最短路径查找"
        },
        {
          "language": "python",
          "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本利用Bellman-Ford算法进行负权回路检测与最短路径求解"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n\n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n\n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n\n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本采用SPFA算法实现的负权回路检测与最短路径计算"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法计算从城市1到城市n的最低运输成本，并检测负权回路。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用SPFA算法优化版的Bellman-Ford算法来解决相同问题，同时更有效地处理负权回路的情况。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java版本的SPFA算法实现，用于解决从城市1到城市n的最低运输成本问题，并检测图中是否存在负权回路。"
        },
        {
          "language": "python",
          "code": "import sys\nfrom collections import deque\nfrom math import inf\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于寻找从城市1到城市n的最短路径（或最低成本），并检查是否存在负权回路。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法实现，通过队列优化了Bellman-Ford算法的过程，特别适用于存在负权边的情况下的最短路径查找。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用 Bellman-Ford 算法计算最短路径并检测负权环。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点 \n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用 SPFA 方法计算最短路径并检测负权环。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java版本使用SPFA方法求解含有负回路的最短路径问题。"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本使用Bellman-Ford算法求解含有负回路的最短路径问题。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本使用SPFA方法求解含有负回路的最短路径问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <queue>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法解决城市间货物运输问题，并检测负权回路"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点 \n    \n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用SPFA算法优化后的Bellman-Ford算法解决城市间货物运输问题，并检测负权回路"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        boolean[] isInQueue = new boolean[n + 1];\n\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false;\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) {\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) {\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) {\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java版本的SPFA算法解决城市间货物运输问题，并检测负权回路"
        },
        {
          "language": "python",
          "code": "import sys\nfrom collections import deque\nfrom math import inf\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法解决城市间货物运输问题，并检测负权回路"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法解决城市间货物运输问题，并检测负权回路"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <list>",
      "text": "#include <climits>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法检测负权回路并计算最短路径"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点 \n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用SPFA算法优化后的Bellman-Ford算法来检测负权回路并计算最短路径"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java实现的基于SPFA的Bellman-Ford算法来处理负权回路和最短路径问题"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python中的Bellman-Ford算法实现，用于检测负权回路和找到最短路径"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n            \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python中的SPFA算法实现，用于处理负权回路和最短路径问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用Bellman-Ford算法检测负权回路并计算从起点到终点的最短路径。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "使用SPFA算法优化的Bellman-Ford算法来检测负权回路并找到最短路径。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        boolean[] isInQueue = new boolean[n + 1];\n\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false;\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) {\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) {\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) {\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java实现的SPFA算法用于检测负权回路和计算最短路径。"
        },
        {
          "language": "python",
          "code": "import sys\nfrom collections import deque\nfrom math import inf\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()\n\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现的Bellman-Ford算法及SPFA算法用于处理含有负回路的最短路径问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "import java.util.*;public class Main {static class Edge {int from;int to;int val;public Edge(int from, int to, int val) {this.from = from;this.to = to;this.val = val;}}public static void main(String[] args) {Scanner sc = new Scanner(System.in);int n = sc.nextInt();int m = sc.nextInt();List<List<Edge>> graph = new ArrayList<>();for (int i = 0; i <= n; i++) {graph.add(new ArrayList<>());}for (int i = 0; i < m; i++) {int from = sc.nextInt();int to = sc.nextInt();int val = sc.nextInt();graph.get(from).add(new Edge(from, to, val));}int[] minDist = new int[n + 1];Arrays.fill(minDist, Integer.MAX_VALUE);minDist[1] = 0;Queue<Integer> queue = new LinkedList<>();queue.offer(1);int[] count = new int[n + 1];count[1]++;boolean[] isInQueue = new boolean[n + 1];boolean flag = false;while (!queue.isEmpty()) {int curNode = queue.poll();isInQueue[curNode] = false;for (Edge edge : graph.get(curNode)) {if (minDist[edge.to] > minDist[edge.from] + edge.val) {minDist[edge.to] = minDist[edge.from] + edge.val;if (!isInQueue[edge.to]) {queue.offer(edge.to);count[edge.to]++;isInQueue[edge.to] = true;}if (count[edge.to] == n) {flag = true;while (!queue.isEmpty()) queue.poll();break;}}}}if (flag) {System.out.println(\"circle\");} else if (minDist[n] == Integer.MAX_VALUE) {System.out.println(\"unconnected\");} else {System.out.println(minDist[n]);}}}",
          "description": "使用Java实现基于Bellman-Ford SPFA算法的负权回路检测和最短路径计算"
        },
        {
          "language": "python",
          "code": "from collections import deque;from math import inf;def main():n, m = [int(i) for i in input().split()];graph = [[] for _ in range(n+1)];min_dist = [inf for _ in range(n+1)];count = [0 for _ in range(n+1)];for _ in range(m):s, t, v = [int(i) for i in input().split()];graph[s].append([t, v]);min_dist[1] = 0;count[1] = 1;d = deque([1]);flag = False;while d:cur_node = d.popleft();for next_node, val in graph[cur_node]:if min_dist[next_node] > min_dist[cur_node] + val:min_dist[next_node] = min_dist[cur_node] + val;count[next_node] += 1;if next_node not in d:d.append(next_node);if count[next_node] == n:flag = True;break;if flag:print(\"circle\");else:if min_dist[-1] == inf:print(\"unconnected\");else:print(min_dist[-1]);if __name__ == \"__main__\":main()",
          "description": "使用Python实现基于SPFA算法的负权回路检测和最短路径计算"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "import java.util.*;",
      "resources": [],
      "code_snippets": [
        {
          "language": "c++",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "C++实现的Bellman-Ford算法，用于检测图中是否存在负权回路，并计算从起点到终点的最短路径。"
        },
        {
          "language": "c++",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点 \n    \n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "C++实现的SPFA算法，优化了Bellman-Ford算法以更高效地处理大型图，并能够检测负权回路。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java语言实现的基于SPFA算法的方法，用于解决含有负权回路的最短路径问题。"
        },
        {
          "language": "python",
          "code": "def main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    import sys\n    main()",
          "description": "Python语言实现的Bellman-Ford算法，用于检测图中是否存在负权回路，并计算从起点到终点的最短路径。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python语言实现的SPFA算法，用于解决含有负权回路的最短路径问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "Bellman-Ford方法求解含有负回路的最短路问题",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "C++版本的Bellman-Ford算法实现，用于检测图中是否存在负权回路并计算从起点到终点的最短路径。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
          "description": "C++版本的SPFA算法实现，通过优化避免了对已出队节点的重复统计，用于检测图中是否存在负权回路并计算从起点到终点的最短路径。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
          "description": "Java版本的SPFA算法实现，用于检测图中是否存在负权回路并计算从起点到终点的最短路径。"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于检测图中是否存在负权回路并计算从起点到终点的最短路径。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法实现，用于检测图中是否存在负权回路并计算从起点到终点的最短路径。"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(N * E)",
    "space_complexity": "O(N)",
    "explanation": "N为节点数量，E为图中边的数量"
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
      "description": "使用Bellman-Ford算法检测负权回路并计算最短路径。"
    },
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}",
      "description": "使用SPFA算法检测负权回路并计算最短路径。"
    },
    {
      "language": "java",
      "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}",
      "description": "使用Java实现基于SPFA算法的负权回路检测及最短路径计算。"
    },
    {
      "language": "python",
      "code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()\n",
      "description": "使用Python实现Bellman-Ford算法进行负权回路检测和最短路径计算。"
    },
    {
      "language": "python",
      "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n    \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n    \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "description": "使用Python实现SPFA算法进行负权回路检测和最短路径计算。"
    }
  ],
  "common_mistakes": [
    "没有正确初始化minDist数组，导致结果不准确。",
    "忽略了对负权回路的检测，直接输出了错误的结果。",
    "在实现代码时，边界条件处理不当，如未考虑从起点到终点不可达的情况。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240705161426.png",
      "description": "这张图片展示了一个有向图，包含四个节点（1、2、3、4）及其之间的加权边，可用于分析图的最短路径或网络流问题。",
      "context": "该图展示了节点1到节点4之间的一条路径及其成本，用于说明在存在负权边的情况下计算最短路径的问题。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240402103712.png",
      "description": "这张图片展示了一个包含负权回路的有向图，涉及节点1、2、3和4，以及它们之间的边权值，强调了在最短路径算法（如Bellman-Ford算法）中的关键概念。",
      "context": "该图展示了存在负权回路的情况下，如何通过在回路中循环来不断降低从节点1到节点4的路径成本。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/2025-06-03_16-12-41.jpg",
      "description": "这张图片展示了一个有向加权图，包含四个节点（1, 2, 3, 4）及其之间的加权边，适用于最短路径算法（如Dijkstra或Bellman-Ford）的分析。",
      "context": "该图展示了导致代码错误的一组数据示例，具体说明了在执行过程中节点4已经出队列但其入度被反复计算的问题。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240705161426.png",
      "description": "GIF展示了使用Bellman-Ford算法在含有负权回路的图中寻找最短路径的过程，其中每次迭代都因负权回路而持续更新最短路径。",
      "context": "该GIF动画展示了在存在负权回路的情况下，通过不断绕圈使得从节点1到节点4的路径成本持续减小的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240402103712.png",
      "description": "GIF展示了Bellman-Ford算法处理包含负权回路的图时，不断通过松弛操作更新最短路径的过程。",
      "context": "该GIF动画展示了图中存在负权回路时，通过不断绕行该回路可以使从节点1到节点4的路径成本无限减小的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/2025-06-03_16-12-41.jpg",
      "description": "GIF展示了图中节点的最短路径寻找过程，特别标注了节点4出队后仍被误计入度计算导致的问题。",
      "context": "GIF动画展示了在给定的数据集上执行原始代码时，节点4出队后仍被反复计算入度导致误判图中存在环的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\最短路\\bellman_ford之判断负权回路.txt",
  "extracted_at": "2025-07-22T01:58:18.959464",
  "raw_content": "bellman_ford之判断负权回路\n卡码网：95. 城市间货物运输 II(https://kamacoder.com/problempage.php?pid=1153)\n\n【题目描述】\n\n某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。\n\n网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；\n\n权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。\n\n然而，在评估从城市 1 到城市 n 的所有可能路径中综合政府补贴后的最低运输成本时，存在一种情况：图中可能出现负权回路。\n\n负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。\n\n为了避免货物运输商采用负权回路这种情况无限的赚取政府补贴，算法还需检测这种特殊情况。\n\n请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。同时能够检测并适当处理负权回路的存在。\n\n城市 1 到城市 n 之间可能会出现没有路径的情况\n\n【输入描述】\n\n第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。\n\n接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。\n\n【输出描述】\n\n如果没有发现负权回路，则输出一个整数，表示从城市 1 到城市 n 的最低运输成本（包括政府补贴）。\n\n如果该整数是负数，则表示实现了盈利。如果发现了负权回路的存在，则输出 \"circle\"。如果从城市 1 无法到达城市 n，则输出 \"unconnected\"。\n\n输入示例\n\n4 4\n1 2 -1\n2 3 1\n3 1 -1\n3 4 1\n输出示例\n\ncircle\n#思路\n本题是 kama94.城市间货物运输I 延伸题目。\n\n本题是要我们判断 负权回路，也就是图中出现环且环上的边总权值为负数。\n\n如果在这样的图中求最短路的话， 就会在这个环里无限循环 （也是负数+负数 只会越来越小），无法求出最短路径。\n\n所以对于 在有负权值的图中求最短路，都需要先看看这个图里有没有负权回路。\n\n接下来我们来看 如何使用 bellman_ford 算法来判断 负权回路。\n\n在 kama94.城市间货物运输I 中 我们讲了 bellman_ford 算法的核心就是一句话：对 所有边 进行 n-1 次松弛。 同时文中的 【拓展】部分， 我们也讲了 松弛n次以上 会怎么样？\n\n在没有负权回路的图中，松弛 n 次以上 ，结果不会有变化。\n\n但本题有 负权回路，如果松弛 n 次，结果就会有变化了，因为 有负权回路 就是可以无限最短路径（一直绕圈，就可以一直得到无限小的最短距离）。\n\n那么每松弛一次，都会更新最短路径，所以结果会一直有变化。\n\n（如果对于 bellman_ford 不了解的录友，建议详细看这里：kama94.城市间货物运输I）\n\n以上为理论分析，接下来我们再画图举例。\n\n我们拿题目中示例来画一个图：\n\nhttps://file1.kamacoder.com/i/algo/20240705161426.png\n\n图中 节点1 到 节点4 的最短路径是多少（题目中的最低运输成本） （注意边可以为负数的）\n\n节点1 -> 节点2 -> 节点3 -> 节点4，这样的路径总成本为 -1 + 1 + 1 = 1\n\n而图中有负权回路：\n\nhttps://file1.kamacoder.com/i/algo/20240402103712.png\n\n那么我们在负权回路中多绕一圈，我们的最短路径 是不是就更小了 （也就是更低的运输成本）\n\n节点1 -> 节点2 -> 节点3 -> 节点1 -> 节点2 -> 节点3 -> 节点4，这样的路径总成本 (-1) + 1 + (-1) + (-1) + 1 + (-1) + 1 = -1\n\n如果在负权回路多绕两圈，三圈，无穷圈，那么我们的总成本就会无限小， 如果要求最小成本的话，你会发现本题就无解了。\n\n在 bellman_ford 算法中，松弛 n-1 次所有的边 就可以求得 起点到任何节点的最短路径，松弛 n 次以上，minDist数组（记录起到到其他节点的最短距离）中的结果也不会有改变 （如果对 bellman_ford 算法 不了解，也不知道 minDist 是什么，建议详看上篇讲解kama94.城市间货物运输I）\n\n而本题有负权回路的情况下，一直都会有更短的最短路，所以 松弛 第n次，minDist数组 也会发生改变。\n\n那么解决本题的 核心思路，就是在 kama94.城市间货物运输I 的基础上，再多松弛一次，看minDist数组 是否发生变化。\n\n代码和 kama94.城市间货物运输I 基本是一样的，如下：（关键地方已注释）\n\n#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (i < n) {\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n            } else { // 多加一次松弛判断负权回路\n                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;\n\n            }\n        }\n\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}\n时间复杂度： O(N * E) , N为节点数量，E为图中边的数量\n空间复杂度： O(N) ，即 minDist 数组所开辟的空间\n#拓展\n本题可不可 使用 队列优化版的bellman_ford（SPFA）呢？\n\n上面的解法中，我们对所有边松弛了n-1次后，在松弛一次，如果出现minDist出现变化就判断有负权回路。\n\n如果使用 SPFA 那么节点都是进队列的，那么节点进入队列几次后 足够判断该图是否有负权回路呢？\n\n在 0094.城市间货物运输I-SPFA 中，我们讲过 在极端情况下，即：所有节点都与其他节点相连，每个节点的入度为 n-1 （n为节点数量），所以每个节点最多加入 n-1 次队列。\n\n那么如果节点加入队列的次数 超过了 n-1次 ，那么该图就一定有负权回路。\n\n所以本题也是可以使用 SPFA 来做的。 代码如下：\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点 \n    \n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                que.push(to);\n                count[to]++; \n                if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                    flag = true;\n                    while (!que.empty()) que.pop();\n                    break;\n                }\n            }\n        }\n    }\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}\n以上代码看上去没问题，但提交之后会发现报错了，为什么呢？\n\n例如这组数据：\n\n4 6\n1 4 3\n1 2 1\n1 3 1\n3 2 -2\n2 4 1\n3 4 0\n如图：\n\nhttps://file1.kamacoder.com/i/algo/2025-06-03_16-12-41.jpg\n\n上面代码在执行的过程中，节点4 已经出队列了，但 计算入度会反复计算 节点4的入度，导致 误判 该图有环。\n\n我们需要记录哪些节点已经出队列了，哪些节点在队列里面，对于已经出队列的节点不用统计入度，以下为优化后的代码：\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    vector<int> count(n+1, 0); // 记录节点加入队列几次\n    count[start]++;\n    vector<bool> inQueue(n+1, false);  // 记录节点是否在队列中\n\n    bool flag = false;\n    while (!que.empty()) {\n\n        int node = que.front(); que.pop();\n        inQueue[node] = false;  // 节点出队\n\n        for (Edge edge : grid[node]) {\n            int from = node;\n            int to = edge.to;\n            int value = edge.val;\n            if (minDist[to] > minDist[from] + value) { // 开始松弛\n                minDist[to] = minDist[from] + value;\n                 if (!inQueue[to]) {  // 避免重复入队\n                    que.push(to);\n                    inQueue[to] = true;\n                    count[to]++;\n                    if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路\n                        flag = true;\n                        while (!que.empty()) que.pop();\n                        break;\n                    }\n                 }\n            }\n        }\n    }\n\n    if (flag) cout << \"circle\" << endl;\n    else if (minDist[end] == INT_MAX) {\n        cout << \"unconnected\" << endl;\n    } else {\n        cout << minDist[end] << endl;\n    }\n}\n#其他语言版本\n#Java\nimport java.util.*;\n\npublic class Main {\n    // 基于Bellman_ford-SPFA方法\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.get(from).add(new Edge(from, to, val));\n        }\n\n        // Declare the minDist array to record the minimum distance form current node to the original node\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[1] = 0;\n\n        // Declare a queue to store the updated nodes instead of traversing all nodes each loop for more efficiency\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(1);\n\n        // Declare an array to record the times each node has been offered in the queue\n        int[] count = new int[n + 1];\n        count[1]++;\n\n        // Declare a boolean array to record if the current node is in the queue to optimise the processing\n        boolean[] isInQueue = new boolean[n + 1];\n\n        // Declare a boolean value to check if there is a negative weight loop inside the graph\n        boolean flag = false;\n\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            isInQueue[curNode] = false; // Represents the current node is not in the queue after being polled\n            for (Edge edge : graph.get(curNode)) {\n                if (minDist[edge.to] > minDist[edge.from] + edge.val) { // Start relaxing the edge\n                    minDist[edge.to] = minDist[edge.from] + edge.val;\n                    if (!isInQueue[edge.to]) { // Don't add the node if it's already in the queue\n                        queue.offer(edge.to);\n                        count[edge.to]++;\n                        isInQueue[edge.to] = true;\n                    }\n\n                    if (count[edge.to] == n) { // If some node has been offered in the queue more than n-1 times\n                        flag = true;\n                        while (!queue.isEmpty()) queue.poll();\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (flag) {\n            System.out.println(\"circle\");\n        } else if (minDist[n] == Integer.MAX_VALUE) {\n            System.out.println(\"unconnected\");\n        } else {\n            System.out.println(minDist[n]);\n        }\n    }\n}\n\n#Python\nBellman-Ford方法求解含有负回路的最短路问题\n\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    grid = []\n    for i in range(m):\n        p1 = int(data[index])\n        index += 1\n        p2 = int(data[index])\n        index += 1\n        val = int(data[index])\n        index += 1\n        # p1 指向 p2，权值为 val\n        grid.append([p1, p2, val])\n\n    start = 1  # 起点\n    end = n    # 终点\n\n    minDist = [float('inf')] * (n + 1)\n    minDist[start] = 0\n    flag = False\n\n    for i in range(1, n + 1):  # 这里我们松弛n次，最后一次判断负权回路\n        for side in grid:\n            from_node = side[0]\n            to = side[1]\n            price = side[2]\n            if i < n:\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    minDist[to] = minDist[from_node] + price\n            else:  # 多加一次松弛判断负权回路\n                if minDist[from_node] != float('inf') and minDist[to] > minDist[from_node] + price:\n                    flag = True\n\n    if flag:\n        print(\"circle\")\n    elif minDist[end] == float('inf'):\n        print(\"unconnected\")\n    else:\n        print(minDist[end])\n\nif __name__ == \"__main__\":\n    main()\n\nSPFA方法求解含有负回路的最短路问题\n\nfrom collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    min_dist = [inf for _ in range(n+1)]\n    count = [0 for _ in range(n+1)]  # 记录节点加入队列的次数\n    for _ in range(m):\n        s, t, v = [int(i) for i in input().split()]\n        graph[s].append([t, v])\n        \n    min_dist[1] = 0  # 初始化\n    count[1] = 1\n    d = deque([1])\n    flag = False\n    \n    while d:  # 主循环\n        cur_node = d.popleft()\n        for next_node, val in graph[cur_node]:\n            if min_dist[next_node] > min_dist[cur_node] + val:\n                min_dist[next_node] = min_dist[cur_node] + val\n                count[next_node] += 1\n                if next_node not in d:\n                    d.append(next_node)\n                if count[next_node] == n:  # 如果某个点松弛了n次，说明有负回路\n                    flag = True\n        if flag:\n            break\n            \n    if flag:\n        print(\"circle\")\n    else:\n        if min_dist[-1] == inf:\n            print(\"unconnected\")\n        else:\n            print(min_dist[-1])\n\n\nif __name__ == \"__main__\":\n    main()"
}