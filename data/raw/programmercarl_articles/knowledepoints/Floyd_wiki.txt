Floyd 算法
是用来求任意两个结点之间的最短路的。

复杂度比较高，但是常数小，容易实现（只有三个 for）。

适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（不能有个负环）

实现
我们定义一个数组 f[k][x][y]，表示只允许经过结点 1 到 k（也就是说，在子图 V'={1, 2, \ldots, k} 中的路径，注意，x 与 y 不一定在这个子图中），结点 x 到结点 y 的最短路长度。

很显然，f[n][x][y] 就是结点 x 到结点 y 的最短路长度（因为 V'={1, 2, \ldots, n} 即为 V 本身，其表示的最短路径就是所求路径）。

接下来考虑如何求出 f 数组的值。

f[0][x][y]：x 与 y 的边权，或者 0，或者 +\infty（f[0][x][y] 什么时候应该是 +\infty？当 x 与 y 间有直接相连的边的时候，为它们的边权；当 x = y 的时候为零，因为到本身的距离为零；当 x 与 y 没有直接相连的边的时候，为 +\infty）。

f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])（f[k-1][x][y]，为不经过 k 点的最短路径，而 f[k-1][x][k]+f[k-1][k][y]，为经过了 k 点的最短路）。

上面两行都显然是对的，所以说这个做法空间是 O(N^3)，我们需要依次增加问题规模（k 从 1 到 n），判断任意两点在当前问题规模下的最短路。


C++
Python
for k in range(1, n + 1):
    for x in range(1, n + 1):
        for y in range(1, n + 1):
            f[k][x][y] = min(f[k - 1][x][y], f[k - 1][x][k] + f[k - 1][k][y])

因为第一维对结果无影响，我们可以发现数组的第一维是可以省略的，于是可以直接改成 f[x][y] = min(f[x][y], f[x][k]+f[k][y])。

证明第一维对结果无影响
对于给定的 k，当更新 f[k][x][y] 时，涉及的元素总是来自 f[k-1] 数组的第 k 行和第 k 列。然后我们可以发现，对于给定的 k，当更新 f[k][k][y] 或 f[k][x][k]，总是不会发生数值更新，因为按照公式 f[k][k][y] = min(f[k-1][k][y], f[k-1][k][k]+f[k-1][k][y]),f[k-1][k][k] 为 0，因此这个值总是 f[k-1][k][y]，对于 f[k][x][k] 的证明类似。

因此，如果省略第一维，在给定的 k 下，每个元素的更新中使用到的元素都没有在这次迭代中更新，因此第一维的省略并不会影响结果。


C++
Python
for (k = 1; k <= n; k++) {
  for (x = 1; x <= n; x++) {
    for (y = 1; y <= n; y++) {
      f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
    }
  }
}

综上时间复杂度是 O(N^3)，空间复杂度是 O(N^2)。

应用
给一个正权无向图，找一个最小权值和的环。
首先这一定是一个简单环。

想一想这个环是怎么构成的。

考虑环上编号最大的结点 u。

f[u-1][x][y] 和 (u,x),(u,y) 共同构成了环。

在 Floyd 的过程中枚举 u，计算这个和的最小值即可。

时间复杂度为 O(n^3)。

更多参见 最小环 部分内容。

已知一个有向图中任意两点之间是否有连边，要求判断任意两点是否连通。
该问题即是求 图的传递闭包。

我们只需要按照 Floyd 的过程，逐个加入点判断一下。

只是此时的边的边权变为 1/0，而取 \min 变成了 或 运算。

再进一步用 bitset 优化，复杂度可以到 
 
O(\frac{n^3}{w})。

// std::bitset<SIZE> f[SIZE];
for (k = 1; k <= n; k++)
  for (i = 1; i <= n; i++)
    if (f[i][k]) f[i] = f[i] | f[k];