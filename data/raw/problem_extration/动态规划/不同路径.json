{
  "id": "AP_1ecf49d6",
  "title": "不同路径",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/unique-paths/",
  "description": "一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？",
  "examples": [
    {
      "input": "见图",
      "output": "见图",
      "explanation": null,
      "image": "https://file1.kamacoder.com/i/algo/20210110174033215.png"
    }
  ],
  "constraints": [],
  "algorithm_tags": [
    "动态规划",
    "深度优先搜索",
    "组合数学"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "状态转移",
    "滚动数组",
    "递归"
  ],
  "difficulty": null,
  "solution_approach": "通过动态规划的方法来解决机器人从网格左上角移动到右下角的不同路径数量问题。首先尝试了深度优先搜索(DFS)方法，但该方法时间复杂度太高导致超时。然后使用动态规划(DP)策略，利用二维数组记录到达每个位置的不同路径数，最终优化为一维数组减少空间开销。此外，还介绍了基于组合数学的解决方案。",
  "key_insights": [
    {
      "content": "无论采取哪种路径，从起点走到终点总共需要m + n - 2步，其中必须有m-1次向下移动和n-1次向右移动。"
    },
    {
      "content": "dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，表示到达(i, j)位置的不同路径总数等于到达其左侧位置与上方位置的不同路径之和。"
    },
    {
      "content": "对于组合数学解法，关键在于计算C(m+n-2, m-1)，即在m+n-2步中选择m-1步向下走的方式数。"
    },
    {
      "content": "初始化时，第一行和第一列的所有元素都设置为1，因为只有一种方式可以到达这些位置：一直向右或一直向下。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "#深搜",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: int dfs(int i, int j, int m, int n) {if (i > m || j > n) return 0; if (i == m && j == n) return 1; return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);}public: int uniquePaths(int m, int n) {return dfs(1, 1, m, n);}};",
          "description": "使用深搜的方法求解不同路径问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {vector<vector<int>> dp(m, vector<int>(n, 0)); for (int i = 0; i < m; i++) dp[i][0] = 1; for (int j = 0; j < n; j++) dp[0][j] = 1; for (int i = 1; i < m; i++) {for (int j = 1; j < n; j++) {dp[i][j] = dp[i - 1][j] + dp[i][j - 1];}} return dp[m - 1][n - 1];}};",
          "description": "动态规划二维数组实现不同路径问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {vector<int> dp(n); for (int i = 0; i < n; i++) dp[i] = 1; for (int j = 1; j < m; j++) {for (int i = 1; i < n; i++) {dp[i] += dp[i - 1];}} return dp[n - 1];}};",
          "description": "动态规划一维数组实现不同路径问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {long long numerator = 1; int denominator = m - 1; int count = m - 1; int t = m + n - 2; while (count--) {numerator *= (t--); while (denominator != 0 && numerator % denominator == 0) {numerator /= denominator; denominator--;}} return numerator;}};",
          "description": "数论方法解决不同路径问题"
        },
        {
          "language": "java",
          "code": "public static int uniquePaths(int m, int n) {int[][] dp = new int[m][n]; for (int i = 0; i < m; i++) {dp[i][0] = 1;} for (int i = 0; i < n; i++) {dp[0][i] = 1;} for (int i = 1; i < m; i++) {for (int j = 1; j < n; j++) {dp[i][j] = dp[i-1][j]+dp[i][j-1];}} return dp[m-1][n-1];}",
          "description": "Java语言，动态规划二维数组实现不同路径问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int uniquePaths(int m, int n) {int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i < m; i ++) {for (int j = 1; j < n; j ++) {dp[j] += dp[j - 1];}} return dp[n - 1];}}",
          "description": "Java语言，动态规划一维数组实现不同路径问题"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: if m == 1 or n == 1: return 1 return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)",
          "description": "Python语言，递归方式实现不同路径问题"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]",
          "description": "Python语言，动态规划二维数组实现不同路径问题"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [1] * n for j in range(1, m): for i in range(1, n): dp[i] += dp[i - 1] return dp[n - 1]",
          "description": "Python语言，动态规划一维数组实现不同路径问题"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: numerator = 1 denominator = m - 1 count = m - 1 t = m + n - 2 while count > 0: numerator *= t t -= 1 while denominator != 0 and numerator % denominator == 0: numerator //= denominator denominator -= 1 count -= 1 return numerator",
          "description": "Python语言，数论方法解决不同路径问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "深搜",
      "text": "这道题目，刚一看最直观的想法就是用图论里的深搜，来枚举出来有多少种路径。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: int dfs(int i, int j, int m, int n) { if (i > m || j > n) return 0; if (i == m && j == n) return 1; return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n); }public: int uniquePaths(int m, int n) { return dfs(1, 1, m, n); }};",
          "description": "使用深度优先搜索的方法来计算从起点到终点的不同路径数。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) { vector<vector<int>> dp(m, vector<int>(n, 0)); for (int i = 0; i < m; i++) dp[i][0] = 1; for (int j = 0; j < n; j++) dp[0][j] = 1; for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; }};",
          "description": "通过动态规划方法解决不同路径问题，使用二维数组存储中间结果。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) { vector<int> dp(n); for (int i = 0; i < n; i++) dp[i] = 1; for (int j = 1; j < m; j++) { for (int i = 1; i < n; i++) { dp[i] += dp[i - 1]; } } return dp[n - 1]; }};",
          "description": "优化空间复杂度的动态规划解法，仅使用一维数组存储当前行的结果。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) { long long numerator = 1; int denominator = m - 1; int count = m - 1; int t = m + n - 2; while (count--) { numerator *= (t--); while (denominator != 0 && numerator % denominator == 0) { numerator /= denominator; denominator--; } } return numerator; }};",
          "description": "基于组合数学原理计算从起点到终点的不同路径数，避免了整数溢出的问题。"
        },
        {
          "language": "java",
          "code": "public static int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; for (int i = 0; i < m; i++) { dp[i][0] = 1; } for (int i = 0; i < n; i++) { dp[0][i] = 1; } for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { dp[i][j] = dp[i-1][j]+dp[i][j-1]; } } return dp[m-1][n-1]; }",
          "description": "Java实现的动态规划解法，用于求解网格中从起点到终点的不同路径总数。"
        },
        {
          "language": "java",
          "code": "class Solution { public int uniquePaths(int m, int n) { int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { dp[j] += dp[j - 1]; } } return dp[n - 1]; }}",
          "description": "Java版本的空间优化动态规划解法，采用一维数组减少内存消耗。"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: if m == 1 or n == 1: return 1 return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)",
          "description": "Python实现递归方式解决不同路径问题。"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]",
          "description": "Python中的二维动态规划解法，适用于寻找网格内不同路径数目。"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [1] * n for j in range(1, m): for i in range(1, n): dp[i] += dp[i - 1] return dp[n - 1]",
          "description": "Python实现的一维动态规划解决方案，以减少空间复杂度。"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: numerator = 1 denominator = m - 1 count = m - 1 t = m + n - 2 while count > 0: numerator *= t t -= 1 while denominator != 0 and numerator % denominator == 0: numerator //= denominator denominator -= 1 count -= 1 return numerator",
          "description": "利用组合数学公式计算网格中不同路径数量的Python实现。"
        }
      ],
      "subsections": []
    },
    {
      "name": "动态规划",
      "text": "机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution { private: int dfs(int i, int j, int m, int n) { if (i > m || j > n) return 0; if (i == m && j == n) return 1; return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n); } public: int uniquePaths(int m, int n) { return dfs(1, 1, m, n); } };",
          "description": "使用深度优先搜索（DFS）来计算从起点到终点的不同路径数量。"
        },
        {
          "language": "cpp",
          "code": "class Solution { public: int uniquePaths(int m, int n) { vector<vector<int>> dp(m, vector<int>(n, 0)); for (int i = 0; i < m; i++) dp[i][0] = 1; for (int j = 0; j < n; j++) dp[0][j] = 1; for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m - 1][n - 1]; } };",
          "description": "使用二维动态规划数组解决不同路径问题，通过构建dp数组来存储到达每个位置的路径数。"
        },
        {
          "language": "cpp",
          "code": "class Solution { public: int uniquePaths(int m, int n) { vector<int> dp(n); for (int i = 0; i < n; i++) dp[i] = 1; for (int j = 1; j < m; j++) { for (int i = 1; i < n; i++) { dp[i] += dp[i - 1]; } } return dp[n - 1]; } };",
          "description": "利用一维滚动数组优化空间复杂度，同样基于动态规划思想求解不同路径问题。"
        },
        {
          "language": "cpp",
          "code": "class Solution { public: int uniquePaths(int m, int n) { long long numerator = 1; int denominator = m - 1; int count = m - 1; int t = m + n - 2; while (count--) { numerator *= (t--); while (denominator != 0 && numerator % denominator == 0) { numerator /= denominator; denominator--; } } return numerator; } };",
          "description": "采用组合数学方法计算从起点到终点的不同路径总数，通过逐步约简分子和分母防止溢出。"
        },
        {
          "language": "java",
          "code": "public static int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; for (int i = 0; i < m; i++) { dp[i][0] = 1; } for (int i = 0; i < n; i++) { dp[0][i] = 1; } for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { dp[i][j] = dp[i-1][j]+dp[i][j-1]; } } return dp[m-1][n-1]; }",
          "description": "Java实现的动态规划方法，用于计算网格中从左上角到右下角的不同路径数量。"
        },
        {
          "language": "java",
          "code": "class Solution { public int uniquePaths(int m, int n) { int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i < m; i ++) { for (int j = 1; j < n; j ++) { dp[j] += dp[j - 1]; } } return dp[n - 1]; } }",
          "description": "Java版本的状态压缩算法，将二维DP数组压缩为一维以减少空间复杂度。"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: if m == 1 or n == 1: return 1 return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)",
          "description": "Python递归实现的方法，直接通过递归调用来计算所有可能路径的数量。"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]",
          "description": "Python中的二维动态规划实现，适用于计算从起点到指定终点的不同路径数。"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [1] * n for j in range(1, m): for i in range(1, n): dp[i] += dp[i - 1] return dp[n - 1]",
          "description": "通过一维数组实现的动态规划方法，降低了内存消耗同时保持了高效性。"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: numerator = 1 denominator = m - 1 count = m - 1 t = m + n - 2 while count > 0: numerator *= t t -= 1 while denominator != 0 and numerator % denominator == 0: numerator //= denominator denominator -= 1 count -= 1 return numerator",
          "description": "基于组合数学原理的Python解决方案，通过精确计算避免数值溢出。"
        }
      ],
      "subsections": []
    },
    {
      "name": "数论方法",
      "text": "在这个图中，可以看出一共m，n的话，无论怎么走，走到终点都需要 m + n - 2 步。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    int dfs(int i, int j, int m, int n) {\n        if (i > m || j > n) return 0; \n        if (i == m && j == n) return 1; \n        return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);\n    }\npublic:\n    int uniquePaths(int m, int n) {\n        return dfs(1, 1, m, n);\n    }\n};",
          "description": null
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n, 0));\n        for (int i = 0; i < m; i++) dp[i][0] = 1;\n        for (int j = 0; j < n; j++) dp[0][j] = 1;\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};",
          "description": null
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> dp(n);\n        for (int i = 0; i < n; i++) dp[i] = 1;\n        for (int j = 1; j < m; j++) {\n            for (int i = 1; i < n; i++) {\n                dp[i] += dp[i - 1];\n            }\n        }\n        return dp[n - 1];\n    }\n};",
          "description": null
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        long long numerator = 1; \n        int denominator = m - 1; \n        int count = m - 1;\n        int t = m + n - 2;\n        while (count--) {\n            numerator *= (t--);\n            while (denominator != 0 && numerator % denominator == 0) {\n                numerator /= denominator;\n                denominator--;\n            }\n        }\n        return numerator;\n    }\n};",
          "description": null
        },
        {
          "language": "java",
          "code": "public static int uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        dp[i][0] = 1;\n    }\n    for (int i = 0; i < n; i++) {\n        dp[0][i] = 1;\n    }\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = dp[i-1][j]+dp[i][j-1];\n        }\n    }\n    return dp[m-1][n-1];\n}",
          "description": null
        },
        {
          "language": "java",
          "code": "public int uniquePaths(int m, int n) {\n    int[] dp = new int[n];\n    Arrays.fill(dp, 1);\n    for (int i = 1; i < m; i ++) {\n        for (int j = 1; j < n; j ++) {\n            dp[j] += dp[j - 1]; \n        }\n    }\n    return dp[n - 1];\n}",
          "description": null
        },
        {
          "language": "python",
          "code": "def uniquePaths(self, m: int, n: int) -> int:\n    if m == 1 or n == 1:\n        return 1\n    return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)",
          "description": null
        },
        {
          "language": "python",
          "code": "def uniquePaths(self, m: int, n: int) -> int:\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        dp[i][0] = 1\n    for j in range(n):\n        dp[0][j] = 1\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]",
          "description": null
        },
        {
          "language": "python",
          "code": "def uniquePaths(self, m: int, n: int) -> int:\n    dp = [1] * n\n    for j in range(1, m):\n        for i in range(1, n):\n            dp[i] += dp[i - 1]\n    return dp[n - 1]",
          "description": null
        },
        {
          "language": "python",
          "code": "def uniquePaths(self, m: int, n: int) -> int:\n    numerator = 1  # 分子\n    denominator = m - 1  # 分母\n    count = m - 1  # 计数器，表示剩余需要计算的乘积项个数\n    t = m + n - 2  # 初始乘积项\n    while count > 0:\n        numerator *= t  # 计算乘积项的分子部分\n        t -= 1  # 递减乘积项\n        while denominator != 0 and numerator % denominator == 0:\n            numerator //= denominator  # 约简分子\n            denominator -= 1  # 递减分母\n        count -= 1  # 计数器减1，继续下一项的计算\n    return numerator  # 返回最终的唯一路径数",
          "description": null
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "本文分别给出了深搜，动规，数论三种方法。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: int dfs(int i, int j, int m, int n) {if (i > m || j > n) return 0; if (i == m && j == n) return 1; return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);}public: int uniquePaths(int m, int n) {return dfs(1, 1, m, n);}};",
          "description": "使用深搜方法求解不同路径问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {vector<vector<int>> dp(m, vector<int>(n, 0));for (int i = 0; i < m; i++) dp[i][0] = 1;for (int j = 0; j < n; j++) dp[0][j] = 1;for (int i = 1; i < m; i++) {for (int j = 1; j < n; j++) {dp[i][j] = dp[i - 1][j] + dp[i][j - 1];}}return dp[m - 1][n - 1];}};",
          "description": "使用动态规划二维数组版本求解不同路径问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {vector<int> dp(n);for (int i = 0; i < n; i++) dp[i] = 1;for (int j = 1; j < m; j++) {for (int i = 1; i < n; i++) {dp[i] += dp[i - 1];}}return dp[n - 1];}};",
          "description": "使用动态规划一维数组版本求解不同路径问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {long long numerator = 1;int denominator = m - 1;int count = m - 1;int t = m + n - 2;while (count--) {numerator *= (t--);while (denominator != 0 && numerator % denominator == 0) {numerator /= denominator;denominator--;}}return numerator;}};",
          "description": "使用数论方法求解不同路径问题"
        },
        {
          "language": "java",
          "code": "public static int uniquePaths(int m, int n) {int[][] dp = new int[m][n];for (int i = 0; i < m; i++) {dp[i][0] = 1;}for (int i = 0; i < n; i++) {dp[0][i] = 1;}for (int i = 1; i < m; i++) {for (int j = 1; j < n; j++) {dp[i][j] = dp[i-1][j]+dp[i][j-1];}}return dp[m-1][n-1];}",
          "description": "Java实现的动态规划二维数组版本求解不同路径问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int uniquePaths(int m, int n) {int[] dp = new int[n];Arrays.fill(dp, 1);for (int i = 1; i < m; i ++) {for (int j = 1; j < n; j ++) {dp[j] += dp[j - 1];}}return dp[n - 1];}}",
          "description": "Java实现的动态规划一维数组版本求解不同路径问题"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: if m == 1 or n == 1: return 1 return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)",
          "description": "Python实现的递归方法求解不同路径问题"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]",
          "description": "Python实现的动态规划二维数组版本求解不同路径问题"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [1] * n for j in range(1, m): for i in range(1, n): dp[i] += dp[i - 1] return dp[n - 1]",
          "description": "Python实现的动态规划一维数组版本求解不同路径问题"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: numerator = 1 denominator = m - 1 count = m - 1 t = m + n - 2 while count > 0: numerator *= t t -= 1 while denominator != 0 and numerator % denominator == 0: numerator //= denominator denominator -= 1 count -= 1 return numerator",
          "description": "Python实现的数论方法求解不同路径问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: int dfs(int i, int j, int m, int n) {if (i > m || j > n) return 0; if (i == m && j == n) return 1; return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);}public: int uniquePaths(int m, int n) {return dfs(1, 1, m, n);}};",
          "description": "深搜算法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {vector<vector<int>> dp(m, vector<int>(n, 0)); for (int i = 0; i < m; i++) dp[i][0] = 1; for (int j = 0; j < n; j++) dp[0][j] = 1; for (int i = 1; i < m; i++) {for (int j = 1; j < n; j++) {dp[i][j] = dp[i - 1][j] + dp[i][j - 1];}} return dp[m - 1][n - 1];}};",
          "description": "二维动态规划"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {vector<int> dp(n); for (int i = 0; i < n; i++) dp[i] = 1; for (int j = 1; j < m; j++) {for (int i = 1; i < n; i++) {dp[i] += dp[i - 1];}} return dp[n - 1];}};",
          "description": "一维动态规划"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {long long numerator = 1; int denominator = m - 1; int count = m - 1; int t = m + n - 2; while (count--) {numerator *= (t--); while (denominator != 0 && numerator % denominator == 0) {numerator /= denominator; denominator--;}} return numerator;}};",
          "description": "数论方法"
        },
        {
          "language": "java",
          "code": "public static int uniquePaths(int m, int n) {int[][] dp = new int[m][n]; for (int i = 0; i < m; i++) {dp[i][0] = 1;} for (int i = 0; i < n; i++) {dp[0][i] = 1;} for (int i = 1; i < m; i++) {for (int j = 1; j < n; j++) {dp[i][j] = dp[i-1][j]+dp[i][j-1];}} return dp[m-1][n-1];}",
          "description": "二维动态规划（Java）"
        },
        {
          "language": "java",
          "code": "public int uniquePaths(int m, int n) {int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i < m; i ++) {for (int j = 1; j < n; j ++) {dp[j] += dp[j - 1];}} return dp[n - 1];}",
          "description": "一维动态规划（状态压缩，Java）"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: if m == 1 or n == 1: return 1 return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)",
          "description": "递归（Python）"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]",
          "description": "二维动态规划（版本一，Python）"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [1] * n for j in range(1, m): for i in range(1, n): dp[i] += dp[i - 1] return dp[n - 1]",
          "description": "一维动态规划（版本二，Python）"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: numerator = 1 denominator = m - 1 count = m - 1 t = m + n - 2 while count > 0: numerator *= t t -= 1 while denominator != 0 and numerator % denominator == 0: numerator //= denominator denominator -= 1 count -= 1 return numerator",
          "description": "数论方法（Python）"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "/**",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: int dfs(int i, int j, int m, int n) {if (i > m || j > n) return 0; if (i == m && j == n) return 1; return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);}public: int uniquePaths(int m, int n) {return dfs(1, 1, m, n);}};",
          "description": "深搜方法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {vector<vector<int>> dp(m, vector<int>(n, 0)); for (int i = 0; i < m; i++) dp[i][0] = 1; for (int j = 0; j < n; j++) dp[0][j] = 1; for (int i = 1; i < m; i++) {for (int j = 1; j < n; j++) {dp[i][j] = dp[i - 1][j] + dp[i][j - 1];}} return dp[m - 1][n - 1];}};",
          "description": "动态规划二维数组"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {vector<int> dp(n); for (int i = 0; i < n; i++) dp[i] = 1; for (int j = 1; j < m; j++) {for (int i = 1; i < n; i++) {dp[i] += dp[i - 1];}} return dp[n - 1];}};",
          "description": "动态规划一维数组"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {long long numerator = 1; int denominator = m - 1; int count = m - 1; int t = m + n - 2; while (count--) {numerator *= (t--); while (denominator != 0 && numerator % denominator == 0) {numerator /= denominator; denominator--;}} return numerator;}};",
          "description": "数论方法"
        },
        {
          "language": "java",
          "code": "public class Solution {public static int uniquePaths(int m, int n) {int[][] dp = new int[m][n]; for (int i = 0; i < m; i++) {dp[i][0] = 1;} for (int i = 0; i < n; i++) {dp[0][i] = 1;} for (int i = 1; i < m; i++) {for (int j = 1; j < n; j++) {dp[i][j] = dp[i-1][j]+dp[i][j-1];}} return dp[m-1][n-1];}}",
          "description": "Java 动态规划二维数组"
        },
        {
          "language": "java",
          "code": "class Solution {public int uniquePaths(int m, int n) {int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i < m; i ++) {for (int j = 1; j < n; j ++) {dp[j] += dp[j - 1];}} return dp[n - 1];}}",
          "description": "Java 动态规划一维数组"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: if m == 1 or n == 1: return 1 return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)",
          "description": "Python 递归"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]",
          "description": "Python 动态规划二维数组"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [1] * n for j in range(1, m): for i in range(1, n): dp[i] += dp[i - 1] return dp[n - 1]",
          "description": "Python 动态规划一维数组"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: numerator = 1 denominator = m - 1 count = m - 1 t = m + n - 2 while count > 0: numerator *= t t -= 1 while denominator != 0 and numerator % denominator == 0: numerator //= denominator denominator -= 1 count -= 1 return numerator",
          "description": "Python 数论方法"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "递归",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: int dfs(int i, int j, int m, int n) {if (i > m || j > n) return 0; if (i == m && j == n) return 1; return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);}public: int uniquePaths(int m, int n) {return dfs(1, 1, m, n);}};",
          "description": "使用深度优先搜索解决不同路径问题，但会超时。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {vector<vector<int>> dp(m, vector<int>(n, 0)); for (int i = 0; i < m; i++) dp[i][0] = 1; for (int j = 0; j < n; j++) dp[0][j] = 1; for (int i = 1; i < m; i++) {for (int j = 1; j < n; j++) {dp[i][j] = dp[i - 1][j] + dp[i][j - 1];}} return dp[m - 1][n - 1];}};",
          "description": "使用二维动态规划数组解决不同路径问题。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {vector<int> dp(n); for (int i = 0; i < n; i++) dp[i] = 1; for (int j = 1; j < m; j++) {for (int i = 1; i < n; i++) {dp[i] += dp[i - 1];}} return dp[n - 1];}};",
          "description": "使用一维动态规划数组（滚动数组）解决不同路径问题。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int uniquePaths(int m, int n) {long long numerator = 1; int denominator = m - 1; int count = m - 1; int t = m + n - 2; while (count--) {numerator *= (t--); while (denominator != 0 && numerator % denominator == 0) {numerator /= denominator; denominator--;}} return numerator;}};",
          "description": "使用组合数学方法解决不同路径问题，注意处理整数溢出。"
        },
        {
          "language": "java",
          "code": "public static int uniquePaths(int m, int n) {int[][] dp = new int[m][n]; for (int i = 0; i < m; i++) {dp[i][0] = 1;} for (int i = 0; i < n; i++) {dp[0][i] = 1;} for (int i = 1; i < m; i++) {for (int j = 1; j < n; j++) {dp[i][j] = dp[i-1][j]+dp[i][j-1];}} return dp[m-1][n-1];}",
          "description": "Java实现的二维动态规划解法。"
        },
        {
          "language": "java",
          "code": "public int uniquePaths(int m, int n) {int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i < m; i ++) {for (int j = 1; j < n; j ++) {dp[j] += dp[j - 1];}} return dp[n - 1];}",
          "description": "Java实现的一维动态规划（滚动数组）解法。"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: if m == 1 or n == 1: return 1 return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)",
          "description": "Python实现的递归解法。"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]",
          "description": "Python实现的二维动态规划解法。"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [1] * n for j in range(1, m): for i in range(1, n): dp[i] += dp[i - 1] return dp[n - 1]",
          "description": "Python实现的一维动态规划（滚动数组）解法。"
        },
        {
          "language": "python",
          "code": "class Solution: def uniquePaths(self, m: int, n: int) -> int: numerator = 1 denominator = m - 1 count = m - 1 t = m + n - 2 while count > 0: numerator *= t t -= 1 while denominator != 0 and numerator % denominator == 0: numerator //= denominator denominator -= 1 count -= 1 return numerator",
          "description": "Python实现的组合数学解法。"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(m × n)",
    "space_complexity": "O(m × n)",
    "explanation": "这个深搜的算法，其实就是要遍历整个二叉树。"
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {\nprivate:\n    int dfs(int i, int j, int m, int n) {\n        if (i > m || j > n) return 0; // 越界了\n        if (i == m && j == n) return 1; // 找到一种方法，相当于找到了叶子节点\n        return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);\n    }\npublic:\n    int uniquePaths(int m, int n) {\n        return dfs(1, 1, m, n);\n    }\n};",
      "description": "使用深度优先搜索计算不同路径"
    },
    {
      "language": "cpp",
      "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n, 0));\n        for (int i = 0; i < m; i++) dp[i][0] = 1;\n        for (int j = 0; j < n; j++) dp[0][j] = 1;\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};",
      "description": "使用二维动态规划计算不同路径"
    },
    {
      "language": "cpp",
      "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> dp(n);\n        for (int i = 0; i < n; i++) dp[i] = 1;\n        for (int j = 1; j < m; j++) {\n            for (int i = 1; i < n; i++) {\n                dp[i] += dp[i - 1];\n            }\n        }\n        return dp[n - 1];\n    }\n};",
      "description": "使用一维动态规划（滚动数组）计算不同路径"
    },
    {
      "language": "cpp",
      "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        long long numerator = 1; // 分子\n        int denominator = m - 1; // 分母\n        int count = m - 1;\n        int t = m + n - 2;\n        while (count--) {\n            numerator *= (t--);\n            while (denominator != 0 && numerator % denominator == 0) {\n                numerator /= denominator;\n                denominator--;\n            }\n        }\n        return numerator;\n    }\n};",
      "description": "使用数论方法计算组合问题来确定不同路径"
    },
    {
      "language": "java",
      "code": "public static int uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        dp[i][0] = 1;\n    }\n    for (int i = 0; i < n; i++) {\n        dp[0][i] = 1;\n    }\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = dp[i-1][j]+dp[i][j-1];\n        }\n    }\n    return dp[m-1][n-1];\n}",
      "description": "Java实现的二维动态规划算法"
    },
    {
      "language": "java",
      "code": "public int uniquePaths(int m, int n) {\n    int[] dp = new int[n];\n    Arrays.fill(dp, 1);\n    for (int i = 1; i < m; i ++) {\n        for (int j = 1; j < n; j ++) {\n            dp[j] += dp[j - 1];\n        }\n    }\n    return dp[n - 1];\n}",
      "description": "Java实现的一维动态规划（状态压缩）算法"
    },
    {
      "language": "python",
      "code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        if m == 1 or n == 1:\n            return 1\n        return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)",
      "description": "Python递归实现的不同路径计算"
    },
    {
      "language": "python",
      "code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m - 1][n - 1]",
      "description": "Python二维动态规划实现的不同路径计算"
    },
    {
      "language": "python",
      "code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [1] * n\n        for j in range(1, m):\n            for i in range(1, n):\n                dp[i] += dp[i - 1]\n        return dp[n - 1]",
      "description": "Python一维动态规划实现的不同路径计算"
    },
    {
      "language": "python",
      "code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        numerator = 1\n        denominator = m - 1\n        count = m - 1\n        t = m + n - 2\n        while count > 0:\n            numerator *= t\n            t -= 1\n            while denominator != 0 and numerator % denominator == 0:\n                numerator //= denominator\n                denominator -= 1\n            count -= 1\n        return numerator",
      "description": "Python数论方法实现的不同路径计算"
    }
  ],
  "common_mistakes": [
    "直接使用递归或深搜可能导致时间复杂度过高而超时。",
    "在计算组合数时如果先计算整个分子再除以分母可能会引起整数溢出。",
    "初始化DP数组时忽略了边界条件，特别是首行和首列的初始化。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210110174033215.png",
      "description": "这是一个网格路径寻找问题，从起点（Start）到终点（Finish）的最短路径可以通过广度优先搜索（BFS）算法来解决。",
      "context": "该图片展示了当网格大小为3x7时，从左上角\"Start\"到右下角\"Finish\"的一个示例布局，用于帮助理解机器人寻找不同路径到达终点的问题设定。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20201209113602700.png",
      "description": "该图展示了将一个2x2网格路径问题（从起点到终点）转化为二叉树结构的过程，用于算法分析和解题。",
      "context": "该图片展示了机器人从起点到终点的所有可能路径，帮助理解如何将问题转化为计算二叉树叶子节点数量的问题。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20201209113631392.png",
      "description": "该图片展示了使用动态规划（DP）算法解决路径计数问题的过程，具体为在3x7的网格中找到从左上角到右下角的不同路径数量。",
      "context": "这张图片展示了dp数组的具体推导过程，帮助理解如何通过递推公式从左至右、从上到下逐层计算数组值。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20201209113602700-20230310120944078.png",
      "description": "该图片展示了将一个2x2网格路径问题（起点到终点）转化为二叉树结构的过程，用于算法分析和解题。",
      "context": "这张图片展示了在一个m×n网格中从起点到终点所需步数的概念，即无论采取何种路径，总步数固定为m+n-2步。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20201209113725324.png",
      "description": "图片展示了组合数学中的一个表达式 \\( C_{m+n-2}^{m-1} \\)，常用于算法路径问题的解题过程中，右侧标注了“代码随想录”的标志。",
      "context": "图片展示了如何通过组合数学的方法计算从起点到终点的不同路径数，直接对应了解决m+n-2步中选择m-1步向下走的方案数问题。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210110174033215.png",
      "description": "GIF展示了机器人在m x n网格中从左上角到右下角移动的所有可能路径。",
      "context": "GIF动画展示了在给定的m x n网格中，从左上角到右下角的不同路径示例。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20201209113602700.png",
      "description": "GIF展示了通过深度优先搜索方法寻找从网格左上角到右下角所有可能路径的过程。",
      "context": "GIF动画展示了如何将机器人从起点到终点的所有可能移动路径抽象为一棵二叉树结构，帮助理解通过深度优先搜索计算路径总数的方法。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20201209113631392.png",
      "description": "GIF展示了动态规划算法中dp数组如何根据递推公式逐步填充的过程。",
      "context": "该GIF动画展示了如何根据递推公式逐步填充dp数组来计算从起点到任意点的不同路径数量。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20201209113602700-20230310120944078.png",
      "description": "GIF展示了在m×n网格中从起点到终点所有可能路径的动态生成过程。",
      "context": "该GIF动画展示了在一个m×n的网格中，从起点到终点共有m+n-2步的不同路径组合方式。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20201209113725324.png",
      "description": "GIF展示了通过组合数学方法计算从起点到终点不同路径数的过程。",
      "context": "该GIF动画展示了如何通过组合数学的方法计算从起点到终点的不同路径总数，直接对应于文本中提到的组合问题解决方案。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\不同路径.txt",
  "extracted_at": "2025-07-20T12:31:36.480215",
  "raw_content": "不同路径\n力扣题目链接(https://leetcode.cn/problems/unique-paths/)\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n示例 1：\n\nhttps://file1.kamacoder.com/i/algo/20210110174033215.png\n\n输入：m = 3, n = 7\n输出：28\n示例 2：\n\n输入：m = 2, n = 3\n输出：3\n解释： 从左上角开始，总共有 3 条路径可以到达右下角。\n\n向右 -> 向右 -> 向下\n向右 -> 向下 -> 向右\n向下 -> 向右 -> 向右\n示例 3：\n\n输入：m = 7, n = 3\n输出：28\n示例 4：\n\n输入：m = 3, n = 3\n输出：6\n提示：\n\n1 <= m, n <= 100\n题目数据保证答案小于等于 2 * 10^9\n\n\n#思路\n#深搜\n这道题目，刚一看最直观的想法就是用图论里的深搜，来枚举出来有多少种路径。\n\n注意题目中说机器人每次只能向下或者向右移动一步，那么其实机器人走过的路径可以抽象为一棵二叉树，而叶子节点就是终点！\n\n如图举例：\n\nhttps://file1.kamacoder.com/i/algo/20201209113602700.png\n\n此时问题就可以转化为求二叉树叶子节点的个数，代码如下：\n\nclass Solution {\nprivate:\n    int dfs(int i, int j, int m, int n) {\n        if (i > m || j > n) return 0; // 越界了\n        if (i == m && j == n) return 1; // 找到一种方法，相当于找到了叶子节点\n        return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);\n    }\npublic:\n    int uniquePaths(int m, int n) {\n        return dfs(1, 1, m, n);\n    }\n};\n大家如果提交了代码就会发现超时了！\n\n来分析一下时间复杂度，这个深搜的算法，其实就是要遍历整个二叉树。\n\n这棵树的深度其实就是m+n-1（深度按从1开始计算）。\n\n那二叉树的节点个数就是 2^(m + n - 1) - 1。可以理解深搜的算法就是遍历了整个满二叉树（其实没有遍历整个满二叉树，只是近似而已）\n\n所以上面深搜代码的时间复杂度为O(2^(m + n - 1) - 1)，可以看出，这是指数级别的时间复杂度，是非常大的。\n\n#动态规划\n机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。\n\n按照动规五部曲来分析：\n\n确定dp数组（dp table）以及下标的含义\ndp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。\n\n确定递推公式\n想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。\n\n此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。\n\n那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。\n\ndp数组的初始化\n如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。\n\n所以初始化代码为：\n\nfor (int i = 0; i < m; i++) dp[i][0] = 1;\nfor (int j = 0; j < n; j++) dp[0][j] = 1;\n确定遍历顺序\n这里要看一下递推公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。\n\n这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。\n\n举例推导dp数组\n如图所示：\n\nhttps://file1.kamacoder.com/i/algo/20201209113631392.png\n\n以上动规五部曲分析完毕，C++代码如下：\n\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n, 0));\n        for (int i = 0; i < m; i++) dp[i][0] = 1;\n        for (int j = 0; j < n; j++) dp[0][j] = 1;\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n时间复杂度：O(m × n)\n空间复杂度：O(m × n)\n其实用一个一维数组（也可以理解是滚动数组）就可以了，但是不利于理解，可以优化点空间，建议先理解了二维，在理解一维，C++代码如下：\n\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> dp(n);\n        for (int i = 0; i < n; i++) dp[i] = 1;\n        for (int j = 1; j < m; j++) {\n            for (int i = 1; i < n; i++) {\n                dp[i] += dp[i - 1];\n            }\n        }\n        return dp[n - 1];\n    }\n};\n时间复杂度：O(m × n)\n空间复杂度：O(n)\n#数论方法\n在这个图中，可以看出一共m，n的话，无论怎么走，走到终点都需要 m + n - 2 步。\n\nhttps://file1.kamacoder.com/i/algo/20201209113602700-20230310120944078.png\n\n在这m + n - 2 步中，一定有 m - 1 步是要向下走的，不用管什么时候向下走。\n\n那么有几种走法呢？ 可以转化为，给你m + n - 2个不同的数，随便取m - 1个数，有几种取法。\n\n那么这就是一个组合问题了。\n\n那么答案，如图所示：\n\nhttps://file1.kamacoder.com/i/algo/20201209113725324.png\n\n求组合的时候，要防止两个int相乘溢出！ 所以不能把算式的分子都算出来，分母都算出来再做除法。\n\n例如如下代码是不行的。\n\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        int numerator = 1, denominator = 1;\n        int count = m - 1;\n        int t = m + n - 2;\n        while (count--) numerator *= (t--); // 计算分子，此时分子就会溢出\n        for (int i = 1; i <= m - 1; i++) denominator *= i; // 计算分母\n        return numerator / denominator;\n    }\n};\n\n需要在计算分子的时候，不断除以分母，代码如下：\n\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        long long numerator = 1; // 分子\n        int denominator = m - 1; // 分母\n        int count = m - 1;\n        int t = m + n - 2;\n        while (count--) {\n            numerator *= (t--);\n            while (denominator != 0 && numerator % denominator == 0) {\n                numerator /= denominator;\n                denominator--;\n            }\n        }\n        return numerator;\n    }\n};\n时间复杂度：O(m)\n空间复杂度：O(1)\n计算组合问题的代码还是有难度的，特别是处理溢出的情况！\n\n#总结\n本文分别给出了深搜，动规，数论三种方法。\n\n深搜当然是超时了，顺便分析了一下使用深搜的时间复杂度，就可以看出为什么超时了。\n\n然后在给出动规的方法，依然是使用动规五部曲，这次我们就要考虑如何正确的初始化了，初始化和遍历顺序其实也很重要！\n\n#其他语言版本\n#Java\n  /**\n     * 1. 确定dp数组下标含义 dp[i][j] 到每一个坐标可能的路径种类\n     * 2. 递推公式 dp[i][j] = dp[i-1][j] dp[i][j-1]\n     * 3. 初始化 dp[i][0]=1 dp[0][i]=1 初始化横竖就可\n     * 4. 遍历顺序 一行一行遍历\n     * 5. 推导结果 。。。。。。。。\n     *\n     * @param m\n     * @param n\n     * @return\n     */\n    public static int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        //初始化\n        for (int i = 0; i < m; i++) {\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i < n; i++) {\n            dp[0][i] = 1;\n        }\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i-1][j]+dp[i][j-1];\n            }\n        }\n        return dp[m-1][n-1];\n    }\n\n状态压缩\n\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        // 在二维dp数组中，当前值的计算只依赖正上方和正左方，因此可以压缩成一维数组。\n        int[] dp = new int[n];\n        // 初始化，第一行只能从正左方跳过来，所以只有一条路径。\n        Arrays.fill(dp, 1);\n        for (int i = 1; i < m; i ++) {\n            // 第一列也只有一条路，不用迭代，所以从第二列开始\n            for (int j = 1; j < n; j ++) {\n                dp[j] += dp[j - 1]; // dp[j] = dp[j] (正上方)+ dp[j - 1] (正左方)\n            }\n        }\n        return dp[n - 1];\n    }\n}\n#Python\n递归\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        if m == 1 or n == 1:\n            return 1\n        return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)\n\n动态规划（版本一）\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        # 创建一个二维列表用于存储唯一路径数\n        dp = [[0] * n for _ in range(m)]\n        \n        # 设置第一行和第一列的基本情况\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        \n        # 计算每个单元格的唯一路径数\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        # 返回右下角单元格的唯一路径数\n        return dp[m - 1][n - 1]\n\n动态规划（版本二）\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        # 创建一个一维列表用于存储每列的唯一路径数\n        dp = [1] * n\n        \n        # 计算每个单元格的唯一路径数\n        for j in range(1, m):\n            for i in range(1, n):\n                dp[i] += dp[i - 1]\n        \n        # 返回右下角单元格的唯一路径数\n        return dp[n - 1]\n数论\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        numerator = 1  # 分子\n        denominator = m - 1  # 分母\n        count = m - 1  # 计数器，表示剩余需要计算的乘积项个数\n        t = m + n - 2  # 初始乘积项\n        while count > 0:\n            numerator *= t  # 计算乘积项的分子部分\n            t -= 1  # 递减乘积项\n            while denominator != 0 and numerator % denominator == 0:\n                numerator //= denominator  # 约简分子\n                denominator -= 1  # 递减分母\n            count -= 1  # 计数器减1，继续下一项的计算\n        return numerator  # 返回最终的唯一路径数"
}