{
  "id": "AP_c16a4aca",
  "title": "dijkstra（堆优化版）精讲",
  "alternative_titles": [],
  "platform": "kamacoder",
  "url": "https://kamacoder.com/problempage.php?pid=1047",
  "description": "",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "Dijkstra算法",
    "图论"
  ],
  "data_structure_tags": [
    "邻接表",
    "优先队列"
  ],
  "technique_tags": [
    "堆优化",
    "图存储"
  ],
  "difficulty": null,
  "solution_approach": "采用堆优化版Dijkstra算法解决单源最短路径问题。首先，使用邻接表存储图结构以节省空间和提高效率。然后，利用优先队列（小顶堆）来动态选取当前距离源点最近的未访问节点，并更新其邻居节点到源点的距离。",
  "key_insights": [
    {
      "content": "通过改变数据结构的选择，即从邻接矩阵改为邻接表，并结合优先队列，可以有效减少在稀疏图中寻找最短路径时的时间复杂度。"
    },
    {
      "content": "利用小顶堆自动维护当前最小距离的节点，避免了朴素Dijkstra算法中每次都要遍历所有节点以找到下一个处理节点的过程，从而提高了效率。"
    },
    {
      "content": "选择合适的图存储方式对于算法性能至关重要，尤其是在处理大规模稀疏图时，邻接表比邻接矩阵更优。"
    },
    {
      "content": "将边的信息存储于优先队列中，使得每次都能快速选出距离源点最近的边，进而确定下一步要处理的节点，极大提升了算法运行效率。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "本篇我们来讲解 堆优化版dijkstra，看本篇之前，一定要先看 我讲解的 朴素版dijkstra，否则本篇会有部分内容看不懂。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用C++实现的堆优化Dijkstra算法"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "使用Java实现的堆优化Dijkstra算法"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "使用Python实现的堆优化Dijkstra算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "图的存储",
      "text": "首先是 图的存储。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用C++实现的Dijkstra算法堆优化版本"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "使用Java实现的Dijkstra算法堆优化版本"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "使用Python实现的Dijkstra算法堆优化版本"
        }
      ],
      "subsections": []
    },
    {
      "name": "邻接矩阵",
      "text": "邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n\n    // 优先队列中存放 pair<节点，源点到该节点的权值>\npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++邻接表版本的Dijkstra算法"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    // 优先队列中存放 pair<节点，源点到该节点的距离>\npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0));\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // <节点， 源点到该节点的距离>\n        // 1、选距离源点最近且未访问过的节点\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        visited[cur.first] = true; // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int j = 1; j <= n; j++) {\n            if (!visited[j] && grid[cur.first][j] != INT_MAX && (minDist[cur.first] + grid[cur.first][j] < minDist[j])) {\n                minDist[j] = minDist[cur.first] + grid[cur.first][j];\n                pq.push(pair<int, int>(j, minDist[j]));\n            }\n        }\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++邻接矩阵版本的Dijkstra算法"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java邻接表版本的Dijkstra算法"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python邻接表版本的Dijkstra算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "邻接表",
      "text": "邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n\n    // 优先队列中存放 pair<节点，源点到该节点的权值>\npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用邻接表存储图的堆优化Dijkstra算法"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的堆优化Dijkstra算法使用邻接表存储图"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python版本的堆优化Dijkstra算法使用邻接表存储图"
        }
      ],
      "subsections": []
    },
    {
      "name": "本题图的存储",
      "text": "接下来我们继续按照稀疏图的角度来分析本题。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用C++实现基于邻接表和小顶堆优化的Dijkstra算法求解最短路径问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\n\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\n\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "使用Java实现基于邻接表和小顶堆优化的Dijkstra算法求解最短路径问题。"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "使用Python实现基于邻接表和小顶堆优化的Dijkstra算法求解最短路径问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "堆优化细节",
      "text": "其实思路依然是 dijkstra 三部曲：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n    vector<list<Edge>> grid(n + 1);\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n    vector<int> minDist(n + 1, INT_MAX);\n    vector<bool> visited(n + 1, false); \n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n    pq.push(pair<int, int>(start, 0)); \n    minDist[start] = 0;  // 起始点到自身的距离为0\n    while (!pq.empty()) {\n        pair<int, int> cur = pq.top(); pq.pop();\n        if (visited[cur.first]) continue;\n        visited[cur.first] = true;\n        for (Edge edge : grid[cur.first]) { \n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { \n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << -1 << endl; else cout << minDist[end] << endl; }",
          "description": "C++堆优化版Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n        int start = 1;  // 起点\n        int end = n;    // 终点\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        boolean[] visited = new boolean[n + 1];\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n        pq.add(new Pair<>(start, 0));\n        minDist[start] = 0;  // 起始点到自身的距离为0\n        while (!pq.isEmpty()) {\n            Pair<Integer, Integer> cur = pq.poll();\n            if (visited[cur.first]) continue;\n            visited[cur.first] = true;\n            for (Edge edge : grid.get(cur.first)) { \n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { \n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); \n        } else {\n            System.out.println(minDist[end]); \n        }\n    }\n}",
          "description": "Java堆优化版Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n        if visited[cur_node]:\n            continue\n        visited[cur_node] = True\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n    return -1 if minDist[end] == float('inf') else minDist[end]\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python堆优化版Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "代码实现",
      "text": "堆优化dijkstra完整代码如下：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的堆优化Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的堆优化Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python版本的堆优化Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Dijkstra算法，使用邻接表和优先队列实现。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法，使用邻接表和优先队列实现。"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python版本的Dijkstra算法，使用邻接表和堆实现。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本使用邻接表和小顶堆优化的Dijkstra算法"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本使用邻接表和小顶堆优化的Dijkstra算法"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python版本使用邻接表和小顶堆优化的Dijkstra算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <list>",
      "text": "#include <queue>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++ 实现使用邻接表存储图并利用Dijkstra算法计算最短路径"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java 实现使用邻接表存储图并利用Dijkstra算法计算最短路径"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python 实现使用邻接表存储图并利用Dijkstra算法计算最短路径"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <queue>",
      "text": "#include <climits>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用C++实现的基于邻接表和小顶堆优化的Dijkstra算法"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "使用Java实现的基于邻接表和小顶堆优化的Dijkstra算法"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "使用Python实现的基于邻接表和小顶堆优化的Dijkstra算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++ Dijkstra算法堆优化版本"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java Dijkstra算法堆优化版本"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python Dijkstra算法堆优化版本"
        }
      ],
      "subsections": []
    },
    {
      "name": "拓展",
      "text": "当然也有录友可能想 堆优化dijkstra 中 我为什么一定要用邻接表呢，我就用邻接矩阵 行不行 ？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++邻接表版本的Dijkstra算法"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java邻接表版本的Dijkstra算法"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python邻接表版本的Dijkstra算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用C++实现的Dijkstra算法（堆优化版），利用邻接表存储图，并通过优先队列选择当前最短路径。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "使用Java实现的Dijkstra算法（堆优化版），采用邻接表存储图结构，并通过优先队列找到当前最优解。"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python版本的Dijkstra算法（堆优化版），通过heapq模块实现了优先队列以加速处理过程，使用列表推导式构建邻接表。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n    vector<list<Edge>> grid(n + 1);\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start = 1;  // 起点\n    int end = n;    // 终点\n    vector<int> minDist(n + 1, INT_MAX);\n    vector<bool> visited(n + 1, false); \n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n    pq.push(pair<int, int>(start, 0)); \n    minDist[start] = 0;  \n    while (!pq.empty()) {\n        pair<int, int> cur = pq.top(); pq.pop();\n        if (visited[cur.first]) continue;\n        visited[cur.first] = true;\n        for (Edge edge : grid[cur.first]) { \n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { \n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << -1 << endl; \n    else cout << minDist[end] << endl; \n}",
          "description": "堆优化Dijkstra算法（C++实现）"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n        int start = 1;  // 起点\n        int end = n;    // 终点\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        boolean[] visited = new boolean[n + 1];\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n        pq.add(new Pair<>(start, 0));\n        minDist[start] = 0;  \n        while (!pq.isEmpty()) {\n            Pair<Integer, Integer> cur = pq.poll();\n            if (visited[cur.first]) continue;\n            visited[cur.first] = true;\n            for (Edge edge : grid.get(cur.first)) { \n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { \n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); \n        } else {\n            System.out.println(minDist[end]); \n        }\n    }\n}",
          "description": "堆优化Dijkstra算法（Java实现）"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n        if visited[cur_node]:\n            continue\n        visited[cur_node] = True\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n    return -1 if minDist[end] == float('inf') else minDist[end]\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "堆优化Dijkstra算法（Python实现）"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <list>",
      "text": "#include <queue>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的堆优化Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的堆优化Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python版本的堆优化Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++语言实现的Dijkstra算法堆优化版本"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java语言实现的Dijkstra算法堆优化版本"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python语言实现的Dijkstra算法堆优化版本"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "在学习一种优化思路的时候，首先就要知道为什么要优化，遇到了什么问题。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Dijkstra算法，使用邻接表存储图和小顶堆优化。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法，同样采用了邻接表和小顶堆进行优化。"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python版本实现了Dijkstra算法，利用了heapq作为优先队列，邻接表存储图。"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "c++",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Dijkstra算法，使用邻接表存储图，并采用小顶堆优化。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法，同样采用邻接表存储图和小顶堆进行优化。"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python版本的Dijkstra算法实现，利用了heapq库提供的优先队列功能来进行堆优化。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "import java.util.*;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用C++实现的Dijkstra算法（堆优化版），采用邻接表存储图。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\n\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\n\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "使用Java实现的Dijkstra算法（堆优化版），采用邻接表存储图。"
        },
        {
          "language": "python",
          "code": "import heapq\n\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\n\n\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "使用Python实现的Dijkstra算法（堆优化版），采用邻接表存储图。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "import heapq",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
          "description": "Python版本的Dijkstra算法实现"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(ElogE)",
    "space_complexity": "O(N + E)",
    "explanation": "可以看出时间复杂度 只和 n （节点数量）有关系。"
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
      "description": "C++版本的Dijkstra算法使用邻接表存储图，并利用小顶堆优化。"
    },
    {
      "language": "java",
      "code": "import java.util.*;\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
      "description": "Java版本的Dijkstra算法使用邻接表存储图，并利用小顶堆优化。"
    },
    {
      "language": "python",
      "code": "import heapq\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)",
      "description": "Python版本的Dijkstra算法使用邻接表存储图，并利用小顶堆优化。"
    }
  ],
  "common_mistakes": [
    "错误地假设图总是稠密的，导致选择了不适合的数据结构。",
    "忽略了图可能为稀疏图的情况，没有考虑使用更高效的空间和时间策略。",
    "在实现邻接表时，未能正确处理带权值的边。",
    "忘记初始化距离数组或设置不正确的初始值。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240227101345.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20240227101345.png",
      "context": "该图展示了从1号车站到7号车站的最短路径，其中绿色路线表示最小时间花费为12单位的最优解路径。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240227101401.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20240227101401.png",
      "context": "此图展示了当从起始车站无法到达终点车站时的情景，用于说明在这种情况下应输出-1。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240222110025.png",
      "description": "这张图片展示了一个二维网格，其中包含两个值为6的单元格，可用于算法中的路径查找或数据结构中的矩阵操作分析。",
      "context": "该图展示了在一个8节点的图中，如何使用邻接矩阵表示一条双向边（grid[2][5] = 6, grid[5][2] = 6），以及由此带来的空间利用情况。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240223103713.png",
      "description": "这张图片展示了数组与链表两种数据结构的对比，其中数组元素通过索引直接访问，而链表元素通过指针链接形成序列。",
      "context": "这张图片展示了使用邻接表（数组+链表）方式表示图结构的具体例子，其中详细描绘了节点间的连接关系。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240223103904.png",
      "description": "这张图片展示了数组与链表结合的数据结构，其中数组的每个元素指向一个链表，链表中的节点存储键值对，体现了哈希表或图的邻接表表示法。",
      "context": "该图片展示了通过使用`vector<list<pair<int, int>>> grid(n + 1);`代码结构来表示的图中各个节点之间的连接关系及其对应的边权值。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240227101345.png",
      "description": "GIF展示了从起点到终点寻找最短路径的过程，通过不断更新各车站之间的最短时间直到找到从1号车站到7号车站的最小花费时间为12。",
      "context": "GIF动画展示了使用堆优化版Dijkstra算法找到从起点1到终点7的最短路径过程，其中绿色路线代表了计算出的最短路径。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240227101401.png",
      "description": "GIF展示了从起点到终点不可达的情况，通过动画形式逐步探索路径直至确定不存在可达路线。",
      "context": "该GIF动画展示了当从起始车站不能到达终点车站时，算法输出-1的情况。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240222110025.png",
      "description": "GIF展示了在一个8节点图中，使用邻接矩阵表示法添加一条双向边的过程。",
      "context": "该GIF动画展示了在一个8节点图中，通过邻接矩阵方式表示节点2与节点5之间存在一条权值为6的双向边的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240223103713.png",
      "description": "GIF展示了使用邻接表表示的图结构中节点与边的链接情况。",
      "context": "该GIF动画展示了如何使用数组加链表结构来构建邻接表，以直观地表示图中节点之间的连接关系。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240223103904.png",
      "description": "GIF展示了有向图中各节点及其指向关系，并标注了每条边的权值。",
      "context": "GIF动画展示了如何使用`vector<list<pair<int, int>>>`结构来表示一个带权图，其中每个节点指向其他节点并附有权值。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\最短路\\参加科学大会_dijkstra堆优化版.txt",
  "extracted_at": "2025-07-22T11:04:43.133187",
  "raw_content": "dijkstra（堆优化版）精讲\n卡码网：47. 参加科学大会(https://kamacoder.com/problempage.php?pid=1047)\n\n【题目描述】\n\n小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。\n\n小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。\n\n小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。\n\n【输入描述】\n\n第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。\n\n接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。\n\n【输出描述】\n\n输出一个整数，代表小明从起点到终点所花费的最小时间。\n\n输入示例\n\n7 9\n1 2 1\n1 3 4\n2 3 2\n2 4 5\n3 4 2\n4 5 3\n2 6 4\n5 7 4\n6 7 9\n输出示例：12\n\n【提示信息】\n\n能够到达的情况：\n\n如下图所示，起始车站为 1 号车站，终点车站为 7 号车站，绿色路线为最短的路线，路线总长度为 12，则输出 12。\n\nhttps://file1.kamacoder.com/i/algo/20240227101345.png\n\n不能到达的情况：\n\n如下图所示，当从起始车站不能到达终点车站时，则输出 -1。\nhttps://file1.kamacoder.com/i/algo/20240227101401.png\n\n\n数据范围：\n\n1 <= N <= 500; 1 <= M <= 5000;\n\n#思路\n本篇我们来讲解 堆优化版dijkstra，看本篇之前，一定要先看 我讲解的 朴素版dijkstra，否则本篇会有部分内容看不懂。\n\n在上一篇中，我们讲解了朴素版的dijkstra，该解法的时间复杂度为 O(n^2)，可以看出时间复杂度 只和 n （节点数量）有关系。\n\n如果n很大的话，我们可以换一个角度来优先性能。\n\n在 讲解 最小生成树的时候，我们 讲了两个算法，prim算法（从点的角度来求最小生成树）、Kruskal算法（从边的角度来求最小生成树）\n\n这么在n 很大的时候，也有另一个思考维度，即：从边的数量出发。\n\n当 n 很大，边 的数量 也很多的时候（稠密图），那么 上述解法没问题。\n\n但 n 很大，边 的数量 很小的时候（稀疏图），是不是可以换成从边的角度来求最短路呢？\n\n毕竟边的数量少。\n\n有的录友可能会想，n （节点数量）很大，边不就多吗？ 怎么会边的数量少呢？\n\n别忘了，谁也没有规定 节点之间一定要有边连接着，例如有一万个节点，只有一条边，这也是一张图。\n\n了解背景之后，再来看 解法思路。\n\n#图的存储\n首先是 图的存储。\n\n关于图的存储 主流有两种方式： 邻接矩阵和邻接表\n\n#邻接矩阵\n邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。\n\n例如： grid[2][5] = 6，表示 节点 2 链接 节点5 为有向图，节点2 指向 节点5，边的权值为6 （套在题意里，可能是距离为6 或者 消耗为6 等等）\n\n如果想表示无向图，即：grid[2][5] = 6，grid[5][2] = 6，表示节点2 与 节点5 相互连通，权值为6。\n\n如图：\n\nhttps://file1.kamacoder.com/i/algo/20240222110025.png\n\n在一个 n （节点数）为8 的图中，就需要申请 8 * 8 这么大的空间，有一条双向边，即：grid[2][5] = 6，grid[5][2] = 6\n\n这种表达方式（邻接矩阵） 在 边少，节点多的情况下，会导致申请过大的二维数组，造成空间浪费。\n\n而且在寻找节点链接情况的时候，需要遍历整个矩阵，即 n * n 的时间复杂度，同样造成时间浪费。\n\n邻接矩阵的优点：\n\n表达方式简单，易于理解\n检查任意两个顶点间是否存在边的操作非常快\n适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。\n缺点：\n\n遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费\n#邻接表\n邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。\n\n邻接表的构造如图：\n\nhttps://file1.kamacoder.com/i/algo/20240223103713.png\n\n这里表达的图是：\n\n节点1 指向 节点3 和 节点5\n节点2 指向 节点4、节点3、节点5\n节点3 指向 节点4，节点4指向节点1。\n有多少边 邻接表才会申请多少个对应的链表节点。\n\n从图中可以直观看出 使用 数组 + 链表 来表达 边的链接情况 。\n\n邻接表的优点：\n\n对于稀疏图的存储，只需要存储边，空间利用率高\n遍历节点链接情况相对容易\n缺点：\n\n检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点链接其他节点的数量。\n实现相对复杂，不易理解\n#本题图的存储\n接下来我们继续按照稀疏图的角度来分析本题。\n\n在第一个版本的实现思路中，我们提到了三部曲：\n\n第一步，选源点到哪个节点近且该节点未被访问过\n第二步，该最近节点被标记访问过\n第三步，更新非访问节点到源点的距离（即更新minDist数组）\n在第一个版本的代码中，这三部曲是套在一个 for 循环里，为什么？\n\n因为我们是从节点的角度来解决问题。\n\n三部曲中第一步（选源点到哪个节点近且该节点未被访问过），这个操作本身需要for循环遍历 minDist 来寻找最近的节点。\n\n同时我们需要 遍历所有 未访问过的节点，所以 我们从 节点角度出发，代码会有两层for循环，代码是这样的： （注意代码中的注释，标记两层for循环的用处）\n\n\nfor (int i = 1; i <= n; i++) { // 遍历所有节点，第一层for循环 \n\n    int minVal = INT_MAX;\n    int cur = 1;\n\n    // 1、选距离源点最近且未访问过的节点 ， 第二层for循环\n    for (int v = 1; v <= n; ++v) {\n        if (!visited[v] && minDist[v] < minVal) {\n            minVal = minDist[v];\n            cur = v;\n        }\n    }\n\n    visited[cur] = true;  // 2、标记该节点已被访问\n\n    // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n    for (int v = 1; v <= n; v++) {\n        if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n            minDist[v] = minDist[cur] + grid[cur][v];\n        }\n    }\n\n}\n那么当从 边 的角度出发， 在处理 三部曲里的第一步（选源点到哪个节点近且该节点未被访问过）的时候 ，我们可以不用去遍历所有节点了。\n\n而且 直接把 边（带权值）加入到 小顶堆（利用堆来自动排序），那么每次我们从 堆顶里 取出 边 自然就是 距离源点最近的节点所在的边。\n\n这样我们就不需要两层for循环来寻找最近的节点了。\n\n了解了大体思路，我们再来看代码实现。\n\n首先是 如何使用 邻接表来表述图结构，这是摆在很多录友面前的第一个难题。\n\n邻接表用 数组+链表 来表示，代码如下：（C++中 vector 为数组，list 为链表， 定义了 n+1 这么大的数组空间）\n\nvector<list<int>> grid(n + 1);\n不少录友，不知道 如何定义的数据结构，怎么表示邻接表的，我来给大家画一个图：\n\nhttps://file1.kamacoder.com/i/algo/20240223103713.png\n\n图中邻接表表示：\n\n节点1 指向 节点3 和 节点5\n节点2 指向 节点4、节点3、节点5\n节点3 指向 节点4\n节点4 指向 节点1\n大家发现图中的边没有权值，而本题中 我们的边是有权值的，权值怎么表示？在哪里表示？\n\n所以 在vector<list<int>> grid(n + 1); 中 就不能使用int了，而是需要一个键值对 来存两个数字，一个数表示节点，一个数表示 指向该节点的这条边的权值。\n\n那么 代码可以改成这样： （pair 为键值对，可以存放两个int）\n\nvector<list<pair<int,int>>> grid(n + 1);\n举例来给大家展示 该代码表达的数据 如下：\n\nhttps://file1.kamacoder.com/i/algo/20240223103904.png\n\n节点1 指向 节点3 权值为 1\n节点1 指向 节点5 权值为 2\n节点2 指向 节点4 权值为 7\n节点2 指向 节点3 权值为 6\n节点2 指向 节点5 权值为 3\n节点3 指向 节点4 权值为 3\n节点5 指向 节点1 权值为 10\n这样 我们就把图中权值表示出来了。\n\n但是在代码中 使用 pair<int, int> 很容易让我们搞混了，第一个int 表示什么，第二个int表示什么，导致代码可读性很差，或者说别人看你的代码看不懂。\n\n那么 可以 定一个类 来取代 pair<int, int>\n\n类（或者说是结构体）定义如下：\n\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n这个类里有两个成员变量，有对应的命名，这样不容易搞混 两个int的含义。\n\n所以 本题中邻接表的定义如下：\n\nstruct Edge {\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nvector<list<Edge>> grid(n + 1); // 邻接表\n\n（我们在下面的讲解中会直接使用这个邻接表的代码表示方式）\n\n#堆优化细节\n其实思路依然是 dijkstra 三部曲：\n\n第一步，选源点到哪个节点近且该节点未被访问过\n第二步，该最近节点被标记访问过\n第三步，更新非访问节点到源点的距离（即更新minDist数组）\n只不过之前是 通过遍历节点来遍历边，通过两层for循环来寻找距离源点最近节点。 这次我们直接遍历边，且通过堆来对边进行排序，达到直接选择距离源点最近节点。\n\n先来看一下针对这三部曲，如果用 堆来优化。\n\n那么三部曲中的第一步（选源点到哪个节点近且该节点未被访问过），我们如何选？\n\n我们要选择距离源点近的节点（即：该边的权值最小），所以 我们需要一个 小顶堆 来帮我们对边的权值排序，每次从小顶堆堆顶 取边就是权值最小的边。\n\nC++定义小顶堆，可以用优先级队列实现，代码如下：\n\n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 优先队列中存放 pair<节点编号，源点到该节点的权值> \npriority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n（pair<int, int>中 第二个int 为什么要存 源点到该节点的权值，因为 这个小顶堆需要按照权值来排序）\n\n有了小顶堆自动对边的权值排序，那我们只需要直接从 堆里取堆顶元素（小顶堆中，最小的权值在上面），就可以取到离源点最近的节点了 （未访问过的节点，不会加到堆里进行排序）\n\n所以三部曲中的第一步，我们不用 for循环去遍历，直接取堆顶元素：\n\n// pair<节点编号，源点到该节点的权值>\npair<int, int> cur = pq.top(); pq.pop();\n\n第二步（该最近节点被标记访问过） 这个就是将 节点做访问标记，和 朴素dijkstra 一样 ，代码如下：\n\n// 2. 第二步，该最近节点被标记访问过\nvisited[cur.first] = true;\n\n（cur.first 是指取 pair<int, int> 里的第一个int，即节点编号 ）\n\n第三步（更新非访问节点到源点的距离），这里的思路 也是 和朴素dijkstra一样的。\n\n但很多录友对这里是最懵的，主要是因为两点：\n\n没有理解透彻 dijkstra 的思路\n没有理解 邻接表的表达方式\n我们来回顾一下 朴素dijkstra 在这一步的代码和思路（如果没看过我讲解的朴素版dijkstra，这里会看不懂）\n\n\n// 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\nfor (int v = 1; v <= n; v++) {\n    if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n        minDist[v] = minDist[cur] + grid[cur][v];\n    }\n}\n其中 for循环是用来做什么的？ 是为了 找到 节点cur 链接指向了哪些节点，因为使用邻接矩阵的表达方式 所以把所有节点遍历一遍。\n\n而在邻接表中，我们可以以相对高效的方式知道一个节点链接指向哪些节点。\n\n再回顾一下邻接表的构造（数组 + 链表）：\n\nhttps://file1.kamacoder.com/i/algo/20240223103713.png\n\n假如 加入的cur 是节点 2， 那么 grid[2] 表示的就是图中第二行链表。 （grid数组的构造我们在 上面 「图的存储」中讲过）\n\n所以在邻接表中，我们要获取 节点cur 链接指向哪些节点，就是遍历 grid[cur节点编号] 这个链表。\n\n这个遍历方式，C++代码如下：\n\nfor (Edge edge : grid[cur.first]) \n（如果不知道 Edge 是什么，看上面「图的存储」中邻接表的讲解）\n\ncur.first 就是cur节点编号， 参考上面pair的定义： pair<节点编号，源点到该节点的权值>\n\n接下来就是更新 非访问节点到源点的距离，代码实现和 朴素dijkstra 是一样的，代码如下：\n\n// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\nfor (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n    // cur指向的节点edge.to，这条边的权值为 edge.val\n    if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n        minDist[edge.to] = minDist[cur.first] + edge.val;\n        pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n    }\n}\n但为什么思路一样，有的录友能写出朴素dijkstra，但堆优化这里的逻辑就是写不出来呢？\n\n主要就是因为对邻接表的表达方式不熟悉！\n\n以上代码中，cur 链接指向的节点编号 为 edge.to， 这条边的权值为 edge.val ，如果对这里模糊的就再回顾一下 Edge的定义：\n\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n确定该节点没有被访问过，!visited[edge.to] ， 目前 源点到cur.first的最短距离（minDist） + cur.first 到 edge.to 的距离 （edge.val） 是否 小于 minDist已经记录的 源点到 edge.to 的距离 （minDist[edge.to]）\n\n如果是的话，就开始更新操作。\n\n即：\n\nif (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n    minDist[edge.to] = minDist[cur.first] + edge.val;\n    pq.push(pair<int, int>(edge.to, minDist[edge.to])); // 由于cur节点的加入，而新链接的边，加入到优先级队里中\n}\n\n同时，由于cur节点的加入，源点又有可以新链接到的边，将这些边加入到优先级队里中。\n\n以上代码思路 和 朴素版dijkstra 是一样一样的，主要区别是两点：\n\n邻接表的表示方式不同\n使用优先级队列（小顶堆）来对新链接的边排序\n#代码实现\n堆优化dijkstra完整代码如下：\n\n#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <climits>\nusing namespace std; \n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n// 定义一个结构体来表示带权重的边\nstruct Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1);\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val; \n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false); \n    \n    // 优先队列中存放 pair<节点，源点到该节点的权值>\n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0)); \n    \n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）\n        // <节点， 源点到该节点的距离>\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        // 2. 第二步，该最近节点被标记访问过\n        visited[cur.first] = true;\n\n        // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (Edge edge : grid[cur.first]) { // 遍历 cur指向的节点，cur指向的节点为 edge\n            // cur指向的节点edge.to，这条边的权值为 edge.val\n            if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                minDist[edge.to] = minDist[cur.first] + edge.val;\n                pq.push(pair<int, int>(edge.to, minDist[edge.to]));\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}\n\n时间复杂度：O(ElogE) E 为边的数量\n空间复杂度：O(N + E) N 为节点的数量\n堆优化的时间复杂度 只和边的数量有关 和节点数无关，在 优先级队列中 放的也是边。\n\n以上代码中，while (!pq.empty()) 里套了 for (Edge edge : grid[cur.first])\n\nfor 里 遍历的是 当前节点 cur 所连接边。\n\n那 当前节点cur 所连接的边 也是不固定的， 这就让大家分不清，这时间复杂度究竟是多少？\n\n其实 for (Edge edge : grid[cur.first]) 里最终的数据走向 是 给队列里添加边。\n\n那么跳出局部代码，整个队列 一定是 所有边添加了一次，同时也弹出了一次。\n\n所以边添加一次时间复杂度是 O(E)， while (!pq.empty()) 里每次都要弹出一个边来进行操作，在优先级队列（小顶堆）中 弹出一个元素的时间复杂度是 O(logE) ，这是堆排序的时间复杂度。\n\n（当然小顶堆里 是 添加元素的时候 排序，还是 取数元素的时候排序，这个无所谓，时间复杂度都是O(E)，总之是一定要排序的，而小顶堆里也不会滞留元素，有多少元素添加 一定就有多少元素弹出）\n\n所以 该算法整体时间复杂度为 O（ElogE)\n\n网上的不少分析 会把 n （节点的数量）算进来，这个分析是有问题的，举一个极端例子，在n 为 10000，且是有一条边的 图里，以上代码，大家感觉执行了多少次？\n\nwhile (!pq.empty()) 中的 pq 存的是边，其实只执行了一次。\n\n所以该算法时间复杂度 和 节点没有关系。\n\n至于空间复杂度，邻接表是 数组 + 链表 数组的空间 是 N ，有E条边 就申请对应多少个链表节点，所以是 复杂度是 N + E\n\n#拓展\n当然也有录友可能想 堆优化dijkstra 中 我为什么一定要用邻接表呢，我就用邻接矩阵 行不行 ？\n\n也行的。\n\n但 正是因为稀疏图，所以我们使用堆优化的思路， 如果我们还用 邻接矩阵 去表达这个图的话，就是 一个高效的算法 使用了低效的数据结构，那么 整体算法效率 依然是低的。\n\n如果还不清楚为什么要使用 邻接表，可以再看看上面 我在 「图的存储」标题下的讲解。\n\n这里我也给出 邻接矩阵版本的堆优化dijkstra代码：\n\n#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n// 小顶堆\nclass mycomparison {\npublic:\n    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n        return lhs.second > rhs.second;\n    }\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;  // 起点\n    int end = n;    // 终点\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    // 优先队列中存放 pair<节点，源点到该节点的距离>\n    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;\n\n\n    // 初始化队列，源点到源点的距离为0，所以初始为0\n    pq.push(pair<int, int>(start, 0));\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    while (!pq.empty()) {\n        // <节点， 源点到该节点的距离>\n        // 1、选距离源点最近且未访问过的节点\n        pair<int, int> cur = pq.top(); pq.pop();\n\n        if (visited[cur.first]) continue;\n\n        visited[cur.first] = true; // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int j = 1; j <= n; j++) {\n            if (!visited[j] && grid[cur.first][j] != INT_MAX && (minDist[cur.first] + grid[cur.first][j] < minDist[j])) {\n                minDist[j] = minDist[cur.first] + grid[cur.first][j];\n                pq.push(pair<int, int>(j, minDist[j]));\n            }\n        }\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n\n}\n\n时间复杂度：O(E * (N + logE)) E为边的数量，N为节点数量\n空间复杂度：O(log(N^2))\nwhile (!pq.empty()) 时间复杂度为 E ，while 里面 每次取元素 时间复杂度 为 logE，和 一个for循环 时间复杂度 为 N 。\n\n所以整体是 E * (N + logE)\n\n#总结\n在学习一种优化思路的时候，首先就要知道为什么要优化，遇到了什么问题。\n\n正如我在开篇就给大家交代清楚 堆优化方式的背景。\n\n堆优化的整体思路和 朴素版是大体一样的，区别是 堆优化从边的角度出发且利用堆来排序。\n\n很多录友别说写堆优化 就是看 堆优化的代码也看的很懵。\n\n主要是因为两点：\n\n不熟悉邻接表的表达方式\n对dijkstra的实现思路还是不熟\n这是我为什么 本篇花了大力气来讲解 图的存储，就是为了让大家彻底理解邻接表以及邻接表的代码写法。\n\n至于 dijkstra的实现思路 ，朴素版 和 堆优化版本 都是 按照 dijkstra 三部曲来的。\n\n理解了三部曲，dijkstra 的思路就是清晰的。\n\n针对邻接表版本代码 我做了详细的 时间复杂度分析，也让录友们清楚，相对于 朴素版，时间都优化到哪了。\n\n最后 我也给出了 邻接矩阵的版本代码，分析了这一版本的必要性以及时间复杂度。\n\n至此通过 两篇dijkstra的文章，终于把 dijkstra 讲完了，如果大家对我讲解里所涉及的内容都吃透的话，详细对 dijkstra 算法也就理解到位了。\n\n#其他语言版本\n#Java\n\nimport java.util.*;\n\nclass Edge {\n    int to;  // 邻接顶点\n    int val; // 边的权重\n\n    Edge(int to, int val) {\n        this.to = to;\n        this.val = val;\n    }\n}\n\nclass MyComparison implements Comparator<Pair<Integer, Integer>> {\n    @Override\n    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {\n        return Integer.compare(lhs.second, rhs.second);\n    }\n}\n\nclass Pair<U, V> {\n    public final U first;\n    public final V second;\n\n    public Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<List<Edge>> grid = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            grid.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid.get(p1).add(new Edge(p2, val));\n        }\n\n        int start = 1;  // 起点\n        int end = n;    // 终点\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        // 优先队列中存放 Pair<节点，源点到该节点的权值>\n        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());\n\n        // 初始化队列，源点到源点的距离为0，所以初始为0\n        pq.add(new Pair<>(start, 0));\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        while (!pq.isEmpty()) {\n            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）\n            // <节点， 源点到该节点的距离>\n            Pair<Integer, Integer> cur = pq.poll();\n\n            if (visited[cur.first]) continue;\n\n            // 2. 第二步，该最近节点被标记访问过\n            visited[cur.first] = true;\n\n            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge\n                // cur指向的节点edge.to，这条边的权值为 edge.val\n                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist\n                    minDist[edge.to] = minDist[cur.first] + edge.val;\n                    pq.add(new Pair<>(edge.to, minDist[edge.to]));\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}\n\n#Python\nimport heapq\n\nclass Edge:\n    def __init__(self, to, val):\n        self.to = to\n        self.val = val\n\ndef dijkstra(n, m, edges, start, end):\n    grid = [[] for _ in range(n + 1)]\n\n    for p1, p2, val in edges:\n        grid[p1].append(Edge(p2, val))\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    pq = []\n    heapq.heappush(pq, (0, start))\n    minDist[start] = 0\n\n    while pq:\n        cur_dist, cur_node = heapq.heappop(pq)\n\n        if visited[cur_node]:\n            continue\n\n        visited[cur_node] = True\n\n        for edge in grid[cur_node]:\n            if not visited[edge.to] and cur_dist + edge.val < minDist[edge.to]:\n                minDist[edge.to] = cur_dist + edge.val\n                heapq.heappush(pq, (minDist[edge.to], edge.to))\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\n# 输入\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nstart = 1  # 起点\nend = n    # 终点\n\n# 运行算法并输出结果\nresult = dijkstra(n, m, edges, start, end)\nprint(result)"
}