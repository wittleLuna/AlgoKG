{
  "id": "AP_9cfa1bd9",
  "title": "监控二叉树",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/binary-tree-cameras/",
  "description": "一个二叉树，我们在树的节点上安装摄像头。\n\n节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。\n\n计算监控树的所有节点所需的最小摄像头数量。",
  "examples": [
    {
      "input": "见图",
      "output": "见图",
      "explanation": null,
      "image": "https://file1.kamacoder.com/i/algo/20201229175736596.png"
    },
    {
      "input": "见图",
      "output": "见图",
      "explanation": null,
      "image": "https://file1.kamacoder.com/i/algo/2020122917584449.png"
    }
  ],
  "constraints": [],
  "algorithm_tags": [
    "贪心",
    "动态规划"
  ],
  "data_structure_tags": [
    "二叉树"
  ],
  "technique_tags": [
    "后序遍历",
    "状态转移"
  ],
  "difficulty": null,
  "solution_approach": "采用贪心算法和后序遍历二叉树的方式，从叶子节点的父节点开始放置摄像头，并尽量避免在叶子节点上安装摄像头，以达到用最少数量的摄像头覆盖整棵树的目的。",
  "key_insights": [
    {
      "content": "为了最大化摄像头的作用范围，不应该将摄像头放在叶子节点上。最佳策略是将其置于叶子节点的直接父节点处，这样可以同时监控到叶子节点及其父节点，甚至更上层的一个节点。"
    },
    {
      "content": "选择后序遍历（左右中）来实现从下至上的处理过程，这允许我们在决定是否在当前节点放置摄像头之前先了解其子节点的状态。"
    },
    {
      "content": "通过定义三种状态（无覆盖、有摄像头、有覆盖）来描述每个节点的情况，并根据子节点的状态决定当前节点应处于哪种状态以及是否需要在此处添加摄像头。"
    },
    {
      "content": "对于空节点，假设其状态为有覆盖，这样做可以防止在叶子节点上放置不必要的摄像头，从而优化了摄像头的总体数量。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "这道题目首先要想，如何放置，才能让摄像头最小的呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: int result; int traversal(TreeNode* cur) { if (cur == NULL) return 2; int left = traversal(cur->left); int right = traversal(cur->right); if (left == 2 && right == 2) return 0; else if (left == 0 || right == 0) { result++; return 1; } else return 2; } public: int minCameraCover(TreeNode* root) { result = 0; if (traversal(root) == 0) { result++; } return result; }};",
          "description": "C++版本的解决方案"
        },
        {
          "language": "java",
          "code": "class Solution { int res=0; public int minCameraCover(TreeNode root) { if(minCame(root)==0){ res++; } return res; } public int minCame(TreeNode root){ if(root==null){ return 2; } int left=minCame(root.left); int right=minCame(root.right); if(left==2&&right==2){ return 0; }else if(left==0||right==0){ res++; return 1; }else{ return 2; } }}",
          "description": "Java版本的解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def minCameraCover(self, root: TreeNode) -> int: result = [0] if self.traversal(root, result) == 0: result[0] += 1 return result[0] def traversal(self, cur: TreeNode, result: List[int]) -> int: if not cur: return 2 left = self.traversal(cur.left, result) right = self.traversal(cur.right, result) if left == 2 and right == 2: return 0 elif left == 0 or right == 0: result[0] += 1 return 1 else: return 2",
          "description": "Python版本的解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "确定遍历顺序",
      "text": "在二叉树中如何从低向上推导呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: int result; int traversal(TreeNode* cur) { if (cur == NULL) return 2; int left = traversal(cur->left); int right = traversal(cur->right); if (left == 2 && right == 2) return 0; else if (left == 0 || right == 0) { result++; return 1; } else return 2; } public: int minCameraCover(TreeNode* root) { result = 0; if (traversal(root) == 0) { result++; } return result; }};",
          "description": "C++版本的二叉树最小摄像头覆盖问题解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {int res=0; public int minCameraCover(TreeNode root) { if(minCame(root)==0){ res++; } return res; } public int minCame(TreeNode root){ if(root==null){ return 2; } int left=minCame(root.left); int right=minCame(root.right); if(left==2&&right==2){ return 0; }else if(left==0||right==0){ res++; return 1; }else{ return 2; } }}",
          "description": "Java版本的二叉树最小摄像头覆盖问题解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def minCameraCover(self, root: TreeNode) -> int: result = [0] if self.traversal(root, result) == 0: result[0] += 1 return result[0] def traversal(self, cur: TreeNode, result: List[int]) -> int: if not cur: return 2 left = self.traversal(cur.left, result) right = self.traversal(cur.right, result) if left == 2 and right == 2: return 0 elif left == 0 or right == 0: result[0] += 1 return 1 else: return 2",
          "description": "Python版本的二叉树最小摄像头覆盖问题解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "如何隔两个节点放一个摄像头",
      "text": "此时需要状态转移的公式，大家不要和动态的状态转移公式混到一起，本题状态转移没有择优的过程，就是单纯的状态转移！",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    int result;\n    int traversal(TreeNode* cur) {\n        if (cur == NULL) return 2;\n        int left = traversal(cur->left);    // 左\n        int right = traversal(cur->right);  // 右\n        if (left == 2 && right == 2) return 0;\n        else if (left == 0 || right == 0) {\n            result++;\n            return 1;\n        } else return 2;\n    }\npublic:\n    int minCameraCover(TreeNode* root) {\n        result = 0;\n        if (traversal(root) == 0) { // root 无覆盖\n            result++;\n        }\n        return result;\n    }\n};",
          "description": "C++实现的二叉树最小摄像头数量问题，使用贪心算法和后序遍历"
        },
        {
          "language": "java",
          "code": "class Solution {\n    int res=0;\n    public int minCameraCover(TreeNode root) {\n        if(minCame(root)==0){\n            res++;\n        }\n        return res;\n    }\n    public int minCame(TreeNode root){\n        if(root==null){\n            return 2;\n        }\n        int left=minCame(root.left);\n        int right=minCame(root.right);\n        if(left==2&&right==2){\n            return 0;\n        }else if(left==0||right==0){\n            res++;\n            return 1;\n        }else{\n            return 2;\n        }\n    }\n}",
          "description": "Java实现的二叉树最小摄像头数量问题，同样采用了贪心策略和递归方法"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        result = [0]\n        if self.traversal(root, result) == 0:\n            result[0] += 1\n        return result[0]\n    def traversal(self, cur: TreeNode, result: list) -> int:\n        if not cur:\n            return 2\n        left = self.traversal(cur.left, result)\n        right = self.traversal(cur.right, result)\n        if left == 2 and right == 2:\n            return 0\n        elif left == 0 or right == 0:\n            result[0] += 1\n            return 1\n        else:\n            return 2",
          "description": "Python版本解决二叉树最小摄像头覆盖问题，基于递归和贪心算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "本题的难点首先是要想到贪心的思路，然后就是遍历和状态推导。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: int result; int traversal(TreeNode* cur) { if (cur == NULL) return 2; int left = traversal(cur->left); int right = traversal(cur->right); if (left == 2 && right == 2) return 0; else if (left == 0 || right == 0) { result++; return 1; } else return 2; } public: int minCameraCover(TreeNode* root) { result = 0; if (traversal(root) == 0) { result++; } return result; }};",
          "description": "C++版本的二叉树摄像头安装问题解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {int res=0;public int minCameraCover(TreeNode root) {if(minCame(root)==0){res++;}return res;}public int minCame(TreeNode root){if(root==null){return 2;}int left=minCame(root.left);int right=minCame(root.right);if(left==2&&right==2){return 0;}else if(left==0||right==0){res++;return 1;}else{return 2;}}}",
          "description": "Java版本的二叉树摄像头安装问题解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def minCameraCover(self, root: TreeNode) -> int: result = [0] if self.traversal(root, result) == 0: result[0] += 1 return result[0] def traversal(self, cur: TreeNode, result: List[int]) -> int: if not cur: return 2 left = self.traversal(cur.left, result) right = self.traversal(cur.right, result) if left == 2 and right == 2: return 0 elif left == 0 or right == 0: result[0] += 1 return 1 else: return 2",
          "description": "Python版本的二叉树摄像头安装问题解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution {\n    int res=0;\n    public int minCameraCover(TreeNode root) {\n        if(minCame(root)==0){\n            res++;\n        }\n        return res;\n    }\n    public int minCame(TreeNode root){\n        if(root==null){\n            return 2;\n        }\n        int left=minCame(root.left);\n        int right=minCame(root.right);\n\n        if(left==2&&right==2){\n            return 0;\n        } else if(left==0||right==0){\n            res++;\n            return 1;\n        } else{\n            return 2;\n        }\n    }\n}",
          "description": "Java版本的二叉树摄像头放置问题解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {\n    static int ans;\n    public int minCameraCover(TreeNode root) {\n        ans = 0;\n        if(f(root) == 0) ans ++;\n        return ans;\n    }\n    public static int f(TreeNode x) {\n        if(x == null) return 1;\n        int l = f(x.left);\n        int r = f(x.right);\n        if(l == 0 || r == 0) {\n            ans ++;\n            return 2;\n        }\n        if(l == 1 && r == 1) return 0;\n        return 1; \n    }\n}",
          "description": "简化分支版本的Java二叉树摄像头放置问题解决方案"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        result = [0]\n        if self.traversal(root, result) == 0:\n            result[0] += 1\n        return result[0]\n\n    def traversal(self, cur: TreeNode, result: List[int]) -> int:\n        if not cur:\n            return 2\n\n        left = self.traversal(cur.left, result)\n        right = self.traversal(cur.right, result)\n\n        if left == 2 and right == 2:\n            return 0\n        elif left == 0 or right == 0:\n            result[0] += 1\n            return 1\n        else:\n            return 2",
          "description": "Python版本的二叉树摄像头放置问题解决方案，使用elif精简代码"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    int result;\n    int traversal(TreeNode* cur) {\n        if (cur == NULL) return 2;\n        int left = traversal(cur->left);    // 左\n        int right = traversal(cur->right);  // 右\n        if (left == 2 && right == 2) return 0;\n        else if (left == 0 || right == 0) {\n            result++;\n            return 1;\n        } else return 2;\n    }\npublic:\n    int minCameraCover(TreeNode* root) {\n        result = 0;\n        if (traversal(root) == 0) { // root 无覆盖\n            result++;\n        }\n        return result;\n    }\n};",
          "description": "C++版本的解决方案，使用后序遍历和贪心算法来确定摄像头的最少数量。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    int res=0;\n    public int minCameraCover(TreeNode root) {\n        if(minCame(root)==0){\n            res++;\n        }\n        return res;\n    }\n    public int minCame(TreeNode root){\n        if(root==null){\n            return 2;\n        }\n        int left=minCame(root.left);\n        int right=minCame(root.right);\n        if(left==2&&right==2){\n            return 0;\n        }else if(left==0||right==0){\n            res++;\n            return 1;\n        }else{\n            return 2;\n        }\n    }\n}",
          "description": "Java版本的解决方案，逻辑与C++版本类似，采用后序遍历和状态标记法来最小化摄像头的数量。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        result = [0]\n        if self.traversal(root, result) == 0:\n            result[0] += 1\n        return result[0]\n    def traversal(self, cur: TreeNode, result: list) -> int:\n        if not cur:\n            return 2\n        left = self.traversal(cur.left, result)\n        right = self.traversal(cur.right, result)\n        if left == 2 and right == 2:\n            return 0\n        elif left == 0 or right == 0:\n            result[0] += 1\n            return 1\n        else:\n            return 2",
          "description": "Python版本的解决方案，通过递归函数实现后序遍历，并根据子节点的状态决定当前节点是否需要安装摄像头。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "贪心（版本一）",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: int result; int traversal(TreeNode* cur) {if (cur == NULL) return 2;int left = traversal(cur->left);int right = traversal(cur->right);if (left == 2 && right == 2) return 0;if (left == 0 || right == 0) {result++;return 1;}if (left == 1 || right == 1) return 2;return -1;}public: int minCameraCover(TreeNode* root) {result = 0;if (traversal(root) == 0) {result++;}return result;}};",
          "description": "C++版本的二叉树摄像头安装算法"
        },
        {
          "language": "java",
          "code": "class Solution {int res=0;public int minCameraCover(TreeNode root) {if(minCame(root)==0){res++;}return res;}public int minCame(TreeNode root){if(root==null){return 2;}int left=minCame(root.left);int right=minCame(root.right);if(left==2&&right==2){return 0;}else if(left==0||right==0){res++;return 1;}else{return 2;}}}",
          "description": "Java版本的二叉树摄像头安装算法"
        },
        {
          "language": "python",
          "code": "class Solution: def minCameraCover(self, root: TreeNode) -> int: result = [0] if self.traversal(root, result) == 0: result[0] += 1 return result[0] def traversal(self, cur: TreeNode, result: List[int]) -> int: if not cur: return 2 left = self.traversal(cur.left, result) right = self.traversal(cur.right, result) if left == 2 and right == 2: return 0 elif left == 0 or right == 0: result[0] += 1 return 1 else: return 2",
          "description": "Python版本的二叉树摄像头安装算法"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "explanation": "需要遍历二叉树上的每个节点"
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "int result; int traversal(TreeNode* cur) { if (cur == NULL) return 2; int left = traversal(cur->left); int right = traversal(cur->right); if (left == 2 && right == 2) return 0; else if (left == 0 || right == 0) { result++; return 1; } else return 2; } public: int minCameraCover(TreeNode* root) { result = 0; if (traversal(root) == 0) { result++; } return result; }",
      "description": "C++版本的二叉树摄像头最小数量解法"
    },
    {
      "language": "java",
      "code": "int res=0; public int minCameraCover(TreeNode root) { if(minCame(root)==0){ res++; } return res; } public int minCame(TreeNode root){ if(root==null){ return 2; } int left=minCame(root.left); int right=minCame(root.right); if(left==2&&right==2){ return 0; }else if(left==0||right==0){ res++; return 1; }else{ return 2; } }",
      "description": "Java版本的二叉树摄像头最小数量解法"
    },
    {
      "language": "python",
      "code": "def minCameraCover(self, root: TreeNode) -> int: result = [0] if self.traversal(root, result) == 0: result[0] += 1 return result[0] def traversal(self, cur: TreeNode, result: List[int]) -> int: if not cur: return 2 left = self.traversal(cur.left, result) right = self.traversal(cur.right, result) if left == 2 and right == 2: return 0 elif left == 0 or right == 0: result[0] += 1 return 1 else: return 2",
      "description": "Python版本的二叉树摄像头最小数量解法"
    }
  ],
  "common_mistakes": [
    "误以为需要考虑所有可能的情况，实际上通过定义有限的状态（无覆盖、有摄像头、被覆盖）简化了问题。",
    "忽略空节点应视为已覆盖的状态，导致不必要的摄像头部署。",
    "没有意识到从叶子向根的方向推进可以帮助减少所需摄像头的数量。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20201229175736596.png",
      "description": "这张图片展示了一个简单的树形数据结构，中心节点（带有相机图标）连接着三个子节点，体现了基本的图论或树结构概念。",
      "context": "该图片展示了示例1中的二叉树结构，通过放置一个摄像头即可监控到所有节点的情况。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/2020122917584449.png",
      "description": "这张图片展示了一个包含五个节点的二叉树结构，其中两个节点标记有相机图标，可能表示特定的数据点或操作。",
      "context": "该图片展示了在给定二叉树结构中，至少需要放置两个摄像头来确保所有节点都被监控到的一个有效配置方案。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20201229203710729.png",
      "description": "这张图片展示了一棵二叉树，节点状态（0、1、2）和覆盖情况用于解决树的监控问题，体现了动态规划或深度优先搜索算法的应用。",
      "context": "该图展示了当左右孩子节点都有覆盖时，中间节点处于无覆盖状态的情形。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/2020122920362355.png",
      "description": "这张图片展示了一个二叉树结构，节点状态（0或1）表示是否安装摄像头，用于解决监控覆盖问题的算法分析。",
      "context": "这张图片展示了当左子节点被摄像头覆盖而右子节点没有被直接覆盖时的情况，帮助解释在特定条件下如何处理二叉树中的摄像头布置问题。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20201229203742446.png",
      "description": "这张图片展示了一个二叉树结构，根节点为0（无覆盖状态），其子节点分别为2和2（有覆盖状态），进一步的子节点为1（有摄像头覆盖），体现了树的遍历与状态标记算法。",
      "context": "展示了递归结束后头结点仍处于无覆盖状态的情况。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20201229175736596.png",
      "description": "GIF展示了在二叉树上放置摄像头的过程，以最小数量的摄像头监控所有节点。",
      "context": "该GIF动画展示了如何通过在二叉树的特定节点上安装一个摄像头来监控整个树的所有节点。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/2020122917584449.png",
      "description": "GIF展示了在二叉树中放置摄像头以覆盖所有节点的过程，特别强调了摄像头未被放置在叶子节点上而是其父节点处，以此来最小化所需摄像头的数量。",
      "context": "该GIF动画展示了如何通过至少两个摄像头的有效放置来监控树的所有节点，直观地说明了解决问题的一种方法。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20201229203710729.png",
      "description": "GIF展示了在二叉树中根据子节点状态决定父节点是否需要放置摄像头的过程。",
      "context": "该GIF动画展示了当左右子节点都被覆盖时，中间节点变为无覆盖状态的情况。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/2020122920362355.png",
      "description": "GIF展示了在二叉树中根据左右子节点的状态决定当前节点状态的递归过程。",
      "context": "该GIF动画展示了当左子节点状态为1（有摄像头）而右子节点状态为0（无覆盖也无摄像头）时，根据算法逻辑如何处理这一特定情况的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20201229203742446.png",
      "description": "递归结束时检查根节点是否被覆盖的过程。",
      "context": "该GIF展示了在递归算法处理后，根节点仍处于未被监控覆盖的情况，强调了需要额外增加一个摄像头来确保整个树结构完全被覆盖。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\贪心算法\\监控二叉树.txt",
  "extracted_at": "2025-07-22T17:02:23.644926",
  "raw_content": "监控二叉树\n力扣题目链接(https://leetcode.cn/problems/binary-tree-cameras/)\n\n给定一个二叉树，我们在树的节点上安装摄像头。\n\n节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。\n\n计算监控树的所有节点所需的最小摄像头数量。\n\n示例 1：\n\nhttps://file1.kamacoder.com/i/algo/20201229175736596.png\n\n输入：[0,0,null,0,0]\n输出：1\n解释：如图所示，一台摄像头足以监控所有节点。\n示例 2：\n\nhttps://file1.kamacoder.com/i/algo/2020122917584449.png\n\n输入：[0,0,null,0,null,0,null,null,0]\n输出：2\n解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。\n提示：\n\n给定树的节点数的范围是 [1, 1000]。\n每个节点的值都是 0。\n\n\n#思路\n这道题目首先要想，如何放置，才能让摄像头最小的呢？\n\n从题目中示例，其实可以得到启发，我们发现题目示例中的摄像头都没有放在叶子节点上！\n\n这是很重要的一个线索，摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费的一层的覆盖。\n\n所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。\n\n那么有同学可能问了，为什么不从头结点开始看起呢，为啥要从叶子节点看呢？\n\n因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。\n\n所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！\n\n局部最优推出全局最优，找不出反例，那么就按照贪心来！\n\n此时，大体思路就是从低到上，先给叶子节点父节点放个摄像头，然后隔两个节点放一个摄像头，直至到二叉树头结点。\n\n此时这道题目还有两个难点：\n\n二叉树的遍历\n如何隔两个节点放一个摄像头\n#确定遍历顺序\n在二叉树中如何从低向上推导呢？\n\n可以使用后序遍历也就是左右中的顺序，这样就可以在回溯的过程中从下到上进行推导了。\n\n后序遍历代码如下：\n\nint traversal(TreeNode* cur) {\n\n    // 空节点，该节点有覆盖\n    if (终止条件) return ;\n\n    int left = traversal(cur->left);    // 左\n    int right = traversal(cur->right);  // 右\n\n    逻辑处理                            // 中\n    return ;\n}\n注意在以上代码中我们取了左孩子的返回值，右孩子的返回值，即left 和 right， 以后推导中间节点的状态\n\n#如何隔两个节点放一个摄像头\n此时需要状态转移的公式，大家不要和动态的状态转移公式混到一起，本题状态转移没有择优的过程，就是单纯的状态转移！\n\n来看看这个状态应该如何转移，先来看看每个节点可能有几种状态：\n\n有如下三种：\n\n该节点无覆盖\n本节点有摄像头\n本节点有覆盖\n我们分别有三个数字来表示：\n\n0：该节点无覆盖\n1：本节点有摄像头\n2：本节点有覆盖\n大家应该找不出第四个节点的状态了。\n\n一些同学可能会想有没有第四种状态：本节点无摄像头，其实无摄像头就是 无覆盖 或者 有覆盖的状态，所以一共还是三个状态。\n\n因为在遍历树的过程中，就会遇到空节点，那么问题来了，空节点究竟是哪一种状态呢？ 空节点表示无覆盖？ 表示有摄像头？还是有覆盖呢？\n\n回归本质，为了让摄像头数量最少，我们要尽量让叶子节点的父节点安装摄像头，这样才能摄像头的数量最少。\n\n那么空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。\n\n所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了\n\n接下来就是递推关系。\n\n那么递归的终止条件应该是遇到了空节点，此时应该返回2（有覆盖），原因上面已经解释过了。\n\n代码如下：\n\n// 空节点，该节点有覆盖\nif (cur == NULL) return 2;\n递归的函数，以及终止条件已经确定了，再来看单层逻辑处理。\n\n主要有如下四类情况：\n\n情况1：左右节点都有覆盖\n左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。\n\n如图：\n\nhttps://file1.kamacoder.com/i/algo/20201229203710729.png\n\n代码如下：\n\n// 左右节点都有覆盖\nif (left == 2 && right == 2) return 0;\n情况2：左右节点至少有一个无覆盖的情况\n如果是以下情况，则中间节点（父节点）应该放摄像头：\n\nleft == 0 && right == 0 左右节点无覆盖\nleft == 1 && right == 0 左节点有摄像头，右节点无覆盖\nleft == 0 && right == 1 左节点有无覆盖，右节点摄像头\nleft == 0 && right == 2 左节点无覆盖，右节点覆盖\nleft == 2 && right == 0 左节点覆盖，右节点无覆盖\n这个不难理解，毕竟有一个孩子没有覆盖，父节点就应该放摄像头。\n\n此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。\n\n代码如下：\n\nif (left == 0 || right == 0) {\n    result++;\n    return 1;\n}\n情况3：左右节点至少有一个有摄像头\n如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）\n\nleft == 1 && right == 2 左节点有摄像头，右节点有覆盖\nleft == 2 && right == 1 左节点有覆盖，右节点有摄像头\nleft == 1 && right == 1 左右节点都有摄像头\n代码如下：\n\nif (left == 1 || right == 1) return 2;\n从这个代码中，可以看出，如果left == 1, right == 0 怎么办？其实这种条件在情况2中已经判断过了，如图：\n\nhttps://file1.kamacoder.com/i/algo/2020122920362355.png\n\n这种情况也是大多数同学容易迷惑的情况。\n\n情况4：头结点没有覆盖\n以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况，如图：\n\nhttps://file1.kamacoder.com/i/algo/20201229203742446.png\n\n所以递归结束之后，还要判断根节点，如果没有覆盖，result++，代码如下：\n\nint minCameraCover(TreeNode* root) {\n    result = 0;\n    if (traversal(root) == 0) { // root 无覆盖\n        result++;\n    }\n    return result;\n}\n以上四种情况我们分析完了，代码也差不多了，整体代码如下：\n\n（以下我的代码注释很详细，为了把情况说清楚，特别把每种情况列出来。）\n\nC++代码如下：\n\n// 版本一\nclass Solution {\nprivate:\n    int result;\n    int traversal(TreeNode* cur) {\n\n        // 空节点，该节点有覆盖\n        if (cur == NULL) return 2;\n\n        int left = traversal(cur->left);    // 左\n        int right = traversal(cur->right);  // 右\n\n        // 情况1\n        // 左右节点都有覆盖\n        if (left == 2 && right == 2) return 0;\n\n        // 情况2\n        // left == 0 && right == 0 左右节点无覆盖\n        // left == 1 && right == 0 左节点有摄像头，右节点无覆盖\n        // left == 0 && right == 1 左节点有无覆盖，右节点摄像头\n        // left == 0 && right == 2 左节点无覆盖，右节点覆盖\n        // left == 2 && right == 0 左节点覆盖，右节点无覆盖\n        if (left == 0 || right == 0) {\n            result++;\n            return 1;\n        }\n\n        // 情况3\n        // left == 1 && right == 2 左节点有摄像头，右节点有覆盖\n        // left == 2 && right == 1 左节点有覆盖，右节点有摄像头\n        // left == 1 && right == 1 左右节点都有摄像头\n        // 其他情况前段代码均已覆盖\n        if (left == 1 || right == 1) return 2;\n\n        // 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解\n        // 这个 return -1 逻辑不会走到这里。\n        return -1;\n    }\n\npublic:\n    int minCameraCover(TreeNode* root) {\n        result = 0;\n        // 情况4\n        if (traversal(root) == 0) { // root 无覆盖\n            result++;\n        }\n        return result;\n    }\n};\n在以上代码的基础上，再进行精简，代码如下：\n\n// 版本二\nclass Solution {\nprivate:\n    int result;\n    int traversal(TreeNode* cur) {\n        if (cur == NULL) return 2;\n        int left = traversal(cur->left);    // 左\n        int right = traversal(cur->right);  // 右\n        if (left == 2 && right == 2) return 0;\n        else if (left == 0 || right == 0) {\n            result++;\n            return 1;\n        } else return 2;\n    }\npublic:\n    int minCameraCover(TreeNode* root) {\n        result = 0;\n        if (traversal(root) == 0) { // root 无覆盖\n            result++;\n        }\n        return result;\n    }\n};\n\n\n时间复杂度: O(n)，需要遍历二叉树上的每个节点\n空间复杂度: O(n)\n大家可能会惊讶，居然可以这么简短，其实就是在版本一的基础上，使用else把一些情况直接覆盖掉了。\n\n在网上关于这道题解可以搜到很多这种神级别的代码，但都没讲不清楚，如果直接看代码的话，指定越看越晕，所以建议大家对着版本一的代码一步一步来，版本二中看不中用！。\n\n#总结\n本题的难点首先是要想到贪心的思路，然后就是遍历和状态推导。\n\n在二叉树上进行状态推导，其实难度就上了一个台阶了，需要对二叉树的操作非常娴熟。\n\n这道题目是名副其实的hard，大家感受感受。\n\n#其他语言版本\n#Java\nclass Solution {\n    int  res=0;\n    public int minCameraCover(TreeNode root) {\n        // 对根节点的状态做检验,防止根节点是无覆盖状态 .\n        if(minCame(root)==0){\n            res++;\n        }\n        return res;\n    }\n    /**\n     节点的状态值：\n       0 表示无覆盖\n       1 表示 有摄像头\n       2 表示有覆盖\n    后序遍历，根据左右节点的情况,来判读 自己的状态\n     */\n    public int minCame(TreeNode root){\n        if(root==null){\n            // 空节点默认为 有覆盖状态，避免在叶子节点上放摄像头\n            return 2;\n        }\n        int left=minCame(root.left);\n        int  right=minCame(root.right);\n\n        // 如果左右节点都覆盖了的话, 那么本节点的状态就应该是无覆盖,没有摄像头\n        if(left==2&&right==2){\n            //(2,2)\n            return 0;\n        }else if(left==0||right==0){\n            // 左右节点都是无覆盖状态,那 根节点此时应该放一个摄像头\n            // (0,0) (0,1) (0,2) (1,0) (2,0)\n            // 状态值为 1 摄像头数 ++;\n            res++;\n            return 1;\n        }else{\n            // 左右节点的 状态为 (1,1) (1,2) (2,1) 也就是左右节点至少存在 1个摄像头，\n            // 那么本节点就是处于被覆盖状态\n            return 2;\n        }\n    }\n}\n简化分支版本：\n\nclass Solution {\n    static int ans;\n    public int minCameraCover(TreeNode root) {\n        ans = 0; // 初始化\n        if(f(root) == 0) ans ++;\n        return ans;\n    }\n    // 定义 f 函数有三种返回值情况\n    // 0：表示 x 节点没有被相机监控，只能依靠父节点放相机\n    // 1：表示 x 节点被相机监控，但相机不是放在自身节点上\n    // 2：表示 x 节点被相机监控，但相机放在自身节点上\n    public static int f(TreeNode x) {\n        if(x == null) return 1; // 空树认为被监控，但没有相机\n        // 左右递归到最深处\n        int l = f(x.left);\n        int r = f(x.right);\n        // 有任意一个子节点为空，就需要当前节点放相机，不然以后没机会\n        if(l == 0 || r == 0) {\n            ans ++; // 放相机\n            return 2;\n        }\n        // 贪心策略，左右子树都被监控，且没有监控到当前节点，\n        // 那么最有利的情况就是将相机放置在当前节点父节点上，\n        // 因为这样能多监控可能的子树节点和父父节点\n        if(l == 1 && r == 1) return 0;\n        // 剩下情况就是左右子树有可能为 2，即当前节点被监控\n        return 1; \n    }\n}\n#Python\n贪心（版本一）\n\nclass Solution:\n         # Greedy Algo:\n        # 从下往上安装摄像头：跳过leaves这样安装数量最少，局部最优 -> 全局最优\n        # 先给leaves的父节点安装，然后每隔两层节点安装一个摄像头，直到Head\n        # 0: 该节点未覆盖\n        # 1: 该节点有摄像头\n        # 2: 该节点有覆盖\n    def minCameraCover(self, root: TreeNode) -> int:\n        # 定义递归函数\n        result = [0]  # 用于记录摄像头的安装数量\n        if self.traversal(root, result) == 0:\n            result[0] += 1\n\n        return result[0]\n\n        \n    def traversal(self, cur: TreeNode, result: List[int]) -> int:\n        if not cur:\n            return 2\n\n        left = self.traversal(cur.left, result)\n        right = self.traversal(cur.right, result)\n\n        # 情况1: 左右节点都有覆盖\n        if left == 2 and right == 2:\n            return 0\n\n        # 情况2:\n        # left == 0 && right == 0 左右节点无覆盖\n        # left == 1 && right == 0 左节点有摄像头，右节点无覆盖\n        # left == 0 && right == 1 左节点无覆盖，右节点有摄像头\n        # left == 0 && right == 2 左节点无覆盖，右节点覆盖\n        # left == 2 && right == 0 左节点覆盖，右节点无覆盖\n        if left == 0 or right == 0:\n            result[0] += 1\n            return 1\n\n        # 情况3:\n        # left == 1 && right == 2 左节点有摄像头，右节点有覆盖\n        # left == 2 && right == 1 左节点有覆盖，右节点有摄像头\n        # left == 1 && right == 1 左右节点都有摄像头\n        if left == 1 or right == 1:\n            return 2\n\n\n贪心（版本二）利用elif精简代码\n\nclass Solution:\n         # Greedy Algo:\n        # 从下往上安装摄像头：跳过leaves这样安装数量最少，局部最优 -> 全局最优\n        # 先给leaves的父节点安装，然后每隔两层节点安装一个摄像头，直到Head\n        # 0: 该节点未覆盖\n        # 1: 该节点有摄像头\n        # 2: 该节点有覆盖\n    def minCameraCover(self, root: TreeNode) -> int:\n        # 定义递归函数\n        result = [0]  # 用于记录摄像头的安装数量\n        if self.traversal(root, result) == 0:\n            result[0] += 1\n\n        return result[0]\n\n        \n    def traversal(self, cur: TreeNode, result: List[int]) -> int:\n        if not cur:\n            return 2\n\n        left = self.traversal(cur.left, result)\n        right = self.traversal(cur.right, result)\n\n        # 情况1: 左右节点都有覆盖\n        if left == 2 and right == 2:\n            return 0\n\n        # 情况2:\n        # left == 0 && right == 0 左右节点无覆盖\n        # left == 1 && right == 0 左节点有摄像头，右节点无覆盖\n        # left == 0 && right == 1 左节点无覆盖，右节点有摄像头\n        # left == 0 && right == 2 左节点无覆盖，右节点覆盖\n        # left == 2 && right == 0 左节点覆盖，右节点无覆盖\n        elif left == 0 or right == 0:\n            result[0] += 1\n            return 1\n\n        # 情况3:\n        # left == 1 && right == 2 左节点有摄像头，右节点有覆盖\n        # left == 2 && right == 1 左节点有覆盖，右节点有摄像头\n        # left == 1 && right == 1 左右节点都有摄像头\n        else:\n            return 2"
}