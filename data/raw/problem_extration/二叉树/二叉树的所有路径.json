{
  "id": "AP_8e9fb1c2",
  "title": "二叉树的所有路径",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/binary-tree-paths/",
  "description": "给定一个二叉树，返回所有从根节点到叶子节点的路径。\n\n说明: 叶子节点是指没有子节点的节点。\n\nhttps://file1.kamacoder.com/i/algo/2021020415161576.png",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "深度优先搜索",
    "递归"
  ],
  "data_structure_tags": [
    "二叉树",
    "向量",
    "栈"
  ],
  "technique_tags": [
    "回溯",
    "路径构造",
    "前序遍历"
  ],
  "difficulty": null,
  "solution_approach": "采用前序遍历的方法遍历二叉树，并使用回溯来记录从根节点到叶子节点的所有路径。当遇到叶子节点时，将当前路径转换成字符串并加入结果集。",
  "key_insights": [
    {
      "content": "前序遍历允许我们按照访问顺序自然地构建从根到叶子的路径。"
    },
    {
      "content": "回溯确保在探索完一条路径后能够正确地返回上一状态，以便尝试其他可能的路径。"
    },
    {
      "content": "通过使用string类型而非引用作为参数传递可以隐藏部分回溯逻辑，简化代码。"
    },
    {
      "content": "迭代法中同样可以通过两个栈来分别存储待处理节点及其对应的路径，从而模拟递归过程。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {path.push_back(cur->val); if (cur->left == NULL && cur->right == NULL) {string sPath; for (int i = 0; i < path.size() - 1; i++) {sPath += to_string(path[i]); sPath += \"->\";} sPath += to_string(path[path.size() - 1]); result.push_back(sPath); return;} if (cur->left) {traversal(cur->left, path, result); path.pop_back();} if (cur->right) {traversal(cur->right, path, result); path.pop_back();}} public: vector<string> binaryTreePaths(TreeNode* root) {vector<string> result; vector<int> path; if (root == NULL) return result; traversal(root, path, result); return result;}};",
          "description": "C++版本一，使用向量记录路径并进行回溯。"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: void traversal(TreeNode* cur, string path, vector<string>& result) {path += to_string(cur->val); if (cur->left == NULL && cur->right == NULL) {result.push_back(path); return;} if (cur->left) traversal(cur->left, path + \"->\", result); if (cur->right) traversal(cur->right, path + \"->\", result);} public: vector<string> binaryTreePaths(TreeNode* root) {vector<string> result; string path; if (root == NULL) return result; traversal(root, path, result); return result;}};",
          "description": "C++版本二，通过字符串拼接方式隐式实现回溯。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<string> binaryTreePaths(TreeNode* root) {stack<TreeNode*> treeSt; stack<string> pathSt; vector<string> result; if (root == NULL) return result; treeSt.push(root); pathSt.push(to_string(root->val)); while (!treeSt.empty()) {TreeNode* node = treeSt.top(); treeSt.pop(); string path = pathSt.top(); pathSt.pop(); if (node->left == NULL && node->right == NULL) {result.push_back(path);} if (node->right) {treeSt.push(node->right); pathSt.push(path + \"->\" + to_string(node->right->val));} if (node->left) {treeSt.push(node->left); pathSt.push(path + \"->\" + to_string(node->left->val));}} return result;}};",
          "description": "C++迭代法，使用栈模拟递归过程。"
        },
        {
          "language": "java",
          "code": "class Solution {public List<String> binaryTreePaths(TreeNode root) {List<String> res = new ArrayList<>(); if (root == null) {return res;} List<Integer> paths = new ArrayList<>(); traversal(root, paths, res); return res;} private void traversal(TreeNode root, List<Integer> paths, List<String> res) {paths.add(root.val); if (root.left == null && root.right == null) {StringBuilder sb = new StringBuilder(); for (int i = 0; i < paths.size() - 1; i++) {sb.append(paths.get(i)).append(\"->\");} sb.append(paths.get(paths.size() - 1)); res.add(sb.toString()); return;} if (root.left != null) {traversal(root.left, paths, res); paths.remove(paths.size() - 1);} if (root.right != null) {traversal(root.right, paths, res); paths.remove(paths.size() - 1);}}}",
          "description": "Java版本一，利用列表存储路径，并进行显式回溯。"
        },
        {
          "language": "java",
          "code": "class Solution {List<String> result = new ArrayList<>(); public List<String> binaryTreePaths(TreeNode root) {deal(root, \"\"); return result;} public void deal(TreeNode node, String s) {if (node == null) return; if (node.left == null && node.right == null) {result.add(new StringBuilder(s).append(node.val).toString()); return;} String tmp = new StringBuilder(s).append(node.val).append(\"->\").toString(); deal(node.left, tmp); deal(node.right, tmp);}}",
          "description": "Java版本二，采用字符串拼接的方式隐式完成回溯。"
        },
        {
          "language": "java",
          "code": "class Solution {public List<String> binaryTreePaths(TreeNode root) {List<String> result = new ArrayList<>(); if (root == null) return result; Stack<Object> stack = new Stack<>(); stack.push(root); stack.push(root.val + \"\"); while (!stack.isEmpty()) {String path = (String) stack.pop(); TreeNode node = (TreeNode) stack.pop(); if (node.left == null && node.right == null) {result.add(path);} if (node.right != null) {stack.push(node.right); stack.push(path + \"->\" + node.right.val);} if (node.left != null) {stack.push(node.left); stack.push(path + \"->\" + node.left.val);}} return result;}}",
          "description": "Java迭代法，单个对象栈同时管理节点和路径。"
        },
        {
          "language": "python",
          "code": "class Solution: def traversal(self, cur, path, result): path.append(cur.val) if not cur.left and not cur.right: sPath = '->'.join(map(str, path)) result.append(sPath) return if cur.left: self.traversal(cur.left, path, result) path.pop() if cur.right: self.traversal(cur.right, path, result) path.pop() def binaryTreePaths(self, root): result = [] path = [] if not root: return result self.traversal(root, path, result) return result",
          "description": "Python版本一，使用列表记录路径并执行显式回溯。"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]: if not root: return [] result = [] self.traversal(root, [], result) return result def traversal(self, cur: TreeNode, path: List[int], result: List[str]) -> None: if not cur: return path.append(cur.val) if not cur.left and not cur.right: result.append('->'.join(map(str, path))) if cur.left: self.traversal(cur.left, path[:], result) if cur.right: self.traversal(cur.right, path[:], result)",
          "description": "Python版本二，通过复制列表达到隐式回溯效果。"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: path = '' result = [] if not root: return result self.traversal(root, path, result) return result def traversal(self, cur: TreeNode, path: str, result: List[str]) -> None: path += str(cur.val) if not cur.left and not cur.right: result.append(path) if cur.left: self.traversal(cur.left, path + '->', result) if cur.right: self.traversal(cur.right, path + '->', result)",
          "description": "Python版本三，使用字符串拼接方式隐式实现回溯。"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: stack, path_st, result = [root], [str(root.val)], [] while stack: cur = stack.pop() path = path_st.pop() if not (cur.left or cur.right): result.append(path) if cur.right: stack.append(cur.right) path_st.append(path + '->' + str(cur.right.val)) if cur.left: stack.append(cur.left) path_st.append(path + '->' + str(cur.left.val)) return result",
          "description": "Python迭代法，使用栈模拟递归过程。"
        }
      ],
      "subsections": []
    },
    {
      "name": "递归",
      "text": "递归函数参数以及返回值",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {\n    path.push_back(cur->val); // 中\n    if (cur->left == NULL && cur->right == NULL) { // 遇到叶子节点\n        string sPath;\n        for (int i = 0; i < path.size() - 1; i++) { \n            sPath += to_string(path[i]);\n            sPath += \"->\";\n        }\n        sPath += to_string(path[path.size() - 1]);\n        result.push_back(sPath);\n        return;\n    }\n    if (cur->left) { // 左\n        traversal(cur->left, path, result);\n        path.pop_back(); // 回溯\n    }\n    if (cur->right) { // 右\n        traversal(cur->right, path, result);\n        path.pop_back(); // 回溯\n    }\n}\nvector<string> binaryTreePaths(TreeNode* root) {\n    vector<string> result;\n    vector<int> path;\n    if (root == NULL) return result;\n    traversal(root, path, result);\n    return result;\n}",
          "description": "递归方式实现二叉树路径查找"
        },
        {
          "language": "C++",
          "code": "void traversal(TreeNode* cur, string path, vector<string>& result) {\n    path += to_string(cur->val); // 中\n    if (cur->left == NULL && cur->right == NULL) {\n        result.push_back(path);\n        return;\n    }\n    if (cur->left) traversal(cur->left, path + \"->\", result); // 左\n    if (cur->right) traversal(cur->right, path + \"->\", result); // 右\n}\nvector<string> binaryTreePaths(TreeNode* root) {\n    vector<string> result;\n    string path;\n    if (root == NULL) return result;\n    traversal(root, path, result);\n    return result;\n}",
          "description": "精简版递归方式实现二叉树路径查找"
        },
        {
          "language": "C++",
          "code": "vector<string> binaryTreePaths(TreeNode* root) {\n    stack<TreeNode*> treeSt; // 保存树的遍历节点\n    stack<string> pathSt;   // 保存遍历路径的节点\n    vector<string> result;  // 保存最终路径集合\n    if (root == NULL) return result;\n    treeSt.push(root);\n    pathSt.push(to_string(root->val));\n    while (!treeSt.empty()) {\n        TreeNode* node = treeSt.top(); treeSt.pop(); // 取出节点\n        string path = pathSt.top();pathSt.pop();    // 取出该节点对应的路径\n        if (node->left == NULL && node->right == NULL) { // 遇到叶子节点\n            result.push_back(path);\n        }\n        if (node->right) { // 右\n            treeSt.push(node->right);\n            pathSt.push(path + \"->\" + to_string(node->right->val));\n        }\n        if (node->left) { // 左\n            treeSt.push(node->left);\n            pathSt.push(path + \"->\" + to_string(node->left->val));\n        }\n    }\n    return result;\n}",
          "description": "迭代法实现二叉树路径查找"
        },
        {
          "language": "Java",
          "code": "public List<String> binaryTreePaths(TreeNode root) {\n    List<String> res = new ArrayList<>();\n    if (root == null) {\n        return res;\n    }\n    List<Integer> paths = new ArrayList<>();\n    traversal(root, paths, res);\n    return res;\n}\nprivate void traversal(TreeNode root, List<Integer> paths, List<String> res) {\n    paths.add(root.val);\n    if (root.left == null && root.right == null) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < paths.size() - 1; i++) {\n            sb.append(paths.get(i)).append(\"->\");\n        }\n        sb.append(paths.get(paths.size() - 1));\n        res.add(sb.toString());\n        return;\n    }\n    if (root.left != null) { \n        traversal(root.left, paths, res);\n        paths.remove(paths.size() - 1);\n    }\n    if (root.right != null) { \n        traversal(root.right, paths, res);\n        paths.remove(paths.size() - 1);\n    }\n}",
          "description": "Java版本递归方法"
        },
        {
          "language": "Java",
          "code": "public List<String> binaryTreePaths(TreeNode root) {\n    List<String> result = new ArrayList<>();\n    if (root == null)\n        return result;\n    Stack<Object> stack = new Stack<>();\n    stack.push(root);\n    stack.push(root.val + \"\");\n    while (!stack.isEmpty()) {\n        String path = (String) stack.pop();\n        TreeNode node = (TreeNode) stack.pop();\n        if (node.left == null && node.right == null) {\n            result.add(path);\n        }\n        if (node.right != null) {\n            stack.push(node.right);\n            stack.push(path + \"->\" + node.right.val);\n        }\n        if (node.left != null) {\n            stack.push(node.left);\n            stack.push(path + \"->\" + node.left.val);\n        }\n    }\n    return result;\n}",
          "description": "Java版本迭代方法"
        },
        {
          "language": "Python",
          "code": "def traversal(self, cur, path, result):\n    path.append(cur.val)  # 中\n    if not cur.left and not cur.right:  # 到达叶子节点\n        sPath = '->'.join(map(str, path))\n        result.append(sPath)\n        return\n    if cur.left:  # 左\n        self.traversal(cur.left, path, result)\n        path.pop()  # 回溯\n    if cur.right:  # 右\n        self.traversal(cur.right, path, result)\n        path.pop()  # 回溯\ndef binaryTreePaths(self, root):\n    result = []\n    path = []\n    if not root:\n        return result\n    self.traversal(root, path, result)\n    return result",
          "description": "Python版本递归方法"
        },
        {
          "language": "Python",
          "code": "def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\n    if not root:\n        return []\n    result = []\n    self.traversal(root, [], result)\n    return result\ndef traversal(self, cur: TreeNode, path: List[int], result: List[str]) -> None:\n    if not cur:\n        return\n    path.append(cur.val)\n    if not cur.left and not cur.right:\n        result.append('->'.join(map(str, path)))\n    if cur.left:\n        self.traversal(cur.left, path[:], result)\n    if cur.right:\n        self.traversal(cur.right, path[:], result)",
          "description": "Python版本递归方法（隐形回溯）"
        },
        {
          "language": "Python",
          "code": "def binaryTreePaths(self, root: TreeNode) -> List[str]:\n    path = ''\n    result = []\n    if not root: return result\n    self.traversal(root, path, result)\n    return result\ndef traversal(self, cur: TreeNode, path: str, result: List[str]) -> None:\n    path += str(cur.val)\n    if not cur.left and not cur.right:\n        result.append(path)\n    if cur.left:\n        self.traversal(cur.left, path + '->', result)\n    if cur.right:\n        self.traversal(cur.right, path + '->', result)",
          "description": "Python版本递归方法（隐形回溯版本二）"
        },
        {
          "language": "Python",
          "code": "def binaryTreePaths(self, root: TreeNode) -> List[str]:\n    stack, path_st, result = [root], [str(root.val)], []\n    while stack:\n        cur = stack.pop()\n        path = path_st.pop()\n        if not (cur.left or cur.right):\n            result.append(path)\n        if cur.right:\n            stack.append(cur.right)\n            path_st.append(path + '->' + str(cur.right.val))\n        if cur.left:\n            stack.append(cur.left)\n            path_st.append(path + '->' + str(cur.left.val))\n    return result",
          "description": "Python版本迭代方法"
        }
      ],
      "subsections": []
    },
    {
      "name": "拓展",
      "text": "这里讲解本题解的写法逻辑以及一些更具体的细节，下面的讲解中，涉及到C++语法特性，如果不是C++的录友，就可以不看了，避免越看越晕。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {path.push_back(cur->val); if (cur->left == NULL && cur->right == NULL) {string sPath; for (int i = 0; i < path.size() - 1; i++) {sPath += to_string(path[i]); sPath += \"->\";} sPath += to_string(path[path.size() - 1]); result.push_back(sPath); return;} if (cur->left) {traversal(cur->left, path, result); path.pop_back();} if (cur->right) {traversal(cur->right, path, result); path.pop_back();}} public: vector<string> binaryTreePaths(TreeNode* root) {vector<string> result; vector<int> path; if (root == NULL) return result; traversal(root, path, result); return result;}};",
          "description": "C++版本一：使用递归和回溯获取二叉树的所有路径"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: void traversal(TreeNode* cur, string path, vector<string>& result) {path += to_string(cur->val); if (cur->left == NULL && cur->right == NULL) {result.push_back(path); return;} if (cur->left) traversal(cur->left, path + \"->\", result); if (cur->right) traversal(cur->right, path + \"->\", result);} public: vector<string> binaryTreePaths(TreeNode* root) {vector<string> result; string path; if (root == NULL) return result; traversal(root, path, result); return result;}};",
          "description": "C++版本二：简化版的递归实现，通过字符串拼接隐式完成回溯"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<string> binaryTreePaths(TreeNode* root) {stack<TreeNode*> treeSt; stack<string> pathSt; vector<string> result; if (root == NULL) return result; treeSt.push(root); pathSt.push(to_string(root->val)); while (!treeSt.empty()) {TreeNode* node = treeSt.top(); treeSt.pop(); string path = pathSt.top(); pathSt.pop(); if (node->left == NULL && node->right == NULL) {result.push_back(path);} if (node->right) {treeSt.push(node->right); pathSt.push(path + \"->\" + to_string(node->right->val));} if (node->left) {treeSt.push(node->left); pathSt.push(path + \"->\" + to_string(node->left->val));}} return result;}};",
          "description": "C++迭代法：利用栈来模拟递归过程，同时存储节点及其对应的路径"
        },
        {
          "language": "java",
          "code": "class Solution {public List<String> binaryTreePaths(TreeNode root) {List<String> res = new ArrayList<>(); if (root == null) {return res;} List<Integer> paths = new ArrayList<>(); traversal(root, paths, res); return res;} private void traversal(TreeNode root, List<Integer> paths, List<String> res) {paths.add(root.val); if (root.left == null && root.right == null) {StringBuilder sb = new StringBuilder(); for (int i = 0; i < paths.size() - 1; i++) {sb.append(paths.get(i)).append(\"->\");} sb.append(paths.get(paths.size() - 1)); res.add(sb.toString()); return;} if (root.left != null) {traversal(root.left, paths, res); paths.remove(paths.size() - 1);} if (root.right != null) {traversal(root.right, paths, res); paths.remove(paths.size() - 1);}}}",
          "description": "Java解法一：采用递归加回溯的方式遍历二叉树并收集所有路径"
        },
        {
          "language": "java",
          "code": "class Solution {public List<String> binaryTreePaths(TreeNode root) {List<String> result = new ArrayList<>(); if (root == null) return result; Stack<Object> stack = new Stack<>(); stack.push(root); stack.push(root.val + \"\"); while (!stack.isEmpty()) {String path = (String) stack.pop(); TreeNode node = (TreeNode) stack.pop(); if (node.left == null && node.right == null) {result.add(path);} if (node.right != null) {stack.push(node.right); stack.push(path + \"->\" + node.right.val);} if (node.left != null) {stack.push(node.left); stack.push(path + \"->\" + node.left.val);}} return result;}}",
          "description": "Java解法二：迭代方式求解，使用一个栈来同时存储待处理节点及其路径"
        },
        {
          "language": "python",
          "code": "class Solution: def traversal(self, cur, path, result): path.append(cur.val) if not cur.left and not cur.right: sPath = '->'.join(map(str, path)) result.append(sPath) return if cur.left: self.traversal(cur.left, path, result) path.pop() if cur.right: self.traversal(cur.right, path, result) path.pop() def binaryTreePaths(self, root): result = [] path = [] if not root: return result self.traversal(root, path, result) return result",
          "description": "Python递归法+回溯：定义了一个辅助函数`traversal`用于递归遍历树，并在遇到叶子节点时将路径加入结果列表"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]: if not root: return [] result = [] self.traversal(root, [], result) return result def traversal(self, cur: TreeNode, path: List[int], result: List[str]) -> None: if not cur: return path.append(cur.val) if not cur.left and not cur.right: result.append('->'.join(map(str, path))) if cur.left: self.traversal(cur.left, path[:], result) if cur.right: self.traversal(cur.right, path[:], result)",
          "description": "Python递归法+隐形回溯（版本一）：通过复制当前路径列表传递给子节点的递归调用来实现回溯"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: path = '' result = [] if not root: return result self.traversal(root, path, result) return result def traversal(self, cur: TreeNode, path: str, result: List[str]) -> None: path += str(cur.val) if not cur.left and not cur.right: result.append(path) if cur.left: self.traversal(cur.left, path + '->', result) if cur.right: self.traversal(cur.right, path + '->', result)",
          "description": "Python递归法+隐形回溯（版本二）：直接在递归调用中构建完整的路径字符串"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: stack, path_st, result = [root], [str(root.val)], [] while stack: cur = stack.pop() path = path_st.pop() if not (cur.left or cur.right): result.append(path) if cur.right: stack.append(cur.right) path_st.append(path + '->' + str(cur.right.val)) if cur.left: stack.append(cur.left) path_st.append(path + '->' + str(cur.left.val)) return result",
          "description": "Python迭代法：使用两个栈来分别存储待处理的节点和到这些节点的路径"
        }
      ],
      "subsections": []
    },
    {
      "name": "迭代法",
      "text": "至于非递归的方式，我们可以依然可以使用前序遍历的迭代方式来模拟遍历路径的过程，对该迭代方式不了解的同学，可以看文章二叉树：听说递归能做的，栈也能做！ (https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html)和二叉树：前中后序迭代方式统一写法 (https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html)。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {\n        path.push_back(cur->val); \n        if (cur->left == NULL && cur->right == NULL) {\n            string sPath;\n            for (int i = 0; i < path.size() - 1; i++) {\n                sPath += to_string(path[i]);\n                sPath += \"->\";\n            }\n            sPath += to_string(path[path.size() - 1]);\n            result.push_back(sPath);\n            return;\n        }\n        if (cur->left) {\n            traversal(cur->left, path, result);\n            path.pop_back(); \n        }\n        if (cur->right) {\n            traversal(cur->right, path, result);\n            path.pop_back(); \n        }\n    }\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> result;\n        vector<int> path;\n        if (root == NULL) return result;\n        traversal(root, path, result);\n        return result;\n    }\n};",
          "description": "C++版本一，使用vector记录路径并进行回溯。"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    void traversal(TreeNode* cur, string path, vector<string>& result) {\n        path += to_string(cur->val); \n        if (cur->left == NULL && cur->right == NULL) {\n            result.push_back(path);\n            return;\n        }\n        if (cur->left) traversal(cur->left, path + \"->\", result); \n        if (cur->right) traversal(cur->right, path + \"->\", result); \n    }\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> result;\n        string path;\n        if (root == NULL) return result;\n        traversal(root, path, result);\n        return result;\n    }\n};",
          "description": "C++版本二，通过参数传递隐式实现回溯。"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        stack<TreeNode*> treeSt;\n        stack<string> pathSt;   \n        vector<string> result;  \n        if (root == NULL) return result;\n        treeSt.push(root);\n        pathSt.push(to_string(root->val));\n        while (!treeSt.empty()) {\n            TreeNode* node = treeSt.top(); treeSt.pop(); \n            string path = pathSt.top();pathSt.pop();    \n            if (node->left == NULL && node->right == NULL) { \n                result.push_back(path);\n            }\n            if (node->right) { \n                treeSt.push(node->right);\n                pathSt.push(path + \"->\" + to_string(node->right->val));\n            }\n            if (node->left) { \n                treeSt.push(node->left);\n                pathSt.push(path + \"->\" + to_string(node->left->val));\n            }\n        }\n        return result;\n    }\n};",
          "description": "C++迭代法，利用栈结构模拟递归过程。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> res = new ArrayList<>();\n        if (root == null) {\n            return res;\n        }\n        List<Integer> paths = new ArrayList<>();\n        traversal(root, paths, res);\n        return res;\n    }\n\n    private void traversal(TreeNode root, List<Integer> paths, List<String> res) {\n        paths.add(root.val);\n        if (root.left == null && root.right == null) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < paths.size() - 1; i++) {\n                sb.append(paths.get(i)).append(\"->\");\n            }\n            sb.append(paths.get(paths.size() - 1));\n            res.add(sb.toString());\n            return;\n        }\n        if (root.left != null) { \n            traversal(root.left, paths, res);\n            paths.remove(paths.size() - 1);\n        }\n        if (root.right != null) { \n            traversal(root.right, paths, res);\n            paths.remove(paths.size() - 1);\n        }\n    }\n}",
          "description": "Java版本一，使用ArrayList记录路径并进行回溯。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    List<String> result = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        deal(root, \"\");\n        return result;\n    }\n\n    public void deal(TreeNode node, String s) {\n        if (node == null)\n            return;\n        if (node.left == null && node.right == null) {\n            result.add(new StringBuilder(s).append(node.val).toString());\n            return;\n        }\n        String tmp = new StringBuilder(s).append(node.val).append(\"->\").toString();\n        deal(node.left, tmp);\n        deal(node.right, tmp);\n    }\n}",
          "description": "Java版本二，通过字符串拼接隐式实现回溯。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<>();\n        if (root == null)\n            return result;\n        Stack<Object> stack = new Stack<>();\n        stack.push(root);\n        stack.push(root.val + \"\");\n        while (!stack.isEmpty()) {\n            String path = (String) stack.pop();\n            TreeNode node = (TreeNode) stack.pop();\n            if (node.left == null && node.right == null) {\n                result.add(path);\n            }\n            if (node.right != null) {\n                stack.push(node.right);\n                stack.push(path + \"->\" + node.right.val);\n            }\n            if (node.left != null) {\n                stack.push(node.left);\n                stack.push(path + \"->\" + node.left.val);\n            }\n        }\n        return result;\n    }\n}",
          "description": "Java迭代法，利用单一栈结构同时保存节点和路径。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def traversal(self, cur, path, result):\n        path.append(cur.val)  \n        if not cur.left and not cur.right:  \n            sPath = '->'.join(map(str, path))\n            result.append(sPath)\n            return\n        if cur.left:  \n            self.traversal(cur.left, path, result)\n            path.pop()  \n        if cur.right:  \n            self.traversal(cur.right, path, result)\n            path.pop()  \n\n    def binaryTreePaths(self, root):\n        result = []\n        path = []\n        if not root:\n            return result\n        self.traversal(root, path, result)\n        return result",
          "description": "Python递归法，使用列表记录路径并进行回溯。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\n        if not root:\n            return []\n        result = []\n        self.traversal(root, [], result)\n        return result\n\n    def traversal(self, cur: TreeNode, path: List[int], result: List[str]) -> None:\n        if not cur:\n            return\n        path.append(cur.val)\n        if not cur.left and not cur.right:\n            result.append('->'.join(map(str, path)))\n        if cur.left:\n            self.traversal(cur.left, path[:], result)\n        if cur.right:\n            self.traversal(cur.right, path[:], result)",
          "description": "Python递归法+隐形回溯（版本一），通过复制列表实现回溯。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\n        path = ''\n        result = []\n        if not root: return result\n        self.traversal(root, path, result)\n        return result\n\n    def traversal(self, cur: TreeNode, path: str, result: List[str]) -> None:\n        path += str(cur.val)\n        if not cur.left and not cur.right:\n            result.append(path)\n\n        if cur.left:\n            self.traversal(cur.left, path + '->', result)\n\n        if cur.right:\n            self.traversal(cur.right, path + '->', result)",
          "description": "Python递归法+隐形回溯（版本二），通过字符串拼接实现回溯。"
        },
        {
          "language": "python",
          "code": "class Solution:\n\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\n        stack, path_st, result = [root], [str(root.val)], []\n\n        while stack:\n            cur = stack.pop()\n            path = path_st.pop()\n            if not (cur.left or cur.right):\n                result.append(path)\n            if cur.right:\n                stack.append(cur.right)\n                path_st.append(path + '->' + str(cur.right.val))\n            if cur.left:\n                stack.append(cur.left)\n                path_st.append(path + '->' + str(cur.left.val))\n\n        return result",
          "description": "Python迭代法，利用栈结构模拟递归过程。"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "本文我们开始初步涉及到了回溯，很多同学过了这道题目，可能都不知道自己其实使用了回溯，回溯和递归都是相伴相生的。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {path.push_back(cur->val); if (cur->left == NULL && cur->right == NULL) {string sPath; for (int i = 0; i < path.size() - 1; i++) {sPath += to_string(path[i]); sPath += \"->\";} sPath += to_string(path[path.size() - 1]); result.push_back(sPath); return;} if (cur->left) {traversal(cur->left, path, result); path.pop_back();} if (cur->right) {traversal(cur->right, path, result); path.pop_back();}} public: vector<string> binaryTreePaths(TreeNode* root) {vector<string> result; vector<int> path; if (root == NULL) return result; traversal(root, path, result); return result;}};",
          "description": "C++版本一，使用递归和显式回溯"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: void traversal(TreeNode* cur, string path, vector<string>& result) {path += to_string(cur->val); if (cur->left == NULL && cur->right == NULL) {result.push_back(path); return;} if (cur->left) traversal(cur->left, path + \"->\", result); if (cur->right) traversal(cur->right, path + \"->\", result);} public: vector<string> binaryTreePaths(TreeNode* root) {vector<string> result; string path; if (root == NULL) return result; traversal(root, path, result); return result;}};",
          "description": "C++版本二，使用递归和隐式回溯"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<string> binaryTreePaths(TreeNode* root) {stack<TreeNode*> treeSt; stack<string> pathSt; vector<string> result; if (root == NULL) return result; treeSt.push(root); pathSt.push(to_string(root->val)); while (!treeSt.empty()) {TreeNode* node = treeSt.top(); treeSt.pop(); string path = pathSt.top(); pathSt.pop(); if (node->left == NULL && node->right == NULL) {result.push_back(path);} if (node->right) {treeSt.push(node->right); pathSt.push(path + \"->\" + to_string(node->right->val));} if (node->left) {treeSt.push(node->left); pathSt.push(path + \"->\" + to_string(node->left->val));}} return result;}};",
          "description": "C++迭代法"
        },
        {
          "language": "java",
          "code": "import java.util.*; class Solution {public List<String> binaryTreePaths(TreeNode root) {List<String> res = new ArrayList<>(); if (root == null) {return res;} List<Integer> paths = new ArrayList<>(); traversal(root, paths, res); return res;} private void traversal(TreeNode root, List<Integer> paths, List<String> res) {paths.add(root.val); if (root.left == null && root.right == null) {StringBuilder sb = new StringBuilder(); for (int i = 0; i < paths.size() - 1; i++) {sb.append(paths.get(i)).append(\"->\");} sb.append(paths.get(paths.size() - 1)); res.add(sb.toString()); return;} if (root.left != null) {traversal(root.left, paths, res); paths.remove(paths.size() - 1);} if (root.right != null) {traversal(root.right, paths, res); paths.remove(paths.size() - 1);}}}",
          "description": "Java解法一，使用递归和显式回溯"
        },
        {
          "language": "java",
          "code": "import java.util.*; class Solution {List<String> result = new ArrayList<>(); public List<String> binaryTreePaths(TreeNode root) {deal(root, \"\"); return result;} public void deal(TreeNode node, String s) {if (node == null) return; if (node.left == null && node.right == null) {result.add(new StringBuilder(s).append(node.val).toString()); return;} String tmp = new StringBuilder(s).append(node.val).append(\"->\").toString(); deal(node.left, tmp); deal(node.right, tmp);}}",
          "description": "Java解法二，使用递归和隐式回溯"
        },
        {
          "language": "java",
          "code": "import java.util.*; class Solution {public List<String> binaryTreePaths(TreeNode root) {List<String> result = new ArrayList<>(); if (root == null) return result; Stack<Object> stack = new Stack<>(); stack.push(root); stack.push(root.val + \"\"); while (!stack.isEmpty()) {String path = (String) stack.pop(); TreeNode node = (TreeNode) stack.pop(); if (node.left == null && node.right == null) {result.add(path);} if (node.right != null) {stack.push(node.right); stack.push(path + \"->\" + node.right.val);} if (node.left != null) {stack.push(node.left); stack.push(path + \"->\" + node.left.val);}} return result;}}",
          "description": "Java迭代法"
        },
        {
          "language": "python",
          "code": "class Solution: def traversal(self, cur, path, result): path.append(cur.val) if not cur.left and not cur.right: sPath = '->'.join(map(str, path)) result.append(sPath) return if cur.left: self.traversal(cur.left, path, result) path.pop() if cur.right: self.traversal(cur.right, path, result) path.pop() def binaryTreePaths(self, root): result = [] path = [] if not root: return result self.traversal(root, path, result) return result",
          "description": "Python递归法+显式回溯"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]: if not root: return [] result = [] self.traversal(root, [], result) return result def traversal(self, cur: TreeNode, path: List[int], result: List[str]) -> None: if not cur: return path.append(cur.val) if not cur.left and not cur.right: result.append('->'.join(map(str, path))) if cur.left: self.traversal(cur.left, path[:], result) if cur.right: self.traversal(cur.right, path[:], result)",
          "description": "Python递归法+隐形回溯（版本一）"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: path = '' result = [] if not root: return result self.traversal(root, path, result) return result def traversal(self, cur: TreeNode, path: str, result: List[str]) -> None: path += str(cur.val) if not cur.left and not cur.right: result.append(path) if cur.left: self.traversal(cur.left, path + '->', result) if cur.right: self.traversal(cur.right, path + '->', result)",
          "description": "Python递归法+隐形回溯（版本二）"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: stack, path_st, result = [root], [str(root.val)], [] while stack: cur = stack.pop() path = path_st.pop() if not (cur.left or cur.right): result.append(path) if cur.right: stack.append(cur.right) path_st.append(path + '->' + str(cur.right.val)) if cur.left: stack.append(cur.left) path_st.append(path + '->' + str(cur.left.val)) return result",
          "description": "Python迭代法"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution { public List<String> binaryTreePaths(TreeNode root) { List<String> res = new ArrayList<>(); if (root == null) { return res; } List<Integer> paths = new ArrayList<>(); traversal(root, paths, res); return res; } private void traversal(TreeNode root, List<Integer> paths, List<String> res) { paths.add(root.val); if (root.left == null && root.right == null) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < paths.size() - 1; i++) { sb.append(paths.get(i)).append(\"->\"); } sb.append(paths.get(paths.size() - 1)); res.add(sb.toString()); return; } if (root.left != null) { traversal(root.left, paths, res); paths.remove(paths.size() - 1); } if (root.right != null) { traversal(root.right, paths, res); paths.remove(paths.size() - 1); } } }",
          "description": "Java递归法求解二叉树的所有路径"
        },
        {
          "language": "java",
          "code": "class Solution { List<String> result = new ArrayList<>(); public List<String> binaryTreePaths(TreeNode root) { deal(root, \"\"); return result; } public void deal(TreeNode node, String s) { if (node == null) return; if (node.left == null && node.right == null) { result.add(new StringBuilder(s).append(node.val).toString()); return; } String tmp = new StringBuilder(s).append(node.val).append(\"->\").toString(); deal(node.left, tmp); deal(node.right, tmp); } }",
          "description": "Java递归法（方式二）求解二叉树的所有路径"
        },
        {
          "language": "java",
          "code": "class Solution { public List<String> binaryTreePaths(TreeNode root) { List<String> result = new ArrayList<>(); if (root == null) return result; Stack<Object> stack = new Stack<>(); stack.push(root); stack.push(root.val + \"\"); while (!stack.isEmpty()) { String path = (String) stack.pop(); TreeNode node = (TreeNode) stack.pop(); if (node.left == null && node.right == null) { result.add(path); } if (node.right != null) { stack.push(node.right); stack.push(path + \"->\" + node.right.val); } if (node.left != null) { stack.push(node.left); stack.push(path + \"->\" + node.left.val); } } return result; } }",
          "description": "Java迭代法求解二叉树的所有路径"
        },
        {
          "language": "python",
          "code": "class Solution: def traversal(self, cur, path, result): path.append(cur.val) if not cur.left and not cur.right: sPath = '->'.join(map(str, path)) result.append(sPath) return if cur.left: self.traversal(cur.left, path, result) path.pop() if cur.right: self.traversal(cur.right, path, result) path.pop() def binaryTreePaths(self, root): result = [] path = [] if not root: return result self.traversal(root, path, result) return result",
          "description": "Python递归法加回溯求解二叉树的所有路径"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]: if not root: return [] result = [] self.traversal(root, [], result) return result def traversal(self, cur: TreeNode, path: List[int], result: List[str]) -> None: if not cur: return path.append(cur.val) if not cur.left and not cur.right: result.append('->'.join(map(str, path))) if cur.left: self.traversal(cur.left, path[:], result) if cur.right: self.traversal(cur.right, path[:], result)",
          "description": "Python递归法加隐形回溯（版本一）求解二叉树的所有路径"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: path = '' result = [] if not root: return result self.traversal(root, path, result) return result def traversal(self, cur: TreeNode, path: str, result: List[str]) -> None: path += str(cur.val) if not cur.left and not cur.right: result.append(path) if cur.left: self.traversal(cur.left, path + '->', result) if cur.right: self.traversal(cur.right, path + '->', result)",
          "description": "Python递归法加隐形回溯（版本二）求解二叉树的所有路径"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: stack, path_st, result = [root], [str(root.val)], [] while stack: cur = stack.pop() path = path_st.pop() if not (cur.left or cur.right): result.append(path) if cur.right: stack.append(cur.right) path_st.append(path + '->' + str(cur.right.val)) if cur.left: stack.append(cur.left) path_st.append(path + '->' + str(cur.left.val)) return result",
          "description": "Python迭代法求解二叉树的所有路径"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "//解法一",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {path.push_back(cur->val); if (cur->left == NULL && cur->right == NULL) {string sPath; for (int i = 0; i < path.size() - 1; i++) {sPath += to_string(path[i]); sPath += \"->\";} sPath += to_string(path[path.size() - 1]); result.push_back(sPath); return;} if (cur->left) {traversal(cur->left, path, result); path.pop_back();} if (cur->right) {traversal(cur->right, path, result); path.pop_back();}} public: vector<string> binaryTreePaths(TreeNode* root) {vector<string> result; vector<int> path; if (root == NULL) return result; traversal(root, path, result); return result;}};",
          "description": "C++版递归解法一"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: void traversal(TreeNode* cur, string path, vector<string>& result) {path += to_string(cur->val); if (cur->left == NULL && cur->right == NULL) {result.push_back(path); return;} if (cur->left) traversal(cur->left, path + \"->\", result); if (cur->right) traversal(cur->right, path + \"->\", result);} public: vector<string> binaryTreePaths(TreeNode* root) {vector<string> result; string path; if (root == NULL) return result; traversal(root, path, result); return result;}};",
          "description": "C++版递归解法二"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<string> binaryTreePaths(TreeNode* root) {stack<TreeNode*> treeSt; stack<string> pathSt; vector<string> result; if (root == NULL) return result; treeSt.push(root); pathSt.push(to_string(root->val)); while (!treeSt.empty()) {TreeNode* node = treeSt.top(); treeSt.pop(); string path = pathSt.top(); pathSt.pop(); if (node->left == NULL && node->right == NULL) {result.push_back(path);} if (node->right) {treeSt.push(node->right); pathSt.push(path + \"->\" + to_string(node->right->val));} if (node->left) {treeSt.push(node->left); pathSt.push(path + \"->\" + to_string(node->left->val));}} return result;}};",
          "description": "C++版迭代解法"
        },
        {
          "language": "java",
          "code": "class Solution {public List<String> binaryTreePaths(TreeNode root) {List<String> res = new ArrayList<>(); if (root == null) {return res;} List<Integer> paths = new ArrayList<>(); traversal(root, paths, res); return res;} private void traversal(TreeNode root, List<Integer> paths, List<String> res) {paths.add(root.val); if (root.left == null && root.right == null) {StringBuilder sb = new StringBuilder(); for (int i = 0; i < paths.size() - 1; i++) {sb.append(paths.get(i)).append(\"->\");} sb.append(paths.get(paths.size() - 1)); res.add(sb.toString()); return;} if (root.left != null) {traversal(root.left, paths, res); paths.remove(paths.size() - 1);} if (root.right != null) {traversal(root.right, paths, res); paths.remove(paths.size() - 1);}}}",
          "description": "Java版递归解法一"
        },
        {
          "language": "java",
          "code": "class Solution {List<String> result = new ArrayList<>(); public List<String> binaryTreePaths(TreeNode root) {deal(root, \"\"); return result;} public void deal(TreeNode node, String s) {if (node == null) return; if (node.left == null && node.right == null) {result.add(new StringBuilder(s).append(node.val).toString()); return;} String tmp = new StringBuilder(s).append(node.val).append(\"->\").toString(); deal(node.left, tmp); deal(node.right, tmp);}}",
          "description": "Java版递归解法二"
        },
        {
          "language": "java",
          "code": "class Solution {public List<String> binaryTreePaths(TreeNode root) {List<String> result = new ArrayList<>(); if (root == null) return result; Stack<Object> stack = new Stack<>(); stack.push(root); stack.push(root.val + \"\"); while (!stack.isEmpty()) {String path = (String) stack.pop(); TreeNode node = (TreeNode) stack.pop(); if (node.left == null && node.right == null) {result.add(path);} if (node.right != null) {stack.push(node.right); stack.push(path + \"->\" + node.right.val);} if (node.left != null) {stack.push(node.left); stack.push(path + \"->\" + node.left.val);}} return result;}}",
          "description": "Java版迭代解法"
        },
        {
          "language": "python",
          "code": "class Solution: def traversal(self, cur, path, result): path.append(cur.val) if not cur.left and not cur.right: sPath = '->'.join(map(str, path)) result.append(sPath) return if cur.left: self.traversal(cur.left, path, result) path.pop() if cur.right: self.traversal(cur.right, path, result) path.pop() def binaryTreePaths(self, root): result = [] path = [] if not root: return result self.traversal(root, path, result) return result",
          "description": "Python版递归解法一"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]: if not root: return [] result = [] self.traversal(root, [], result) return result def traversal(self, cur: TreeNode, path: List[int], result: List[str]) -> None: if not cur: return path.append(cur.val) if not cur.left and not cur.right: result.append('->'.join(map(str, path))) if cur.left: self.traversal(cur.left, path[:], result) if cur.right: self.traversal(cur.right, path[:], result)",
          "description": "Python版递归解法二（版本一）"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: path = '' result = [] if not root: return result self.traversal(root, path, result) return result def traversal(self, cur: TreeNode, path: str, result: List[str]) -> None: path += str(cur.val) if not cur.left and not cur.right: result.append(path) if cur.left: self.traversal(cur.left, path + '->', result) if cur.right: self.traversal(cur.right, path + '->', result)",
          "description": "Python版递归解法二（版本二）"
        },
        {
          "language": "python",
          "code": "class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: stack, path_st, result = [root], [str(root.val)], [] while stack: cur = stack.pop() path = path_st.pop() if not (cur.left or cur.right): result.append(path) if cur.right: stack.append(cur.right) path_st.append(path + '->' + str(cur.right.val)) if cur.left: stack.append(cur.left) path_st.append(path + '->' + str(cur.left.val)) return result",
          "description": "Python版迭代解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python:",
      "text": "递归法+回溯",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {\n        path.push_back(cur->val); // 中\n        if (cur->left == NULL && cur->right == NULL) { // 遇到叶子节点\n            string sPath;\n            for (int i = 0; i < path.size() - 1; i++) { // 将path里记录的路径转为string格式\n                sPath += to_string(path[i]);\n                sPath += \"->\";\n            }\n            sPath += to_string(path[path.size() - 1]); // 记录最后一个节点（叶子节点）\n            result.push_back(sPath); // 收集一个路径\n            return;\n        }\n        if (cur->left) { // 左 \n            traversal(cur->left, path, result);\n            path.pop_back(); // 回溯\n        }\n        if (cur->right) { // 右\n            traversal(cur->right, path, result);\n            path.pop_back(); // 回溯\n        }\n    }\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> result;\n        vector<int> path;\n        if (root == NULL) return result;\n        traversal(root, path, result);\n        return result;\n    }\n};",
          "description": "C++版本一，使用vector<int>来存储路径，显式回溯"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    void traversal(TreeNode* cur, string path, vector<string>& result) {\n        path += to_string(cur->val); // 中\n        if (cur->left == NULL && cur->right == NULL) {\n            result.push_back(path);\n            return;\n        }\n        if (cur->left) traversal(cur->left, path + \"->\", result); // 左\n        if (cur->right) traversal(cur->right, path + \"->\", result); // 右\n    }\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> result;\n        string path;\n        if (root == NULL) return result;\n        traversal(root, path, result);\n        return result;\n    }\n};",
          "description": "C++版本二，使用string直接构建路径，隐式回溯"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> res = new ArrayList<>();\n        if (root == null) {\n            return res;\n        }\n        List<Integer> paths = new ArrayList<>();\n        traversal(root, paths, res);\n        return res;\n    }\n    private void traversal(TreeNode root, List<Integer> paths, List<String> res) {\n        paths.add(root.val);\n        if (root.left == null && root.right == null) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < paths.size() - 1; i++) {\n                sb.append(paths.get(i)).append(\"->\");\n            }\n            sb.append(paths.get(paths.size() - 1));\n            res.add(sb.toString());\n            return;\n        }\n        if (root.left != null) {\n            traversal(root.left, paths, res);\n            paths.remove(paths.size() - 1);\n        }\n        if (root.right != null) {\n            traversal(root.right, paths, res);\n            paths.remove(paths.size() - 1);\n        }\n    }\n}",
          "description": "Java递归法+回溯，使用ArrayList存储路径"
        },
        {
          "language": "java",
          "code": "class Solution {\n    List<String> result = new ArrayList<>();\n    public List<String> binaryTreePaths(TreeNode root) {\n        deal(root, \"\");\n        return result;\n    }\n    public void deal(TreeNode node, String s) {\n        if (node == null)\n            return;\n        if (node.left == null && node.right == null) {\n            result.add(new StringBuilder(s).append(node.val).toString());\n            return;\n        }\n        String tmp = new StringBuilder(s).append(node.val).append(\"->\").toString();\n        deal(node.left, tmp);\n        deal(node.right, tmp);\n    }\n}",
          "description": "Java递归法+隐形回溯"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def traversal(self, cur, path, result):\n        path.append(cur.val)  # 中\n        if not cur.left and not cur.right:  # 到达叶子节点\n            sPath = '->'.join(map(str, path))\n            result.append(sPath)\n            return\n        if cur.left:  # 左\n            self.traversal(cur.left, path, result)\n            path.pop()  # 回溯\n        if cur.right:  # 右\n            self.traversal(cur.right, path, result)\n            path.pop()  # 回溯\n    def binaryTreePaths(self, root):\n        result = []\n        path = []\n        if not root:\n            return result\n        self.traversal(root, path, result)\n        return result",
          "description": "Python递归法+回溯"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\n        if not root:\n            return []\n        result = []\n        self.traversal(root, [], result)\n        return result\n    def traversal(self, cur: TreeNode, path: List[int], result: List[str]) -> None:\n        if not cur:\n            return\n        path.append(cur.val)\n        if not cur.left and not cur.right:\n            result.append('->'.join(map(str, path)))\n        if cur.left:\n            self.traversal(cur.left, path[:], result)\n        if cur.right:\n            self.traversal(cur.right, path[:], result)",
          "description": "Python递归法+隐形回溯（版本一）"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\n        path = ''\n        result = []\n        if not root: return result\n        self.traversal(root, path, result)\n        return result\n    def traversal(self, cur: TreeNode, path: str, result: List[str]) -> None:\n        path += str(cur.val)\n        if not cur.left and not cur.right:\n            result.append(path)\n        if cur.left:\n            self.traversal(cur.left, path + '->', result)\n        if cur.right:\n            self.traversal(cur.right, path + '->', result)",
          "description": "Python递归法+隐形回溯（版本二）"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "C++",
      "code": "class Solution {private: void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {path.push_back(cur->val); if (cur->left == NULL && cur->right == NULL) { string sPath; for (int i = 0; i < path.size() - 1; i++) {sPath += to_string(path[i]); sPath += \"->\";} sPath += to_string(path[path.size() - 1]); result.push_back(sPath); return; } if (cur->left) {traversal(cur->left, path, result); path.pop_back();} if (cur->right) {traversal(cur->right, path, result); path.pop_back();}} public: vector<string> binaryTreePaths(TreeNode* root) {vector<string> result; vector<int> path; if (root == NULL) return result; traversal(root, path, result); return result;}};",
      "description": "通过递归和回溯找到二叉树的所有路径。"
    },
    {
      "language": "C++",
      "code": "class Solution {private: void traversal(TreeNode* cur, string path, vector<string>& result) {path += to_string(cur->val); if (cur->left == NULL && cur->right == NULL) {result.push_back(path); return;} if (cur->left) traversal(cur->left, path + \"->\", result); if (cur->right) traversal(cur->right, path + \"->\", result);} public: vector<string> binaryTreePaths(TreeNode* root) {vector<string> result; string path; if (root == NULL) return result; traversal(root, path, result); return result;}};",
      "description": "简化版的递归方法，使用字符串构建路径。"
    },
    {
      "language": "C++",
      "code": "class Solution {public: vector<string> binaryTreePaths(TreeNode* root) {stack<TreeNode*> treeSt; stack<string> pathSt; vector<string> result; if (root == NULL) return result; treeSt.push(root); pathSt.push(to_string(root->val)); while (!treeSt.empty()) {TreeNode* node = treeSt.top(); treeSt.pop(); string path = pathSt.top(); pathSt.pop(); if (node->left == NULL && node->right == NULL) {result.push_back(path);} if (node->right) {treeSt.push(node->right); pathSt.push(path + \"->\" + to_string(node->right->val));} if (node->left) {treeSt.push(node->left); pathSt.push(path + \"->\" + to_string(node->left->val));}} return result;}};",
      "description": "迭代法实现查找所有路径。"
    },
    {
      "language": "Java",
      "code": "class Solution {public List<String> binaryTreePaths(TreeNode root) {List<String> res = new ArrayList<>(); if (root == null) {return res;} List<Integer> paths = new ArrayList<>(); traversal(root, paths, res); return res;} private void traversal(TreeNode root, List<Integer> paths, List<String> res) {paths.add(root.val); if (root.left == null && root.right == null) {StringBuilder sb = new StringBuilder(); for (int i = 0; i < paths.size() - 1; i++) {sb.append(paths.get(i)).append(\"->\");} sb.append(paths.get(paths.size() - 1)); res.add(sb.toString()); return;} if (root.left != null) {traversal(root.left, paths, res); paths.remove(paths.size() - 1);} if (root.right != null) {traversal(root.right, paths, res); paths.remove(paths.size() - 1);}}}",
      "description": "Java版本的递归与回溯实现。"
    },
    {
      "language": "Java",
      "code": "class Solution {public List<String> binaryTreePaths(TreeNode root) {List<String> result = new ArrayList<>(); if (root == null) return result; Stack<Object> stack = new Stack<>(); stack.push(root); stack.push(root.val + \"\"); while (!stack.isEmpty()) {String path = (String) stack.pop(); TreeNode node = (TreeNode) stack.pop(); if (node.left == null && node.right == null) {result.add(path);} if (node.right != null) {stack.push(node.right); stack.push(path + \"->\" + node.right.val);} if (node.left != null) {stack.push(node.left); stack.push(path + \"->\" + node.left.val);}} return result;}}",
      "description": "Java版本的迭代法实现。"
    },
    {
      "language": "Python",
      "code": "class Solution: def traversal(self, cur, path, result): path.append(cur.val) if not cur.left and not cur.right: sPath = '->'.join(map(str, path)) result.append(sPath) return if cur.left: self.traversal(cur.left, path, result) path.pop() if cur.right: self.traversal(cur.right, path, result) path.pop() def binaryTreePaths(self, root): result = [] path = [] if not root: return result self.traversal(root, path, result) return result",
      "description": "Python版本的递归与回溯实现。"
    },
    {
      "language": "Python",
      "code": "class Solution: def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]: if not root: return [] result = [] self.traversal(root, [], result) return result def traversal(self, cur: TreeNode, path: List[int], result: List[str]) -> None: if not cur: return path.append(cur.val) if not cur.left and not cur.right: result.append('->'.join(map(str, path))) if cur.left: self.traversal(cur.left, path[:], result) if cur.right: self.traversal(cur.right, path[:], result)",
      "description": "Python版本的隐形回溯实现（版本一）。"
    },
    {
      "language": "Python",
      "code": "class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: path = '' result = [] if not root: return result self.traversal(root, path, result) return result def traversal(self, cur: TreeNode, path: str, result: List[str]) -> None: path += str(cur.val) if not cur.left and not cur.right: result.append(path) if cur.left: self.traversal(cur.left, path + '->', result) if cur.right: self.traversal(cur.right, path + '->', result)",
      "description": "Python版本的隐形回溯实现（版本二）。"
    },
    {
      "language": "Python",
      "code": "class Solution: def binaryTreePaths(self, root: TreeNode) -> List[str]: stack, path_st, result = [root], [str(root.val)], [] while stack: cur = stack.pop() path = path_st.pop() if not (cur.left or cur.right): result.append(path) if cur.right: stack.append(cur.right) path_st.append(path + '->' + str(cur.right.val)) if cur.left: stack.append(cur.left) path_st.append(path + '->' + str(cur.left.val)) return result",
      "description": "Python版本的迭代法实现。"
    }
  ],
  "common_mistakes": [
    "未正确实现回溯逻辑，导致某些路径被重复添加或遗漏。",
    "忽视了对空指针的处理，可能导致程序崩溃或错误的结果。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/2021020415161576.png",
      "description": "该图片展示了一个二叉树结构，要求找到从根节点到每个叶子节点的所有路径，并以字符串形式输出，体现了深度优先搜索（DFS）算法的应用。",
      "context": "该图片展示了给定二叉树的结构，用于说明题目中提到的从根节点到叶子节点的所有路径问题。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210204151702443.png",
      "description": "这张图片展示了二叉树的前序遍历过程，通过红色箭头和数字标注了访问节点的顺序和回溯路径。",
      "context": "该图片展示了在解决从根节点到叶子节点路径问题时采用的前序遍历及回溯过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20220831173322.png",
      "description": "这张图片展示了一棵二叉树，重点描述了在遍历过程中路径值的更新（`path += 3`）和回溯操作。",
      "context": "该图片展示了在不使用引用作为参数的情况下，路径字符串path在递归过程中的变化情况，具体说明了当从节点4移动到节点3再返回时，path值未受影响的现象。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/2021020415161576.png",
      "description": "GIF展示了二叉树前序遍历及回溯过程，用于寻找从根节点到每个叶子节点的所有路径。",
      "context": "该GIF动画展示了如何通过前序遍历及回溯的方法记录从根节点到叶子节点的所有路径的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210204151702443.png",
      "description": "GIF展示了通过前序遍历二叉树并使用回溯法记录从根节点到每个叶子节点路径的过程。",
      "context": "该GIF动画展示了从根节点到叶子节点进行前序遍历并应用回溯法记录路径的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20220831173322.png",
      "description": "GIF展示了在遍历树结构过程中，路径字符串随着节点访问而变化但不进行回溯的过程。",
      "context": "该GIF动画展示了在递归过程中，由于参数`path`未使用引用传递，因此当从子节点回溯到父节点时，`path`的值不会保留子节点的信息，从而直观地解释了为何不需要显式回溯路径。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\二叉树\\二叉树的所有路径.txt",
  "extracted_at": "2025-07-19T16:53:16.225300",
  "raw_content": "二叉树的所有路径\n力扣题目链接(https://leetcode.cn/problems/binary-tree-paths/)\n\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n\n说明: 叶子节点是指没有子节点的节点。\n\nhttps://file1.kamacoder.com/i/algo/2021020415161576.png\n\n\n#思路\n这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。\n\n在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。\n\n前序遍历以及回溯的过程如图：\n\nhttps://file1.kamacoder.com/i/algo/20210204151702443.png\n\n我们先使用递归的方式，来做前序遍历。要知道递归和回溯就是一家的，本题也需要回溯。\n\n#递归\n递归函数参数以及返回值\n要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下：\n\nvoid traversal(TreeNode* cur, vector<int>& path, vector<string>& result)\n确定递归终止条件\n在写递归的时候都习惯了这么写：\n\nif (cur == NULL) {\n    终止处理逻辑\n}\n但是本题的终止条件这样写会很麻烦，因为本题要找到叶子节点，就开始结束的处理逻辑了（把路径放进result里）。\n\n那么什么时候算是找到了叶子节点？ 是当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。\n\n所以本题的终止条件是：\n\nif (cur->left == NULL && cur->right == NULL) {\n    终止处理逻辑\n}\n为什么没有判断cur是否为空呢，因为下面的逻辑可以控制空节点不入循环。\n\n再来看一下终止处理的逻辑。\n\n这里使用vector<int> 结构path来记录路径，所以要把vector<int> 结构的path转为string格式，再把这个string 放进 result里。\n\n那么为什么使用了vector<int> 结构来记录路径呢？ 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。\n\n可能有的同学问了，我看有些人的代码也没有回溯啊。\n\n其实是有回溯的，只不过隐藏在函数调用时的参数赋值里，下文我还会提到。\n\n这里我们先使用vector<int>结构的path容器来记录路径，那么终止处理逻辑如下：\n\nif (cur->left == NULL && cur->right == NULL) { // 遇到叶子节点\n    string sPath;\n    for (int i = 0; i < path.size() - 1; i++) { // 将path里记录的路径转为string格式\n        sPath += to_string(path[i]);\n        sPath += \"->\";\n    }\n    sPath += to_string(path[path.size() - 1]); // 记录最后一个节点（叶子节点）\n    result.push_back(sPath); // 收集一个路径\n    return;\n}\n确定单层递归逻辑\n因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。\n\npath.push_back(cur->val);\n\n然后是递归和回溯的过程，上面说过没有判断cur是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。\n\n所以递归前要加上判断语句，下面要递归的节点是否为空，如下\n\nif (cur->left) {\n    traversal(cur->left, path, result);\n}\nif (cur->right) {\n    traversal(cur->right, path, result);\n}\n此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。\n\n那么回溯要怎么回溯呢，一些同学会这么写，如下：\n\nif (cur->left) {\n    traversal(cur->left, path, result);\n}\nif (cur->right) {\n    traversal(cur->right, path, result);\n}\npath.pop_back();\n这个回溯就有很大的问题，我们知道，回溯和递归是一一对应的，有一个递归，就要有一个回溯，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。\n\n所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！\n\n那么代码应该这么写：\n\nif (cur->left) {\n    traversal(cur->left, path, result);\n    path.pop_back(); // 回溯\n}\nif (cur->right) {\n    traversal(cur->right, path, result);\n    path.pop_back(); // 回溯\n}\n那么本题整体代码如下：\n\n// 版本一\nclass Solution {\nprivate:\n\n    void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {\n        path.push_back(cur->val); // 中，中为什么写在这里，因为最后一个节点也要加入到path中 \n        // 这才到了叶子节点\n        if (cur->left == NULL && cur->right == NULL) {\n            string sPath;\n            for (int i = 0; i < path.size() - 1; i++) {\n                sPath += to_string(path[i]);\n                sPath += \"->\";\n            }\n            sPath += to_string(path[path.size() - 1]);\n            result.push_back(sPath);\n            return;\n        }\n        if (cur->left) { // 左 \n            traversal(cur->left, path, result);\n            path.pop_back(); // 回溯\n        }\n        if (cur->right) { // 右\n            traversal(cur->right, path, result);\n            path.pop_back(); // 回溯\n        }\n    }\n\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> result;\n        vector<int> path;\n        if (root == NULL) return result;\n        traversal(root, path, result);\n        return result;\n    }\n};\n如上的C++代码充分体现了回溯。\n\n那么如上代码可以精简成如下代码：\n\nclass Solution {\nprivate:\n\n    void traversal(TreeNode* cur, string path, vector<string>& result) {\n        path += to_string(cur->val); // 中\n        if (cur->left == NULL && cur->right == NULL) {\n            result.push_back(path);\n            return;\n        }\n        if (cur->left) traversal(cur->left, path + \"->\", result); // 左\n        if (cur->right) traversal(cur->right, path + \"->\", result); // 右\n    }\n\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> result;\n        string path;\n        if (root == NULL) return result;\n        traversal(root, path, result);\n        return result;\n\n    }\n};\n如上代码精简了不少，也隐藏了不少东西。\n\n注意在函数定义的时候void traversal(TreeNode* cur, string path, vector<string>& result) ，定义的是string path，每次都是复制赋值，不用使用引用，否则就无法做到回溯的效果。（这里涉及到C++语法知识）\n\n那么在如上代码中，貌似没有看到回溯的逻辑，其实不然，回溯就隐藏在traversal(cur->left, path + \"->\", result);中的 path + \"->\"。 每次函数调用完，path依然是没有加上\"->\" 的，这就是回溯了。\n\n为了把这份精简代码的回溯过程展现出来，大家可以试一试把：\n\nif (cur->left) traversal(cur->left, path + \"->\", result); // 左  回溯就隐藏在这里\n改成如下代码：\n\npath += \"->\";\ntraversal(cur->left, path, result); // 左\n即：\n\nif (cur->left) {\n    path += \"->\";\n    traversal(cur->left, path, result); // 左\n}\nif (cur->right) {\n    path += \"->\";\n    traversal(cur->right, path, result); // 右\n}\n此时就没有回溯了，这个代码就是通过不了的了。\n\n如果想把回溯加上，就要 在上面代码的基础上，加上回溯，就可以AC了。\n\nif (cur->left) {\n    path += \"->\";\n    traversal(cur->left, path, result); // 左\n    path.pop_back(); // 回溯 '>'\n    path.pop_back(); // 回溯 '-'\n}\nif (cur->right) {\n    path += \"->\";\n    traversal(cur->right, path, result); // 右\n    path.pop_back(); // 回溯 '>' \n    path.pop_back(); //  回溯 '-' \n}\n整体代码如下：\n\n//版本二\nclass Solution {\nprivate:\n    void traversal(TreeNode* cur, string path, vector<string>& result) {\n        path += to_string(cur->val); // 中，中为什么写在这里，因为最后一个节点也要加入到path中\n        if (cur->left == NULL && cur->right == NULL) {\n            result.push_back(path);\n            return;\n        }\n        if (cur->left) {\n            path += \"->\";\n            traversal(cur->left, path, result); // 左\n            path.pop_back(); // 回溯 '>'\n            path.pop_back(); // 回溯 '-'\n        }\n        if (cur->right) {\n            path += \"->\";\n            traversal(cur->right, path, result); // 右\n            path.pop_back(); // 回溯'>'\n            path.pop_back(); // 回溯 '-'\n        }\n    }\n\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> result;\n        string path;\n        if (root == NULL) return result;\n        traversal(root, path, result);\n        return result;\n\n    }\n};\n\n大家应该可以感受出来，如果把 path + \"->\"作为函数参数就是可以的，因为并没有改变path的数值，执行完递归函数之后，path依然是之前的数值（相当于回溯了）\n\n综合以上，第二种递归的代码虽然精简但把很多重要的点隐藏在了代码细节里，第一种递归写法虽然代码多一些，但是把每一个逻辑处理都完整的展现出来了。\n\n#拓展\n这里讲解本题解的写法逻辑以及一些更具体的细节，下面的讲解中，涉及到C++语法特性，如果不是C++的录友，就可以不看了，避免越看越晕。\n\n如果是C++的录友，建议本题独立刷过两遍，再看下面的讲解，同样避免越看越晕，造成不必要的负担。\n\n在第二版本的代码中，其实仅仅是回溯了 -> 部分（调用两次pop_back，一个pop> 一次pop-），大家应该疑惑那么 path += to_string(cur->val); 这一步为什么没有回溯呢？ 一条路径能持续加节点 不做回溯吗？\n\n其实关键还在于 参数，使用的是 string path，这里并没有加上引用& ，即本层递归中，path + 该节点数值，但该层递归结束，上一层path的数值并不会受到任何影响。 如图所示：\n\nhttps://file1.kamacoder.com/i/algo/20220831173322.png\n\n节点4 的path，在遍历到节点3，path+3，遍历节点3的递归结束之后，返回节点4（回溯的过程），path并不会把3加上。\n\n所以这是参数中，不带引用，不做地址拷贝，只做内容拷贝的效果。（这里涉及到C++引用方面的知识）\n\n在第一个版本中，函数参数我就使用了引用，即 vector<int>& path ，这是会拷贝地址的，所以 本层递归逻辑如果有path.push_back(cur->val); 就一定要有对应的 path.pop_back()\n\n那有同学可能想，为什么不去定义一个 string& path 这样的函数参数呢，然后也可能在递归函数中展现回溯的过程，但关键在于，path += to_string(cur->val); 每次是加上一个数字，这个数字如果是个位数，那好说，就调用一次path.pop_back()，但如果是 十位数，百位数，千位数呢？ 百位数就要调用三次path.pop_back()，才能实现对应的回溯操作，这样代码实现就太冗余了。\n\n所以，第一个代码版本中，我才使用 vector 类型的path，这样方便给大家演示代码中回溯的操作。 vector类型的path，不管 每次 路径收集的数字是几位数，总之一定是int，所以就一次 pop_back就可以。\n\n#迭代法\n至于非递归的方式，我们可以依然可以使用前序遍历的迭代方式来模拟遍历路径的过程，对该迭代方式不了解的同学，可以看文章二叉树：听说递归能做的，栈也能做！ (https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html)和二叉树：前中后序迭代方式统一写法 (https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html)。\n\n这里除了模拟递归需要一个栈，同时还需要一个栈来存放对应的遍历路径。\n\nC++代码如下：\n\nclass Solution {\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        stack<TreeNode*> treeSt;// 保存树的遍历节点\n        stack<string> pathSt;   // 保存遍历路径的节点\n        vector<string> result;  // 保存最终路径集合\n        if (root == NULL) return result;\n        treeSt.push(root);\n        pathSt.push(to_string(root->val));\n        while (!treeSt.empty()) {\n            TreeNode* node = treeSt.top(); treeSt.pop(); // 取出节点 中\n            string path = pathSt.top();pathSt.pop();    // 取出该节点对应的路径\n            if (node->left == NULL && node->right == NULL) { // 遇到叶子节点\n                result.push_back(path);\n            }\n            if (node->right) { // 右\n                treeSt.push(node->right);\n                pathSt.push(path + \"->\" + to_string(node->right->val));\n            }\n            if (node->left) { // 左\n                treeSt.push(node->left);\n                pathSt.push(path + \"->\" + to_string(node->left->val));\n            }\n        }\n        return result;\n    }\n};\n当然，使用java的同学，可以直接定义一个成员变量为object的栈Stack<Object> stack = new Stack<>();，这样就不用定义两个栈了，都放到一个栈里就可以了。\n\n#总结\n本文我们开始初步涉及到了回溯，很多同学过了这道题目，可能都不知道自己其实使用了回溯，回溯和递归都是相伴相生的。\n\n我在第一版递归代码中，把递归与回溯的细节都充分的展现了出来，大家可以自己感受一下。\n\n第二版递归代码对于初学者其实非常不友好，代码看上去简单，但是隐藏细节于无形。\n\n最后我依然给出了迭代法。\n\n对于本题充分了解递归与回溯的过程之后，有精力的同学可以再去实现迭代法。\n\n#其他语言版本\n#Java：\n//解法一\n\n//方式一\nclass Solution {\n    /**\n     * 递归法\n     */\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> res = new ArrayList<>();// 存最终的结果\n        if (root == null) {\n            return res;\n        }\n        List<Integer> paths = new ArrayList<>();// 作为结果中的路径\n        traversal(root, paths, res);\n        return res;\n    }\n\n    private void traversal(TreeNode root, List<Integer> paths, List<String> res) {\n        paths.add(root.val);// 前序遍历，中\n        // 遇到叶子结点\n        if (root.left == null && root.right == null) {\n            // 输出\n            StringBuilder sb = new StringBuilder();// StringBuilder用来拼接字符串，速度更快\n            for (int i = 0; i < paths.size() - 1; i++) {\n                sb.append(paths.get(i)).append(\"->\");\n            }\n            sb.append(paths.get(paths.size() - 1));// 记录最后一个节点\n            res.add(sb.toString());// 收集一个路径\n            return;\n        }\n        // 递归和回溯是同时进行，所以要放在同一个花括号里\n        if (root.left != null) { // 左\n            traversal(root.left, paths, res);\n            paths.remove(paths.size() - 1);// 回溯\n        }\n        if (root.right != null) { // 右\n            traversal(root.right, paths, res);\n            paths.remove(paths.size() - 1);// 回溯\n        }\n    }\n}\n\n//方式二\nclass Solution {\n\n    List<String> result = new ArrayList<>();\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        deal(root, \"\");\n        return result;\n    }\n\n    public void deal(TreeNode node, String s) {\n        if (node == null)\n            return;\n        if (node.left == null && node.right == null) {\n            result.add(new StringBuilder(s).append(node.val).toString());\n            return;\n        }\n        String tmp = new StringBuilder(s).append(node.val).append(\"->\").toString();\n        deal(node.left, tmp);\n        deal(node.right, tmp);\n    }\n}\n// 解法二\nclass Solution {\n    /**\n     * 迭代法\n     */\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<>();\n        if (root == null)\n            return result;\n        Stack<Object> stack = new Stack<>();\n        // 节点和路径同时入栈\n        stack.push(root);\n        stack.push(root.val + \"\");\n        while (!stack.isEmpty()) {\n            // 节点和路径同时出栈\n            String path = (String) stack.pop();\n            TreeNode node = (TreeNode) stack.pop();\n            // 若找到叶子节点\n            if (node.left == null && node.right == null) {\n                result.add(path);\n            }\n            //右子节点不为空\n            if (node.right != null) {\n                stack.push(node.right);\n                stack.push(path + \"->\" + node.right.val);\n            }\n            //左子节点不为空\n            if (node.left != null) {\n                stack.push(node.left);\n                stack.push(path + \"->\" + node.left.val);\n            }\n        }\n        return result;\n    }\n}\n#Python:\n递归法+回溯\n\n# Definition for a binary tree node.\nclass Solution:\n    def traversal(self, cur, path, result):\n        path.append(cur.val)  # 中\n        if not cur.left and not cur.right:  # 到达叶子节点\n            sPath = '->'.join(map(str, path))\n            result.append(sPath)\n            return\n        if cur.left:  # 左\n            self.traversal(cur.left, path, result)\n            path.pop()  # 回溯\n        if cur.right:  # 右\n            self.traversal(cur.right, path, result)\n            path.pop()  # 回溯\n\n    def binaryTreePaths(self, root):\n        result = []\n        path = []\n        if not root:\n            return result\n        self.traversal(root, path, result)\n        return result\n\n\n递归法+隐形回溯（版本一）\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom typing import List, Optional\n\nclass Solution:\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\n        if not root:\n            return []\n        result = []\n        self.traversal(root, [], result)\n        return result\n    \n    def traversal(self, cur: TreeNode, path: List[int], result: List[str]) -> None:\n        if not cur:\n            return\n        path.append(cur.val)\n        if not cur.left and not cur.right:\n            result.append('->'.join(map(str, path)))\n        if cur.left:\n            self.traversal(cur.left, path[:], result)\n        if cur.right:\n            self.traversal(cur.right, path[:], result)\n\n递归法+隐形回溯（版本二）\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\n        path = ''\n        result = []\n        if not root: return result\n        self.traversal(root, path, result)\n        return result\n    \n    def traversal(self, cur: TreeNode, path: str, result: List[str]) -> None:\n        path += str(cur.val)\n        # 若当前节点为leave，直接输出\n        if not cur.left and not cur.right:\n            result.append(path)\n\n        if cur.left:\n            # + '->' 是隐藏回溯\n            self.traversal(cur.left, path + '->', result)\n        \n        if cur.right:\n            self.traversal(cur.right, path + '->', result)\n迭代法：\n\nclass Solution:\n\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\n        # 题目中节点数至少为1\n        stack, path_st, result = [root], [str(root.val)], []\n\n        while stack:\n            cur = stack.pop()\n            path = path_st.pop()\n            # 如果当前节点为叶子节点，添加路径到结果中\n            if not (cur.left or cur.right):\n                result.append(path)\n            if cur.right:\n                stack.append(cur.right)\n                path_st.append(path + '->' + str(cur.right.val))\n            if cur.left:\n                stack.append(cur.left)\n                path_st.append(path + '->' + str(cur.left.val))\n\n        return result"
}