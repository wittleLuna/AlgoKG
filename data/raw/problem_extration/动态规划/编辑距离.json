{
  "id": "AP_ef6e2778",
  "title": "编辑距离",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/edit-distance/",
  "description": "两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n插入一个字符\n\n删除一个字符\n\n替换一个字符",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划"
  ],
  "data_structure_tags": [
    "数组",
    "矩阵"
  ],
  "technique_tags": [
    "表格填充",
    "优化"
  ],
  "difficulty": null,
  "solution_approach": "通过构建一个二维DP数组来解决编辑距离问题，其中dp[i][j]表示将word1的前i个字符转换为word2的前j个字符所需的最小操作数。根据字符是否相等以及可能的操作（插入、删除、替换）更新状态值。",
  "key_insights": [
    {
      "content": "正确理解dp[i][j]的含义对于解决问题至关重要，它代表了word1的前i-1个字符与word2的前j-1个字符之间的最短编辑距离。"
    },
    {
      "content": "在处理字符串编辑时，向一个字符串中添加元素的效果等同于从另一个字符串中移除该元素，这有助于简化递推公式。"
    },
    {
      "content": "初始化dp数组时，考虑到空串的情况，dp[i][0]=i和dp[0][j]=j分别表示将长度为i或j的字符串变为空串所需的操作次数。"
    },
    {
      "content": "递推过程需要考虑三种基本操作：如果当前字符相同则无需操作；否则，选择替换、插入或删除中的最优解。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "编辑距离终于来了，这道题目如果大家没有了解动态规划的话，会感觉超级复杂。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int minDistance(string word1, string word2) {vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0)); for (int i = 0; i <= word1.size(); i++) dp[i][0] = i; for (int j = 0; j <= word2.size(); j++) dp[0][j] = j; for (int i = 1; i <= word1.size(); i++) {for (int j = 1; j <= word2.size(); j++) {if (word1[i - 1] == word2[j - 1]) {dp[i][j] = dp[i - 1][j - 1];} else {dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;}}} return dp[word1.size()][word2.size()];}};",
          "description": "C++版本的编辑距离解决方案"
        },
        {
          "language": "java",
          "code": "public int minDistance(String word1, String word2) {int m = word1.length();int n = word2.length();int[][] dp = new int[m + 1][n + 1];for (int i = 1; i <= m; i++) {dp[i][0] =  i;}for (int j = 1; j <= n; j++) {dp[0][j] = j;}for (int i = 1; i <= m; i++) {for (int j = 1; j <= n; j++) {if (word1.charAt(i - 1) == word2.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1];} else {dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;}}}return dp[m][n];}",
          "description": "Java版本的编辑距离解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def minDistance(self, word1: str, word2: str) -> int: dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)] for i in range(len(word1)+1): dp[i][0] = i for j in range(len(word2)+1): dp[0][j] = j for i in range(1, len(word1)+1): for j in range(1, len(word2)+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 return dp[-1][-1]",
          "description": "Python版本的编辑距离解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "1. 确定dp数组（dp table）以及下标的含义",
      "text": "dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int minDistance(string word1, string word2) {vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0)); for (int i = 0; i <= word1.size(); i++) dp[i][0] = i; for (int j = 0; j <= word2.size(); j++) dp[0][j] = j; for (int i = 1; i <= word1.size(); i++) {for (int j = 1; j <= word2.size(); j++) {if (word1[i - 1] == word2[j - 1]) {dp[i][j] = dp[i - 1][j - 1];} else {dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;}}} return dp[word1.size()][word2.size()];}};",
          "description": "C++实现的编辑距离算法"
        },
        {
          "language": "java",
          "code": "public int minDistance(String word1, String word2) {int m = word1.length(); int n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i <= m; i++) {dp[i][0] =  i;} for (int j = 1; j <= n; j++) {dp[0][j] = j;} for (int i = 1; i <= m; i++) {for (int j = 1; j <= n; j++) {if (word1.charAt(i - 1) == word2.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1];} else {dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;}}} return dp[m][n];}",
          "description": "Java实现的编辑距离算法"
        },
        {
          "language": "python",
          "code": "class Solution: def minDistance(self, word1: str, word2: str) -> int: dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)] for i in range(len(word1)+1): dp[i][0] = i for j in range(len(word2)+1): dp[0][j] = j for i in range(1, len(word1)+1): for j in range(1, len(word2)+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 return dp[-1][-1]",
          "description": "Python实现的编辑距离算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "2. 确定递推公式",
      "text": "在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int minDistance(string word1, string word2) { vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0)); for (int i = 0; i <= word1.size(); i++) dp[i][0] = i; for (int j = 0; j <= word2.size(); j++) dp[0][j] = j; for (int i = 1; i <= word1.size(); i++) { for (int j = 1; j <= word2.size(); j++) { if (word1[i - 1] == word2[j - 1]) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1; } } } return dp[word1.size()][word2.size()]; }};",
          "description": "C++实现计算两个字符串的编辑距离"
        },
        {
          "language": "java",
          "code": "public int minDistance(String word1, String word2) { int m = word1.length(); int n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i <= m; i++) { dp[i][0] =  i; } for (int j = 1; j <= n; j++) { dp[0][j] = j; } for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1; } } } return dp[m][n];}",
          "description": "Java实现计算两个字符串的编辑距离"
        },
        {
          "language": "python",
          "code": "class Solution: def minDistance(self, word1: str, word2: str) -> int: dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)] for i in range(len(word1)+1): dp[i][0] = i for j in range(len(word2)+1): dp[0][j] = j for i in range(1, len(word1)+1): for j in range(1, len(word2)+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 return dp[-1][-1]",
          "description": "Python实现计算两个字符串的编辑距离"
        }
      ],
      "subsections": []
    },
    {
      "name": "3. dp数组如何初始化",
      "text": "再回顾一下dp[i][j]的定义：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int minDistance(string word1, string word2) { vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0)); for (int i = 0; i <= word1.size(); i++) dp[i][0] = i; for (int j = 0; j <= word2.size(); j++) dp[0][j] = j; for (int i = 1; i <= word1.size(); i++) { for (int j = 1; j <= word2.size(); j++) { if (word1[i - 1] == word2[j - 1]) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1; } } } return dp[word1.size()][word2.size()]; }};",
          "description": "C++实现的编辑距离算法"
        },
        {
          "language": "java",
          "code": "public int minDistance(String word1, String word2) { int m = word1.length(); int n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i <= m; i++) { dp[i][0] =  i; } for (int j = 1; j <= n; j++) { dp[0][j] = j; } for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1; } } } return dp[m][n];}",
          "description": "Java实现的编辑距离算法"
        },
        {
          "language": "python",
          "code": "class Solution: def minDistance(self, word1: str, word2: str) -> int: dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)] for i in range(len(word1)+1): dp[i][0] = i for j in range(len(word2)+1): dp[0][j] = j for i in range(1, len(word1)+1): for j in range(1, len(word2)+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 return dp[-1][-1]",
          "description": "Python实现的编辑距离算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "4. 确定遍历顺序",
      "text": "从如下四个递推公式：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int minDistance(string word1, string word2) {vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0)); for (int i = 0; i <= word1.size(); i++) dp[i][0] = i; for (int j = 0; j <= word2.size(); j++) dp[0][j] = j; for (int i = 1; i <= word1.size(); i++) {for (int j = 1; j <= word2.size(); j++) {if (word1[i - 1] == word2[j - 1]) {dp[i][j] = dp[i - 1][j - 1];} else {dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;}}} return dp[word1.size()][word2.size()];}};",
          "description": "C++版本的编辑距离解决方案"
        },
        {
          "language": "java",
          "code": "public int minDistance(String word1, String word2) {int m = word1.length(); int n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i <= m; i++) {dp[i][0] =  i;} for (int j = 1; j <= n; j++) {dp[0][j] = j;} for (int i = 1; i <= m; i++) {for (int j = 1; j <= n; j++) {if (word1.charAt(i - 1) == word2.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1];} else {dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;}}} return dp[m][n];}",
          "description": "Java版本的编辑距离解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def minDistance(self, word1: str, word2: str) -> int: dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)] for i in range(len(word1)+1): dp[i][0] = i for j in range(len(word2)+1): dp[0][j] = j for i in range(1, len(word1)+1): for j in range(1, len(word2)+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 return dp[-1][-1]",
          "description": "Python版本的编辑距离解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "5. 举例推导dp数组",
      "text": "以示例1为例，输入：word1 = \"horse\", word2 = \"ros\"为例，dp矩阵状态图如下：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int minDistance(string word1, string word2) {vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0)); for (int i = 0; i <= word1.size(); i++) dp[i][0] = i; for (int j = 0; j <= word2.size(); j++) dp[0][j] = j; for (int i = 1; i <= word1.size(); i++) {for (int j = 1; j <= word2.size(); j++) {if (word1[i - 1] == word2[j - 1]) {dp[i][j] = dp[i - 1][j - 1];} else {dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;}}} return dp[word1.size()][word2.size()];}};",
          "description": "C++解决方案"
        },
        {
          "language": "java",
          "code": "public int minDistance(String word1, String word2) {int m = word1.length(); int n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i <= m; i++) {dp[i][0] =  i;} for (int j = 1; j <= n; j++) {dp[0][j] = j;} for (int i = 1; i <= m; i++) {for (int j = 1; j <= n; j++) {if (word1.charAt(i - 1) == word2.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1];} else {dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;}}} return dp[m][n];}",
          "description": "Java解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def minDistance(self, word1: str, word2: str) -> int: dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)] for i in range(len(word1)+1): dp[i][0] = i for j in range(len(word2)+1): dp[0][j] = j for i in range(1, len(word1)+1): for j in range(1, len(word2)+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 return dp[-1][-1]",
          "description": "Python解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "public int minDistance(String word1, String word2) { int m = word1.length(); int n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i <= m; i++) { dp[i][0] =  i; } for (int j = 1; j <= n; j++) { dp[0][j] = j; } for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1; } } } return dp[m][n]; }",
          "description": "使用动态规划计算两个字符串的最小编辑距离。"
        },
        {
          "language": "python",
          "code": "class Solution: def minDistance(self, word1: str, word2: str) -> int: dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)] for i in range(len(word1)+1): dp[i][0] = i for j in range(len(word2)+1): dp[0][j] = j for i in range(1, len(word1)+1): for j in range(1, len(word2)+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 return dp[-1][-1]",
          "description": "使用动态规划计算两个字符串的最小编辑距离。"
        },
        {
          "language": "cpp",
          "code": "class Solution { public: int minDistance(string word1, string word2) { vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0)); for (int i = 0; i <= word1.size(); i++) dp[i][0] = i; for (int j = 0; j <= word2.size(); j++) dp[0][j] = j; for (int i = 1; i <= word1.size(); i++) { for (int j = 1; j <= word2.size(); j++) { if (word1[i - 1] == word2[j - 1]) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1; } } } return dp[word1.size()][word2.size()]; } };",
          "description": "使用动态规划计算两个字符串的最小编辑距离。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "public int minDistance(String word1, String word2) {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));\n        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;\n        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;\n        for (int i = 1; i <= word1.size(); i++) {\n            for (int j = 1; j <= word2.size(); j++) {\n                if (word1[i - 1] == word2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                }\n                else {\n                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n                }\n            }\n        }\n        return dp[word1.size()][word2.size()];\n    }\n};",
          "description": "计算两个字符串之间的最小编辑距离"
        },
        {
          "language": "java",
          "code": "public int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    for (int i = 1; i <= m; i++) {\n        dp[i][0] =  i;\n    }\n    for (int j = 1; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;\n            }\n        }\n    }\n    return dp[m][n];\n}",
          "description": "计算两个字符串之间的最小编辑距离"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)]\n        for i in range(len(word1)+1):\n            dp[i][0] = i\n        for j in range(len(word2)+1):\n            dp[0][j] = j\n        for i in range(1, len(word1)+1):\n            for j in range(1, len(word2)+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n        return dp[-1][-1]",
          "description": "计算两个字符串之间的最小编辑距离"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "class Solution:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));\n        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;\n        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;\n        for (int i = 1; i <= word1.size(); i++) {\n            for (int j = 1; j <= word2.size(); j++) {\n                if (word1[i - 1] == word2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                }\n                else {\n                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n                }\n            }\n        }\n        return dp[word1.size()][word2.size()];\n    }\n};",
          "description": "C++实现编辑距离算法"
        },
        {
          "language": "java",
          "code": "public int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    // 初始化\n    for (int i = 1; i <= m; i++) {\n        dp[i][0] =  i;\n    }\n    for (int j = 1; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;\n            }\n        }\n    }\n    return dp[m][n];\n}",
          "description": "Java实现编辑距离算法"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)]\n        for i in range(len(word1)+1):\n            dp[i][0] = i\n        for j in range(len(word2)+1):\n            dp[0][j] = j\n        for i in range(1, len(word1)+1):\n            for j in range(1, len(word2)+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n        return dp[-1][-1]",
          "description": "Python实现编辑距离算法"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n * m)",
    "space_complexity": "O(n * m)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int minDistance(string word1, string word2) {vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0)); for (int i = 0; i <= word1.size(); i++) dp[i][0] = i; for (int j = 0; j <= word2.size(); j++) dp[0][j] = j; for (int i = 1; i <= word1.size(); i++) {for (int j = 1; j <= word2.size(); j++) {if (word1[i - 1] == word2[j - 1]) {dp[i][j] = dp[i - 1][j - 1];} else {dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;}}} return dp[word1.size()][word2.size()];}};",
      "description": "C++实现编辑距离算法"
    },
    {
      "language": "java",
      "code": "public int minDistance(String word1, String word2) {int m = word1.length(); int n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i <= m; i++) {dp[i][0] =  i;} for (int j = 1; j <= n; j++) {dp[0][j] = j;} for (int i = 1; i <= m; i++) {for (int j = 1; j <= n; j++) {if (word1.charAt(i - 1) == word2.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1];} else {dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;}}} return dp[m][n];}",
      "description": "Java实现编辑距离算法"
    },
    {
      "language": "python",
      "code": "class Solution: def minDistance(self, word1: str, word2: str) -> int: dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)] for i in range(len(word1)+1): dp[i][0] = i for j in range(len(word2)+1): dp[0][j] = j for i in range(1, len(word1)+1): for j in range(1, len(word2)+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 return dp[-1][-1]",
      "description": "Python实现编辑距离算法"
    }
  ],
  "common_mistakes": [
    "忽视了dp数组的边界条件初始化，比如没有正确设置当其中一个串为空时的情况。",
    "错误地认为只能通过增删改三种方式直接得到最终结果而忽略了使用动态规划的思想逐步逼近最优解的过程。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210114162113131.jpg",
      "description": "这张图片展示了动态规划（DP）中状态转移的四种来源：左上（dp[i-1][j-1]）、正上（dp[i-1][j]）、左边（dp[i][j-1]）和当前位置（dp[i][j]）。",
      "context": "该图展示了动态规划过程中dp[i][j]与其依赖的左方、上方及左上方元素之间的关系，帮助理解为何需要按照从左到右、从上到下的顺序遍历dp矩阵。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210114162132300.jpg",
      "description": "这张图片展示了一个动态规划算法的二维数组，用于计算两个字符串（\"horse\" 和 \"ros\"）之间的编辑距离。",
      "context": "该图片展示了当输入为word1=\"horse\"和word2=\"ros\"时，动态规划算法中dp矩阵的状态变化情况。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210114162113131.jpg",
      "description": "GIF展示了动态规划算法中dp矩阵从左到右、从上到下填充的过程，用于解决字符串编辑距离问题。",
      "context": "GIF动画展示了动态规划矩阵dp[i][j]如何根据其左方、上方和左上方元素进行填充的过程，直观地解释了算法中遍历顺序的重要性。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210114162132300.jpg",
      "description": "GIF展示了动态规划算法中dp数组填充的过程，用于计算两个字符串之间的最小编辑距离。",
      "context": "该GIF动画展示了通过动态规划方法计算两个字符串\"horse\"和\"ros\"之间最小编辑距离过程中dp数组的变化情况。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\编辑距离.txt",
  "extracted_at": "2025-07-21T00:00:42.617516",
  "raw_content": "编辑距离\n力扣题目链接(https://leetcode.cn/problems/edit-distance/)\n\n给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n插入一个字符\n\n删除一个字符\n\n替换一个字符\n\n示例 1：\n\n输入：word1 = \"horse\", word2 = \"ros\"\n\n输出：3\n\n解释： horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e')\n\n示例 2：\n\n输入：word1 = \"intention\", word2 = \"execution\"\n\n输出：5\n\n解释： intention -> inention (删除 't') inention -> enention (将 'i' 替换为 'e') enention -> exention (将 'n' 替换为 'x') exention -> exection (将 'n' 替换为 'c') exection -> execution (插入 'u')\n\n提示：\n\n0 <= word1.length, word2.length <= 500\nword1 和 word2 由小写英文字母组成\n\n\n#思路\n编辑距离终于来了，这道题目如果大家没有了解动态规划的话，会感觉超级复杂。\n\n编辑距离是用动规来解决的经典题目，这道题目看上去好像很复杂，但用动规可以很巧妙的算出最少编辑距离。\n\n接下来我依然使用动规五部曲，对本题做一个详细的分析：\n\n#1. 确定dp数组（dp table）以及下标的含义\ndp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。\n\n有同学问了，为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？\n\n为什么这么定义我在 718. 最长重复子数组 (https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html)中做了详细的讲解。\n\n其实用i来表示也可以！ 用i-1就是为了方便后面dp数组初始化的。\n\n#2. 确定递推公式\n在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：\n\nif (word1[i - 1] == word2[j - 1])\n    不操作\nif (word1[i - 1] != word2[j - 1])\n    增\n    删\n    换\n也就是如上4种情况。\n\nif (word1[i - 1] == word2[j - 1]) 那么说明不用任何编辑，dp[i][j] 就应该是 dp[i - 1][j - 1]，即dp[i][j] = dp[i - 1][j - 1];\n\n此时可能有同学有点不明白，为啥要即dp[i][j] = dp[i - 1][j - 1]呢？\n\n那么就在回顾上面讲过的dp[i][j]的定义，word1[i - 1] 与 word2[j - 1]相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串word2的最近编辑距离dp[i - 1][j - 1]就是 dp[i][j]了。\n\n在下面的讲解中，如果哪里看不懂，就回想一下dp[i][j]的定义，就明白了。\n\n在整个动规的过程中，最为关键就是正确理解dp[i][j]的定义！\n\nif (word1[i - 1] != word2[j - 1])，此时就需要编辑了，如何编辑呢？\n\n操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。\n即 dp[i][j] = dp[i - 1][j] + 1;\n\n操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。\n即 dp[i][j] = dp[i][j - 1] + 1;\n\n这里有同学发现了，怎么都是删除元素，添加元素去哪了。\n\nword2添加一个元素，相当于word1删除一个元素，例如 word1 = \"ad\" ，word2 = \"a\"，word1删除元素'd' 和 word2添加一个元素'd'，变成word1=\"a\", word2=\"ad\"， 最终的操作数是一样！ dp数组如下图所示意的：\n\n             a                                 a     d\n   +-----+-----+              +-----+-----+-----+\n   |  0  |  1  |            \t     |  0  |  1  |  2  |\n   +-----+-----+   ===>  +-----+-----+-----+\n a |  1  |  0  |           \t  a |  1  |  0  |  1  |\n   +-----+-----+              +-----+-----+-----+\n d |  2  |  1  |\n   +-----+-----+\n操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增删加元素。\n\n可以回顾一下，if (word1[i - 1] == word2[j - 1])的时候我们的操作 是 dp[i][j] = dp[i - 1][j - 1] 对吧。\n\n那么只需要一次替换的操作，就可以让 word1[i - 1] 和 word2[j - 1] 相同。\n\n所以 dp[i][j] = dp[i - 1][j - 1] + 1;\n\n综上，当 if (word1[i - 1] != word2[j - 1]) 时取最小的，即：dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n\n递归公式代码如下：\n\nif (word1[i - 1] == word2[j - 1]) {\n    dp[i][j] = dp[i - 1][j - 1];\n}\nelse {\n    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n}\n#3. dp数组如何初始化\n再回顾一下dp[i][j]的定义：\n\ndp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。\n\n那么dp[i][0] 和 dp[0][j] 表示什么呢？\n\ndp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。\n\n那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i;\n\n同理dp[0][j] = j;\n\n所以C++代码如下：\n\nfor (int i = 0; i <= word1.size(); i++) dp[i][0] = i;\nfor (int j = 0; j <= word2.size(); j++) dp[0][j] = j;\n#4. 确定遍历顺序\n从如下四个递推公式：\n\ndp[i][j] = dp[i - 1][j - 1]\ndp[i][j] = dp[i - 1][j - 1] + 1\ndp[i][j] = dp[i][j - 1] + 1\ndp[i][j] = dp[i - 1][j] + 1\n可以看出dp[i][j]是依赖左方，上方和左上方元素的，如图：\n\nhttps://file1.kamacoder.com/i/algo/20210114162113131.jpg\n\n所以在dp矩阵中一定是从左到右从上到下去遍历。\n\n代码如下：\n\nfor (int i = 1; i <= word1.size(); i++) {\n    for (int j = 1; j <= word2.size(); j++) {\n        if (word1[i - 1] == word2[j - 1]) {\n            dp[i][j] = dp[i - 1][j - 1];\n        }\n        else {\n            dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n        }\n    }\n}\n#5. 举例推导dp数组\n以示例1为例，输入：word1 = \"horse\", word2 = \"ros\"为例，dp矩阵状态图如下：\n\nhttps://file1.kamacoder.com/i/algo/20210114162132300.jpg\n\n以上动规五部分析完毕，C++代码如下：\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));\n        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;\n        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;\n        for (int i = 1; i <= word1.size(); i++) {\n            for (int j = 1; j <= word2.size(); j++) {\n                if (word1[i - 1] == word2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                }\n                else {\n                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\n                }\n            }\n        }\n        return dp[word1.size()][word2.size()];\n    }\n};\n时间复杂度: O(n * m)\n空间复杂度: O(n * m)\n#其他语言版本\n#Java：\npublic int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    // 初始化\n    for (int i = 1; i <= m; i++) {\n        dp[i][0] =  i;\n    }\n    for (int j = 1; j <= n; j++) {\n        dp[0][j] = j;\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            // 因为dp数组有效位从1开始\n            // 所以当前遍历到的字符串的位置为i-1 | j-1\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;\n            }\n        }\n    }\n    return dp[m][n];\n}\n#Python：\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)]\n        for i in range(len(word1)+1):\n            dp[i][0] = i\n        for j in range(len(word2)+1):\n            dp[0][j] = j\n        for i in range(1, len(word1)+1):\n            for j in range(1, len(word2)+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n        return dp[-1][-1]"
}