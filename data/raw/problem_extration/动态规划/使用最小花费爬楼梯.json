{
  "id": "AP_c52c0f2c",
  "title": "使用最小花费爬楼梯",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/min-cost-climbing-stairs/",
  "description": "找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "状态转移",
    "空间优化"
  ],
  "difficulty": null,
  "solution_approach": "定义dp[i]为到达第i个台阶所需的最小花费。通过递推公式 dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) 更新每个状态的值。初始化dp[0]和dp[1]均为0，表示从这两个位置开始不需要花费体力。最后返回dp数组最后一个元素的值。",
  "key_insights": [
    {
      "content": "可以从下标0或1开始爬楼梯且不需消耗体力是关键点，这直接影响了dp数组的初始化方式。"
    },
    {
      "content": "每次到达新阶梯时，都选择前两个阶梯中成本更低的路径加上当前阶梯的成本作为当前阶梯的最小成本。"
    },
    {
      "content": "利用动态规划可以有效地解决此类问题，并可通过状态压缩进一步优化空间复杂度。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "（在力扣修改了题目描述下，我又重新修改了题解）",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {vector<int> dp(cost.size() + 1);dp[0] = 0;dp[1] = 0;for (int i = 2; i <= cost.size(); i++) {dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);}return dp[cost.size()];}};",
          "description": "使用动态规划计算到达楼梯顶部的最低花费。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {int dp0 = 0;int dp1 = 0;for (int i = 2; i <= cost.size(); i++) {int dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]);dp0 = dp1;dp1 = dpi;}return dp1;}};",
          "description": "优化空间复杂度版本，仅使用两个变量存储前两步的状态。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {vector<int> dp(cost.size());dp[0] = cost[0];dp[1] = cost[1];for (int i = 2; i < cost.size(); i++) {dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];}return min(dp[cost.size() - 1], dp[cost.size() - 2]);}};",
          "description": "假设第一步是花费的，最后一步不花费。"
        },
        {
          "language": "java",
          "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int len = cost.length;int[] dp = new int[len + 1];dp[0] = 0;dp[1] = 0;for (int i = 2; i <= len; i++) {dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);}return dp[len];}}",
          "description": "Java实现，使用动态规划求解最小花费。"
        },
        {
          "language": "java",
          "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int[] dp = new int[cost.length];dp[0] = cost[0];dp[1] = cost[1];for (int i = 2; i < cost.length; i++) {dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];}return Math.min(dp[cost.length - 1], dp[cost.length - 2]);}}",
          "description": "Java实现，假设第一步支付费用的版本。"
        },
        {
          "language": "java",
          "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int beforeTwoCost = 0, beforeOneCost = 0, currentCost = 0;for (int i = 2; i <= cost.length; i ++) {currentCost = Math.min(beforeOneCost + cost[i - 1], beforeTwoCost + cost[i - 2]);beforeTwoCost = beforeOneCost;beforeOneCost = currentCost;}return currentCost;}}",
          "description": "Java实现，状态压缩版本，使用三个变量代替数组。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost): dp = [0] * (len(cost) + 1) dp[0] = 0 dp[1] = 0 for i in range(2, len(cost) + 1): dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) return dp[len(cost)]",
          "description": "Python实现，使用动态规划计算最小花费。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost): dp0 = 0 dp1 = 0 for i in range(2, len(cost) + 1): dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]) dp0 = dp1 dp1 = dpi return dp1",
          "description": "Python实现，优化空间复杂度版本。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost): dp = [0] * len(cost) dp[0] = cost[0] dp[1] = cost[1] for i in range(2, len(cost)): dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i] return min(dp[-1], dp[-2])",
          "description": "Python实现，假设第一步有花费的版本。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost): n = len(cost) prev_1 = cost[0] prev_2 = cost[1] for i in range(2, n): current = min(prev_1, prev_2) + cost[i] prev_1, prev_2 = prev_2, current return min(prev_1, prev_2)",
          "description": "Python实现，状态压缩版本。"
        }
      ],
      "subsections": []
    },
    {
      "name": "拓展",
      "text": "旧力扣描述，如果按照 第一步是花费的，最后一步不花费，那么代码是这么写的，提交也可以通过",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) { vector<int> dp(cost.size() + 1); dp[0] = 0; dp[1] = 0; for (int i = 2; i <= cost.size(); i++) { dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); } return dp[cost.size()]; }};",
          "description": "使用动态规划计算到达楼梯顶部的最低花费，初始化dp[0]和dp[1]为0，遍历cost数组更新dp值。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) { int dp0 = 0; int dp1 = 0; for (int i = 2; i <= cost.size(); i++) { int dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]); dp0 = dp1; dp1 = dpi; } return dp1; }};",
          "description": "优化空间复杂度版本，只用几个变量代替整个dp数组来保存当前及前两步的状态。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) { vector<int> dp(cost.size()); dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i < cost.size(); i++) { dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]; } return min(dp[cost.size() - 1], dp[cost.size() - 2]); }};",
          "description": "基于旧题目描述的解法，假设第一步需要花费体力，并且最后一步不花费。"
        },
        {
          "language": "java",
          "code": "class Solution { public int minCostClimbingStairs(int[] cost) { int len = cost.length; int[] dp = new int[len + 1]; dp[0] = 0; dp[1] = 0; for (int i = 2; i <= len; i++) { dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); } return dp[len]; }}",
          "description": "Java版本，按照新题目描述实现的动态规划解决方案。"
        },
        {
          "language": "java",
          "code": "class Solution { public int minCostClimbingStairs(int[] cost) { int[] dp = new int[cost.length]; dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i < cost.length; i++) { dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]; } return Math.min(dp[cost.length - 1], dp[cost.length - 2]); }}",
          "description": "另一种Java版本，处理旧题目描述情况下的解法。"
        },
        {
          "language": "java",
          "code": "class Solution { public int minCostClimbingStairs(int[] cost) { int beforeTwoCost = 0, beforeOneCost = 0, currentCost = 0; for (int i = 2; i <= cost.length; i++) { currentCost = Math.min(beforeOneCost + cost[i - 1], beforeTwoCost + cost[i - 2]); beforeTwoCost = beforeOneCost; beforeOneCost = currentCost; } return currentCost; }}",
          "description": "Java版本的空间优化解法，通过三个变量替代dp数组。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost): dp = [0] * (len(cost) + 1) dp[0] = 0; dp[1] = 0 for i in range(2, len(cost) + 1): dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) return dp[len(cost)]",
          "description": "Python版本的动态规划解法，初始化dp数组并遍历更新。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost): dp0 = 0; dp1 = 0 for i in range(2, len(cost) + 1): dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]) dp0 = dp1; dp1 = dpi return dp1",
          "description": "Python版本的空间优化解法，仅使用常数级额外空间。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost): dp = [0] * len(cost) dp[0] = cost[0]; dp[1] = cost[1] for i in range(2, len(cost)): dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i] return min(dp[-1], dp[-2])",
          "description": "针对旧题目描述的Python解法，考虑了第一步有花费的情况。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost): n = len(cost) prev_1 = cost[0]; prev_2 = cost[1] for i in range(2, n): current = min(prev_1, prev_2) + cost[i] prev_1, prev_2 = prev_2, current return min(prev_1, prev_2)",
          "description": "Python版本，使用滚动数组思想进一步减少了空间使用。"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "大家可以发现这道题目相对于 昨天的动态规划：爬楼梯 (https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html)又难了一点，但整体思路是一样的。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {vector<int> dp(cost.size() + 1);dp[0] = 0;dp[1] = 0;for (int i = 2; i <= cost.size(); i++) {dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);}return dp[cost.size()];}};",
          "description": "使用动态规划计算到达楼梯顶部的最低花费，初始化dp数组为0"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {int dp0 = 0;int dp1 = 0;for (int i = 2; i <= cost.size(); i++) {int dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]);dp0 = dp1;dp1 = dpi;}return dp1;}};",
          "description": "优化空间复杂度版本，仅使用两个变量存储前两步的状态"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {vector<int> dp(cost.size());dp[0] = cost[0];dp[1] = cost[1];for (int i = 2; i < cost.size(); i++) {dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];}return min(dp[cost.size() - 1], dp[cost.size() - 2]);}};",
          "description": "旧力扣描述下的解法，假设第一步需要花费体力值"
        },
        {
          "language": "java",
          "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int len = cost.length;int[] dp = new int[len + 1];dp[0] = 0;dp[1] = 0;for (int i = 2; i <= len; i++) {dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);}return dp[len];}}",
          "description": "Java实现的第一种方式，不考虑第一步的花费"
        },
        {
          "language": "java",
          "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int[] dp = new int[cost.length];dp[0] = cost[0];dp[1] = cost[1];for (int i = 2; i < cost.length; i++) {dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];}return Math.min(dp[cost.length - 1], dp[cost.length - 2]);}}",
          "description": "Java实现的第二种方式，考虑第一步的花费"
        },
        {
          "language": "java",
          "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int beforeTwoCost = 0, beforeOneCost = 0, currentCost = 0;for (int i = 2; i <= cost.length; i ++) {currentCost = Math.min(beforeOneCost + cost[i - 1], beforeTwoCost + cost[i - 2]);beforeTwoCost = beforeOneCost;beforeOneCost = currentCost;}return currentCost;}}",
          "description": "Java实现的空间优化版本"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: dp = [0] * (len(cost) + 1) dp[0] = 0 dp[1] = 0 for i in range(2, len(cost) + 1): dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) return dp[len(cost)]",
          "description": "Python实现的第一种方式，不考虑第一步的花费"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: dp0 = 0 dp1 = 0 for i in range(2, len(cost) + 1): dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]) dp0 = dp1 dp1 = dpi return dp1",
          "description": "Python实现的空间优化版本"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: dp = [0] * len(cost) dp[0] = cost[0] dp[1] = cost[1] for i in range(2, len(cost)): dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i] return min(dp[-1], dp[-2])",
          "description": "Python实现的第三种方式，考虑第一步的花费"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: n = len(cost) prev_1 = cost[0] prev_2 = cost[1] for i in range(2, n): current = min(prev_1, prev_2) + cost[i] prev_1, prev_2 = prev_2, current return min(prev_1, prev_2)",
          "description": "Python实现的第四种方式，考虑最后一步无需花费"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution { public int minCostClimbingStairs(int[] cost) { int len = cost.length; int[] dp = new int[len + 1]; dp[0] = 0; dp[1] = 0; for (int i = 2; i <= len; i++) { dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); } return dp[len]; }}",
          "description": "Java实现：使用动态规划，从下标为 0 或 1 的台阶开始爬楼梯，计算到达每一层台阶的最小费用"
        },
        {
          "language": "java",
          "code": "class Solution { public int minCostClimbingStairs(int[] cost) { int[] dp = new int[cost.length]; dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i < cost.length; i++) { dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]; } return Math.min(dp[cost.length - 1], dp[cost.length - 2]); }}",
          "description": "Java实现：假设第一步支付费用，然后计算到达楼顶的最低花费"
        },
        {
          "language": "java",
          "code": "class Solution { public int minCostClimbingStairs(int[] cost) { int beforeTwoCost = 0, beforeOneCost = 0, currentCost = 0; for (int i = 2; i <= cost.length; i ++) { currentCost = Math.min(beforeOneCost + cost[i - 1], beforeTwoCost + cost[i - 2]); beforeTwoCost = beforeOneCost; beforeOneCost = currentCost; } return currentCost; }}",
          "description": "Java实现：状态压缩版本，不使用数组而是通过三个变量来跟踪前两个台阶和当前台阶的最少费用"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost): dp = [0] * (len(cost) + 1); dp[0] = 0; dp[1] = 0; for i in range(2, len(cost) + 1): dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); return dp[len(cost)];",
          "description": "Python实现：动态规划方法，初始化dp数组，并基于前两步的最小值更新当前步的花费"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost): dp0 = 0; dp1 = 0; for i in range(2, len(cost) + 1): dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]); dp0 = dp1; dp1 = dpi; return dp1;",
          "description": "Python实现：空间优化版本，仅使用常数级别的额外空间存储前两步的状态"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost): dp = [0] * len(cost); dp[0] = cost[0]; dp[1] = cost[1]; for i in range(2, len(cost)): dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]; return min(dp[-1], dp[-2]);",
          "description": "Python实现：考虑第一步即有花费的情况下的动态规划解法"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost): n = len(cost); prev_1 = cost[0]; prev_2 = cost[1]; for i in range(2, n): current = min(prev_1, prev_2) + cost[i]; prev_1, prev_2 = prev_2, current; return min(prev_1, prev_2);",
          "description": "Python实现：进一步优化空间复杂度至O(1)，利用滚动数组思想"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "// 方式一：第一步不支付费用",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {vector<int> dp(cost.size() + 1);dp[0] = 0;dp[1] = 0;for (int i = 2; i <= cost.size(); i++) {dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);}return dp[cost.size()];}};",
          "description": "使用动态规划计算到达楼梯顶部的最低花费。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {int dp0 = 0;int dp1 = 0;for (int i = 2; i <= cost.size(); i++) {int dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]);dp0 = dp1;dp1 = dpi;}return dp1;}};",
          "description": "优化空间复杂度，只使用两个变量来存储前两步的状态。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {vector<int> dp(cost.size());dp[0] = cost[0];dp[1] = cost[1];for (int i = 2; i < cost.size(); i++) {dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];}return min(dp[cost.size() - 1], dp[cost.size() - 2]);}};",
          "description": "如果按照第一步是花费的，最后一步不花费的情况下的解法。"
        },
        {
          "language": "java",
          "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int len = cost.length;int[] dp = new int[len + 1];dp[0] = 0;dp[1] = 0;for (int i = 2; i <= len; i++) {dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);}return dp[len];}}",
          "description": "Java版本，使用动态规划计算到达楼梯顶部的最低花费。"
        },
        {
          "language": "java",
          "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int[] dp = new int[cost.length];dp[0] = cost[0];dp[1] = cost[1];for (int i = 2; i < cost.length; i++) {dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];}return Math.min(dp[cost.length - 1], dp[cost.length - 2]);}}",
          "description": "Java版本，如果按照第一步是花费的，最后一步不花费的情况下的解法。"
        },
        {
          "language": "java",
          "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int beforeTwoCost = 0, beforeOneCost = 0, currentCost = 0;for (int i = 2; i <= cost.length; i ++) {currentCost = Math.min(beforeOneCost + cost[i - 1], beforeTwoCost + cost[i - 2]);beforeTwoCost = beforeOneCost;beforeOneCost = currentCost;}return currentCost;}}",
          "description": "Java版本，状态压缩，使用三个变量来代替数组。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: dp = [0] * (len(cost) + 1) dp[0] = 0 dp[1] = 0 for i in range(2, len(cost) + 1): dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) return dp[len(cost)]",
          "description": "Python版本，使用动态规划计算到达楼梯顶部的最低花费。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: dp0 = 0 dp1 = 0 for i in range(2, len(cost) + 1): dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]) dp0 = dp1 dp1 = dpi return dp1",
          "description": "Python版本，优化空间复杂度，只使用两个变量来存储前两步的状态。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: dp = [0] * len(cost) dp[0] = cost[0] dp[1] = cost[1] for i in range(2, len(cost)): dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i] return min(dp[-1], dp[-2])",
          "description": "Python版本，如果按照第一步是花费的，最后一步不花费的情况下的解法。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: n = len(cost) prev_1 = cost[0] prev_2 = cost[1] for i in range(2, n): current = min(prev_1, prev_2) + cost[i] prev_1, prev_2 = prev_2, current return min(prev_1, prev_2)",
          "description": "Python版本，状态压缩，使用三个变量来代替数组。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "动态规划（版本一）",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {vector<int> dp(cost.size() + 1);dp[0] = 0; dp[1] = 0;for (int i = 2; i <= cost.size(); i++) {dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);}return dp[cost.size()];}};",
          "description": "动态规划版本一，使用数组记录到达每个台阶的最小花费。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {int dp0 = 0;int dp1 = 0;for (int i = 2; i <= cost.size(); i++) {int dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]);dp0 = dp1;dp1 = dpi;}return dp1;}};",
          "description": "动态规划版本二，优化空间复杂度到O(1)，使用三个变量代替数组。"
        },
        {
          "language": "java",
          "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int len = cost.length;int[] dp = new int[len + 1];dp[0] = 0;dp[1] = 0;for (int i = 2; i <= len; i++) {dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);}return dp[len];}}",
          "description": "Java实现，动态规划求解爬楼梯问题。"
        },
        {
          "language": "java",
          "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int[] dp = new int[cost.length];dp[0] = cost[0];dp[1] = cost[1];for (int i = 2; i < cost.length; i++) {dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];}return Math.min(dp[cost.length - 1], dp[cost.length - 2]);}}",
          "description": "Java实现，另一种动态规划方法，假设第一步即开始计算费用。"
        },
        {
          "language": "java",
          "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int beforeTwoCost = 0, beforeOneCost = 0, currentCost = 0;for (int i = 2; i <= cost.length; i ++) {currentCost = Math.min(beforeOneCost + cost[i - 1], beforeTwoCost + cost[i - 2]);beforeTwoCost = beforeOneCost;beforeOneCost = currentCost;}return currentCost;}}",
          "description": "Java实现，通过状态压缩将空间复杂度降低至O(1)。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: dp = [0] * (len(cost) + 1) dp[0] = 0 dp[1] = 0 for i in range(2, len(cost) + 1): dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) return dp[len(cost)]",
          "description": "Python实现，动态规划求解爬楼梯问题。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: dp0 = 0 dp1 = 0 for i in range(2, len(cost) + 1): dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]) dp0 = dp1 dp1 = dpi return dp1",
          "description": "Python实现，空间优化后的动态规划解法。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: dp = [0] * len(cost) dp[0] = cost[0] dp[1] = cost[1] for i in range(2, len(cost)): dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i] return min(dp[-1], dp[-2])",
          "description": "Python实现，另一种动态规划方式，考虑最后一步不花费体力。"
        },
        {
          "language": "python",
          "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: n = len(cost) prev_1 = cost[0] prev_2 = cost[1] for i in range(2, n): current = min(prev_1, prev_2) + cost[i] prev_1, prev_2 = prev_2, current return min(prev_1, prev_2)",
          "description": "Python实现，状态压缩技术减少空间使用。"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {vector<int> dp(cost.size() + 1);dp[0] = 0;dp[1] = 0;for (int i = 2; i <= cost.size(); i++) {dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);}return dp[cost.size()];}};",
      "description": "使用动态规划计算到达楼梯顶部的最低花费（版本一）"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int minCostClimbingStairs(vector<int>& cost) {int dp0 = 0;int dp1 = 0;for (int i = 2; i <= cost.size(); i++) {int dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]);dp0 = dp1;dp1 = dpi;}return dp1;}};",
      "description": "优化空间复杂度后的动态规划解法（版本二）"
    },
    {
      "language": "java",
      "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int len = cost.length;int[] dp = new int[len + 1];dp[0] = 0;dp[1] = 0;for (int i = 2; i <= len; i++) {dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);}return dp[len];}}",
      "description": "Java实现，使用动态规划计算最小花费（方式一：第一步不支付费用）"
    },
    {
      "language": "java",
      "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int[] dp = new int[cost.length];dp[0] = cost[0];dp[1] = cost[1];for (int i = 2; i < cost.length; i++) {dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];}return Math.min(dp[cost.length - 1], dp[cost.length - 2]);}}",
      "description": "Java实现，使用动态规划计算最小花费（方式二：第一步支付费用）"
    },
    {
      "language": "java",
      "code": "class Solution {public int minCostClimbingStairs(int[] cost) {int beforeTwoCost = 0, beforeOneCost = 0, currentCost = 0;for (int i = 2; i <= cost.length; i ++) {currentCost = Math.min(beforeOneCost + cost[i - 1], beforeTwoCost + cost[i - 2]);beforeTwoCost = beforeOneCost;beforeOneCost = currentCost;}return currentCost;}}",
      "description": "Java实现的状态压缩方法，用于计算最小花费"
    },
    {
      "language": "python",
      "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: dp = [0] * (len(cost) + 1) dp[0] = 0 dp[1] = 0 for i in range(2, len(cost) + 1): dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) return dp[len(cost)]",
      "description": "Python实现，使用动态规划计算最小花费（版本一）"
    },
    {
      "language": "python",
      "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: dp0 = 0 dp1 = 0 for i in range(2, len(cost) + 1): dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]) dp0 = dp1 dp1 = dpi return dp1",
      "description": "Python实现的空间优化版动态规划（版本二）"
    },
    {
      "language": "python",
      "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: dp = [0] * len(cost) dp[0] = cost[0] dp[1] = cost[1] for i in range(2, len(cost)): dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i] return min(dp[-1], dp[-2])",
      "description": "Python实现，基于动态规划的第一步有花费方案（版本三）"
    },
    {
      "language": "python",
      "code": "class Solution: def minCostClimbingStairs(self, cost: List[int]) -> int: n = len(cost) prev_1 = cost[0] prev_2 = cost[1] for i in range(2, n): current = min(prev_1, prev_2) + cost[i] prev_1, prev_2 = prev_2, current return min(prev_1, prev_2)",
      "description": "Python实现的状态压缩方法，用于计算最小花费（版本四）"
    }
  ],
  "common_mistakes": [
    "错误地初始化dp数组（例如设置dp[0]或dp[1]为非零值）。",
    "没有正确处理边界条件，特别是对于只有几个元素的小数组。",
    "忽略了最终答案可能是从倒数第二个或倒数第三个元素计算得出的事实。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20221031170131.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20221031170131.png",
      "context": "这张图片展示了爬楼梯问题中的台阶与花费示意图，帮助理解从不同起点开始爬至顶部所需的最低费用计算方法。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20221026175104.png",
      "description": "这张图片展示了使用动态规划（DP）算法解决最小代价爬楼梯问题的过程，其中dp数组记录了到达每个台阶的最小成本。",
      "context": "该图片展示了使用示例2的成本数组时，dp数组状态变化的具体过程，帮助理解背包问题中动态规划的应用。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20221031170131.png",
      "description": "GIF展示了通过动态规划方法解决爬楼梯问题的过程，形象地演示了如何从下标0或1开始，逐步计算到达每一级台阶所需的最小花费。",
      "context": "GIF动画展示了根据题目要求，从楼梯底部到达顶部过程中每一步选择的动态规划过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20221026175104.png",
      "description": "GIF展示了通过动态规划方法计算最小花费爬楼梯过程中dp数组状态的变化。",
      "context": "该GIF动画展示了在给定cost数组的情况下，动态规划dp数组状态随遍历过程的变化情况，帮助理解为何在使用一维dp数组时需要倒序遍历背包容量。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\使用最小花费爬楼梯.txt",
  "extracted_at": "2025-07-20T16:31:12.521127",
  "raw_content": "使用最小花费爬楼梯\n力扣题目链接(https://leetcode.cn/problems/min-cost-climbing-stairs/)\n\n旧题目描述：\n\n数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。\n\n每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。\n\n请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。\n\n示例 1：\n\n输入：cost = [10, 15, 20]\n输出：15\n解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。\n示例 2：\n\n输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n输出：6\n解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。\n提示：\n\ncost 的长度范围是 [2, 1000]。\ncost[i] 将会是一个整型数据，范围为 [0, 999] 。\n\n本题之前的题目描述是很模糊的，看不出来，第一步需要花费体力值，最后一步不用花费，还是说 第一步不花费体力值，最后一步花费。\n\n后来力扣改了题目描述，新题目描述：\n\n给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n\n请你计算并返回达到楼梯顶部的最低花费。\n\nhttps://file1.kamacoder.com/i/algo/20221031170131.png\n\n#思路\n（在力扣修改了题目描述下，我又重新修改了题解）\n\n修改之后的题意就比较明确了，题目中说 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯” 也就是相当于 跳到 下标 0 或者 下标 1 是不花费体力的， 从 下标 0 下标1 开始跳就要花费体力了。\n\n确定dp数组以及下标的含义\n使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。\n\ndp[i]的定义：到达第i台阶所花费的最少体力为dp[i]。\n\n对于dp数组的定义，大家一定要清晰！\n\n确定递推公式\n可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]。\n\ndp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。\n\ndp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。\n\n那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？\n\n一定是选最小的，所以dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n\ndp数组如何初始化\n看一下递归公式，dp[i]由dp[i - 1]，dp[i - 2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]dp[1]推出。\n\n那么 dp[0] 应该是多少呢？ 根据dp数组的定义，到达第0台阶所花费的最小体力为dp[0]，那么有同学可能想，那dp[0] 应该是 cost[0]，例如 cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 的话，dp[0] 就是 cost[0] 应该是1。\n\n这里就要说明本题力扣为什么改题意，而且修改题意之后 就清晰很多的原因了。\n\n新题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。\n\n所以初始化 dp[0] = 0，dp[1] = 0;\n\n确定遍历顺序\n最后一步，递归公式有了，初始化有了，如何遍历呢？\n\n本题的遍历顺序其实比较简单，简单到很多同学都忽略了思考这一步直接就把代码写出来了。\n\n因为是模拟台阶，而且dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。\n\n但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来。 例如：01背包，都知道两个for循环，一个for遍历物品嵌套一个for遍历背包容量，那么为什么不是一个for遍历背包容量嵌套一个for遍历物品呢？ 以及在使用一维dp数组的时候遍历背包容量为什么要倒序呢？\n\n这些都与遍历顺序息息相关。当然背包问题后续「代码随想录」都会重点讲解的！\n\n举例推导dp数组\n拿示例2：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下dp数组的状态变化，如下：\n\nhttps://file1.kamacoder.com/i/algo/20221026175104.png\n\n如果大家代码写出来有问题，就把dp数组打印出来，看看和如上推导的是不是一样的。\n\n以上分析完毕，整体C++代码如下：\n\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        vector<int> dp(cost.size() + 1);\n        dp[0] = 0; // 默认第一步都是不花费体力的\n        dp[1] = 0;\n        for (int i = 2; i <= cost.size(); i++) {\n            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n        return dp[cost.size()];\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(n)\n还可以优化空间复杂度，因为dp[i]就是由前两位推出来的，那么也不用dp数组了，C++代码如下：\n\n// 版本二\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int dp0 = 0;\n        int dp1 = 0;\n        for (int i = 2; i <= cost.size(); i++) {\n            int dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2]);\n            dp0 = dp1; // 记录一下前两位\n            dp1 = dpi;\n        }\n        return dp1;\n    }\n};\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n当然如果在面试中，能写出版本一就行，除非面试官额外要求 空间复杂度，那么再去思考版本二，因为版本二还是有点绕。版本一才是正常思路。\n\n#拓展\n旧力扣描述，如果按照 第一步是花费的，最后一步不花费，那么代码是这么写的，提交也可以通过\n\n// 版本一\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        vector<int> dp(cost.size());\n        dp[0] = cost[0]; // 第一步有花费\n        dp[1] = cost[1];\n        for (int i = 2; i < cost.size(); i++) {\n            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];\n        }\n        // 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值\n        return min(dp[cost.size() - 1], dp[cost.size() - 2]);\n    }\n};\n当然如果对 动态规划 理解不够深入的话，拓展内容就别看了，容易越看越懵。\n\n#总结\n大家可以发现这道题目相对于 昨天的动态规划：爬楼梯 (https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html)又难了一点，但整体思路是一样的。\n\n从动态规划：斐波那契数 (https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html)到 动态规划：爬楼梯 (https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html)再到今天这道题目，录友们感受到循序渐进的梯度了嘛。\n\n每个系列开始的时候，都有录友和我反馈说题目太简单了，赶紧上难度，但也有录友和我说有点难了，快跟不上了。\n\n其实我选的题目都是有目的性的，就算是简单题，也是为了练习方法论，然后难度都是梯度上来的，一环扣一环。\n\n但我也可以随便选来一道难题讲呗，这其实是最省事的，不用管什么题目顺序，看心情找一道就讲。\n\n难的是把题目按梯度排好，循序渐进，再按照统一方法论把这些都串起来，所以大家不要催我哈，按照我的节奏一步一步来就行了。\n\n#其他语言版本\n\n\n#Java\n// 方式一：第一步不支付费用\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int len = cost.length;\n        int[] dp = new int[len + 1];\n\n        // 从下标为 0 或下标为 1 的台阶开始，因此支付费用为0\n        dp[0] = 0;\n        dp[1] = 0;\n\n        // 计算到达每一层台阶的最小费用\n        for (int i = 2; i <= len; i++) {\n            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n\n        return dp[len];\n    }\n}\n// 方式二：第一步支付费用\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int[] dp = new int[cost.length];\n        dp[0] = cost[0];\n        dp[1] = cost[1];\n        for (int i = 2; i < cost.length; i++) {\n            dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];\n        }\n        //最后一步，如果是由倒数第二步爬，则最后一步的体力花费可以不用算\n        return Math.min(dp[cost.length - 1], dp[cost.length - 2]);\n    }\n}\n// 状态压缩，使用三个变量来代替数组\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        // 以下三个变量分别表示前两个台阶的最少费用、前一个的、当前的。\n        int beforeTwoCost = 0, beforeOneCost = 0, currentCost = 0;\n        // 前两个台阶不需要费用就能上到，因此从下标2开始；因为最后一个台阶需要跨越，所以需要遍历到cost.length\n        for (int i = 2; i <= cost.length; i ++) {\n            // 此处遍历的是cost[i - 1]，不会越界\n            currentCost = Math.min(beforeOneCost + cost[i - 1], beforeTwoCost + cost[i - 2]);\n            beforeTwoCost = beforeOneCost;\n            beforeOneCost = currentCost;\n        }\n        return currentCost;\n    }\n}\n#Python\n动态规划（版本一）\n\n\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        dp = [0] * (len(cost) + 1)\n        dp[0] = 0  # 初始值，表示从起点开始不需要花费体力\n        dp[1] = 0  # 初始值，表示经过第一步不需要花费体力\n        \n        for i in range(2, len(cost) + 1):\n            # 在第i步，可以选择从前一步（i-1）花费体力到达当前步，或者从前两步（i-2）花费体力到达当前步\n            # 选择其中花费体力较小的路径，加上当前步的花费，更新dp数组\n            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])\n        \n        return dp[len(cost)]  # 返回到达楼顶的最小花费\n\n动态规划（版本二）\n\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        dp0 = 0  # 初始值，表示从起点开始不需要花费体力\n        dp1 = 0  # 初始值，表示经过第一步不需要花费体力\n        \n        for i in range(2, len(cost) + 1):\n            # 在第i步，可以选择从前一步（i-1）花费体力到达当前步，或者从前两步（i-2）花费体力到达当前步\n            # 选择其中花费体力较小的路径，加上当前步的花费，得到当前步的最小花费\n            dpi = min(dp1 + cost[i - 1], dp0 + cost[i - 2])\n            \n            dp0 = dp1  # 更新dp0为前一步的值，即上一次循环中的dp1\n            dp1 = dpi  # 更新dp1为当前步的最小花费\n        \n        return dp1  # 返回到达楼顶的最小花费\n\n动态规划（版本三）\n\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        dp = [0] * len(cost)\n        dp[0] = cost[0]  # 第一步有花费\n        dp[1] = cost[1]\n        for i in range(2, len(cost)):\n            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n        # 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值\n        return min(dp[-1], dp[-2])\n\n动态规划（版本四）\n\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        n = len(cost)\n        prev_1 = cost[0]  # 前一步的最小花费\n        prev_2 = cost[1]  # 前两步的最小花费\n        for i in range(2, n):\n            current = min(prev_1, prev_2) + cost[i]  # 当前位置的最小花费\n            prev_1, prev_2 = prev_2, current  # 更新前一步和前两步的最小花费\n        return min(prev_1, prev_2)  # 最后一步可以理解为不用花费，取倒数第一步和第二步的最少值"
}