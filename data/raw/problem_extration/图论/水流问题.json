{
  "id": "AP_8d1fc8b0",
  "title": "水流问题",
  "alternative_titles": [],
  "platform": "kamacoder",
  "url": "https://kamacoder.com/problempage.php?pid=1175",
  "description": "",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "Depth-First Search (DFS)",
    "Graph Traversal"
  ],
  "data_structure_tags": [
    "2D Array",
    "Boolean Matrix"
  ],
  "technique_tags": [
    "Backtracking",
    "Bidirectional Search"
  ],
  "difficulty": null,
  "solution_approach": "通过从第一组边界和第二组边界出发，反向使用深度优先搜索（DFS）来标记可以从这些边界到达的所有位置。接着，检查哪些单元格同时被两个方向的搜索所标记，这些单元就是满足条件的单元格。",
  "key_insights": [
    {
      "content": "从边界的节点开始逆流而上进行搜索，可以有效减少不必要的计算量，直接找到能够同时到达两组边界的节点，从而优化了算法效率。"
    },
    {
      "content": "分别从第一组边界和第二组边界出发，执行两次独立的搜索，并将结果合并，这种方法能更直观地识别出符合条件的位置。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "一个比较直白的想法，其实就是 遍历每个点，然后看这个点 能不能同时到达第一组边界和第二组边界。",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y]) return;\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\n        if (grid[x][y] > grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历\n\n        dfs (grid, visited, nextx, nexty);\n    }\n    return;\n}\nint main() {\n\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> firstBorder(n, vector<bool>(m, false));\n\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> secondBorder(n, vector<bool>(m, false));\n\n    // 从最上和最下行的节点出发，向高处遍历\n    for (int i = 0; i < n; i++) {\n        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界\n        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界\n    }\n\n    // 从最左和最右列的节点出发，向高处遍历\n    for (int j = 0; j < m; j++) {\n        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界\n        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            // 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果\n            if (firstBorder[i][j] && secondBorder[i][j]) cout << i << \" \" << j << endl;;\n        }\n    }\n}",
          "description": "使用深度优先搜索(DFS)方法解决水流问题"
        },
        {
          "language": "Java",
          "code": "import java.util.*;\npublic class Main {\n    public static void dfs(int[][] heights, int x, int y, boolean[][] visited, int preH) {\n        if (x < 0 || x >= heights.length || y < 0 || y >= heights[0].length || visited[x][y]) return;\n        if (heights[x][y] < preH) return;\n        visited[x][y] = true;\n\n        dfs(heights, x + 1, y, visited, heights[x][y]);\n        dfs(heights, x - 1, y, visited, heights[x][y]);\n        dfs(heights, x, y + 1, visited, heights[x][y]);\n        dfs(heights, x, y - 1, visited, heights[x][y]);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] heights = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                heights[i][j] = sc.nextInt();\n            }\n        }\n\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            dfs(heights, i, 0, pacific, Integer.MIN_VALUE);\n            dfs(heights, i, n - 1, atlantic, Integer.MIN_VALUE);\n        }\n\n        for (int j = 0; j < n; j++) {\n            dfs(heights, 0, j, pacific, Integer.MIN_VALUE);\n            dfs(heights, m - 1, j, atlantic, Integer.MIN_VALUE);\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    res.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        for (List<Integer> list : res) {\n            for (int k = 0; k < list.size(); k++) {\n                if (k == 0) {\n                    System.out.print(list.get(k) + \" \");\n                } else {\n                    System.out.print(list.get(k));\n                }\n            }\n            System.out.println();\n        }\n    }\n}",
          "description": "采用DFS进行搜索以解决水流问题"
        },
        {
          "language": "Python",
          "code": "first = set()\nsecond = set()\ndirections = [[-1, 0], [0, 1], [1, 0], [0, -1]]\ndef dfs(i, j, graph, visited, side):\n    if visited[i][j]:\n        return\n\n    visited[i][j] = True\n    side.add((i, j))\n\n    for x, y in directions:\n        new_x = i + x\n        new_y = j + y\n        if (\n            0 <= new_x < len(graph)\n            and 0 <= new_y < len(graph[0])\n            and int(graph[new_x][new_y]) >= int(graph[i][j])\n        ):\n            dfs(new_x, new_y, graph, visited, side)\ndef main():\n    global first\n    global second\n\n    N, M = map(int, input().strip().split())\n    graph = []\n    for _ in range(N):\n        row = input().strip().split()\n        graph.append(row)\n\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(0, i, graph, visited, first)\n    for i in range(N):\n        dfs(i, 0, graph, visited, first)\n\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(N - 1, i, graph, visited, second)\n    for i in range(N):\n        dfs(i, M - 1, graph, visited, second)\n\n    res = first & second\n\n    for x, y in res:\n        print(f\"{x} {y}\")\nif __name__ == \"__main__\":\n    main()",
          "description": "通过深度优先搜索(DFS)来确定哪些单元格可以从两个不同的边界到达"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y]) return;\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\n        if (grid[x][y] > grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历\n\n        dfs (grid, visited, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> firstBorder(n, vector<bool>(m, false));\n\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> secondBorder(n, vector<bool>(m, false));\n\n    // 从最上和最下行的节点出发，向高处遍历\n    for (int i = 0; i < n; i++) {\n        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界\n        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界\n    }\n\n    // 从最左和最右列的节点出发，向高处遍历\n    for (int j = 0; j < m; j++) {\n        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界\n        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            // 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果\n            if (firstBorder[i][j] && secondBorder[i][j]) cout << i << \" \" << j << endl;;\n        }\n    }\n}",
          "description": "C++代码实现水流问题"
        },
        {
          "language": "java",
          "code": "public class Main {\n\n    public static void dfs(int[][] heights, int x, int y, boolean[][] visited, int preH) {\n        if (x < 0 || x >= heights.length || y < 0 || y >= heights[0].length || visited[x][y]) return;\n        if (heights[x][y] < preH) return;\n        visited[x][y] = true;\n\n        dfs(heights, x + 1, y, visited, heights[x][y]);\n        dfs(heights, x - 1, y, visited, heights[x][y]);\n        dfs(heights, x, y + 1, visited, heights[x][y]);\n        dfs(heights, x, y - 1, visited, heights[x][y]);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] heights = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                heights[i][j] = sc.nextInt();\n            }\n        }\n\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            dfs(heights, i, 0, pacific, Integer.MIN_VALUE);\n            dfs(heights, i, n - 1, atlantic, Integer.MIN_VALUE);\n        }\n\n        for (int j = 0; j < n; j++) {\n            dfs(heights, 0, j, pacific, Integer.MIN_VALUE);\n            dfs(heights, m - 1, j, atlantic, Integer.MIN_VALUE);\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    res.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        for (List<Integer> list : res) {\n            for (int k = 0; k < list.size(); k++) {\n                if (k == 0) {\n                    System.out.print(list.get(k) + \" \");\n                } else {\n                    System.out.print(list.get(k));\n                }\n            }\n            System.out.println();\n        }\n    }\n}",
          "description": "Java代码实现水流问题"
        },
        {
          "language": "python",
          "code": "first = set()\nsecond = set()\ndirections = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n\ndef dfs(i, j, graph, visited, side):\n    if visited[i][j]:\n        return\n    visited[i][j] = True\n    side.add((i, j))\n    for x, y in directions:\n        new_x = i + x\n        new_y = j + y\n        if 0 <= new_x < len(graph) and 0 <= new_y < len(graph[0]) and int(graph[new_x][new_y]) >= int(graph[i][j]):\n            dfs(new_x, new_y, graph, visited, side)\n\ndef main():\n    global first, second\n    N, M = map(int, input().strip().split())\n    graph = [input().strip().split() for _ in range(N)]\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(0, i, graph, visited, first)\n    for i in range(N):\n        dfs(i, 0, graph, visited, first)\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(N - 1, i, graph, visited, second)\n    for i in range(N):\n        dfs(i, M - 1, graph, visited, second)\n    res = first & second\n    for x, y in res:\n        print(f\"{x} {y}\")\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python代码实现水流问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y]) return;\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\n        if (grid[x][y] > grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历\n\n        dfs (grid, visited, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> firstBorder(n, vector<bool>(m, false));\n\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> secondBorder(n, vector<bool>(m, false));\n\n    // 从最上和最下行的节点出发，向高处遍历\n    for (int i = 0; i < n; i++) {\n        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界\n        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界\n    }\n\n    // 从最左和最右列的节点出发，向高处遍历\n    for (int j = 0; j < m; j++) {\n        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界\n        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            // 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果\n            if (firstBorder[i][j] && secondBorder[i][j]) cout << i << \" \" << j << endl;;\n        }\n    }\n}",
          "description": "C++代码实现水流问题"
        },
        {
          "language": "java",
          "code": "public class Main {\n\n    // 采用 DFS 进行搜索\n    public static void dfs(int[][] heights, int x, int y, boolean[][] visited, int preH) {\n        // 遇到边界或者访问过的点，直接返回\n        if (x < 0 || x >= heights.length || y < 0 || y >= heights[0].length || visited[x][y]) return;\n        // 不满足水流入条件的直接返回\n        if (heights[x][y] < preH) return;\n        // 满足条件，设置为true，表示可以从边界到达此位置\n        visited[x][y] = true;\n\n        // 向下一层继续搜索\n        dfs(heights, x + 1, y, visited, heights[x][y]);\n        dfs(heights, x - 1, y, visited, heights[x][y]);\n        dfs(heights, x, y + 1, visited, heights[x][y]);\n        dfs(heights, x, y - 1, visited, heights[x][y]);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] heights = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                heights[i][j] = sc.nextInt();\n            }\n        }\n\n        // 初始化两个二位boolean数组，代表两个边界\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n\n        // 从左右边界出发进行DFS\n        for (int i = 0; i < m; i++) {\n            dfs(heights, i, 0, pacific, Integer.MIN_VALUE);\n            dfs(heights, i, n - 1, atlantic, Integer.MIN_VALUE);\n        }\n\n        // 从上下边界出发进行DFS\n        for (int j = 0; j < n; j++) {\n            dfs(heights, 0, j, pacific, Integer.MIN_VALUE);\n            dfs(heights, m - 1, j, atlantic, Integer.MIN_VALUE);\n        }\n\n        // 当两个边界二维数组在某个位置都为true时，符合题目要求\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    res.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // 打印结果\n        for (List<Integer> list : res) {\n            for (int k = 0; k < list.size(); k++) {\n                if (k == 0) {\n                    System.out.print(list.get(k) + \" \");\n                } else {\n                    System.out.print(list.get(k));\n                }\n            }\n            System.out.println();\n        }\n    }\n}",
          "description": "Java代码实现水流问题"
        },
        {
          "language": "python",
          "code": "first = set()\nsecond = set()\ndirections = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n\ndef dfs(i, j, graph, visited, side):\n    if visited[i][j]:\n        return\n    \n    visited[i][j] = True\n    side.add((i, j))\n    \n    for x, y in directions:\n        new_x = i + x\n        new_y = j + y\n        if (\n            0 <= new_x < len(graph)\n            and 0 <= new_y < len(graph[0])\n            and int(graph[new_x][new_y]) >= int(graph[i][j])\n        ):\n            dfs(new_x, new_y, graph, visited, side)\n\ndef main():\n    global first\n    global second\n    \n    N, M = map(int, input().strip().split())\n    graph = []\n    for _ in range(N):\n        row = input().strip().split()\n        graph.append(row)\n    \n    # 是否可到达第一边界\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(0, i, graph, visited, first)\n    for i in range(N):\n        dfs(i, 0, graph, visited, first)\n    \n    # 是否可到达第二边界\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(N - 1, i, graph, visited, second)\n    for i in range(N):\n        dfs(i, M - 1, graph, visited, second)\n    \n    # 可到达第一边界和第二边界\n    res = first & second\n    \n    for x, y in res:\n        print(f\"{x} {y}\")\n    \n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python代码实现水流问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "优化",
      "text": "那么我们可以 反过来想，从第一组边界上的节点 逆流而上，将遍历过的节点都标记上。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y]) return;\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\n        if (grid[x][y] > grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历\n\n        dfs (grid, visited, nextx, nexty);\n    }\n    return;\n}\nint main() {\n\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> firstBorder(n, vector<bool>(m, false));\n\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> secondBorder(n, vector<bool>(m, false));\n\n    // 从最上和最下行的节点出发，向高处遍历\n    for (int i = 0; i < n; i++) {\n        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界\n        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界\n    }\n\n    // 从最左和最右列的节点出发，向高处遍历\n    for (int j = 0; j < m; j++) {\n        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界\n        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            // 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果\n            if (firstBorder[i][j] && secondBorder[i][j]) cout << i << \" \" << j << endl;;\n        }\n    }\n}",
          "description": "C++版本的解决方案，使用深度优先搜索（DFS）来解决问题。"
        },
        {
          "language": "java",
          "code": "public class Main {\n\n    public static void dfs(int[][] heights, int x, int y, boolean[][] visited, int preH) {\n        if (x < 0 || x >= heights.length || y < 0 || y >= heights[0].length || visited[x][y]) return;\n        if (heights[x][y] < preH) return;\n        visited[x][y] = true;\n\n        dfs(heights, x + 1, y, visited, heights[x][y]);\n        dfs(heights, x - 1, y, visited, heights[x][y]);\n        dfs(heights, x, y + 1, visited, heights[x][y]);\n        dfs(heights, x, y - 1, visited, heights[x][y]);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] heights = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                heights[i][j] = sc.nextInt();\n            }\n        }\n\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            dfs(heights, i, 0, pacific, Integer.MIN_VALUE);\n            dfs(heights, i, n - 1, atlantic, Integer.MIN_VALUE);\n        }\n\n        for (int j = 0; j < n; j++) {\n            dfs(heights, 0, j, pacific, Integer.MIN_VALUE);\n            dfs(heights, m - 1, j, atlantic, Integer.MIN_VALUE);\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    res.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        for (List<Integer> list : res) {\n            for (int k = 0; k < list.size(); k++) {\n                if (k == 0) {\n                    System.out.print(list.get(k) + \" \");\n                } else {\n                    System.out.print(list.get(k));\n                }\n            }\n            System.out.println();\n        }\n    }\n}",
          "description": "Java版本的解决方案，同样采用深度优先搜索（DFS）方法。"
        },
        {
          "language": "python",
          "code": "first = set()\nsecond = set()\ndirections = [[-1, 0], [0, 1], [1, 0], [0, -1]]\ndef dfs(i, j, graph, visited, side):\n    if visited[i][j]:\n        return\n\n    visited[i][j] = True\n    side.add((i, j))\n\n    for x, y in directions:\n        new_x = i + x\n        new_y = j + y\n        if (\n            0 <= new_x < len(graph)\n            and 0 <= new_y < len(graph[0])\n            and int(graph[new_x][new_y]) >= int(graph[i][j])\n        ):\n            dfs(new_x, new_y, graph, visited, side)\ndef main():\n    global first\n    global second\n\n    N, M = map(int, input().strip().split())\n    graph = []\n    for _ in range(N):\n        row = input().strip().split()\n        graph.append(row)\n\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(0, i, graph, visited, first)\n    for i in range(N):\n        dfs(i, 0, graph, visited, first)\n\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(N - 1, i, graph, visited, second)\n    for i in range(N):\n        dfs(i, M - 1, graph, visited, second)\n\n    res = first & second\n\n    for x, y in res:\n        print(f\"{x} {y}\")\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的解决方案，也使用了深度优先搜索（DFS）。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y]) return;\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\n        if (grid[x][y] > grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历\n\n        dfs (grid, visited, nextx, nexty);\n    }\n    return;\n}\nint main() {\n\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> firstBorder(n, vector<bool>(m, false));\n\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> secondBorder(n, vector<bool>(m, false));\n\n    // 从最上和最下行的节点出发，向高处遍历\n    for (int i = 0; i < n; i++) {\n        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界\n        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界\n    }\n\n    // 从最左和最右列的节点出发，向高处遍历\n    for (int j = 0; j < m; j++) {\n        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界\n        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            // 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果\n            if (firstBorder[i][j] && secondBorder[i][j]) cout << i << \" \" << j << endl;;\n        }\n    }\n}",
          "description": "C++代码实现题目要求的功能"
        },
        {
          "language": "java",
          "code": "public class Main {\n\n    public static void dfs(int[][] heights, int x, int y, boolean[][] visited, int preH) {\n        if (x < 0 || x >= heights.length || y < 0 || y >= heights[0].length || visited[x][y]) return;\n        if (heights[x][y] < preH) return;\n        visited[x][y] = true;\n\n        dfs(heights, x + 1, y, visited, heights[x][y]);\n        dfs(heights, x - 1, y, visited, heights[x][y]);\n        dfs(heights, x, y + 1, visited, heights[x][y]);\n        dfs(heights, x, y - 1, visited, heights[x][y]);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] heights = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                heights[i][j] = sc.nextInt();\n            }\n        }\n\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            dfs(heights, i, 0, pacific, Integer.MIN_VALUE);\n            dfs(heights, i, n - 1, atlantic, Integer.MIN_VALUE);\n        }\n\n        for (int j = 0; j < n; j++) {\n            dfs(heights, 0, j, pacific, Integer.MIN_VALUE);\n            dfs(heights, m - 1, j, atlantic, Integer.MIN_VALUE);\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    res.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        for (List<Integer> list : res) {\n            for (int k = 0; k < list.size(); k++) {\n                if (k == 0) {\n                    System.out.print(list.get(k) + \" \");\n                } else {\n                    System.out.print(list.get(k));\n                }\n            }\n            System.out.println();\n        }\n    }\n}",
          "description": "Java代码实现题目要求的功能"
        },
        {
          "language": "python",
          "code": "first = set()\nsecond = set()\ndirections = [[-1, 0], [0, 1], [1, 0], [0, -1]]\ndef dfs(i, j, graph, visited, side):\n    if visited[i][j]:\n        return\n\n    visited[i][j] = True\n    side.add((i, j))\n\n    for x, y in directions:\n        new_x = i + x\n        new_y = j + y\n        if 0 <= new_x < len(graph) and 0 <= new_y < len(graph[0]) and int(graph[new_x][new_y]) >= int(graph[i][j]):\n            dfs(new_x, new_y, graph, visited, side)\ndef main():\n    global first\n    global second\n\n    N, M = map(int, input().strip().split())\n    graph = []\n    for _ in range(N):\n        row = input().strip().split()\n        graph.append(row)\n\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(0, i, graph, visited, first)\n    for i in range(N):\n        dfs(i, 0, graph, visited, first)\n\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(N - 1, i, graph, visited, second)\n    for i in range(N):\n        dfs(i, M - 1, graph, visited, second)\n\n    res = first & second\n\n    for x, y in res:\n        print(f\"{x} {y}\")\nif __name__ == \"__main__\":\n    main()",
          "description": "Python代码实现题目要求的功能"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y]) return;\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\n        if (grid[x][y] > grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历\n\n        dfs (grid, visited, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> firstBorder(n, vector<bool>(m, false));\n\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> secondBorder(n, vector<bool>(m, false));\n\n    // 从最上和最下行的节点出发，向高处遍历\n    for (int i = 0; i < n; i++) {\n        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界\n        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界\n    }\n\n    // 从最左和最右列的节点出发，向高处遍历\n    for (int j = 0; j < m; j++) {\n        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界\n        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            // 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果\n            if (firstBorder[i][j] && secondBorder[i][j]) cout << i << \" \" << j << endl;;\n        }\n    }\n}",
          "description": "C++代码实现水流问题的优化解决方案"
        },
        {
          "language": "java",
          "code": "public class Main {\n\n    public static void dfs(int[][] heights, int x, int y, boolean[][] visited, int preH) {\n        if (x < 0 || x >= heights.length || y < 0 || y >= heights[0].length || visited[x][y]) return;\n        if (heights[x][y] < preH) return;\n        visited[x][y] = true;\n\n        dfs(heights, x + 1, y, visited, heights[x][y]);\n        dfs(heights, x - 1, y, visited, heights[x][y]);\n        dfs(heights, x, y + 1, visited, heights[x][y]);\n        dfs(heights, x, y - 1, visited, heights[x][y]);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] heights = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                heights[i][j] = sc.nextInt();\n            }\n        }\n\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            dfs(heights, i, 0, pacific, Integer.MIN_VALUE);\n            dfs(heights, i, n - 1, atlantic, Integer.MIN_VALUE);\n        }\n\n        for (int j = 0; j < n; j++) {\n            dfs(heights, 0, j, pacific, Integer.MIN_VALUE);\n            dfs(heights, m - 1, j, atlantic, Integer.MIN_VALUE);\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    res.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        for (List<Integer> list : res) {\n            for (int k = 0; k < list.size(); k++) {\n                if (k == 0) {\n                    System.out.print(list.get(k) + \" \");\n                } else {\n                    System.out.print(list.get(k));\n                }\n            }\n            System.out.println();\n        }\n    }\n}",
          "description": "Java代码实现水流问题的解决方案"
        },
        {
          "language": "python",
          "code": "first = set()\nsecond = set()\ndirections = [[-1, 0], [0, 1], [1, 0], [0, -1]]\ndef dfs(i, j, graph, visited, side):\n    if visited[i][j]:\n        return\n    visited[i][j] = True\n    side.add((i, j))\n    for x, y in directions:\n        new_x = i + x\n        new_y = j + y\n        if 0 <= new_x < len(graph) and 0 <= new_y < len(graph[0]) and int(graph[new_x][new_y]) >= int(graph[i][j]):\n            dfs(new_x, new_y, graph, visited, side)\ndef main():\n    global first, second\n    N, M = map(int, input().strip().split())\n    graph = [input().strip().split() for _ in range(N)]\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(0, i, graph, visited, first)\n    for i in range(N):\n        dfs(i, 0, graph, visited, first)\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(N - 1, i, graph, visited, second)\n    for i in range(N):\n        dfs(i, M - 1, graph, visited, second)\n    res = first & second\n    for x, y in res:\n        print(f\"{x} {y}\")\nif __name__ == \"__main__\":\n    main()",
          "description": "Python代码实现水流问题的解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "c++",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y]) return;\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\n        if (grid[x][y] > grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历\n\n        dfs (grid, visited, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> firstBorder(n, vector<bool>(m, false));\n\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> secondBorder(n, vector<bool>(m, false));\n\n    // 从最上和最下行的节点出发，向高处遍历\n    for (int i = 0; i < n; i++) {\n        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界\n        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界\n    }\n\n    // 从最左和最右列的节点出发，向高处遍历\n    for (int j = 0; j < m; j++) {\n        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界\n        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            // 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果\n            if (firstBorder[i][j] && secondBorder[i][j]) cout << i << \" \" << j << endl;;\n        }\n    }\n}",
          "description": "C++代码实现水流问题解决方案。"
        },
        {
          "language": "java",
          "code": "public class Main {\n\n    public static void dfs(int[][] heights, int x, int y, boolean[][] visited, int preH) {\n        if (x < 0 || x >= heights.length || y < 0 || y >= heights[0].length || visited[x][y]) return;\n        if (heights[x][y] < preH) return;\n        visited[x][y] = true;\n\n        dfs(heights, x + 1, y, visited, heights[x][y]);\n        dfs(heights, x - 1, y, visited, heights[x][y]);\n        dfs(heights, x, y + 1, visited, heights[x][y]);\n        dfs(heights, x, y - 1, visited, heights[x][y]);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] heights = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                heights[i][j] = sc.nextInt();\n            }\n        }\n\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            dfs(heights, i, 0, pacific, Integer.MIN_VALUE);\n            dfs(heights, i, n - 1, atlantic, Integer.MIN_VALUE);\n        }\n\n        for (int j = 0; j < n; j++) {\n            dfs(heights, 0, j, pacific, Integer.MIN_VALUE);\n            dfs(heights, m - 1, j, atlantic, Integer.MIN_VALUE);\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    res.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        for (List<Integer> list : res) {\n            for (int k = 0; k < list.size(); k++) {\n                if (k == 0) {\n                    System.out.print(list.get(k) + \" \");\n                } else {\n                    System.out.print(list.get(k));\n                }\n            }\n            System.out.println();\n        }\n    }\n}",
          "description": "Java代码实现水流问题解决方案。"
        },
        {
          "language": "python",
          "code": "first = set()\nsecond = set()\ndirections = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n\ndef dfs(i, j, graph, visited, side):\n    if visited[i][j]:\n        return\n\n    visited[i][j] = True\n    side.add((i, j))\n\n    for x, y in directions:\n        new_x = i + x\n        new_y = j + y\n        if (\n            0 <= new_x < len(graph)\n            and 0 <= new_y < len(graph[0])\n            and int(graph[new_x][new_y]) >= int(graph[i][j])\n        ):\n            dfs(new_x, new_y, graph, visited, side)\n\ndef main():\n    global first\n    global second\n\n    N, M = map(int, input().strip().split())\n    graph = []\n    for _ in range(N):\n        row = input().strip().split()\n        graph.append(row)\n\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(0, i, graph, visited, first)\n    for i in range(N):\n        dfs(i, 0, graph, visited, first)\n\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(N - 1, i, graph, visited, second)\n    for i in range(N):\n        dfs(i, M - 1, graph, visited, second)\n\n    res = first & second\n\n    for x, y in res:\n        print(f\"{x} {y}\")\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python代码实现水流问题解决方案。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "public class Main {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y]) return;\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\n        if (grid[x][y] > grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历\n\n        dfs (grid, visited, nextx, nexty);\n    }\n    return;\n}\nint main() {\n\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> firstBorder(n, vector<bool>(m, false));\n\n    vector<vector<bool>> secondBorder(n, vector<bool>(m, false));\n\n    for (int i = 0; i < n; i++) {\n        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界\n        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界\n    }\n\n    for (int j = 0; j < m; j++) {\n        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界\n        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (firstBorder[i][j] && secondBorder[i][j]) cout << i << \" \" << j << endl;;\n        }\n    }\n}",
          "description": "C++版本的解决方案，使用DFS从边界逆流而上标记可访问节点。"
        },
        {
          "language": "java",
          "code": "public class Main {\n\n    public static void dfs(int[][] heights, int x, int y, boolean[][] visited, int preH) {\n        if (x < 0 || x >= heights.length || y < 0 || y >= heights[0].length || visited[x][y]) return;\n        if (heights[x][y] < preH) return;\n        visited[x][y] = true;\n\n        dfs(heights, x + 1, y, visited, heights[x][y]);\n        dfs(heights, x - 1, y, visited, heights[x][y]);\n        dfs(heights, x, y + 1, visited, heights[x][y]);\n        dfs(heights, x, y - 1, visited, heights[x][y]);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] heights = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                heights[i][j] = sc.nextInt();\n            }\n        }\n\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            dfs(heights, i, 0, pacific, Integer.MIN_VALUE);\n            dfs(heights, i, n - 1, atlantic, Integer.MIN_VALUE);\n        }\n\n        for (int j = 0; j < n; j++) {\n            dfs(heights, 0, j, pacific, Integer.MIN_VALUE);\n            dfs(heights, m - 1, j, atlantic, Integer.MIN_VALUE);\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    res.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        for (List<Integer> list : res) {\n            for (int k = 0; k < list.size(); k++) {\n                if (k == 0) {\n                    System.out.print(list.get(k) + \" \");\n                } else {\n                    System.out.print(list.get(k));\n                }\n            }\n            System.out.println();\n        }\n    }\n}",
          "description": "Java版本的解决方案，同样采用DFS方法从边界开始探索并标记可达点。"
        },
        {
          "language": "python",
          "code": "first = set()\nsecond = set()\ndirections = [[-1, 0], [0, 1], [1, 0], [0, -1]]\ndef dfs(i, j, graph, visited, side):\n    if visited[i][j]:\n        return\n    \n    visited[i][j] = True\n    side.add((i, j))\n    \n    for x, y in directions:\n        new_x = i + x\n        new_y = j + y\n        if (\n            0 <= new_x < len(graph)\n            and 0 <= new_y < len(graph[0])\n            and int(graph[new_x][new_y]) >= int(graph[i][j])\n        ):\n            dfs(new_x, new_y, graph, visited, side)\ndef main():\n    global first\n    global second\n    \n    N, M = map(int, input().strip().split())\n    graph = []\n    for _ in range(N):\n        row = input().strip().split()\n        graph.append(row)\n    \n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(0, i, graph, visited, first)\n    for i in range(N):\n        dfs(i, 0, graph, visited, first)\n    \n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(N - 1, i, graph, visited, second)\n    for i in range(N):\n        dfs(i, M - 1, graph, visited, second)\n    \n    res = first & second\n    \n    for x, y in res:\n        print(f\"{x} {y}\")\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的解决方案，通过集合来存储能够同时到达两个边界的坐标，并使用DFS算法进行搜索。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "first = set()",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y]) return;\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\n        if (grid[x][y] > grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历\n\n        dfs (grid, visited, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> firstBorder(n, vector<bool>(m, false));\n\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> secondBorder(n, vector<bool>(m, false));\n\n    // 从最上和最下行的节点出发，向高处遍历\n    for (int i = 0; i < n; i++) {\n        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界\n        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界\n    }\n\n    // 从最左和最右列的节点出发，向高处遍历\n    for (int j = 0; j < m; j++) {\n        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界\n        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            // 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果\n            if (firstBorder[i][j] && secondBorder[i][j]) cout << i << \" \" << j << endl;;\n        }\n    }\n}",
          "description": "C++代码实现矩阵中水流动问题的解决方案。"
        },
        {
          "language": "java",
          "code": "public class Main {\n\n    public static void dfs(int[][] heights, int x, int y, boolean[][] visited, int preH) {\n        if (x < 0 || x >= heights.length || y < 0 || y >= heights[0].length || visited[x][y]) return;\n        if (heights[x][y] < preH) return;\n        visited[x][y] = true;\n\n        dfs(heights, x + 1, y, visited, heights[x][y]);\n        dfs(heights, x - 1, y, visited, heights[x][y]);\n        dfs(heights, x, y + 1, visited, heights[x][y]);\n        dfs(heights, x, y - 1, visited, heights[x][y]);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] heights = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                heights[i][j] = sc.nextInt();\n            }\n        }\n\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            dfs(heights, i, 0, pacific, Integer.MIN_VALUE);\n            dfs(heights, i, n - 1, atlantic, Integer.MIN_VALUE);\n        }\n\n        for (int j = 0; j < n; j++) {\n            dfs(heights, 0, j, pacific, Integer.MIN_VALUE);\n            dfs(heights, m - 1, j, atlantic, Integer.MIN_VALUE);\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    res.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        for (List<Integer> list : res) {\n            for (int k = 0; k < list.size(); k++) {\n                if (k == 0) {\n                    System.out.print(list.get(k) + \" \");\n                } else {\n                    System.out.print(list.get(k));\n                }\n            }\n            System.out.println();\n        }\n    }\n}",
          "description": "Java代码实现矩阵中水流动问题的解决方案。"
        },
        {
          "language": "python",
          "code": "first = set()\nsecond = set()\ndirections = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n\ndef dfs(i, j, graph, visited, side):\n    if visited[i][j]:\n        return\n\n    visited[i][j] = True\n    side.add((i, j))\n\n    for x, y in directions:\n        new_x = i + x\n        new_y = j + y\n        if (\n            0 <= new_x < len(graph)\n            and 0 <= new_y < len(graph[0])\n            and int(graph[new_x][new_y]) >= int(graph[i][j])\n        ):\n            dfs(new_x, new_y, graph, visited, side)\n\ndef main():\n    global first\n    global second\n\n    N, M = map(int, input().strip().split())\n    graph = []\n    for _ in range(N):\n        row = input().strip().split()\n        graph.append(row)\n\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(0, i, graph, visited, first)\n    for i in range(N):\n        dfs(i, 0, graph, visited, first)\n\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(N - 1, i, graph, visited, second)\n    for i in range(N):\n        dfs(i, M - 1, graph, visited, second)\n\n    res = first & second\n\n    for x, y in res:\n        print(f\"{x} {y}\")\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python代码实现矩阵中水流动问题的解决方案。"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y]) return;\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\n        if (grid[x][y] > grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历\n\n        dfs (grid, visited, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> firstBorder(n, vector<bool>(m, false));\n\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> secondBorder(n, vector<bool>(m, false));\n\n    // 从最上和最下行的节点出发，向高处遍历\n    for (int i = 0; i < n; i++) {\n        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界\n        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界\n    }\n\n    // 从最左和最右列的节点出发，向高处遍历\n    for (int j = 0; j < m; j++) {\n        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界\n        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            // 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果\n            if (firstBorder[i][j] && secondBorder[i][j]) cout << i << \" \" << j << endl;;\n        }\n    }\n}",
      "description": "C++实现的DFS算法解决水流问题"
    },
    {
      "language": "java",
      "code": "public class Main {\n\n    public static void dfs(int[][] heights, int x, int y, boolean[][] visited, int preH) {\n        if (x < 0 || x >= heights.length || y < 0 || y >= heights[0].length || visited[x][y]) return;\n        if (heights[x][y] < preH) return;\n        visited[x][y] = true;\n\n        dfs(heights, x + 1, y, visited, heights[x][y]);\n        dfs(heights, x - 1, y, visited, heights[x][y]);\n        dfs(heights, x, y + 1, visited, heights[x][y]);\n        dfs(heights, x, y - 1, visited, heights[x][y]);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] heights = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                heights[i][j] = sc.nextInt();\n            }\n        }\n\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            dfs(heights, i, 0, pacific, Integer.MIN_VALUE);\n            dfs(heights, i, n - 1, atlantic, Integer.MIN_VALUE);\n        }\n\n        for (int j = 0; j < n; j++) {\n            dfs(heights, 0, j, pacific, Integer.MIN_VALUE);\n            dfs(heights, m - 1, j, atlantic, Integer.MIN_VALUE);\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    res.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        for (List<Integer> list : res) {\n            for (int k = 0; k < list.size(); k++) {\n                if (k == 0) {\n                    System.out.print(list.get(k) + \" \");\n                } else {\n                    System.out.print(list.get(k));\n                }\n            }\n            System.out.println();\n        }\n    }\n}",
      "description": "Java实现的DFS算法解决水流问题"
    },
    {
      "language": "python",
      "code": "first = set()\nsecond = set()\ndirections = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n\ndef dfs(i, j, graph, visited, side):\n    if visited[i][j]:\n        return\n\n    visited[i][j] = True\n    side.add((i, j))\n\n    for x, y in directions:\n        new_x = i + x\n        new_y = j + y\n        if (\n            0 <= new_x < len(graph)\n            and 0 <= new_y < len(graph[0])\n            and int(graph[new_x][new_y]) >= int(graph[i][j])\n        ):\n            dfs(new_x, new_y, graph, visited, side)\n\ndef main():\n    global first\n    global second\n\n    N, M = map(int, input().strip().split())\n    graph = []\n    for _ in range(N):\n        row = input().strip().split()\n        graph.append(row)\n\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(0, i, graph, visited, first)\n    for i in range(N):\n        dfs(i, 0, graph, visited, first)\n\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(N - 1, i, graph, visited, second)\n    for i in range(N):\n        dfs(i, M - 1, graph, visited, second)\n\n    res = first & second\n\n    for x, y in res:\n        print(f\"{x} {y}\")\n\nif __name__ == \"__main__\":\n    main()",
      "description": "Python实现的DFS算法解决水流问题"
    }
  ],
  "common_mistakes": [
    "忽略了地形高度对水流路径的影响，导致错误地标记某些不可达位置。",
    "在实现DFS时未正确处理边界条件，可能会导致数组越界。",
    "未能充分理解题目要求，比如只考虑了单向可达性而非双向可达性。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240517115816.png",
      "description": "这张图片展示了一个二维数组（矩阵）的边界划分，第一组边界（红色）和第二组边界（蓝色）分别标记了不同的子矩阵区域，适用于矩阵操作或子矩阵求和等算法问题。",
      "context": "图示展示了矩阵中能够同时流向两组边界的单元格（以蓝色标出），对应于题目要求找出的所有符合条件的坐标位置。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20250304174747.png",
      "description": "这张图片展示了在一个二维数组中，通过两组边界（红色和绿色）来划分区域，并使用箭头指示遍历路径，体现了矩阵遍历或子矩阵提取的算法思想。",
      "context": "展示了从第一组边界节点逆流而上标记遍历过的节点的过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20250304174801.png",
      "description": "这张图片展示了在一个二维数组中，通过特定的边界条件（第一组边界和第二组边界）进行遍历或计算的过程，涉及算法中的路径寻找或区域填充问题。",
      "context": "该图片展示了从第二组边界上节点出发进行遍历的关键路径，用于识别可以同时流向两组边界的节点。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240517115816.png",
      "description": "GIF展示了通过深度优先搜索（DFS）方法，从矩阵中的每个点出发探索能否同时到达指定的两组边界的过程。",
      "context": "GIF动画展示了如何通过遍历每个点来确定哪些单元格可以同时到达两个指定边界的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20250304174747.png",
      "description": "从第一组边界上的节点逆流而上进行深度优先搜索的过程。",
      "context": "GIF动画展示了从第一组边界上的节点逆流而上，标记遍历过的节点的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20250304174801.png",
      "description": "GIF展示了从边界节点逆流而上标记可到达节点的过程，以识别能够同时流向两组边界的节点。",
      "context": "该GIF动画展示了从第二组边界上节点出发遍历图的过程，用以识别既能流向第一组也能流向第二组边界的节点。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\图论\\水流问题.txt",
  "extracted_at": "2025-07-21T18:30:30.217805",
  "raw_content": "水流问题\n卡码网题目链接（ACM模式）(https://kamacoder.com/problempage.php?pid=1175)\n\n题目描述：\n\n现有一个 N × M 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。\n\n矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。\n\n输入描述：\n\n第一行包含两个整数 N 和 M，分别表示矩阵的行数和列数。\n\n后续 N 行，每行包含 M 个整数，表示矩阵中的每个单元格的高度。\n\n输出描述：\n\n输出共有多行，每行输出两个整数，用一个空格隔开，表示可达第一组边界和第二组边界的单元格的坐标，输出顺序任意。\n\n输入示例：\n\n5 5\n1 3 1 2 4\n1 2 1 3 2\n2 4 7 2 1\n4 5 6 1 1\n1 4 1 2 1\n输出示例：\n\n0 4\n1 3\n2 2\n3 0\n3 1\n3 2\n4 0\n4 1\n提示信息：\nhttps://file1.kamacoder.com/i/algo/20240517115816.png\n\n\n图中的蓝色方块上的雨水既能流向第一组边界，也能流向第二组边界。所以最终答案为所有蓝色方块的坐标。\n\n数据范围：\n\n1 <= M, N <= 50\n\n#思路\n\n\n一个比较直白的想法，其实就是 遍历每个点，然后看这个点 能不能同时到达第一组边界和第二组边界。\n\n至于遍历方式，可以用dfs，也可以用bfs，以下用dfs来举例。\n\n那么这种思路的实现代码如下：\n\n#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\n\n// 从 x，y 出发 把可以走的地方都标记上\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y]) return;\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\n        if (grid[x][y] < grid[nextx][nexty]) continue; // 高度不合适\n\n        dfs (grid, visited, nextx, nexty);\n    }\n    return;\n}\nbool isResult(vector<vector<int>>& grid, int x, int y) {\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    // 深搜，将x,y出发 能到的节点都标记上。\n    dfs(grid, visited, x, y);\n    bool isFirst = false;\n    bool isSecond = false;\n\n    // 以下就是判断x，y出发，是否到达第一组边界和第二组边界\n    // 第一边界的上边\n    for (int j = 0; j < m; j++) {\n        if (visited[0][j]) {\n            isFirst = true;\n            break;\n        }\n    }\n    // 第一边界的左边\n    for (int i = 0; i < n; i++) {\n        if (visited[i][0]) {\n            isFirst = true;\n            break;\n        }\n    }\n    // 第二边界下边\n    for (int j = 0; j < m; j++) {\n        if (visited[n - 1][j]) {\n            isSecond = true;\n            break;\n        }\n    }\n    // 第二边界右边\n    for (int i = 0; i < n; i++) {\n        if (visited[i][m - 1]) {\n            isSecond = true;\n            break;\n        }\n    }\n    if (isFirst && isSecond) return true;\n    return false;\n}\n\n\nint main() {\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 遍历每一个点，看是否能同时到达第一组边界和第二组边界\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (isResult(grid, i, j)) {\n                cout << i << \" \" << j << endl;\n            }\n        }\n    }\n}\n\n这种思路很直白，但很明显，以上代码超时了。 来看看时间复杂度。\n\n遍历每一个节点，是 m * n，遍历每一个节点的时候，都要做深搜，深搜的时间复杂度是： m * n\n\n那么整体时间复杂度 就是 O(m^2 * n^2) ，这是一个四次方的时间复杂度。\n\n#优化\n那么我们可以 反过来想，从第一组边界上的节点 逆流而上，将遍历过的节点都标记上。\n\n同样从第二组边界的边上节点 逆流而上，将遍历过的节点也标记上。\n\n然后两方都标记过的节点就是既可以流向第一组边界也可以流向第二组边界的节点。\n\n从第一组边界边上节点出发，如图： （图中并没有把所有遍历的方向都画出来，只画关键部分）\n\nhttps://file1.kamacoder.com/i/algo/20250304174747.png\n\n从第二组边界上节点出发，如图： （图中并没有把所有遍历的方向都画出来，只画关键部分）\nhttps://file1.kamacoder.com/i/algo/20250304174801.png\n\n\n最后，我们得到两个方向交界的这些节点，就是我们最后要求的节点。\n\n按照这样的逻辑，就可以写出如下遍历代码：（详细注释）\n\n#include <iostream>\n#include <vector>\nusing namespace std;\nint n, m;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y]) return;\n\n    visited[x][y] = true;\n\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\n        if (grid[x][y] > grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历\n\n        dfs (grid, visited, nextx, nexty);\n    }\n    return;\n}\n\n\n\nint main() {\n\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> firstBorder(n, vector<bool>(m, false));\n\n    // 标记从第一组边界上的节点出发，可以遍历的节点\n    vector<vector<bool>> secondBorder(n, vector<bool>(m, false));\n\n    // 从最上和最下行的节点出发，向高处遍历\n    for (int i = 0; i < n; i++) {\n        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界\n        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界\n    }\n\n    // 从最左和最右列的节点出发，向高处遍历\n    for (int j = 0; j < m; j++) {\n        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界\n        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            // 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果\n            if (firstBorder[i][j] && secondBorder[i][j]) cout << i << \" \" << j << endl;;\n        }\n    }\n\n\n}\n\n时间复杂度分析， 关于dfs函数搜索的过程 时间复杂度是 O(n * m)，这个大家比较容易想。\n\n关键看主函数，那么每次dfs的时候，上面还是有for循环的。\n\n第一个for循环，时间复杂度是：n * (n * m) 。\n\n第二个for循环，时间复杂度是：m * (n * m)。\n\n所以本题看起来 时间复杂度好像是 ： n * (n * m) + m * (n * m) = (m * n) * (m + n) 。\n\n其实这是一个误区，大家再自己看 dfs函数的实现，其实 有visited函数记录 走过的节点，而走过的节点是不会再走第二次的。\n\n所以 调用dfs函数，只要参数传入的是 数组 firstBorder，那么地图中 每一个节点其实就遍历一次，无论你调用多少次。\n\n同理，调用dfs函数，只要 参数传入的是 数组 secondBorder，地图中每个节点也只会遍历一次。\n\n所以，以下这段代码的时间复杂度是 2 * n * m。 地图用每个节点就遍历了两次，参数传入 firstBorder 的时候遍历一次，参数传入 secondBorder 的时候遍历一次。\n\n// 从最上和最下行的节点出发，向高处遍历\nfor (int i = 0; i < n; i++) {\n    dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界\n    dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界\n}\n\n// 从最左和最右列的节点出发，向高处遍历\nfor (int j = 0; j < m; j++) {\n    dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界\n    dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界\n}\n那么本题整体的时间复杂度其实是： 2 * n * m + n * m ，所以最终时间复杂度为 O(n * m) 。\n\n空间复杂度为：O(n * m) 这个就不难理解了。开了几个 n * m 的数组。\n\n#其他语言版本\n#Java\npublic class Main {\n\n    // 采用 DFS 进行搜索\n    public static void dfs(int[][] heights, int x, int y, boolean[][] visited, int preH) {\n        // 遇到边界或者访问过的点，直接返回\n        if (x < 0 || x >= heights.length || y < 0 || y >= heights[0].length || visited[x][y]) return;\n        // 不满足水流入条件的直接返回\n        if (heights[x][y] < preH) return;\n        // 满足条件，设置为true，表示可以从边界到达此位置\n        visited[x][y] = true;\n\n        // 向下一层继续搜索\n        dfs(heights, x + 1, y, visited, heights[x][y]);\n        dfs(heights, x - 1, y, visited, heights[x][y]);\n        dfs(heights, x, y + 1, visited, heights[x][y]);\n        dfs(heights, x, y - 1, visited, heights[x][y]);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] heights = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                heights[i][j] = sc.nextInt();\n            }\n        }\n\n        // 初始化两个二位boolean数组，代表两个边界\n        boolean[][] pacific = new boolean[m][n];\n        boolean[][] atlantic = new boolean[m][n];\n\n        // 从左右边界出发进行DFS\n        for (int i = 0; i < m; i++) {\n            dfs(heights, i, 0, pacific, Integer.MIN_VALUE);\n            dfs(heights, i, n - 1, atlantic, Integer.MIN_VALUE);\n        }\n\n        // 从上下边界出发进行DFS\n        for (int j = 0; j < n; j++) {\n            dfs(heights, 0, j, pacific, Integer.MIN_VALUE);\n            dfs(heights, m - 1, j, atlantic, Integer.MIN_VALUE);\n        }\n\n        // 当两个边界二维数组在某个位置都为true时，符合题目要求\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    res.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        // 打印结果\n        for (List<Integer> list : res) {\n            for (int k = 0; k < list.size(); k++) {\n                if (k == 0) {\n                    System.out.print(list.get(k) + \" \");\n                } else {\n                    System.out.print(list.get(k));\n                }\n            }\n            System.out.println();\n        }\n    }\n}\n\n#Python\nfirst = set()\nsecond = set()\ndirections = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n\ndef dfs(i, j, graph, visited, side):\n    if visited[i][j]:\n        return\n    \n    visited[i][j] = True\n    side.add((i, j))\n    \n    for x, y in directions:\n        new_x = i + x\n        new_y = j + y\n        if (\n            0 <= new_x < len(graph)\n            and 0 <= new_y < len(graph[0])\n            and int(graph[new_x][new_y]) >= int(graph[i][j])\n        ):\n            dfs(new_x, new_y, graph, visited, side)\n\ndef main():\n    global first\n    global second\n    \n    N, M = map(int, input().strip().split())\n    graph = []\n    for _ in range(N):\n        row = input().strip().split()\n        graph.append(row)\n    \n    # 是否可到达第一边界\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(0, i, graph, visited, first)\n    for i in range(N):\n        dfs(i, 0, graph, visited, first)\n    \n    # 是否可到达第二边界\n    visited = [[False] * M for _ in range(N)]\n    for i in range(M):\n        dfs(N - 1, i, graph, visited, second)\n    for i in range(N):\n        dfs(i, M - 1, graph, visited, second)\n\n    # 可到达第一边界和第二边界\n    res = first & second\n    \n    for x, y in res:\n        print(f\"{x} {y}\")\n    \n    \nif __name__ == \"__main__\":\n    main()"
}