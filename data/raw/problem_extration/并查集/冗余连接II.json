{
  "id": "AP_3a83fda8",
  "title": "冗余连接II",
  "alternative_titles": [],
  "platform": "kamacoder",
  "url": "https://kamacoder.com/problempage.php?pid=1182",
  "description": "返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。\n\n输入描述\n\n第一行输入一个整数 N，表示有向图中节点和边的个数。\n\n后续 N 行，每行输入两个整数 s 和 t，代表这是 s 节点连接并指向 t 节点的单向边\n\n输出描述\n\n输出一条可以删除的边，若有多条边可以删除，请输出标准输入中最后出现的一条边。\n\n输入",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "图论",
    "并查集"
  ],
  "data_structure_tags": [
    "数组",
    "向量"
  ],
  "technique_tags": [
    "深度优先搜索",
    "路径压缩",
    "逆序遍历"
  ],
  "difficulty": null,
  "solution_approach": "首先统计每个节点的入度，并记录所有边。如果发现某节点入度为2，则尝试删除指向该节点的两条边中的任意一条，通过判断删除后是否能形成有向树来决定删除哪条边。如果不存在入度为2的情况，则说明图中存在环，需要找到并移除构成环的一条边以打破环。",
  "key_insights": [
    {
      "content": "在有向树中，只有根节点的入度为0，其他所有节点的入度都为1。因此，若发现某个节点的入度为2，则说明这个点至少被两个不同的父节点所指，这违反了有向树的定义。"
    },
    {
      "content": "当多条边都能作为冗余连接时，题目要求输出最后出现的那一组边。这种情况下，从输入顺序的逆方向开始检查变得至关重要。"
    },
    {
      "content": "如果没有节点的入度为2但仍然无法形成有向树，这意味着图中必定存在一个或多个环。此时，找到并移除构成环的任一边即可解决问题。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "本题与 108.冗余连接（https://programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html） 类似，但本题是一个有向图，有向图相对要复杂一些。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n;\nvector<int> father (1001, 0);\n// 并查集初始化\nvoid init() {\n    for (int i = 1; i <= n; ++i) {\n        father[i] = i;\n    }\n}\n// 并查集里寻根的过程\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\n// 将v->u 这条边加入并查集\nvoid join(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return ;\n    father[v] = u;\n}\n// 判断 u 和 v是否找到同一个根\nbool same(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\n\n// 在有向图里找到删除的那条边，使其变成树\nvoid getRemoveEdge(const vector<vector<int>>& edges) {\n    init(); // 初始化并查集\n    for (int i = 0; i < n; i++) { // 遍历所有的边\n        if (same(edges[i][0], edges[i][1])) { // 构成有向环了，就是要删除的边\n            cout << edges[i][0] << \" \" << edges[i][1];\n            return;\n        } else {\n            join(edges[i][0], edges[i][1]);\n        }\n    }\n}\n\n// 删一条边之后判断是不是树\nbool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {\n    init(); // 初始化并查集\n    for (int i = 0; i < n; i++) {\n        if (i == deleteEdge) continue;\n        if (same(edges[i][0], edges[i][1])) { // 构成有向环了，一定不是树\n            return false;\n        }\n        join(edges[i][0], edges[i][1]);\n    }\n    return true;\n}\n\nint main() {\n    int s, t;\n    vector<vector<int>> edges;\n    cin >> n;\n    vector<int> inDegree(n + 1, 0); // 记录节点入度\n    for (int i = 0; i < n; i++) {\n        cin >> s >> t;\n        inDegree[t]++;\n        edges.push_back({s, t});\n    }\n\n    vector<int> vec; // 记录入度为2的边（如果有的话就两条边）\n    // 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边\n    for (int i = n - 1; i >= 0; i--) {\n        if (inDegree[edges[i][1]] == 2) {\n            vec.push_back(i);\n        }\n    }\n    // 情况一、情况二\n    if (vec.size() > 0) {\n        // 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边\n        if (isTreeAfterRemoveEdge(edges, vec[0])) {\n            cout << edges[vec[0]][0] << \" \" << edges[vec[0]][1];\n        } else {\n            cout << edges[vec[1]][0] << \" \" << edges[vec[1]][1];\n        }\n        return 0;\n    }\n\n    // 处理情况三\n    // 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了\n    getRemoveEdge(edges);\n}",
          "description": "C++实现的冗余连接II问题解决方案"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\n/* \n * 冗余连接II。主要问题是存在入度为2或者成环，也可能两个问题同时存在。\n * 1.判断入度为2的边 \n * 2.判断是否成环（并查集）\n */\n\npublic class Main {\n    /**\n     * 并查集模板\n     */\n    static class Disjoint {\n\n        private final int[] father;\n\n        public Disjoint(int n) {\n            father = new int[n];\n            for (int i = 0; i < n; i++) {\n                father[i] = i;\n            }\n        }\n\n        public void join(int n, int m) {\n            n = find(n);\n            m = find(m);\n            if (n == m) return;\n            father[n] = m;\n        }\n\n        public int find(int n) {\n            return father[n] == n ? n : (father[n] = find(father[n]));\n        }\n\n        public boolean isSame(int n, int m) {\n            return find(n) == find(m);\n        }\n    }\n\n    static class Edge {\n        int s;\n        int t;\n\n        public Edge(int s, int t) {\n            this.s = s;\n            this.t = t;\n        }\n    }\n\n    static class Node {\n        int id;\n        int in;\n        int out;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Edge> edges = new ArrayList<>();\n        Node[] nodeMap = new Node[n + 1];\n        for (int i = 1; i <= n; i++) {\n            nodeMap[i] = new Node();\n        }\n        Integer doubleIn = null;\n        for (int i = 0; i < n; i++) {\n            int s = scanner.nextInt();\n            int t = scanner.nextInt();\n            //记录入度\n            nodeMap[t].in++;\n            if (!(nodeMap[t].in < 2)) doubleIn = t;\n            Edge edge = new Edge(s, t);\n            edges.add(edge);\n        }\n        Edge result = null;\n        //存在入度为2的节点，既要消除入度为2的问题同时解除可能存在的环\n        if (doubleIn != null) {\n            List<Edge> doubleInEdges = new ArrayList<>();\n            for (Edge edge : edges) {\n                if (edge.t == doubleIn) doubleInEdges.add(edge);\n                if (doubleInEdges.size() == 2) break;\n            }\n            Edge edge = doubleInEdges.get(1);\n            if (isTreeWithExclude(edges, edge, nodeMap)) {\n                result = edge;\n            } else {\n                result = doubleInEdges.get(0);\n            }\n        } else {\n            //不存在入度为2的节点,则只需要解除环即可\n            result = getRemoveEdge(edges, nodeMap);\n        }\n\n        System.out.println(result.s + \" \" + result.t);\n    }\n\n    public static boolean isTreeWithExclude(List<Edge> edges, Edge exculdEdge, Node[] nodeMap) {\n        Disjoint disjoint = new Disjoint(nodeMap.length + 1);\n        for (Edge edge : edges) {\n            if (edge == exculdEdge) continue;\n            //成环则不是树\n            if (disjoint.isSame(edge.s, edge.t)) {\n                return false;\n            }\n            disjoint.join(edge.s, edge.t);\n        }\n        return true;\n    }\n\n    public static Edge getRemoveEdge(List<Edge> edges, Node[] nodeMap) {\n        int length = nodeMap.length;\n        Disjoint disjoint = new Disjoint(length);\n\n        for (Edge edge : edges) {\n            if (disjoint.isSame(edge.s, edge.t)) return edge;\n            disjoint.join(edge.s, edge.t);\n        }\n        return null;\n    }\n\n}",
          "description": "Java实现的冗余连接II问题解决方案"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\n\nfather = list()\n\ndef find(u):\n    if u == father[u]:\n        return u\n    else:\n        father[u] = find(father[u])\n        return father[u]\n\n\ndef is_same(u, v):\n    u = find(u)\n    v = find(v)\n    return u == v\n\n\ndef join(u, v):\n    u = find(u)\n    v = find(v)\n    if u != v:\n        father[u] = v\n\n\ndef is_tree_after_remove_edge(edges, edge, n):\n    # 初始化并查集\n    global father \n    father = [i for i in range(n + 1)]\n\n    for i in range(len(edges)):\n        if i == edge:\n            continue\n        s, t = edges[i]\n        if is_same(s, t): # 成環，即不是有向樹\n            return False\n        else: # 將s,t放入集合中\n            join(s, t)\n    return True\n\n\ndef get_remove_edge(edges):\n    # 初始化并查集\n    global father\n    father = [i for i in range(n + 1)]\n\n    for s, t in edges:\n        if is_same(s, t):\n            print(s, t)\n            return\n        else:\n            join(s, t)\n\n\nif __name__ == \"__main__\":\n    # 輸入\n    n = int(input())\n    edges = list()\n    in_degree = defaultdict(int)\n\n    for i in range(n):\n        s, t = map(int, input().split())\n        in_degree[t] += 1\n        edges.append([s, t])\n\n    # 尋找入度為2的邊，並紀錄其下標(index)\n    vec = list()\n    for i in range(n - 1, -1, -1):\n        if in_degree[edges[i][1]] == 2:\n            vec.append(i)\n\n    # 輸出\n    if len(vec) > 0:\n        # 情況一：刪除輸出順序靠後的邊 \n        if is_tree_after_remove_edge(edges, vec[0], n):\n            print(edges[vec[0]][0], edges[vec[0]][1])\n        # 情況二：只能刪除特定的邊\n        else:\n            print(edges[vec[1]][0], edges[vec[1]][1])\n    else:\n        # 情況三： 原圖有環\n        get_remove_edge(edges)",
          "description": "Python实现的冗余连接II问题解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "写代码",
      "text": "把每条边记录下来，并统计节点入度：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "int s, t;\nvector<vector<int>> edges;\ncin >> n;\nvector<int> inDegree(n + 1, 0); // 记录节点入度\nfor (int i = 0; i < n; i++) {\n    cin >> s >> t;\n    inDegree[t]++;\n    edges.push_back({s, t});\n}\nvector<int> vec; // 记录入度为2的边（如果有的话就两条边）\n// 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边\nfor (int i = n - 1; i >= 0; i--) {\n    if (inDegree[edges[i][1]] == 2) {\n        vec.push_back(i);\n    }\n}\nif (vec.size() > 0) {\n    // 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边\n    if (isTreeAfterRemoveEdge(edges, vec[0])) {\n        cout << edges[vec[0]][0] << \" \" << edges[vec[0]][1];\n    } else {\n        cout << edges[vec[1]][0] << \" \" << edges[vec[1]][1];\n    }\n    return 0;\n}",
          "description": "C++代码片段用于处理输入和识别入度为2的边"
        },
        {
          "language": "java",
          "code": "int n = scanner.nextInt();\nList<Edge> edges = new ArrayList<>();\nNode[] nodeMap = new Node[n + 1];\nfor (int i = 1; i <= n; i++) {\n    nodeMap[i] = new Node();\n}\nInteger doubleIn = null;\nfor (int i = 0; i < n; i++) {\n    int s = scanner.nextInt();\n    int t = scanner.nextInt();\n    //记录入度\n    nodeMap[t].in++;\n    if (!(nodeMap[t].in < 2)) doubleIn = t;\n    Edge edge = new Edge(s, t);\n    edges.add(edge);\n}\nEdge result = null;\n//存在入度为2的节点，既要消除入度为2的问题同时解除可能存在的环\nif (doubleIn != null) {\n    List<Edge> doubleInEdges = new ArrayList<>();\n    for (Edge edge : edges) {\n        if (edge.t == doubleIn) doubleInEdges.add(edge);\n        if (doubleInEdges.size() == 2) break;\n    }\n    Edge edge = doubleInEdges.get(1);\n    if (isTreeWithExclude(edges, edge, nodeMap)) {\n        result = edge;\n    } else {\n        result = doubleInEdges.get(0);\n    }\n} else {\n    //不存在入度为2的节点,则只需要解除环即可\n    result = getRemoveEdge(edges, nodeMap);\n}\nSystem.out.println(result.s + \" \" + result.t);",
          "description": "Java代码片段用于处理输入、识别入度为2的边以及输出结果"
        },
        {
          "language": "python",
          "code": "n = int(input())\nedges = list()\nin_degree = defaultdict(int)\nfor i in range(n):\n    s, t = map(int, input().split())\n    in_degree[t] += 1\n    edges.append([s, t])\n# 尋找入度為2的邊，並紀錄其下標(index)\nvec = list()\nfor i in range(n - 1, -1, -1):\n    if in_degree[edges[i][1]] == 2:\n        vec.append(i)\n# 輸出\nif len(vec) > 0:\n    # 情況一：刪除輸出順序靠後的邊 \n    if is_tree_after_remove_edge(edges, vec[0], n):\n        print(edges[vec[0]][0], edges[vec[0]][1])\n    # 情況二：只能刪除特定的邊\n    else:\n        print(edges[vec[1]][0], edges[vec[1]][1])\nelse:\n    # 情況三： 原圖有環\n    get_remove_edge(edges)",
          "description": "Python代码片段用于处理输入、识别入度为2的边以及输出结果"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n;\nvector<int> father (1001, 0);\nvoid init() {\n    for (int i = 1; i <= n; ++i) {\n        father[i] = i;\n    }\n}\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\nvoid join(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return ;\n    father[v] = u;\n}\nbool same(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\nvoid getRemoveEdge(const vector<vector<int>>& edges) {\n    init();\n    for (int i = 0; i < n; i++) {\n        if (same(edges[i][0], edges[i][1])) {\n            cout << edges[i][0] << \" \" << edges[i][1];\n            return;\n        } else {\n            join(edges[i][0], edges[i][1]);\n        }\n    }\n}\nbool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {\n    init();\n    for (int i = 0; i < n; i++) {\n        if (i == deleteEdge) continue;\n        if (same(edges[i][0], edges[i][1])) {\n            return false;\n        }\n        join(edges[i][0], edges[i][1]);\n    }\n    return true;\n}\nint main() {\n    int s, t;\n    vector<vector<int>> edges;\n    cin >> n;\n    vector<int> inDegree(n + 1, 0);\n    for (int i = 0; i < n; i++) {\n        cin >> s >> t;\n        inDegree[t]++;\n        edges.push_back({s, t});\n    }\n\n    vector<int> vec;\n    for (int i = n - 1; i >= 0; i--) {\n        if (inDegree[edges[i][1]] == 2) {\n            vec.push_back(i);\n        }\n    }\n    if (vec.size() > 0) {\n        if (isTreeAfterRemoveEdge(edges, vec[0])) {\n            cout << edges[vec[0]][0] << \" \" << edges[vec[0]][1];\n        } else {\n            cout << edges[vec[1]][0] << \" \" << edges[vec[1]][1];\n        }\n        return 0;\n    }\n    getRemoveEdge(edges);\n}",
          "description": "C++版本的冗余连接II解决方案"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    static class Disjoint {\n        private final int[] father;\n        public Disjoint(int n) {\n            father = new int[n];\n            for (int i = 0; i < n; i++) {\n                father[i] = i;\n            }\n        }\n        public void join(int n, int m) {\n            n = find(n);\n            m = find(m);\n            if (n == m) return;\n            father[n] = m;\n        }\n        public int find(int n) {\n            return father[n] == n ? n : (father[n] = find(father[n]));\n        }\n        public boolean isSame(int n, int m) {\n            return find(n) == find(m);\n        }\n    }\n    static class Edge {\n        int s;\n        int t;\n        public Edge(int s, int t) {\n            this.s = s;\n            this.t = t;\n        }\n    }\n    static class Node {\n        int id;\n        int in;\n        int out;\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Edge> edges = new ArrayList<>();\n        Node[] nodeMap = new Node[n + 1];\n        for (int i = 1; i <= n; i++) {\n            nodeMap[i] = new Node();\n        }\n        Integer doubleIn = null;\n        for (int i = 0; i < n; i++) {\n            int s = scanner.nextInt();\n            int t = scanner.nextInt();\n            nodeMap[t].in++;\n            if (!(nodeMap[t].in < 2)) doubleIn = t;\n            Edge edge = new Edge(s, t);\n            edges.add(edge);\n        }\n        Edge result = null;\n        if (doubleIn != null) {\n            List<Edge> doubleInEdges = new ArrayList<>();\n            for (Edge edge : edges) {\n                if (edge.t == doubleIn) doubleInEdges.add(edge);\n                if (doubleInEdges.size() == 2) break;\n            }\n            Edge edge = doubleInEdges.get(1);\n            if (isTreeWithExclude(edges, edge, nodeMap)) {\n                result = edge;\n            } else {\n                result = doubleInEdges.get(0);\n            }\n        } else {\n            result = getRemoveEdge(edges, nodeMap);\n        }\n        System.out.println(result.s + \" \" + result.t);\n    }\n    public static boolean isTreeWithExclude(List<Edge> edges, Edge exculdEdge, Node[] nodeMap) {\n        Disjoint disjoint = new Disjoint(nodeMap.length + 1);\n        for (Edge edge : edges) {\n            if (edge == exculdEdge) continue;\n            if (disjoint.isSame(edge.s, edge.t)) {\n                return false;\n            }\n            disjoint.join(edge.s, edge.t);\n        }\n        return true;\n    }\n    public static Edge getRemoveEdge(List<Edge> edges, Node[] nodeMap) {\n        int length = nodeMap.length;\n        Disjoint disjoint = new Disjoint(length);\n        for (Edge edge : edges) {\n            if (disjoint.isSame(edge.s, edge.t)) return edge;\n            disjoint.join(edge.s, edge.t);\n        }\n        return null;\n    }\n}",
          "description": "Java版本的冗余连接II解决方案"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\nfather = list()\ndef find(u):\n    if u == father[u]:\n        return u\n    else:\n        father[u] = find(father[u])\n        return father[u]\ndef is_same(u, v):\n    u = find(u)\n    v = find(v)\n    return u == v\ndef join(u, v):\n    u = find(u)\n    v = find(v)\n    if u != v:\n        father[u] = v\ndef is_tree_after_remove_edge(edges, edge, n):\n    global father\n    father = [i for i in range(n + 1)]\n    for i in range(len(edges)):\n        if i == edge:\n            continue\n        s, t = edges[i]\n        if is_same(s, t):\n            return False\n        else:\n            join(s, t)\n    return True\ndef get_remove_edge(edges):\n    global father\n    father = [i for i in range(n + 1)]\n    for s, t in edges:\n        if is_same(s, t):\n            print(s, t)\n            return\n        else:\n            join(s, t)\nif __name__ == \"__main__\":\n    n = int(input())\n    edges = list()\n    in_degree = defaultdict(int)\n    for i in range(n):\n        s, t = map(int, input().split())\n        in_degree[t] += 1\n        edges.append([s, t])\n    vec = list()\n    for i in range(n - 1, -1, -1):\n        if in_degree[edges[i][1]] == 2:\n            vec.append(i)\n    if len(vec) > 0:\n        if is_tree_after_remove_edge(edges, vec[0], n):\n            print(edges[vec[0]][0], edges[vec[0]][1])\n        else:\n            print(edges[vec[1]][0], edges[vec[1]][1])\n    else:\n        get_remove_edge(edges)",
          "description": "Python版本的冗余连接II解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n;\nvector<int> father (1001, 0);\nvoid init() {\n    for (int i = 1; i <= n; ++i) {\n        father[i] = i;\n    }\n}\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\nvoid join(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return ;\n    father[v] = u;\n}\nbool same(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\nvoid getRemoveEdge(const vector<vector<int>>& edges) {\n    init();\n    for (int i = 0; i < n; i++) {\n        if (same(edges[i][0], edges[i][1])) {\n            cout << edges[i][0] << \" \" << edges[i][1];\n            return;\n        } else {\n            join(edges[i][0], edges[i][1]);\n        }\n    }\n}\nbool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {\n    init();\n    for (int i = 0; i < n; i++) {\n        if (i == deleteEdge) continue;\n        if (same(edges[i][0], edges[i][1])) {\n            return false;\n        }\n        join(edges[i][0], edges[i][1]);\n    }\n    return true;\n}\nint main() {\n    int s, t;\n    vector<vector<int>> edges;\n    cin >> n;\n    vector<int> inDegree(n + 1, 0);\n    for (int i = 0; i < n; i++) {\n        cin >> s >> t;\n        inDegree[t]++;\n        edges.push_back({s, t});\n    }\n\n    vector<int> vec;\n    for (int i = n - 1; i >= 0; i--) {\n        if (inDegree[edges[i][1]] == 2) {\n            vec.push_back(i);\n        }\n    }\n    if (vec.size() > 0) {\n        if (isTreeAfterRemoveEdge(edges, vec[0])) {\n            cout << edges[vec[0]][0] << \" \" << edges[vec[0]][1];\n        } else {\n            cout << edges[vec[1]][0] << \" \" << edges[vec[1]][1];\n        }\n        return 0;\n    }\n    getRemoveEdge(edges);\n}",
          "description": "C++实现的冗余连接II问题解决方案"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    static class Disjoint {\n        private final int[] father;\n        public Disjoint(int n) {\n            father = new int[n];\n            for (int i = 0; i < n; i++) {\n                father[i] = i;\n            }\n        }\n        public void join(int n, int m) {\n            n = find(n);\n            m = find(m);\n            if (n == m) return;\n            father[n] = m;\n        }\n        public int find(int n) {\n            return father[n] == n ? n : (father[n] = find(father[n]));\n        }\n        public boolean isSame(int n, int m) {\n            return find(n) == find(m);\n        }\n    }\n    static class Edge {\n        int s;\n        int t;\n        public Edge(int s, int t) {\n            this.s = s;\n            this.t = t;\n        }\n    }\n    static class Node {\n        int id;\n        int in;\n        int out;\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Edge> edges = new ArrayList<>();\n        Node[] nodeMap = new Node[n + 1];\n        for (int i = 1; i <= n; i++) {\n            nodeMap[i] = new Node();\n        }\n        Integer doubleIn = null;\n        for (int i = 0; i < n; i++) {\n            int s = scanner.nextInt();\n            int t = scanner.nextInt();\n            nodeMap[t].in++;\n            if (!(nodeMap[t].in < 2)) doubleIn = t;\n            Edge edge = new Edge(s, t);\n            edges.add(edge);\n        }\n        Edge result = null;\n        if (doubleIn != null) {\n            List<Edge> doubleInEdges = new ArrayList<>();\n            for (Edge edge : edges) {\n                if (edge.t == doubleIn) doubleInEdges.add(edge);\n                if (doubleInEdges.size() == 2) break;\n            }\n            Edge edge = doubleInEdges.get(1);\n            if (isTreeWithExclude(edges, edge, nodeMap)) {\n                result = edge;\n            } else {\n                result = doubleInEdges.get(0);\n            }\n        } else {\n            result = getRemoveEdge(edges, nodeMap);\n        }\n        System.out.println(result.s + \" \" + result.t);\n    }\n    public static boolean isTreeWithExclude(List<Edge> edges, Edge exculdEdge, Node[] nodeMap) {\n        Disjoint disjoint = new Disjoint(nodeMap.length + 1);\n        for (Edge edge : edges) {\n            if (edge == exculdEdge) continue;\n            if (disjoint.isSame(edge.s, edge.t)) {\n                return false;\n            }\n            disjoint.join(edge.s, edge.t);\n        }\n        return true;\n    }\n    public static Edge getRemoveEdge(List<Edge> edges, Node[] nodeMap) {\n        Disjoint disjoint = new Disjoint(nodeMap.length);\n        for (Edge edge : edges) {\n            if (disjoint.isSame(edge.s, edge.t)) return edge;\n            disjoint.join(edge.s, edge.t);\n        }\n        return null;\n    }\n}",
          "description": "Java实现的冗余连接II问题解决方案"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\nfather = list()\ndef find(u):\n    if u == father[u]:\n        return u\n    else:\n        father[u] = find(father[u])\n        return father[u]\ndef is_same(u, v):\n    u = find(u)\n    v = find(v)\n    return u == v\ndef join(u, v):\n    u = find(u)\n    v = find(v)\n    if u != v:\n        father[u] = v\ndef is_tree_after_remove_edge(edges, edge, n):\n    global father \n    father = [i for i in range(n + 1)]\n    for i in range(len(edges)):\n        if i == edge:\n            continue\n        s, t = edges[i]\n        if is_same(s, t): \n            return False\n        else: \n            join(s, t)\n    return True\ndef get_remove_edge(edges):\n    global father\n    father = [i for i in range(n + 1)]\n    for s, t in edges:\n        if is_same(s, t):\n            print(s, t)\n            return\n        else:\n            join(s, t)\nif __name__ == \"__main__\":\n    n = int(input())\n    edges = list()\n    in_degree = defaultdict(int)\n    for i in range(n):\n        s, t = map(int, input().split())\n        in_degree[t] += 1\n        edges.append([s, t])\n    vec = list()\n    for i in range(n - 1, -1, -1):\n        if in_degree[edges[i][1]] == 2:\n            vec.append(i)\n    if len(vec) > 0:\n        if is_tree_after_remove_edge(edges, vec[0], n):\n            print(edges[vec[0]][0], edges[vec[0]][1])\n        else:\n            print(edges[vec[1]][0], edges[vec[1]][1])\n    else:\n        get_remove_edge(edges)",
          "description": "Python实现的冗余连接II问题解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Disjoint {\n        private final int[] father;\n\n        public Disjoint(int n) {\n            father = new int[n];\n            for (int i = 0; i < n; i++) {\n                father[i] = i;\n            }\n        }\n\n        public void join(int n, int m) {\n            n = find(n);\n            m = find(m);\n            if (n == m) return;\n            father[n] = m;\n        }\n\n        public int find(int n) {\n            return father[n] == n ? n : (father[n] = find(father[n]));\n        }\n\n        public boolean isSame(int n, int m) {\n            return find(n) == find(m);\n        }\n    }\n\n    static class Edge {\n        int s;\n        int t;\n\n        public Edge(int s, int t) {\n            this.s = s;\n            this.t = t;\n        }\n    }\n\n    static class Node {\n        int id;\n        int in;\n        int out;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Edge> edges = new ArrayList<>();\n        Node[] nodeMap = new Node[n + 1];\n        for (int i = 1; i <= n; i++) {\n            nodeMap[i] = new Node();\n        }\n        Integer doubleIn = null;\n        for (int i = 0; i < n; i++) {\n            int s = scanner.nextInt();\n            int t = scanner.nextInt();\n            nodeMap[t].in++;\n            if (!(nodeMap[t].in < 2)) doubleIn = t;\n            Edge edge = new Edge(s, t);\n            edges.add(edge);\n        }\n        Edge result = null;\n        if (doubleIn != null) {\n            List<Edge> doubleInEdges = new ArrayList<>();\n            for (Edge edge : edges) {\n                if (edge.t == doubleIn) doubleInEdges.add(edge);\n                if (doubleInEdges.size() == 2) break;\n            }\n            Edge edge = doubleInEdges.get(1);\n            if (isTreeWithExclude(edges, edge, nodeMap)) {\n                result = edge;\n            } else {\n                result = doubleInEdges.get(0);\n            }\n        } else {\n            result = getRemoveEdge(edges, nodeMap);\n        }\n\n        System.out.println(result.s + \" \" + result.t);\n    }\n\n    public static boolean isTreeWithExclude(List<Edge> edges, Edge exculdEdge, Node[] nodeMap) {\n        Disjoint disjoint = new Disjoint(nodeMap.length + 1);\n        for (Edge edge : edges) {\n            if (edge == exculdEdge) continue;\n            if (disjoint.isSame(edge.s, edge.t)) {\n                return false;\n            }\n            disjoint.join(edge.s, edge.t);\n        }\n        return true;\n    }\n\n    public static Edge getRemoveEdge(List<Edge> edges, Node[] nodeMap) {\n        Disjoint disjoint = new Disjoint(nodeMap.length);\n        for (Edge edge : edges) {\n            if (disjoint.isSame(edge.s, edge.t)) return edge;\n            disjoint.join(edge.s, edge.t);\n        }\n        return null;\n    }\n}",
          "description": "Java实现的冗余连接II问题，利用并查集解决有向图中删除一条边使其成为有向树的问题。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n;\nvector<int> father (1001, 0);\nvoid init() {\n    for (int i = 1; i <= n; ++i) {\n        father[i] = i;\n    }\n}\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\nvoid join(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return ;\n    father[v] = u;\n}\nbool same(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\nvoid getRemoveEdge(const vector<vector<int>>& edges) {\n    init();\n    for (int i = 0; i < n; i++) {\n        if (same(edges[i][0], edges[i][1])) {\n            cout << edges[i][0] << \" \" << edges[i][1];\n            return;\n        } else {\n            join(edges[i][0], edges[i][1]);\n        }\n    }\n}\nbool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {\n    init();\n    for (int i = 0; i < n; i++) {\n        if (i == deleteEdge) continue;\n        if (same(edges[i][0], edges[i][1])) {\n            return false;\n        }\n        join(edges[i][0], edges[i][1]);\n    }\n    return true;\n}\nint main() {\n    int s, t;\n    vector<vector<int>> edges;\n    cin >> n;\n    vector<int> inDegree(n + 1, 0);\n    for (int i = 0; i < n; i++) {\n        cin >> s >> t;\n        inDegree[t]++;\n        edges.push_back({s, t});\n    }\n    vector<int> vec;\n    for (int i = n - 1; i >= 0; i--) {\n        if (inDegree[edges[i][1]] == 2) {\n            vec.push_back(i);\n        }\n    }\n    if (vec.size() > 0) {\n        if (isTreeAfterRemoveEdge(edges, vec[0])) {\n            cout << edges[vec[0]][0] << \" \" << edges[vec[0]][1];\n        } else {\n            cout << edges[vec[1]][0] << \" \" << edges[vec[1]][1];\n        }\n        return 0;\n    }\n    getRemoveEdge(edges);\n}",
          "description": "C++实现的冗余连接II问题，通过并查集来判断删除哪条边可以使有向图变为有向树。"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\n\nfather = list()\n\ndef find(u):\n    if u == father[u]:\n        return u\n    else:\n        father[u] = find(father[u])\n        return father[u]\n\ndef is_same(u, v):\n    u = find(u)\n    v = find(v)\n    return u == v\ndef join(u, v):\n    u = find(u)\n    v = find(v)\n    if u != v:\n        father[u] = v\ndef is_tree_after_remove_edge(edges, edge, n):\n    global father \n    father = [i for i in range(n + 1)]\n    for i in range(len(edges)):\n        if i == edge:\n            continue\n        s, t = edges[i]\n        if is_same(s, t): \n            return False\n        else: \n            join(s, t)\n    return True\ndef get_remove_edge(edges):\n    global father\n    father = [i for i in range(n + 1)]\n    for s, t in edges:\n        if is_same(s, t):\n            print(s, t)\n            return\n        else:\n            join(s, t)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    edges = list()\n    in_degree = defaultdict(int)\n    for i in range(n):\n        s, t = map(int, input().split())\n        in_degree[t] += 1\n        edges.append([s, t])\n    vec = list()\n    for i in range(n - 1, -1, -1):\n        if in_degree[edges[i][1]] == 2:\n            vec.append(i)\n    if len(vec) > 0:\n        if is_tree_after_remove_edge(edges, vec[0], n):\n            print(edges[vec[0]][0], edges[vec[0]][1])\n        else:\n            print(edges[vec[1]][0], edges[vec[1]][1])\n    else:\n        get_remove_edge(edges)",
          "description": "Python版本的冗余连接II解法，使用了并查集算法来确定需要移除的边以形成一个有向树。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "import java.util.*;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n;\nvector<int> father (1001, 0);\nvoid init() {\n    for (int i = 1; i <= n; ++i) {\n        father[i] = i;\n    }\n}\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\nvoid join(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return ;\n    father[v] = u;\n}\nbool same(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\nvoid getRemoveEdge(const vector<vector<int>>& edges) {\n    init();\n    for (int i = 0; i < n; i++) {\n        if (same(edges[i][0], edges[i][1])) {\n            cout << edges[i][0] << \" \" << edges[i][1];\n            return;\n        } else {\n            join(edges[i][0], edges[i][1]);\n        }\n    }\n}\nbool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {\n    init();\n    for (int i = 0; i < n; i++) {\n        if (i == deleteEdge) continue;\n        if (same(edges[i][0], edges[i][1])) {\n            return false;\n        }\n        join(edges[i][0], edges[i][1]);\n    }\n    return true;\n}\nint main() {\n    int s, t;\n    vector<vector<int>> edges;\n    cin >> n;\n    vector<int> inDegree(n + 1, 0);\n    for (int i = 0; i < n; i++) {\n        cin >> s >> t;\n        inDegree[t]++;\n        edges.push_back({s, t});\n    }\n\n    vector<int> vec;\n    for (int i = n - 1; i >= 0; i--) {\n        if (inDegree[edges[i][1]] == 2) {\n            vec.push_back(i);\n        }\n    }\n    if (vec.size() > 0) {\n        if (isTreeAfterRemoveEdge(edges, vec[0])) {\n            cout << edges[vec[0]][0] << \" \" << edges[vec[0]][1];\n        } else {\n            cout << edges[vec[1]][0] << \" \" << edges[vec[1]][1];\n        }\n        return 0;\n    }\n    getRemoveEdge(edges);\n}",
          "description": "C++代码实现，通过并查集判断删除哪条边后图可以成为有向树。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    static class Disjoint {\n        private final int[] father;\n        public Disjoint(int n) {\n            father = new int[n];\n            for (int i = 0; i < n; i++) {\n                father[i] = i;\n            }\n        }\n        public void join(int n, int m) {\n            n = find(n);\n            m = find(m);\n            if (n == m) return;\n            father[n] = m;\n        }\n        public int find(int n) {\n            return father[n] == n ? n : (father[n] = find(father[n]));\n        }\n        public boolean isSame(int n, int m) {\n            return find(n) == find(m);\n        }\n    }\n    static class Edge {\n        int s;\n        int t;\n        public Edge(int s, int t) {\n            this.s = s;\n            this.t = t;\n        }\n    }\n    static class Node {\n        int id;\n        int in;\n        int out;\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Edge> edges = new ArrayList<>();\n        Node[] nodeMap = new Node[n + 1];\n        for (int i = 1; i <= n; i++) {\n            nodeMap[i] = new Node();\n        }\n        Integer doubleIn = null;\n        for (int i = 0; i < n; i++) {\n            int s = scanner.nextInt();\n            int t = scanner.nextInt();\n            nodeMap[t].in++;\n            if (!(nodeMap[t].in < 2)) doubleIn = t;\n            Edge edge = new Edge(s, t);\n            edges.add(edge);\n        }\n        Edge result = null;\n        if (doubleIn != null) {\n            List<Edge> doubleInEdges = new ArrayList<>();\n            for (Edge edge : edges) {\n                if (edge.t == doubleIn) doubleInEdges.add(edge);\n                if (doubleInEdges.size() == 2) break;\n            }\n            Edge edge = doubleInEdges.get(1);\n            if (isTreeWithExclude(edges, edge, nodeMap)) {\n                result = edge;\n            } else {\n                result = doubleInEdges.get(0);\n            }\n        } else {\n            result = getRemoveEdge(edges, nodeMap);\n        }\n        System.out.println(result.s + \" \" + result.t);\n    }\n    public static boolean isTreeWithExclude(List<Edge> edges, Edge exculdEdge, Node[] nodeMap) {\n        Disjoint disjoint = new Disjoint(nodeMap.length + 1);\n        for (Edge edge : edges) {\n            if (edge == exculdEdge) continue;\n            if (disjoint.isSame(edge.s, edge.t)) {\n                return false;\n            }\n            disjoint.join(edge.s, edge.t);\n        }\n        return true;\n    }\n    public static Edge getRemoveEdge(List<Edge> edges, Node[] nodeMap) {\n        Disjoint disjoint = new Disjoint(nodeMap.length);\n        for (Edge edge : edges) {\n            if (disjoint.isSame(edge.s, edge.t)) return edge;\n            disjoint.join(edge.s, edge.t);\n        }\n        return null;\n    }\n}",
          "description": "Java代码实现，通过并查集和辅助类来处理有向图中的冗余连接问题。"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\nfather = list()\ndef find(u):\n    if u == father[u]:\n        return u\n    else:\n        father[u] = find(father[u])\n        return father[u]\ndef is_same(u, v):\n    u = find(u)\n    v = find(v)\n    return u == v\ndef join(u, v):\n    u = find(u)\n    v = find(v)\n    if u != v:\n        father[u] = v\ndef is_tree_after_remove_edge(edges, edge, n):\n    global father\n    father = [i for i in range(n + 1)]\n    for i in range(len(edges)):\n        if i == edge:\n            continue\n        s, t = edges[i]\n        if is_same(s, t):\n            return False\n        else:\n            join(s, t)\n    return True\ndef get_remove_edge(edges):\n    global father\n    father = [i for i in range(n + 1)]\n    for s, t in edges:\n        if is_same(s, t):\n            print(s, t)\n            return\n        else:\n            join(s, t)\nif __name__ == \"__main__\":\n    n = int(input())\n    edges = list()\n    in_degree = defaultdict(int)\n    for i in range(n):\n        s, t = map(int, input().split())\n        in_degree[t] += 1\n        edges.append([s, t])\n    vec = list()\n    for i in range(n - 1, -1, -1):\n        if in_degree[edges[i][1]] == 2:\n            vec.append(i)\n    if len(vec) > 0:\n        if is_tree_after_remove_edge(edges, vec[0], n):\n            print(edges[vec[0]][0], edges[vec[0]][1])\n        else:\n            print(edges[vec[1]][0], edges[vec[1]][1])\n    else:\n        get_remove_edge(edges)",
          "description": "Python代码实现，利用字典和列表等数据结构以及并查集算法解决题目要求的问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "from collections import defaultdict",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n;\nvector<int> father (1001, 0);\n// 并查集初始化\nvoid init() {\n    for (int i = 1; i <= n; ++i) {\n        father[i] = i;\n    }\n}\n// 并查集里寻根的过程\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\n// 将v->u 这条边加入并查集\nvoid join(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return ;\n    father[v] = u;\n}\n// 判断 u 和 v是否找到同一个根\nbool same(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\n\n// 在有向图里找到删除的那条边，使其变成树\nvoid getRemoveEdge(const vector<vector<int>>& edges) {\n    init(); // 初始化并查集\n    for (int i = 0; i < n; i++) { // 遍历所有的边\n        if (same(edges[i][0], edges[i][1])) { // 构成有向环了，就是要删除的边\n            cout << edges[i][0] << \" \" << edges[i][1];\n            return;\n        } else {\n            join(edges[i][0], edges[i][1]);\n        }\n    }\n}\n\n// 删一条边之后判断是不是树\nbool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {\n    init(); // 初始化并查集\n    for (int i = 0; i < n; i++) {\n        if (i == deleteEdge) continue;\n        if (same(edges[i][0], edges[i][1])) { // 构成有向环了，一定不是树\n            return false;\n        }\n        join(edges[i][0], edges[i][1]);\n    }\n    return true;\n}\n\nint main() {\n    int s, t;\n    vector<vector<int>> edges;\n    cin >> n;\n    vector<int> inDegree(n + 1, 0); // 记录节点入度\n    for (int i = 0; i < n; i++) {\n        cin >> s >> t;\n        inDegree[t]++;\n        edges.push_back({s, t});\n    }\n\n    vector<int> vec; // 记录入度为2的边（如果有的话就两条边）\n    // 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边\n    for (int i = n - 1; i >= 0; i--) {\n        if (inDegree[edges[i][1]] == 2) {\n            vec.push_back(i);\n        }\n    }\n    // 情况一、情况二\n    if (vec.size() > 0) {\n        // 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边\n        if (isTreeAfterRemoveEdge(edges, vec[0])) {\n            cout << edges[vec[0]][0] << \" \" << edges[vec[0]][1];\n        } else {\n            cout << edges[vec[1]][0] << \" \" << edges[vec[1]][1];\n        }\n        return 0;\n    }\n\n    // 处理情况三\n    // 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了\n    getRemoveEdge(edges);\n}",
          "description": "C++版本的冗余连接II解决方案"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\n/* \n * 冗余连接II。主要问题是存在入度为2或者成环，也可能两个问题同时存在。\n * 1.判断入度为2的边 \n * 2.判断是否成环（并查集）\n */\n\npublic class Main {\n    static class Disjoint {\n\n        private final int[] father;\n\n        public Disjoint(int n) {\n            father = new int[n];\n            for (int i = 0; i < n; i++) {\n                father[i] = i;\n            }\n        }\n\n        public void join(int n, int m) {\n            n = find(n);\n            m = find(m);\n            if (n == m) return;\n            father[n] = m;\n        }\n\n        public int find(int n) {\n            return father[n] == n ? n : (father[n] = find(father[n]));\n        }\n\n        public boolean isSame(int n, int m) {\n            return find(n) == find(m);\n        }\n    }\n\n    static class Edge {\n        int s;\n        int t;\n\n        public Edge(int s, int t) {\n            this.s = s;\n            this.t = t;\n        }\n    }\n\n    static class Node {\n        int id;\n        int in;\n        int out;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Edge> edges = new ArrayList<>();\n        Node[] nodeMap = new Node[n + 1];\n        for (int i = 1; i <= n; i++) {\n            nodeMap[i] = new Node();\n        }\n        Integer doubleIn = null;\n        for (int i = 0; i < n; i++) {\n            int s = scanner.nextInt();\n            int t = scanner.nextInt();\n            //记录入度\n            nodeMap[t].in++;\n            if (!(nodeMap[t].in < 2)) doubleIn = t;\n            Edge edge = new Edge(s, t);\n            edges.add(edge);\n        }\n        Edge result = null;\n        //存在入度为2的节点，既要消除入度为2的问题同时解除可能存在的环\n        if (doubleIn != null) {\n            List<Edge> doubleInEdges = new ArrayList<>();\n            for (Edge edge : edges) {\n                if (edge.t == doubleIn) doubleInEdges.add(edge);\n                if (doubleInEdges.size() == 2) break;\n            }\n            Edge edge = doubleInEdges.get(1);\n            if (isTreeWithExclude(edges, edge, nodeMap)) {\n                result = edge;\n            } else {\n                result = doubleInEdges.get(0);\n            }\n        } else {\n            //不存在入度为2的节点,则只需要解除环即可\n            result = getRemoveEdge(edges, nodeMap);\n        }\n\n        System.out.println(result.s + \" \" + result.t);\n    }\n\n    public static boolean isTreeWithExclude(List<Edge> edges, Edge exculdEdge, Node[] nodeMap) {\n        Disjoint disjoint = new Disjoint(nodeMap.length + 1);\n        for (Edge edge : edges) {\n            if (edge == exculdEdge) continue;\n            //成环则不是树\n            if (disjoint.isSame(edge.s, edge.t)) {\n                return false;\n            }\n            disjoint.join(edge.s, edge.t);\n        }\n        return true;\n    }\n\n    public static Edge getRemoveEdge(List<Edge> edges, Node[] nodeMap) {\n        int length = nodeMap.length;\n        Disjoint disjoint = new Disjoint(length);\n\n        for (Edge edge : edges) {\n            if (disjoint.isSame(edge.s, edge.t)) return edge;\n            disjoint.join(edge.s, edge.t);\n        }\n        return null;\n    }\n\n}",
          "description": "Java版本的冗余连接II解决方案"
        },
        {
          "language": "python",
          "code": "from collections import defaultdict\n\nfather = list()\n\ndef find(u):\n    if u == father[u]:\n        return u\n    else:\n        father[u] = find(father[u])\n        return father[u]\n\n\ndef is_same(u, v):\n    u = find(u)\n    v = find(v)\n    return u == v\n\n\ndef join(u, v):\n    u = find(u)\n    v = find(v)\n    if u != v:\n        father[u] = v\n\n\ndef is_tree_after_remove_edge(edges, edge, n):\n    # 初始化并查集\n    global father \n    father = [i for i in range(n + 1)]\n\n    for i in range(len(edges)):\n        if i == edge:\n            continue\n        s, t = edges[i]\n        if is_same(s, t): # 成環，即不是有向樹\n            return False\n        else: # 將s,t放入集合中\n            join(s, t)\n    return True\n\n\ndef get_remove_edge(edges):\n    # 初始化并查集\n    global father\n    father = [i for i in range(n + 1)]\n\n    for s, t in edges:\n        if is_same(s, t):\n            print(s, t)\n            return\n        else:\n            join(s, t)\n\n\nif __name__ == \"__main__\":\n    # 輸入\n    n = int(input())\n    edges = list()\n    in_degree = defaultdict(int)\n\n    for i in range(n):\n        s, t = map(int, input().split())\n        in_degree[t] += 1\n        edges.append([s, t])\n\n    # 尋找入度為2的邊，並紀錄其下標(index)\n    vec = list()\n    for i in range(n - 1, -1, -1):\n        if in_degree[edges[i][1]] == 2:\n            vec.append(i)\n\n    # 輸出\n    if len(vec) > 0:\n        # 情況一：刪除輸出順序靠後的邊 \n        if is_tree_after_remove_edge(edges, vec[0], n):\n            print(edges[vec[0]][0], edges[vec[0]][1])\n        # 情況二：只能刪除特定的邊\n        else:\n            print(edges[vec[1]][0], edges[vec[1]][1])\n    else:\n        # 情況三： 原圖有環\n        get_remove_edge(edges)",
          "description": "Python版本的冗余连接II解决方案"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint n;\nvector<int> father (1001, 0);\nvoid init() {\n    for (int i = 1; i <= n; ++i) {\n        father[i] = i;\n    }\n}\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\nvoid join(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return ;\n    father[v] = u;\n}\nbool same(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\nvoid getRemoveEdge(const vector<vector<int>>& edges) {\n    init();\n    for (int i = 0; i < n; i++) {\n        if (same(edges[i][0], edges[i][1])) {\n            cout << edges[i][0] << \" \" << edges[i][1];\n            return;\n        } else {\n            join(edges[i][0], edges[i][1]);\n        }\n    }\n}\nbool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {\n    init();\n    for (int i = 0; i < n; i++) {\n        if (i == deleteEdge) continue;\n        if (same(edges[i][0], edges[i][1])) {\n            return false;\n        }\n        join(edges[i][0], edges[i][1]);\n    }\n    return true;\n}\nint main() {\n    int s, t;\n    vector<vector<int>> edges;\n    cin >> n;\n    vector<int> inDegree(n + 1, 0);\n    for (int i = 0; i < n; i++) {\n        cin >> s >> t;\n        inDegree[t]++;\n        edges.push_back({s, t});\n    }\n    vector<int> vec;\n    for (int i = n - 1; i >= 0; i--) {\n        if (inDegree[edges[i][1]] == 2) {\n            vec.push_back(i);\n        }\n    }\n    if (vec.size() > 0) {\n        if (isTreeAfterRemoveEdge(edges, vec[0])) {\n            cout << edges[vec[0]][0] << \" \" << edges[vec[0]][1];\n        } else {\n            cout << edges[vec[1]][0] << \" \" << edges[vec[1]][1];\n        }\n        return 0;\n    }\n    getRemoveEdge(edges);\n}",
      "description": "C++实现的解决冗余连接II问题的代码，使用了并查集来判断和处理图中的环以及入度为2的情况。"
    },
    {
      "language": "java",
      "code": "import java.util.*;\npublic class Main {\nstatic class Disjoint {\nprivate final int[] father;\npublic Disjoint(int n) {\n    father = new int[n];\n    for (int i = 0; i < n; i++) {\n        father[i] = i;\n    }\n}\npublic void join(int n, int m) {\n    n = find(n);\n    m = find(m);\n    if (n == m) return;\n    father[n] = m;\n}\npublic int find(int n) {\n    return father[n] == n ? n : (father[n] = find(father[n]));\n}\npublic boolean isSame(int n, int m) {\n    return find(n) == find(m);\n}\n}\nstatic class Edge {\nint s;\nint t;\npublic Edge(int s, int t) {\n    this.s = s;\n    this.t = t;\n}\n}\nstatic class Node {\nint id;\nint in;\nint out;\n}\npublic static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    int n = scanner.nextInt();\n    List<Edge> edges = new ArrayList<>();\n    Node[] nodeMap = new Node[n + 1];\n    for (int i = 1; i <= n; i++) {\n        nodeMap[i] = new Node();\n    }\n    Integer doubleIn = null;\n    for (int i = 0; i < n; i++) {\n        int s = scanner.nextInt();\n        int t = scanner.nextInt();\n        nodeMap[t].in++;\n        if (!(nodeMap[t].in < 2)) doubleIn = t;\n        Edge edge = new Edge(s, t);\n        edges.add(edge);\n    }\n    Edge result = null;\n    if (doubleIn != null) {\n        List<Edge> doubleInEdges = new ArrayList<>();\n        for (Edge edge : edges) {\n            if (edge.t == doubleIn) doubleInEdges.add(edge);\n            if (doubleInEdges.size() == 2) break;\n        }\n        Edge edge = doubleInEdges.get(1);\n        if (isTreeWithExclude(edges, edge, nodeMap)) {\n            result = edge;\n        } else {\n            result = doubleInEdges.get(0);\n        }\n    } else {\n        result = getRemoveEdge(edges, nodeMap);\n    }\n    System.out.println(result.s + \" \" + result.t);\n}\npublic static boolean isTreeWithExclude(List<Edge> edges, Edge exculdEdge, Node[] nodeMap) {\n    Disjoint disjoint = new Disjoint(nodeMap.length + 1);\n    for (Edge edge : edges) {\n        if (edge == exculdEdge) continue;\n        if (disjoint.isSame(edge.s, edge.t)) {\n            return false;\n        }\n        disjoint.join(edge.s, edge.t);\n    }\n    return true;\n}\npublic static Edge getRemoveEdge(List<Edge> edges, Node[] nodeMap) {\n    int length = nodeMap.length;\n    Disjoint disjoint = new Disjoint(length);\n    for (Edge edge : edges) {\n        if (disjoint.isSame(edge.s, edge.t)) return edge;\n        disjoint.join(edge.s, edge.t);\n    }\n    return null;\n}\n}",
      "description": "Java实现的解决冗余连接II问题的代码，通过定义边和节点类，并使用并查集来检测和移除图中的环或处理入度为2的情况。"
    },
    {
      "language": "python",
      "code": "from collections import defaultdict\nfather = list()\ndef find(u):\n    if u == father[u]:\n        return u\n    else:\n        father[u] = find(father[u])\n        return father[u]\ndef is_same(u, v):\n    u = find(u)\n    v = find(v)\n    return u == v\ndef join(u, v):\n    u = find(u)\n    v = find(v)\n    if u != v:\n        father[u] = v\ndef is_tree_after_remove_edge(edges, edge, n):\n    global father \n    father = [i for i in range(n + 1)]\n    for i in range(len(edges)):\n        if i == edge:\n            continue\n        s, t = edges[i]\n        if is_same(s, t):\n            return False\n        else:\n            join(s, t)\n    return True\ndef get_remove_edge(edges):\n    global father\n    father = [i for i in range(n + 1)]\n    for s, t in edges:\n        if is_same(s, t):\n            print(s, t)\n            return\n        else:\n            join(s, t)\nif __name__ == \"__main__\":\n    n = int(input())\n    edges = list()\n    in_degree = defaultdict(int)\n    for i in range(n):\n        s, t = map(int, input().split())\n        in_degree[t] += 1\n        edges.append([s, t])\n    vec = list()\n    for i in range(n - 1, -1, -1):\n        if in_degree[edges[i][1]] == 2:\n            vec.append(i)\n    if len(vec) > 0:\n        if is_tree_after_remove_edge(edges, vec[0], n):\n            print(edges[vec[0]][0], edges[vec[0]][1])\n        else:\n            print(edges[vec[1]][0], edges[vec[1]][1])\n    else:\n        get_remove_edge(edges)",
      "description": "Python实现的解决冗余连接II问题的代码，利用并查集算法来识别和删除构成环的边或者处理入度为2的情况。"
    }
  ],
  "common_mistakes": [
    "忽视了题目中关于‘若有多条边可以删除，请输出标准输入中最后出现的一条边’的要求。",
    "没有正确地使用并查集去检测环的存在与否。",
    "在处理入度为2的情况时，直接删除第一条遇到的边而不是考虑所有可能的边。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240827152106.png",
      "description": "该图展示了一个包含五个节点的有向图，可用于分析图的遍历算法或检测环路。",
      "context": "这张图片展示了题目中描述的一种理想状态下的有向树结构，其中仅有一个根节点，并且除了根节点外的每个节点都恰好有一个父节点。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240827152134.png",
      "description": "该图展示了一个有向图的数据结构，包含五个节点（1至5）及其之间的有向边，可用于图算法分析或路径查找问题。",
      "context": "这张图片展示了一个通过在有向树中两个不直接相连的节点之间添加一条边而形成的有向图示例。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240527112633.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20240527112633.png",
      "context": "该图片展示了通过删除边2到3后，有向图如何转变成一棵合法的有向树的过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240527115807.png",
      "description": "这张图片展示了一个简单的有向图，包含三个节点（1、2、3），体现了图论中的基本数据结构和连接关系。",
      "context": "展示了节点3的入度为2的情况，说明了在存在多条可删除边时应选择删除顺序靠后的边。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240527151456.png",
      "description": "这张图片展示了一个包含四个节点（1、2、3、4）的有向图，体现了图论中的数据结构和算法概念。",
      "context": "该图展示了当节点3的入度为2时，只能删除特定的一条边（即从节点1到节点3的边），以保持图形作为有向树的结构。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240527120531.png",
      "description": "这张图片展示了一个包含四个节点（1、2、3、4）的有向图，体现了图论中的数据结构和算法概念。",
      "context": "该图片展示了在处理有向图以形成有向树时，针对不同情况（如节点入度为2或存在有向环）应如何选择删除边的示例。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240827152106.png",
      "description": "GIF展示了有向树结构及其节点之间的连接关系。",
      "context": "GIF动画展示了构成有向树的节点与边的基本结构，帮助理解题目中所述的有向树模型。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240827152134.png",
      "description": "GIF展示了在有向图中添加一条额外边后形成环的过程，以及如何通过删除某条边来恢复成有向树结构。",
      "context": "该GIF动画展示了在有向树中添加一条额外的有向边后形成的有向图结构，帮助理解题目要求解决的问题背景。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240527112633.png",
      "description": "GIF展示了通过遍历有向图来识别并标记可以删除以形成有向树的冗余边的过程。",
      "context": "GIF动画展示了通过删除特定边将有向图转换为合法的有向树的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240527115807.png",
      "description": "GIF展示了通过删除一条边将包含一个入度为2节点的有向图恢复成有向树的过程。",
      "context": "该GIF动画展示了如何通过删除一条边来修复一个含有入度为2节点的有向图，使其恢复成有向树结构。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240527151456.png",
      "description": "GIF展示了如何在有向图中识别入度为2的节点，并演示了删除特定边以确保剩余结构仍构成有向树的过程。",
      "context": "此GIF展示了当节点3的入度为2时，仅能删除特定边（从节点1到节点3）以保持图结构为有向树的情形。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240527120531.png",
      "description": "GIF展示了检测并移除有向图中形成环的边的过程。",
      "context": "该GIF动画展示了在处理有向图中入度为2的节点时，通过删除特定边来确保最终形成的图为有向树的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\并查集\\冗余连接II.txt",
  "extracted_at": "2025-07-21T21:05:40.672239",
  "raw_content": "冗余连接II\n卡码网题目链接（ACM模式）(https://kamacoder.com/problempage.php?pid=1182)\n\n题目描述\n\n有一种有向树,该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。有向树拥有 n 个节点和 n - 1 条边。如图：\nhttps://file1.kamacoder.com/i/algo/20240827152106.png\n\n现在有一个有向图，有向图是在有向树中的两个没有直接链接的节点中间添加一条有向边。如图：\nhttps://file1.kamacoder.com/i/algo/20240827152134.png\n\n输入一个有向图，该图由一个有着 n 个节点(节点编号 从 1 到 n)，n 条边，请返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。\n\n输入描述\n\n第一行输入一个整数 N，表示有向图中节点和边的个数。\n\n后续 N 行，每行输入两个整数 s 和 t，代表这是 s 节点连接并指向 t 节点的单向边\n\n输出描述\n\n输出一条可以删除的边，若有多条边可以删除，请输出标准输入中最后出现的一条边。\n\n输入示例\n\n3\n1 2\n1 3\n2 3\n输出示例\n\n2 3\n\n提示信息\nhttps://file1.kamacoder.com/i/algo/20240527112633.png\n\n在删除 2 3 后有向图可以变为一棵合法的有向树，所以输出 2 3\n\n数据范围：\n\n1 <= N <= 1000.\n\n#思路\n本题与 108.冗余连接（https://programmercarl.com/kamacoder/0108.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html） 类似，但本题是一个有向图，有向图相对要复杂一些。\n\n本题的本质是 ：有一个有向图，是由一颗有向树 + 一条有向边组成的 （所以此时这个图就不能称之为有向树），现在让我们找到那条边 把这条边删了，让这个图恢复为有向树。\n\n还有“若有多条边可以删除，请输出标准输入中最后出现的一条边”，这说明在两条边都可以删除的情况下，要删顺序靠后的边！\n\n我们来想一下 有向树的性质，如果是有向树的话，只有根节点入度为0，其他节点入度都为1（因为该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点）。\n\n所以情况一：如果我们找到入度为2的点，那么删一条指向该节点的边就行了。\n\n如图：\n\nhttps://file1.kamacoder.com/i/algo/20240527115807.png\n\n找到了节点3 的入度为2，删 1 -> 3 或者 2 -> 3 。选择删顺序靠后便可。\n\n但 入度为2 还有一种情况，情况二，只能删特定的一条边，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240527151456.png\n\n节点3 的入度为 2，但在删除边的时候，只能删 这条边（节点1 -> 节点3），如果删这条边（节点4 -> 节点3），那么删后本图也不是有向树了（因为找不到根节点）。\n\n综上，如果发现入度为2的节点，我们需要判断 删除哪一条边，删除后本图能成为有向树。如果是删哪个都可以，优先删顺序靠后的边。\n\n情况三： 如果没有入度为2的点，说明 图中有环了（注意是有向环）。\n\n如图：\n\nhttps://file1.kamacoder.com/i/algo/20240527120531.png\n\n对于情况三，删掉构成环的边就可以了。\n\n#写代码\n把每条边记录下来，并统计节点入度：\n\n    int s, t;\n    vector<vector<int>> edges;\n    cin >> n;\n    vector<int> inDegree(n + 1, 0); // 记录节点入度\n    for (int i = 0; i < n; i++) {\n        cin >> s >> t;\n        inDegree[t]++;\n        edges.push_back({s, t});\n    }\n\n\n前两种入度为2的情况，一定是删除指向入度为2的节点的两条边其中的一条，如果删了一条，判断这个图是一个树，那么这条边就是答案。\n\n同时注意要从后向前遍历，因为如果两条边删哪一条都可以成为树，就删最后那一条。\n\n代码如下：\n\nvector<int> vec; // 记录入度为2的边（如果有的话就两条边）\n// 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边\nfor (int i = n - 1; i >= 0; i--) {\n    if (inDegree[edges[i][1]] == 2) {\n        vec.push_back(i);\n    }\n}\nif (vec.size() > 0) {\n    // 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边\n    if (isTreeAfterRemoveEdge(edges, vec[0])) {\n        cout << edges[vec[0]][0] << \" \" << edges[vec[0]][1];\n    } else {\n        cout << edges[vec[1]][0] << \" \" << edges[vec[1]][1];\n    }\n    return 0;\n}\n再来看情况三，明确没有入度为2的情况，那么一定有向环，找到构成环的边就是要删除的边。\n\n可以定义一个函数，代码如下：\n\n// 在有向图里找到删除的那条边，使其变成树 \nvoid getRemoveEdge(const vector<vector<int>>& edges)\n大家应该知道了，我们要解决本题要实现两个最为关键的函数：\n\nisTreeAfterRemoveEdge() 判断删一个边之后是不是有向树\ngetRemoveEdge() 确定图中一定有了有向环，那么要找到需要删除的那条边\n此时就用到并查集了。\n\n如果还不了解并查集，可以看这里：并查集理论基础(https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)\n\nisTreeAfterRemoveEdge() 判断删一个边之后是不是有向树： 将所有边的两端节点分别加入并查集，遇到要 要删除的边则跳过，如果遇到即将加入并查集的边的两端节点 本来就在并查集了，说明构成了环。\n\n如果顺利将所有边的两端节点（除了要删除的边）加入了并查集，则说明 删除该条边 还是一个有向树\n\ngetRemoveEdge()确定图中一定有了有向环，那么要找到需要删除的那条边： 将所有边的两端节点分别加入并查集，如果遇到即将加入并查集的边的两端节点 本来就在并查集了，说明构成了环。\n\n本题C++代码如下：（详细注释了）\n\n#include <iostream>\n#include <vector>\nusing namespace std;\nint n;\nvector<int> father (1001, 0);\n// 并查集初始化\nvoid init() {\n    for (int i = 1; i <= n; ++i) {\n        father[i] = i;\n    }\n}\n// 并查集里寻根的过程\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\n// 将v->u 这条边加入并查集\nvoid join(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return ;\n    father[v] = u;\n}\n// 判断 u 和 v是否找到同一个根\nbool same(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\n\n// 在有向图里找到删除的那条边，使其变成树\nvoid getRemoveEdge(const vector<vector<int>>& edges) {\n    init(); // 初始化并查集\n    for (int i = 0; i < n; i++) { // 遍历所有的边\n        if (same(edges[i][0], edges[i][1])) { // 构成有向环了，就是要删除的边\n            cout << edges[i][0] << \" \" << edges[i][1];\n            return;\n        } else {\n            join(edges[i][0], edges[i][1]);\n        }\n    }\n}\n\n// 删一条边之后判断是不是树\nbool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {\n    init(); // 初始化并查集\n    for (int i = 0; i < n; i++) {\n        if (i == deleteEdge) continue;\n        if (same(edges[i][0], edges[i][1])) { // 构成有向环了，一定不是树\n            return false;\n        }\n        join(edges[i][0], edges[i][1]);\n    }\n    return true;\n}\n\nint main() {\n    int s, t;\n    vector<vector<int>> edges;\n    cin >> n;\n    vector<int> inDegree(n + 1, 0); // 记录节点入度\n    for (int i = 0; i < n; i++) {\n        cin >> s >> t;\n        inDegree[t]++;\n        edges.push_back({s, t});\n    }\n\n    vector<int> vec; // 记录入度为2的边（如果有的话就两条边）\n    // 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边\n    for (int i = n - 1; i >= 0; i--) {\n        if (inDegree[edges[i][1]] == 2) {\n            vec.push_back(i);\n        }\n    }\n    // 情况一、情况二\n    if (vec.size() > 0) {\n        // 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边\n        if (isTreeAfterRemoveEdge(edges, vec[0])) {\n            cout << edges[vec[0]][0] << \" \" << edges[vec[0]][1];\n        } else {\n            cout << edges[vec[1]][0] << \" \" << edges[vec[1]][1];\n        }\n        return 0;\n    }\n\n    // 处理情况三\n    // 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了\n    getRemoveEdge(edges);\n}\n#其他语言版本\n#Java\nimport java.util.*;\n\n/* \n * 冗余连接II。主要问题是存在入度为2或者成环，也可能两个问题同时存在。\n * 1.判断入度为2的边 \n * 2.判断是否成环（并查集）\n */\n \npublic class Main {\n    /**\n     * 并查集模板\n     */\n    static class Disjoint {\n\n        private final int[] father;\n\n        public Disjoint(int n) {\n            father = new int[n];\n            for (int i = 0; i < n; i++) {\n                father[i] = i;\n            }\n        }\n\n        public void join(int n, int m) {\n            n = find(n);\n            m = find(m);\n            if (n == m) return;\n            father[n] = m;\n        }\n\n        public int find(int n) {\n            return father[n] == n ? n : (father[n] = find(father[n]));\n        }\n\n        public boolean isSame(int n, int m) {\n            return find(n) == find(m);\n        }\n    }\n\n    static class Edge {\n        int s;\n        int t;\n\n        public Edge(int s, int t) {\n            this.s = s;\n            this.t = t;\n        }\n    }\n\n    static class Node {\n        int id;\n        int in;\n        int out;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Edge> edges = new ArrayList<>();\n        Node[] nodeMap = new Node[n + 1];\n        for (int i = 1; i <= n; i++) {\n            nodeMap[i] = new Node();\n        }\n        Integer doubleIn = null;\n        for (int i = 0; i < n; i++) {\n            int s = scanner.nextInt();\n            int t = scanner.nextInt();\n            //记录入度\n            nodeMap[t].in++;\n            if (!(nodeMap[t].in < 2)) doubleIn = t;\n            Edge edge = new Edge(s, t);\n            edges.add(edge);\n        }\n        Edge result = null;\n        //存在入度为2的节点，既要消除入度为2的问题同时解除可能存在的环\n        if (doubleIn != null) {\n            List<Edge> doubleInEdges = new ArrayList<>();\n            for (Edge edge : edges) {\n                if (edge.t == doubleIn) doubleInEdges.add(edge);\n                if (doubleInEdges.size() == 2) break;\n            }\n            Edge edge = doubleInEdges.get(1);\n            if (isTreeWithExclude(edges, edge, nodeMap)) {\n                result = edge;\n            } else {\n                result = doubleInEdges.get(0);\n            }\n        } else {\n            //不存在入度为2的节点,则只需要解除环即可\n            result = getRemoveEdge(edges, nodeMap);\n        }\n\n        System.out.println(result.s + \" \" + result.t);\n    }\n\n    public static boolean isTreeWithExclude(List<Edge> edges, Edge exculdEdge, Node[] nodeMap) {\n        Disjoint disjoint = new Disjoint(nodeMap.length + 1);\n        for (Edge edge : edges) {\n            if (edge == exculdEdge) continue;\n            //成环则不是树\n            if (disjoint.isSame(edge.s, edge.t)) {\n                return false;\n            }\n            disjoint.join(edge.s, edge.t);\n        }\n        return true;\n    }\n\n    public static Edge getRemoveEdge(List<Edge> edges, Node[] nodeMap) {\n        int length = nodeMap.length;\n        Disjoint disjoint = new Disjoint(length);\n\n        for (Edge edge : edges) {\n            if (disjoint.isSame(edge.s, edge.t)) return edge;\n            disjoint.join(edge.s, edge.t);\n        }\n        return null;\n    }\n\n}\n\n#Python\nfrom collections import defaultdict\n\nfather = list()\n\n\ndef find(u):\n    if u == father[u]:\n        return u\n    else:\n        father[u] = find(father[u])\n        return father[u]\n        \n        \ndef is_same(u, v):\n    u = find(u)\n    v = find(v)\n    return u == v\n    \n    \ndef join(u, v):\n    u = find(u)\n    v = find(v)\n    if u != v:\n        father[u] = v\n    \n    \ndef is_tree_after_remove_edge(edges, edge, n):\n    # 初始化并查集\n    global father \n    father = [i for i in range(n + 1)]\n    \n    for i in range(len(edges)):\n        if i == edge:\n            continue\n        s, t = edges[i]\n        if is_same(s, t): # 成環，即不是有向樹\n            return False\n        else: # 將s,t放入集合中\n            join(s, t)\n    return True\n    \n\ndef get_remove_edge(edges):\n    # 初始化并查集\n    global father\n    father = [i for i in range(n + 1)]\n    \n    for s, t in edges:\n        if is_same(s, t):\n            print(s, t)\n            return\n        else:\n            join(s, t)\n        \n\nif __name__ == \"__main__\":\n    # 輸入\n    n = int(input())\n    edges = list()\n    in_degree = defaultdict(int)\n    \n    for i in range(n):\n        s, t = map(int, input().split())\n        in_degree[t] += 1\n        edges.append([s, t])\n        \n    # 尋找入度為2的邊，並紀錄其下標(index)\n    vec = list()\n    for i in range(n - 1, -1, -1):\n        if in_degree[edges[i][1]] == 2:\n            vec.append(i)\n            \n    # 輸出\n    if len(vec) > 0:\n        # 情況一：刪除輸出順序靠後的邊 \n        if is_tree_after_remove_edge(edges, vec[0], n):\n            print(edges[vec[0]][0], edges[vec[0]][1])\n        # 情況二：只能刪除特定的邊\n        else:\n            print(edges[vec[1]][0], edges[vec[1]][1])\n    else:\n        # 情況三： 原圖有環\n        get_remove_edge(edges)"
}