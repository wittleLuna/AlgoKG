{
  "id": "AP_9b6f154d",
  "title": "零钱兑换",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/coin-change/",
  "description": "不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n\n你可以认为每种硬币的数量是无限的。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划",
    "完全背包"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "状态转移",
    "边界条件处理"
  ],
  "difficulty": null,
  "solution_approach": "采用动态规划方法来解决零钱兑换问题。定义dp数组，其中dp[j]表示凑足总额为j所需的最少硬币个数。通过遍历每种硬币和每个金额值，使用递推公式dp[j] = min(dp[j - coins[i]] + 1, dp[j])更新dp数组以找到最小的硬币数量。最终返回dp[amount]作为结果。",
  "key_insights": [
    {
      "content": "这是一个典型的完全背包问题，因为每种硬币的数量是无限的。"
    },
    {
      "content": "dp数组初始化时除了dp[0]=0外，其他元素都设为INT_MAX（或最大整数值），以便在计算过程中能够正确选取最小值。"
    },
    {
      "content": "对于求最少数目的问题，物品与背包的遍历顺序可以互换而不影响结果，因为在本题中不区分组合还是排列。"
    },
    {
      "content": "只有当dp[j - coins[i]]不是初始最大值时才进行状态转移，保证了不会将无效的状态计入结果。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "在动态规划：518.零钱兑换II (https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)中我们已经兑换一次零钱了，这次又要兑换，套路不一样！",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int coinChange(vector<int>& coins, int amount) {vector<int> dp(amount + 1, INT_MAX);dp[0] = 0;for (int i = 0; i < coins.size(); i++) { for (int j = coins[i]; j <= amount; j++) { if (dp[j - coins[i]] != INT_MAX) { dp[j] = min(dp[j - coins[i]] + 1, dp[j]); } }}if (dp[amount] == INT_MAX) return -1;return dp[amount];}};",
          "description": "版本一"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int coinChange(vector<int>& coins, int amount) {vector<int> dp(amount + 1, INT_MAX);dp[0] = 0;for (int i = 1; i <= amount; i++) { for (int j = 0; j < coins.size(); j++) { if (i - coins[j] >= 0 && dp[i - coins[j]] != INT_MAX ) { dp[i] = min(dp[i - coins[j]] + 1, dp[i]); } }}if (dp[amount] == INT_MAX) return -1;return dp[amount];}};",
          "description": "版本二"
        },
        {
          "language": "java",
          "code": "class Solution {public int coinChange(int[] coins, int amount) {int max = Integer.MAX_VALUE;int[] dp = new int[amount + 1];for (int j = 0; j < dp.length; j++) {dp[j] = max;}dp[0] = 0;for (int i = 0; i < coins.length; i++) {for (int j = coins[i]; j <= amount; j++) {if (dp[j - coins[i]] != max) {dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);}}}}return dp[amount] == max ? -1 : dp[amount];}}",
          "description": ""
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for i in range(coin, amount + 1): if dp[i - coin] != float('inf'): dp[i] = min(dp[i - coin] + 1, dp[i]) if dp[amount] == float('inf'): return -1 return dp[amount]",
          "description": "先遍历物品 后遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for j in range(len(coins)): if i - coins[j] >= 0 and dp[i - coins[j]] != float('inf'): dp[i] = min(dp[i - coins[j]] + 1, dp[i]) if dp[amount] == float('inf'): return -1 return dp[amount]",
          "description": "先遍历背包 后遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for i in range(coin, amount + 1): dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1",
          "description": "先遍历物品 后遍历背包（优化版）"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1",
          "description": "先遍历背包 后遍历物品（优化版）"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "细心的同学看网上的题解，可能看一篇是遍历背包的for循环放外面，看一篇又是遍历背包的for循环放里面，看多了都看晕了，到底两个for循环应该是什么先后关系。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int coinChange(vector<int>& coins, int amount) {vector<int> dp(amount + 1, INT_MAX);dp[0] = 0;for (int i = 0; i < coins.size(); i++) {for (int j = coins[i]; j <= amount; j++) {if (dp[j - coins[i]] != INT_MAX) {dp[j] = min(dp[j - coins[i]] + 1, dp[j]);}}}if (dp[amount] == INT_MAX) return -1;return dp[amount];}};",
          "description": "C++版本一：先遍历物品，后遍历背包"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int coinChange(vector<int>& coins, int amount) {vector<int> dp(amount + 1, INT_MAX);dp[0] = 0;for (int i = 1; i <= amount; i++) {for (int j = 0; j < coins.size(); j++) {if (i - coins[j] >= 0 && dp[i - coins[j]] != INT_MAX ) {dp[i] = min(dp[i - coins[j]] + 1, dp[i]);}}}if (dp[amount] == INT_MAX) return -1;return dp[amount];}};",
          "description": "C++版本二：先遍历背包，后遍历物品"
        },
        {
          "language": "java",
          "code": "class Solution {public int coinChange(int[] coins, int amount) {int max = Integer.MAX_VALUE;int[] dp = new int[amount + 1];for (int j = 0; j < dp.length; j++) {dp[j] = max;}dp[0] = 0;for (int i = 0; i < coins.length; i++) {for (int j = coins[i]; j <= amount; j++) {if (dp[j - coins[i]] != max) {dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);}}}return dp[amount] == max ? -1 : dp[amount];}}",
          "description": "Java实现：先遍历物品，后遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for i in range(coin, amount + 1): if dp[i - coin] != float('inf'): dp[i] = min(dp[i - coin] + 1, dp[i]) if dp[amount] == float('inf'): return -1 return dp[amount]",
          "description": "Python实现：先遍历物品，后遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for j in range(len(coins)): if i - coins[j] >= 0 and dp[i - coins[j]] != float('inf'): dp[i] = min(dp[i - coins[j]] + 1, dp[i]) if dp[amount] == float('inf'): return -1 return dp[amount]",
          "description": "Python实现：先遍历背包，后遍历物品"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        int max = Integer.MAX_VALUE;\n        int[] dp = new int[amount + 1];\n        for (int j = 0; j < dp.length; j++) {\n            dp[j] = max;\n        }\n        dp[0] = 0;\n        for (int i = 0; i < coins.length; i++) {\n            for (int j = coins[i]; j <= amount; j++) {\n                if (dp[j - coins[i]] != max) {\n                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);\n                }\n            }\n        }\n        return dp[amount] == max ? -1 : dp[amount];\n    }\n}",
          "description": "Java版本，使用动态规划解决零钱兑换问题。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                if dp[i - coin] != float('inf'):\n                    dp[i] = min(dp[i - coin] + 1, dp[i])\n\n        if dp[amount] == float('inf'):\n            return -1\n        return dp[amount]",
          "description": "Python版本，先遍历物品后遍历背包，解决零钱兑换问题。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for i in range(1, amount + 1):\n            for j in range(len(coins)):\n                if i - coins[j] >= 0 and dp[i - coins[j]] != float('inf'):\n                    dp[i] = min(dp[i - coins[j]] + 1, dp[i])\n\n        if dp[amount] == float('inf'):\n            return -1\n        return dp[amount]",
          "description": "Python版本，先遍历背包后遍历物品，解决零钱兑换问题。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n        return dp[amount] if dp[amount] != float('inf') else -1",
          "description": "Python优化版，先遍历物品后遍历背包，解决零钱兑换问题。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for i in range(1, amount + 1):\n            for coin in coins:\n                if i - coin >= 0:\n                    dp[i] = min(dp[i], dp[i - coin] + 1)\n\n        return dp[amount] if dp[amount] != float('inf') else -1",
          "description": "Python优化版，先遍历背包后遍历物品，解决零钱兑换问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int coinChange(vector<int>& coins, int amount) {vector<int> dp(amount + 1, INT_MAX);dp[0] = 0;for (int i = 0; i < coins.size(); i++) {for (int j = coins[i]; j <= amount; j++) {if (dp[j - coins[i]] != INT_MAX) {dp[j] = min(dp[j - coins[i]] + 1, dp[j]);}}}if (dp[amount] == INT_MAX) return -1;return dp[amount];}};",
          "description": "C++ 版本，先遍历物品后遍历背包"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int coinChange(vector<int>& coins, int amount) {vector<int> dp(amount + 1, INT_MAX);dp[0] = 0;for (int i = 1; i <= amount; i++) {for (int j = 0; j < coins.size(); j++) {if (i - coins[j] >= 0 && dp[i - coins[j]] != INT_MAX ) {dp[i] = min(dp[i - coins[j]] + 1, dp[i]);}}}if (dp[amount] == INT_MAX) return -1;return dp[amount];}};",
          "description": "C++ 版本，先遍历背包后遍历物品"
        },
        {
          "language": "java",
          "code": "class Solution {public int coinChange(int[] coins, int amount) {int max = Integer.MAX_VALUE;int[] dp = new int[amount + 1];for (int j = 0; j < dp.length; j++) {dp[j] = max;}dp[0] = 0;for (int i = 0; i < coins.length; i++) {for (int j = coins[i]; j <= amount; j++) {if (dp[j - coins[i]] != max) {dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);}}}return dp[amount] == max ? -1 : dp[amount];}}",
          "description": "Java 版本，先遍历物品后遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for i in range(coin, amount + 1): if dp[i - coin] != float('inf'): dp[i] = min(dp[i - coin] + 1, dp[i]) if dp[amount] == float('inf'): return -1 return dp[amount]",
          "description": "Python 版本，先遍历物品后遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for j in range(len(coins)): if i - coins[j] >= 0 and dp[i - coins[j]] != float('inf'): dp[i] = min(dp[i - coins[j]] + 1, dp[i]) if dp[amount] == float('inf'): return -1 return dp[amount]",
          "description": "Python 版本，先遍历背包后遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for i in range(coin, amount + 1): dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1",
          "description": "Python 优化版本，先遍历物品后遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1",
          "description": "Python 优化版本，先遍历背包后遍历物品"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "先遍历物品 后遍历背包",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int coinChange(vector<int>& coins, int amount) {vector<int> dp(amount + 1, INT_MAX);dp[0] = 0;for (int i = 0; i < coins.size(); i++) { for (int j = coins[i]; j <= amount; j++) { if (dp[j - coins[i]] != INT_MAX) { dp[j] = min(dp[j - coins[i]] + 1, dp[j]); } }}if (dp[amount] == INT_MAX) return -1;return dp[amount];}};",
          "description": "先遍历物品 后遍历背包"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int coinChange(vector<int>& coins, int amount) {vector<int> dp(amount + 1, INT_MAX);dp[0] = 0;for (int i = 1; i <= amount; i++) { for (int j = 0; j < coins.size(); j++) { if (i - coins[j] >= 0 && dp[i - coins[j]] != INT_MAX ) { dp[i] = min(dp[i - coins[j]] + 1, dp[i]); } }}if (dp[amount] == INT_MAX) return -1;return dp[amount];}};",
          "description": "先遍历背包 后遍历物品"
        },
        {
          "language": "java",
          "code": "class Solution {public int coinChange(int[] coins, int amount) {int max = Integer.MAX_VALUE;int[] dp = new int[amount + 1];for (int j = 0; j < dp.length; j++) {dp[j] = max;}dp[0] = 0;for (int i = 0; i < coins.length; i++) {for (int j = coins[i]; j <= amount; j++) {if (dp[j - coins[i]] != max) {dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);}}}}return dp[amount] == max ? -1 : dp[amount];}}",
          "description": "先遍历物品 后遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for i in range(coin, amount + 1): if dp[i - coin] != float('inf'): dp[i] = min(dp[i - coin] + 1, dp[i]) if dp[amount] == float('inf'): return -1 return dp[amount]",
          "description": "先遍历物品 后遍历背包"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for j in range(len(coins)): if i - coins[j] >= 0 and dp[i - coins[j]] != float('inf'): dp[i] = min(dp[i - coins[j]] + 1, dp[i]) if dp[amount] == float('inf'): return -1 return dp[amount]",
          "description": "先遍历背包 后遍历物品"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for i in range(coin, amount + 1): dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1",
          "description": "先遍历物品 后遍历背包（优化版）"
        },
        {
          "language": "python",
          "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1",
          "description": "先遍历背包 后遍历物品（优化版）"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n * amount)",
    "space_complexity": "O(amount)",
    "explanation": "其中 n 为 coins 的长度"
  },
  "code_solutions": [
    {
      "language": "C++",
      "code": "class Solution {public: int coinChange(vector<int>& coins, int amount) {vector<int> dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i < coins.size(); i++) { for (int j = coins[i]; j <= amount; j++) { if (dp[j - coins[i]] != INT_MAX) { dp[j] = min(dp[j - coins[i]] + 1, dp[j]); } } } if (dp[amount] == INT_MAX) return -1; return dp[amount];}};",
      "description": "版本一：先遍历物品后遍历背包"
    },
    {
      "language": "C++",
      "code": "class Solution {public: int coinChange(vector<int>& coins, int amount) {vector<int> dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 1; i <= amount; i++) { for (int j = 0; j < coins.size(); j++) { if (i - coins[j] >= 0 && dp[i - coins[j]] != INT_MAX ) { dp[i] = min(dp[i - coins[j]] + 1, dp[i]); } } } if (dp[amount] == INT_MAX) return -1; return dp[amount];}};",
      "description": "版本二：先遍历背包后遍历物品"
    },
    {
      "language": "Java",
      "code": "class Solution {public int coinChange(int[] coins, int amount) {int max = Integer.MAX_VALUE; int[] dp = new int[amount + 1]; for (int j = 0; j < dp.length; j++) { dp[j] = max; } dp[0] = 0; for (int i = 0; i < coins.length; i++) { for (int j = coins[i]; j <= amount; j++) { if (dp[j - coins[i]] != max) { dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1); } } } return dp[amount] == max ? -1 : dp[amount];}}",
      "description": "Java实现，先遍历物品后遍历背包"
    },
    {
      "language": "Python",
      "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for i in range(coin, amount + 1): if dp[i - coin] != float('inf'): dp[i] = min(dp[i - coin] + 1, dp[i]) if dp[amount] == float('inf'): return -1 return dp[amount]",
      "description": "Python实现，先遍历物品后遍历背包"
    },
    {
      "language": "Python",
      "code": "class Solution: def coinChange(self, coins: List[int], amount: int) -> int: dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for j in range(len(coins)): if i - coins[j] >= 0 and dp[i - coins[j]] != float('inf'): dp[i] = min(dp[i - coins[j]] + 1, dp[i]) if dp[amount] == float('inf'): return -1 return dp[amount]",
      "description": "Python实现，先遍历背包后遍历物品"
    }
  ],
  "common_mistakes": [
    "未正确初始化dp数组导致逻辑错误。",
    "混淆了组合数和排列数的问题，误认为遍历顺序固定不可变。",
    "忽视了当没有合法解时应返回-1这一条件。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210201111833906.jpg",
      "description": "这张图片展示了使用动态规划算法解决零钱兑换问题的过程，具体为给定硬币种类和目标金额，求解最少硬币数的dp数组状态转移。",
      "context": "该图片展示了以coins = [1, 2, 5], amount = 5为例推导dp数组的过程，辅助说明了完全背包问题中采用特定遍历顺序时动态规划解决方案的应用。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210201111833906.jpg",
      "description": "GIF展示了动态规划解决零钱兑换问题时，dp数组随外层遍历硬币面额和内层遍历目标金额而逐步更新的过程。",
      "context": "GIF动画展示了通过动态规划方法解决零钱兑换问题时，dp数组如何根据给定的硬币面额和目标金额逐步更新的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\零钱兑换.txt",
  "extracted_at": "2025-07-21T00:08:33.228942",
  "raw_content": "零钱兑换\n力扣题目链接(https://leetcode.cn/problems/coin-change/)\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n\n你可以认为每种硬币的数量是无限的。\n\n示例 1：\n\n输入：coins = [1, 2, 5], amount = 11\n输出：3\n解释：11 = 5 + 5 + 1\n示例 2：\n\n输入：coins = [2], amount = 3\n输出：-1\n示例 3：\n\n输入：coins = [1], amount = 0\n输出：0\n示例 4：\n\n输入：coins = [1], amount = 1\n输出：1\n示例 5：\n\n输入：coins = [1], amount = 2\n输出：2\n提示：\n\n1 <= coins.length <= 12\n1 <= coins[i] <= 2^31 - 1\n0 <= amount <= 10^4\n\n\n#思路\n在动态规划：518.零钱兑换II (https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)中我们已经兑换一次零钱了，这次又要兑换，套路不一样！\n\n题目中说每种硬币的数量是无限的，可以看出是典型的完全背包问题。\n\n动规五部曲分析如下：\n\n确定dp数组以及下标的含义\ndp[j]：凑足总额为j所需钱币的最少个数为dp[j]\n\n确定递推公式\n凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）\n\n所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。\n\n递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);\n\ndp数组如何初始化\n首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;\n\n其他下标对应的数值呢？\n\n考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。\n\n所以下标非0的元素都是应该是最大值。\n\n代码如下：\n\nvector<int> dp(amount + 1, INT_MAX);\ndp[0] = 0;\n确定遍历顺序\n本题求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。\n\n所以本题并不强调集合是组合还是排列。\n\n如果求组合数就是外层for循环遍历物品，内层for遍历背包。\n\n如果求排列数就是外层for遍历背包，内层for循环遍历物品。\n\n在动态规划专题我们讲过了求组合数是动态规划：518.零钱兑换II (https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)，求排列数是动态规划：377. 组合总和 Ⅳ (https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html)。\n\n所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！\n\n那么我采用coins放在外循环，target在内循环的方式。\n\n本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序\n\n综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。\n\n举例推导dp数组\n以输入：coins = [1, 2, 5], amount = 5为例\n\nhttps://file1.kamacoder.com/i/algo/20210201111833906.jpg\n\ndp[amount]为最终结果。\n\n以上分析完毕，C++ 代码如下：\n\n// 版本一\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount + 1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 0; i < coins.size(); i++) { // 遍历物品\n            for (int j = coins[i]; j <= amount; j++) { // 遍历背包\n                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过\n                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);\n                }\n            }\n        }\n        if (dp[amount] == INT_MAX) return -1;\n        return dp[amount];\n    }\n};\n时间复杂度: O(n * amount)，其中 n 为 coins 的长度\n空间复杂度: O(amount)\n对于遍历方式遍历背包放在外循环，遍历物品放在内循环也是可以的，我就直接给出代码了\n\n// 版本二\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount + 1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {  // 遍历背包\n            for (int j = 0; j < coins.size(); j++) { // 遍历物品\n                if (i - coins[j] >= 0 && dp[i - coins[j]] != INT_MAX ) {\n                    dp[i] = min(dp[i - coins[j]] + 1, dp[i]);\n                }\n            }\n        }\n        if (dp[amount] == INT_MAX) return -1;\n        return dp[amount];\n    }\n};\n同上\n#总结\n细心的同学看网上的题解，可能看一篇是遍历背包的for循环放外面，看一篇又是遍历背包的for循环放里面，看多了都看晕了，到底两个for循环应该是什么先后关系。\n\n能把遍历顺序讲明白的文章几乎找不到！\n\n这也是大多数同学学习动态规划的苦恼所在，有的时候递推公式很简单，难在遍历顺序上！\n\n但最终又可以稀里糊涂的把题目过了，也不知道为什么这样可以过，反正就是过了。\n\n那么这篇文章就把遍历顺序分析的清清楚楚。\n\n动态规划：518.零钱兑换II (https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)中求的是组合数，动态规划：377. 组合总和 Ⅳ (https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html)中求的是排列数。\n\n而本题是要求最少硬币数量，硬币是组合数还是排列数都无所谓！所以两个for循环先后顺序怎样都可以！\n\n这也是我为什么要先讲518.零钱兑换II 然后再讲本题即：322.零钱兑换，这是Carl的良苦用心那。\n\n相信大家看完之后，对背包问题中的遍历顺序有更深的理解了。\n\n#其他语言版本\n#Java：\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        int max = Integer.MAX_VALUE;\n        int[] dp = new int[amount + 1];\n        //初始化dp数组为最大值\n        for (int j = 0; j < dp.length; j++) {\n            dp[j] = max;\n        }\n        //当金额为0时需要的硬币数目为0\n        dp[0] = 0;\n        for (int i = 0; i < coins.length; i++) {\n            //正序遍历：完全背包每个硬币可以选择多次\n            for (int j = coins[i]; j <= amount; j++) {\n                //只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要\n                if (dp[j - coins[i]] != max) {\n                    //选择硬币数目最小的情况\n                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);\n                }\n            }\n        }\n        return dp[amount] == max ? -1 : dp[amount];\n    }\n}\n#Python：\n先遍历物品 后遍历背包\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)  # 创建动态规划数组，初始值为正无穷大\n        dp[0] = 0  # 初始化背包容量为0时的最小硬币数量为0\n\n        for coin in coins:  # 遍历硬币列表，相当于遍历物品\n            for i in range(coin, amount + 1):  # 遍历背包容量\n                if dp[i - coin] != float('inf'):  # 如果dp[i - coin]不是初始值，则进行状态转移\n                    dp[i] = min(dp[i - coin] + 1, dp[i])  # 更新最小硬币数量\n\n        if dp[amount] == float('inf'):  # 如果最终背包容量的最小硬币数量仍为正无穷大，表示无解\n            return -1\n        return dp[amount]  # 返回背包容量为amount时的最小硬币数量\n\n先遍历背包 后遍历物品\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)  # 创建动态规划数组，初始值为正无穷大\n        dp[0] = 0  # 初始化背包容量为0时的最小硬币数量为0\n\n        for i in range(1, amount + 1):  # 遍历背包容量\n            for j in range(len(coins)):  # 遍历硬币列表，相当于遍历物品\n                if i - coins[j] >= 0 and dp[i - coins[j]] != float('inf'):  # 如果dp[i - coins[j]]不是初始值，则进行状态转移\n                    dp[i] = min(dp[i - coins[j]] + 1, dp[i])  # 更新最小硬币数量\n\n        if dp[amount] == float('inf'):  # 如果最终背包容量的最小硬币数量仍为正无穷大，表示无解\n            return -1\n        return dp[amount]  # 返回背包容量为amount时的最小硬币数量\n\n先遍历物品 后遍历背包（优化版）\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for i in range(coin, amount + 1): # 进行优化，从能装得下的背包开始计算，则不需要进行比较\n                # 更新凑成金额 i 所需的最少硬币数量\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n        return dp[amount] if dp[amount] != float('inf') else -1\n\n\n先遍历背包 后遍历物品（优化版）\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for i in range(1, amount + 1):  # 遍历背包容量\n            for coin in coins:  # 遍历物品\n                if i - coin >= 0:\n                    # 更新凑成金额 i 所需的最少硬币数量\n                    dp[i] = min(dp[i], dp[i - coin] + 1)\n\n        return dp[amount] if dp[amount] != float('inf') else -1"
}