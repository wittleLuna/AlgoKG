{
  "id": "AP_487a06e7",
  "title": "分发饼干",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/assign-cookies/",
  "description": "的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n\n对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "贪心算法",
    "排序"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "双指针",
    "逆向遍历"
  ],
  "difficulty": null,
  "solution_approach": "采用贪心算法来解决这个问题。首先对孩子的胃口值和饼干的尺寸进行排序，然后从大到小（或从小到大）遍历孩子的需求，并试图用当前最大（或最小）可用饼干满足之，以最大化满足的孩子数量。",
  "key_insights": [
    {
      "content": "为了最大化被满足的孩子数，应该避免使用较大尺寸的饼干去满足较小胃口的孩子，这样可以为更大胃口的孩子保留更多的机会。"
    },
    {
      "content": "无论是先满足胃口大的孩子还是先满足胃口小的孩子，通过正确的顺序匹配都能达到最优解。关键在于确保每次分配都是当前条件下最合适的。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "为了满足更多的小孩，就不要造成饼干尺寸的浪费。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = s.size() - 1; int result = 0; for (int i = g.size() - 1; i >= 0; i--) { if (index >= 0 && s[index] >= g[i]) { result++; index--; } } return result; }};",
          "description": "C++版本，使用贪心策略，优先满足胃口大的孩子"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(),g.end()); sort(s.begin(),s.end()); int index = 0; for(int i = 0; i < s.size(); i++) { if(index < g.size() && g[index] <= s[i]){ index++; } } return index; }};",
          "description": "C++版本，从小饼干开始喂饱小胃口的孩子"
        },
        {
          "language": "java",
          "code": "class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int start = 0; int count = 0; for (int i = 0; i < s.length && start < g.length; i++) { if (s[i] >= g[start]) { start++; count++; } } return count; }}",
          "description": "Java版本，优先考虑饼干，小饼干先喂饱小胃口"
        },
        {
          "language": "java",
          "code": "class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int count = 0; int start = s.length - 1; for (int index = g.length - 1; index >= 0; index--) { if(start >= 0 && g[index] <= s[start]) { start--; count++; } } return count; }}",
          "description": "Java版本，优先考虑胃口，先喂饱大胃口"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = len(s) - 1 result = 0 for i in range(len(g)-1, -1, -1): if index >= 0 and s[index] >= g[i]: result += 1 index -= 1 return result",
          "description": "Python版本，采用贪心算法，大饼干优先满足胃口大的孩子"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = 0 for i in range(len(s)): if index < len(g) and g[index] <= s[i]: index += 1 return index",
          "description": "Python版本，采用贪心算法，小饼干优先满足小胃口的孩子"
        }
      ],
      "subsections": []
    },
    {
      "name": "注意事项",
      "text": "注意版本一的代码中，可以看出来，是先遍历的胃口，在遍历的饼干，那么可不可以 先遍历 饼干，在遍历胃口呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = s.size() - 1; int result = 0; for (int i = g.size() - 1; i >= 0; i--) { if (index >= 0 && s[index] >= g[i]) { result++; index--; } } return result; }};",
          "description": "C++版本一代码，先遍历胃口后遍历饼干"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(),g.end()); sort(s.begin(),s.end()); int index = 0; for(int i = 0; i < s.size(); i++) { if(index < g.size() && g[index] <= s[i]){ index++; } } return index; }};",
          "description": "C++版本二代码，从小到大遍历饼干和胃口"
        },
        {
          "language": "java",
          "code": "class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int start = 0; int count = 0; for (int i = 0; i < s.length && start < g.length; i++) { if (s[i] >= g[start]) { start++; count++; } } return count; }}",
          "description": "Java版本，优先考虑饼干，小饼干先喂饱小胃口"
        },
        {
          "language": "java",
          "code": "class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int count = 0; int start = s.length - 1; for (int index = g.length - 1; index >= 0; index--) { if(start >= 0 && g[index] <= s[start]) { start--; count++; } } return count; }}",
          "description": "Java版本，优先考虑胃口，先喂饱大胃口"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = len(s) - 1 result = 0 for i in range(len(g)-1, -1, -1): if index >= 0 and s[index] >= g[i]: result += 1 index -= 1 return result",
          "description": "Python版本，大饼干优先"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = 0 for i in range(len(s)): if index < len(g) and g[index] <= s[i]: index += 1 return index",
          "description": "Python版本，小饼干优先"
        },
        {
          "language": "python",
          "code": "from collections import deque class Solution: def findContentChildren(self, g, s): result = 0 queue_g = deque(sorted(g, reverse=True)) queue_s = deque(sorted(s, reverse=True)) while queue_g and queue_s: child = queue_g.popleft() cookies = queue_s.popleft() if child <= cookies: result += 1 else: queue_s.appendleft(cookies) return result",
          "description": "Python版本使用栈实现，大饼干优先"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他思路",
      "text": "也可以换一个思路，小饼干先喂饱小胃口",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = s.size() - 1; int result = 0; for (int i = g.size() - 1; i >= 0; i--) {if (index >= 0 && s[index] >= g[i]) {result++; index--;}} return result;}};",
          "description": "C++版本，使用贪心算法解决分发饼干问题，优先考虑大饼干喂饱胃口大的孩子。"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(),g.end()); sort(s.begin(),s.end()); int index = 0; for(int i = 0; i < s.size(); i++) {if(index < g.size() && g[index] <= s[i]){index++;}} return index;}};",
          "description": "C++版本，使用贪心算法解决分发饼干问题，优先考虑小饼干先喂饱小胃口的孩子。"
        },
        {
          "language": "java",
          "code": "class Solution {public int findContentChildren(int[] g, int[] s) {Arrays.sort(g); Arrays.sort(s); int start = 0; int count = 0; for (int i = 0; i < s.length && start < g.length; i++) {if (s[i] >= g[start]) {start++; count++;}} return count;}}",
          "description": "Java版本，使用贪心算法解决分发饼干问题，优先考虑小饼干先喂饱小胃口的孩子。"
        },
        {
          "language": "java",
          "code": "class Solution {public int findContentChildren(int[] g, int[] s) {Arrays.sort(g); Arrays.sort(s); int count = 0; int start = s.length - 1; for (int index = g.length - 1; index >= 0; index--) {if(start >= 0 && g[index] <= s[start]) {start--; count++;}} return count;}}",
          "description": "Java版本，使用贪心算法解决分发饼干问题，优先考虑大饼干喂饱胃口大的孩子。"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = len(s) - 1 result = 0 for i in range(len(g)-1, -1, -1): if index >= 0 and s[index] >= g[i]: result += 1 index -= 1 return result",
          "description": "Python版本，使用贪心算法解决分发饼干问题，优先考虑大饼干喂饱胃口大的孩子。"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = 0 for i in range(len(s)): if index < len(g) and g[index] <= s[i]: index += 1 return index",
          "description": "Python版本，使用贪心算法解决分发饼干问题，优先考虑小饼干先喂饱小胃口的孩子。"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "这道题是贪心很好的一道入门题目，思路还是比较容易想到的。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = s.size() - 1; int result = 0; for (int i = g.size() - 1; i >= 0; i--) { if (index >= 0 && s[index] >= g[i]) { result++; index--; } } return result; }};",
          "description": "大饼干优先满足胃口大的孩子"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(),g.end()); sort(s.begin(),s.end()); int index = 0; for(int i = 0; i < s.size(); i++) { if(index < g.size() && g[index] <= s[i]){ index++; } } return index; }};",
          "description": "小饼干先喂饱小胃口"
        },
        {
          "language": "java",
          "code": "class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int start = 0; int count = 0; for (int i = 0; i < s.length && start < g.length; i++) { if (s[i] >= g[start]) { start++; count++; } } return count; }}",
          "description": "优先考虑饼干，小饼干先喂饱小胃口"
        },
        {
          "language": "java",
          "code": "class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int count = 0; int start = s.length - 1; for (int index = g.length - 1; index >= 0; index--) { if(start >= 0 && g[index] <= s[start]) { start--; count++; } } return count; }}",
          "description": "优先考虑胃口，先喂饱大胃口"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = len(s) - 1 result = 0 for i in range(len(g)-1, -1, -1): if index >= 0 and s[index] >= g[i]: result += 1 index -= 1 return result",
          "description": "贪心 大饼干优先"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = 0 for i in range(len(s)): if index < len(g) and g[index] <= s[i]: index += 1 return index",
          "description": "贪心 小饼干优先"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = s.size() - 1; int result = 0; for (int i = g.size() - 1; i >= 0; i--) { if (index >= 0 && s[index] >= g[i]) { result++; index--; } } return result; }};",
          "description": "C++版本，大饼干优先满足胃口大的孩子"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(),g.end()); sort(s.begin(),s.end()); int index = 0; for(int i = 0; i < s.size(); i++) { if(index < g.size() && g[index] <= s[i]){ index++; } } return index; }};",
          "description": "C++版本，小饼干先喂饱小胃口"
        },
        {
          "language": "java",
          "code": "class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int start = 0; int count = 0; for (int i = 0; i < s.length && start < g.length; i++) { if (s[i] >= g[start]) { start++; count++; } } return count; }}",
          "description": "Java版本，小饼干先喂饱小胃口"
        },
        {
          "language": "java",
          "code": "class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int count = 0; int start = s.length - 1; for (int index = g.length - 1; index >= 0; index--) { if(start >= 0 && g[index] <= s[start]) { start--; count++; } } return count; }}",
          "description": "Java版本，大饼干优先满足胃口大的孩子"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = len(s) - 1 result = 0 for i in range(len(g)-1, -1, -1): if index >= 0 and s[index] >= g[i]: result += 1 index -= 1 return result",
          "description": "Python版本，大饼干优先满足胃口大的孩子"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = 0 for i in range(len(s)): if index < len(g) and g[index] <= s[i]: index += 1 return index",
          "description": "Python版本，小饼干先喂饱小胃口"
        },
        {
          "language": "python",
          "code": "from collections import deque class Solution: def findContentChildren(self, g, s): result = 0 queue_g = deque(sorted(g, reverse=True)) queue_s = deque(sorted(s, reverse=True)) while queue_g and queue_s: child = queue_g.popleft() cookies = queue_s.popleft() if child <= cookies: result += 1 else: queue_s.appendleft(cookies) return result",
          "description": "Python版本使用deque，大饼干优先满足胃口大的孩子"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = s.size() - 1; int result = 0; for (int i = g.size() - 1; i >= 0; i--) { if (index >= 0 && s[index] >= g[i]) { result++; index--; } } return result; }};",
          "description": "C++版本，大饼干优先满足胃口大的孩子"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(),g.end()); sort(s.begin(),s.end()); int index = 0; for(int i = 0; i < s.size(); i++) { if(index < g.size() && g[index] <= s[i]){ index++; } } return index; }};",
          "description": "C++版本，小饼干先喂饱小胃口的孩子"
        },
        {
          "language": "java",
          "code": "class Solution {public int findContentChildren(int[] g, int[] s) {Arrays.sort(g); Arrays.sort(s); int start = 0; int count = 0; for (int i = 0; i < s.length && start < g.length; i++) { if (s[i] >= g[start]) { start++; count++; } } return count; }}",
          "description": "Java版本，小饼干先喂饱小胃口的孩子"
        },
        {
          "language": "java",
          "code": "class Solution {public int findContentChildren(int[] g, int[] s) {Arrays.sort(g); Arrays.sort(s); int count = 0; int start = s.length - 1; for (int index = g.length - 1; index >= 0; index--) { if(start >= 0 && g[index] <= s[start]) { start--; count++; } } return count; }}",
          "description": "Java版本，大饼干优先满足胃口大的孩子"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = len(s) - 1 result = 0 for i in range(len(g)-1, -1, -1): if index >= 0 and s[index] >= g[i]: result += 1 index -= 1 return result",
          "description": "Python版本，大饼干优先满足胃口大的孩子"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = 0 for i in range(len(s)): if index < len(g) and g[index] <= s[i]: index += 1 return index",
          "description": "Python版本，小饼干先喂饱小胃口的孩子"
        },
        {
          "language": "python",
          "code": "from collections import deque\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        result = 0\n        queue_g = deque(sorted(g, reverse=True))\n        queue_s = deque(sorted(s, reverse=True))\n        while queue_g and queue_s:\n            child = queue_g.popleft()\n            cookies = queue_s.popleft()\n            if child <= cookies:\n                result += 1\n            else:\n                queue_s.appendleft(cookies)\n        return result",
          "description": "Python版本，使用栈实现大饼干优先满足胃口大的孩子"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "贪心 大饼干优先",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = s.size() - 1; int result = 0; for (int i = g.size() - 1; i >= 0; i--) { if (index >= 0 && s[index] >= g[i]) { result++; index--; } } return result; }};",
          "description": "大饼干优先满足胃口大的孩子"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(),g.end()); sort(s.begin(),s.end()); int index = 0; for(int i = 0; i < s.size(); i++) { if(index < g.size() && g[index] <= s[i]){ index++; } } return index; }};",
          "description": "小饼干先喂饱小胃口的孩子"
        },
        {
          "language": "java",
          "code": "class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int start = 0; int count = 0; for (int i = 0; i < s.length && start < g.length; i++) { if (s[i] >= g[start]) { start++; count++; } } return count; }}",
          "description": "小饼干先喂饱小胃口的孩子"
        },
        {
          "language": "java",
          "code": "class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int count = 0; int start = s.length - 1; for (int index = g.length - 1; index >= 0; index--) { if(start >= 0 && g[index] <= s[start]) { start--; count++; } } return count; }}",
          "description": "大饼干优先满足胃口大的孩子"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = len(s) - 1 result = 0 for i in range(len(g)-1, -1, -1): if index >= 0 and s[index] >= g[i]: result += 1 index -= 1 return result",
          "description": "大饼干优先满足胃口大的孩子"
        },
        {
          "language": "python",
          "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = 0 for i in range(len(s)): if index < len(g) and g[index] <= s[i]: index += 1 return index",
          "description": "小饼干先喂饱小胃口的孩子"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(nlogn)",
    "space_complexity": "O(1)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = s.size() - 1; int result = 0; for (int i = g.size() - 1; i >= 0; i--) { if (index >= 0 && s[index] >= g[i]) { result++; index--; } } return result; }};",
      "description": "C++实现，使用贪心算法从大饼干优先满足胃口大的孩子。"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int findContentChildren(vector<int>& g, vector<int>& s) {sort(g.begin(),g.end()); sort(s.begin(),s.end()); int index = 0; for(int i = 0; i < s.size(); i++) { if(index < g.size() && g[index] <= s[i]){ index++; } } return index; }};",
      "description": "C++实现，使用贪心算法从小饼干优先满足胃口小的孩子。"
    },
    {
      "language": "java",
      "code": "class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int start = 0; int count = 0; for (int i = 0; i < s.length && start < g.length; i++) { if (s[i] >= g[start]) { start++; count++; } } return count; }}",
      "description": "Java实现，采用小饼干先喂饱小胃口的策略。"
    },
    {
      "language": "java",
      "code": "class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int count = 0; int start = s.length - 1; for (int index = g.length - 1; index >= 0; index--) { if(start >= 0 && g[index] <= s[start]) { start--; count++; } } return count; }}",
      "description": "Java实现，采用大饼干优先满足大胃口的策略。"
    },
    {
      "language": "python",
      "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = len(s) - 1 result = 0 for i in range(len(g)-1, -1, -1): if index >= 0 and s[index] >= g[i]: result += 1 index -= 1 return result",
      "description": "Python实现，使用贪心算法从大饼干优先满足胃口大的孩子。"
    },
    {
      "language": "python",
      "code": "class Solution: def findContentChildren(self, g, s): g.sort() s.sort() index = 0 for i in range(len(s)): if index < len(g) and g[index] <= s[i]: index += 1 return index",
      "description": "Python实现，使用贪心算法从小饼干优先满足胃口小的孩子。"
    }
  ],
  "common_mistakes": [
    "错误地认为必须同时遍历两个数组，而实际上可以通过一个外部循环和条件判断内的索引来实现有效遍历。",
    "尝试直接使用两个for循环分别遍历孩子和饼干，这会导致逻辑复杂化且可能无法正确处理所有情况。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20230405225628.png",
      "description": "这张图片展示了通过贪心算法匹配饼干和小孩满意度的过程，每个小孩的满意度可以通过分配合适的饼干来满足。",
      "context": "该图示例了如何通过将大饼干优先分配给胃口较大的孩子来最大化满足的孩子数量，展示了贪心算法的应用场景。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20230112102848.png",
      "description": "这张图片展示了“分配饼干”问题的解题思路，通过两个数组（胃口g和饼干s）的匹配过程，利用if和for控制结构来找到最优解。",
      "context": "该图片展示了当外层循环控制饼干、内层条件判断控制胃口时可能出现的问题，即胃口较大的孩子无法被满足而导致所有饼干都无法正确分配的情况。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20230405225628.png",
      "description": "GIF展示了如何通过排序后从大到小匹配饼干与孩子胃口的过程，以达到最大化满足孩子数量的目标。",
      "context": "GIF动画展示了如何通过排序饼干和小孩的需求，并采用大饼干优先满足胃口大的小孩的策略，来最大化被喂饱的小孩数量的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20230112102848.png",
      "description": "GIF展示了当尝试用饼干匹配孩子胃口时，如果控制逻辑设置不当（即外部循环遍历饼干而非胃口），导致无法正确匹配的过程。",
      "context": "此GIF动画展示了当外层循环控制饼干、内层条件判断控制胃口时，由于某些大胃口无法被当前饼干满足而导致遍历过程中出现的不匹配情况。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\贪心算法\\分发饼干.txt",
  "extracted_at": "2025-07-22T14:55:48.948653",
  "raw_content": "分发饼干\n力扣题目链接(https://leetcode.cn/problems/assign-cookies/)\n\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n\n对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n\n示例  1:\n\n输入: g = [1,2,3], s = [1,1]\n输出: 1 解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。\n示例  2:\n\n输入: g = [1,2], s = [1,2,3]\n输出: 2\n解释:你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2.\n提示：\n\n1 <= g.length <= 3 * 10^4\n0 <= s.length <= 3 * 10^4\n1 <= g[i], s[j] <= 2^31 - 1\n\n\n#思路\n为了满足更多的小孩，就不要造成饼干尺寸的浪费。\n\n大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。\n\n这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。\n\n可以尝试使用贪心策略，先将饼干数组和小孩数组排序。\n\n然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。\n\n如图：\n\nhttps://file1.kamacoder.com/i/algo/20230405225628.png\n\n这个例子可以看出饼干 9 只有喂给胃口为 7 的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。\n\nC++代码整体如下：\n\n// 版本一\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int index = s.size() - 1; // 饼干数组的下标\n        int result = 0;\n        for (int i = g.size() - 1; i >= 0; i--) { // 遍历胃口\n            if (index >= 0 && s[index] >= g[i]) { // 遍历饼干\n                result++;\n                index--;\n            }\n        }\n        return result;\n    }\n};\n时间复杂度：O(nlogn)\n空间复杂度：O(1)\n从代码中可以看出我用了一个 index 来控制饼干数组的遍历，遍历饼干并没有再起一个 for 循环，而是采用自减的方式，这也是常用的技巧。\n\n有的同学看到要遍历两个数组，就想到用两个 for 循环，那样逻辑其实就复杂了。\n\n#注意事项\n注意版本一的代码中，可以看出来，是先遍历的胃口，在遍历的饼干，那么可不可以 先遍历 饼干，在遍历胃口呢？\n\n其实是不可以的。\n\n外面的 for 是里的下标 i 是固定移动的，而 if 里面的下标 index 是符合条件才移动的。\n\n如果 for 控制的是饼干， if 控制胃口，就是出现如下情况 ：\n\nhttps://file1.kamacoder.com/i/algo/20230112102848.png\n\nif 里的 index 指向 胃口 10， for 里的 i 指向饼干 9，因为 饼干 9 满足不了 胃口 10，所以 i 持续向前移动，而 index 走不到s[index] >= g[i] 的逻辑，所以 index 不会移动，那么当 i 持续向前移动，最后所有的饼干都匹配不上。\n\n所以 一定要 for 控制 胃口，里面的 if 控制饼干。\n\n#其他思路\n也可以换一个思路，小饼干先喂饱小胃口\n\n代码如下：\n\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(),g.end());\n        sort(s.begin(),s.end());\n        int index = 0;\n        for(int i = 0; i < s.size(); i++) { // 饼干\n            if(index < g.size() && g[index] <= s[i]){ // 胃口\n                index++;\n            }\n        }\n        return index;\n    }\n};\n时间复杂度：O(nlogn)\n空间复杂度：O(1)\n细心的录友可以发现，这种写法，两个循环的顺序改变了，先遍历的饼干，在遍历的胃口，这是因为遍历顺序变了，我们是从小到大遍历。\n\n理由在上面 “注意事项”中 已经讲过。\n\n#总结\n这道题是贪心很好的一道入门题目，思路还是比较容易想到的。\n\n文中详细介绍了思考的过程，想清楚局部最优，想清楚全局最优，感觉局部最优是可以推出全局最优，并想不出反例，那么就试一试贪心。\n\n#其他语言版本\n#Java\nclass Solution {\n    // 思路1：优先考虑饼干，小饼干先喂饱小胃口\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int start = 0;\n        int count = 0;\n        for (int i = 0; i < s.length && start < g.length; i++) {\n            if (s[i] >= g[start]) {\n                start++;\n                count++;\n            }\n        }\n        return count;\n    }\n}\nclass Solution {\n    // 思路2：优先考虑胃口，先喂饱大胃口\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int count = 0;\n        int start = s.length - 1;\n        // 遍历胃口\n        for (int index = g.length - 1; index >= 0; index--) {\n            if(start >= 0 && g[index] <= s[start]) {\n                start--;\n                count++;\n            }\n        }\n        return count;\n    }\n}\n#Python\n贪心 大饼干优先\n\nclass Solution:\n    def findContentChildren(self, g, s):\n        g.sort()  # 将孩子的贪心因子排序\n        s.sort()  # 将饼干的尺寸排序\n        index = len(s) - 1  # 饼干数组的下标，从最后一个饼干开始\n        result = 0  # 满足孩子的数量\n        for i in range(len(g)-1, -1, -1):  # 遍历胃口，从最后一个孩子开始\n            if index >= 0 and s[index] >= g[i]:  # 遍历饼干\n                result += 1\n                index -= 1\n        return result\n\n贪心 小饼干优先\n\nclass Solution:\n    def findContentChildren(self, g, s):\n        g.sort()  # 将孩子的贪心因子排序\n        s.sort()  # 将饼干的尺寸排序\n        index = 0\n        for i in range(len(s)):  # 遍历饼干\n            if index < len(g) and g[index] <= s[i]:  # 如果当前孩子的贪心因子小于等于当前饼干尺寸\n                index += 1  # 满足一个孩子，指向下一个孩子\n        return index  # 返回满足的孩子数目\n\n栈 大饼干优先\n\nfrom collecion import deque\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n      #思路,饼干和孩子按从大到小排序,依次从栈中取出，若满足条件result += 1 否则将饼干栈顶元素重新返回 \n        result = 0\n        queue_g = deque(sorted(g, reverse = True))\n        queue_s = deque(sorted(s, reverse = True))\n        while queue_g and queue_s:\n            child = queue_g.popleft()\n            cookies = queue_s.popleft()\n            if child <= cookies:\n                result += 1\n            else:\n                queue_s.appendleft(cookies)\n        return result"
}