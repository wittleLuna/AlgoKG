éªŒè¯äºŒå‰æœç´¢æ ‘
åŠ›æ‰£é¢˜ç›®é“¾æ¥(https://leetcode.cn/problems/validate-binary-search-tree/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚

å‡è®¾ä¸€ä¸ªäºŒå‰æœç´¢æ ‘å…·æœ‰å¦‚ä¸‹ç‰¹å¾ï¼š

èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å«å°äºå½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å«å¤§äºå½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚

https://file1.kamacoder.com/i/algo/20230310000750.png



#æ€è·¯
è¦çŸ¥é“ä¸­åºéå†ä¸‹ï¼Œè¾“å‡ºçš„äºŒå‰æœç´¢æ ‘èŠ‚ç‚¹çš„æ•°å€¼æ˜¯æœ‰åºåºåˆ—ã€‚

æœ‰äº†è¿™ä¸ªç‰¹æ€§ï¼ŒéªŒè¯äºŒå‰æœç´¢æ ‘ï¼Œå°±ç›¸å½“äºå˜æˆäº†åˆ¤æ–­ä¸€ä¸ªåºåˆ—æ˜¯ä¸æ˜¯é€’å¢çš„äº†ã€‚

#é€’å½’æ³•
å¯ä»¥é€’å½’ä¸­åºéå†å°†äºŒå‰æœç´¢æ ‘è½¬å˜æˆä¸€ä¸ªæ•°ç»„ï¼Œä»£ç å¦‚ä¸‹ï¼š

vector<int> vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    vec.push_back(root->val); // å°†äºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºæœ‰åºæ•°ç»„
    traversal(root->right);
}
ç„¶ååªè¦æ¯”è¾ƒä¸€ä¸‹ï¼Œè¿™ä¸ªæ•°ç»„æ˜¯å¦æ˜¯æœ‰åºçš„ï¼Œæ³¨æ„äºŒå‰æœç´¢æ ‘ä¸­ä¸èƒ½æœ‰é‡å¤å…ƒç´ ã€‚

traversal(root);
for (int i = 1; i < vec.size(); i++) {
    // æ³¨æ„è¦å°äºç­‰äºï¼Œæœç´¢æ ‘é‡Œä¸èƒ½æœ‰ç›¸åŒå…ƒç´ 
    if (vec[i] <= vec[i - 1]) return false;
}
return true;
æ•´ä½“ä»£ç å¦‚ä¸‹ï¼š

class Solution {
private:
    vector<int> vec;
    void traversal(TreeNode* root) {
        if (root == NULL) return;
        traversal(root->left);
        vec.push_back(root->val); // å°†äºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºæœ‰åºæ•°ç»„
        traversal(root->right);
    }
public:
    bool isValidBST(TreeNode* root) {
        vec.clear(); // ä¸åŠ è¿™å¥åœ¨leetcodeä¸Šä¹Ÿå¯ä»¥è¿‡ï¼Œä½†æœ€å¥½åŠ ä¸Š
        traversal(root);
        for (int i = 1; i < vec.size(); i++) {
            // æ³¨æ„è¦å°äºç­‰äºï¼Œæœç´¢æ ‘é‡Œä¸èƒ½æœ‰ç›¸åŒå…ƒç´ 
            if (vec[i] <= vec[i - 1]) return false;
        }
        return true;
    }
};
ä»¥ä¸Šä»£ç ä¸­ï¼Œæˆ‘ä»¬æŠŠäºŒå‰æ ‘è½¬å˜ä¸ºæ•°ç»„æ¥åˆ¤æ–­ï¼Œæ˜¯æœ€ç›´è§‚çš„ï¼Œä½†å…¶å®ä¸ç”¨è½¬å˜æˆæ•°ç»„ï¼Œå¯ä»¥åœ¨é€’å½’éå†çš„è¿‡ç¨‹ä¸­ç›´æ¥åˆ¤æ–­æ˜¯å¦æœ‰åºã€‚

è¿™é“é¢˜ç›®æ¯”è¾ƒå®¹æ˜“é™·å…¥ä¸¤ä¸ªé™·é˜±ï¼š

é™·é˜±1
ä¸èƒ½å•çº¯çš„æ¯”è¾ƒå·¦èŠ‚ç‚¹å°äºä¸­é—´èŠ‚ç‚¹ï¼Œå³èŠ‚ç‚¹å¤§äºä¸­é—´èŠ‚ç‚¹å°±å®Œäº‹äº†ã€‚

å†™å‡ºäº†ç±»ä¼¼è¿™æ ·çš„ä»£ç ï¼š

if (root->val > root->left->val && root->val < root->right->val) {
    return true;
} else {
    return false;
}
æˆ‘ä»¬è¦æ¯”è¾ƒçš„æ˜¯ å·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å°äºä¸­é—´èŠ‚ç‚¹ï¼Œå³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å¤§äºä¸­é—´èŠ‚ç‚¹ã€‚æ‰€ä»¥ä»¥ä¸Šä»£ç çš„åˆ¤æ–­é€»è¾‘æ˜¯é”™è¯¯çš„ã€‚

ä¾‹å¦‚ï¼š [10,5,15,null,null,6,20] è¿™ä¸ªcaseï¼š

https://file1.kamacoder.com/i/algo/20230310000824.png

èŠ‚ç‚¹10å¤§äºå·¦èŠ‚ç‚¹5ï¼Œå°äºå³èŠ‚ç‚¹15ï¼Œä½†å³å­æ ‘é‡Œå‡ºç°äº†ä¸€ä¸ª6 è¿™å°±ä¸ç¬¦åˆäº†ï¼

é™·é˜±2
æ ·ä¾‹ä¸­æœ€å°èŠ‚ç‚¹ å¯èƒ½æ˜¯intçš„æœ€å°å€¼ï¼Œå¦‚æœè¿™æ ·ä½¿ç”¨æœ€å°çš„intæ¥æ¯”è¾ƒä¹Ÿæ˜¯ä¸è¡Œçš„ã€‚

æ­¤æ—¶å¯ä»¥åˆå§‹åŒ–æ¯”è¾ƒå…ƒç´ ä¸ºlonglongçš„æœ€å°å€¼ã€‚

é—®é¢˜å¯ä»¥è¿›ä¸€æ­¥æ¼”è¿›ï¼šå¦‚æœæ ·ä¾‹ä¸­æ ¹èŠ‚ç‚¹çš„val å¯èƒ½æ˜¯longlongçš„æœ€å°å€¼ åˆè¦æ€ä¹ˆåŠå‘¢ï¼Ÿæ–‡ä¸­ä¼šè§£ç­”ã€‚

äº†è§£è¿™äº›é™·é˜±ä¹‹åæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ä»£ç åº”è¯¥æ€ä¹ˆå†™ï¼š

é€’å½’ä¸‰éƒ¨æ›²ï¼š

ç¡®å®šé€’å½’å‡½æ•°ï¼Œè¿”å›å€¼ä»¥åŠå‚æ•°
è¦å®šä¹‰ä¸€ä¸ªlonglongçš„å…¨å±€å˜é‡ï¼Œç”¨æ¥æ¯”è¾ƒéå†çš„èŠ‚ç‚¹æ˜¯å¦æœ‰åºï¼Œå› ä¸ºåå°æµ‹è¯•æ•°æ®ä¸­æœ‰intæœ€å°å€¼ï¼Œæ‰€ä»¥å®šä¹‰ä¸ºlonglongçš„ç±»å‹ï¼Œåˆå§‹åŒ–ä¸ºlonglongæœ€å°å€¼ã€‚

æ³¨æ„é€’å½’å‡½æ•°è¦æœ‰boolç±»å‹çš„è¿”å›å€¼ï¼Œ æˆ‘ä»¬åœ¨äºŒå‰æ ‘ï¼šé€’å½’å‡½æ•°ç©¶ç«Ÿä»€ä¹ˆæ—¶å€™éœ€è¦è¿”å›å€¼ï¼Œä»€ä¹ˆæ—¶å€™ä¸è¦è¿”å›å€¼ï¼Ÿ (https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html)ä¸­è®²äº†ï¼Œåªæœ‰å¯»æ‰¾æŸä¸€æ¡è¾¹ï¼ˆæˆ–è€…ä¸€ä¸ªèŠ‚ç‚¹ï¼‰çš„æ—¶å€™ï¼Œé€’å½’å‡½æ•°ä¼šæœ‰boolç±»å‹çš„è¿”å›å€¼ã€‚

å…¶å®æœ¬é¢˜æ˜¯åŒæ ·çš„é“ç†ï¼Œæˆ‘ä»¬åœ¨å¯»æ‰¾ä¸€ä¸ªä¸ç¬¦åˆæ¡ä»¶çš„èŠ‚ç‚¹ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°è¿™ä¸ªèŠ‚ç‚¹å°±éå†äº†æ•´ä¸ªæ ‘ï¼Œå¦‚æœæ‰¾åˆ°ä¸ç¬¦åˆçš„èŠ‚ç‚¹äº†ï¼Œç«‹åˆ»è¿”å›ã€‚

ä»£ç å¦‚ä¸‹ï¼š

long long maxVal = LONG_MIN; // å› ä¸ºåå°æµ‹è¯•æ•°æ®ä¸­æœ‰intæœ€å°å€¼
bool isValidBST(TreeNode* root)
ç¡®å®šç»ˆæ­¢æ¡ä»¶
å¦‚æœæ˜¯ç©ºèŠ‚ç‚¹ æ˜¯ä¸æ˜¯äºŒå‰æœç´¢æ ‘å‘¢ï¼Ÿ

æ˜¯çš„ï¼ŒäºŒå‰æœç´¢æ ‘ä¹Ÿå¯ä»¥ä¸ºç©ºï¼

ä»£ç å¦‚ä¸‹ï¼š

if (root == NULL) return true;
ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘
ä¸­åºéå†ï¼Œä¸€ç›´æ›´æ–°maxValï¼Œä¸€æ—¦å‘ç°maxVal >= root->valï¼Œå°±è¿”å›falseï¼Œæ³¨æ„å…ƒç´ ç›¸åŒæ—¶å€™ä¹Ÿè¦è¿”å›falseã€‚

ä»£ç å¦‚ä¸‹ï¼š

bool left = isValidBST(root->left);         // å·¦

// ä¸­åºéå†ï¼ŒéªŒè¯éå†çš„å…ƒç´ æ˜¯ä¸æ˜¯ä»å°åˆ°å¤§
if (maxVal < root->val) maxVal = root->val; // ä¸­
else return false;

bool right = isValidBST(root->right);       // å³
return left && right;
æ•´ä½“ä»£ç å¦‚ä¸‹ï¼š

class Solution {
public:
    long long maxVal = LONG_MIN; // å› ä¸ºåå°æµ‹è¯•æ•°æ®ä¸­æœ‰intæœ€å°å€¼
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;

        bool left = isValidBST(root->left);
        // ä¸­åºéå†ï¼ŒéªŒè¯éå†çš„å…ƒç´ æ˜¯ä¸æ˜¯ä»å°åˆ°å¤§
        if (maxVal < root->val) maxVal = root->val;
        else return false;
        bool right = isValidBST(root->right);

        return left && right;
    }
};
ä»¥ä¸Šä»£ç æ˜¯å› ä¸ºåå°æ•°æ®æœ‰intæœ€å°å€¼æµ‹è¯•ç”¨ä¾‹ï¼Œæ‰€ä»¥éƒ½æŠŠmaxValæ”¹æˆäº†longlongæœ€å°å€¼ã€‚

å¦‚æœæµ‹è¯•æ•°æ®ä¸­æœ‰ longlongçš„æœ€å°å€¼ï¼Œæ€ä¹ˆåŠï¼Ÿ

ä¸å¯èƒ½åœ¨åˆå§‹åŒ–ä¸€ä¸ªæ›´å°çš„å€¼äº†å§ã€‚ å»ºè®®é¿å… åˆå§‹åŒ–æœ€å°å€¼ï¼Œå¦‚ä¸‹æ–¹æ³•å–åˆ°æœ€å·¦é¢èŠ‚ç‚¹çš„æ•°å€¼æ¥æ¯”è¾ƒã€‚

ä»£ç å¦‚ä¸‹ï¼š

class Solution {
public:
    TreeNode* pre = NULL; // ç”¨æ¥è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;
        bool left = isValidBST(root->left);

        if (pre != NULL && pre->val >= root->val) return false;
        pre = root; // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹

        bool right = isValidBST(root->right);
        return left && right;
    }
};
æœ€åè¿™ä»½ä»£ç çœ‹ä¸Šå»æ•´æ´ä¸€äº›ï¼Œæ€è·¯ä¹Ÿæ¸…æ™°ã€‚

#è¿­ä»£æ³•
å¯ä»¥ç”¨è¿­ä»£æ³•æ¨¡æ‹ŸäºŒå‰æ ‘ä¸­åºéå†ï¼Œå¯¹å‰ä¸­ååºè¿­ä»£æ³•ç”Ÿç–çš„åŒå­¦å¯ä»¥çœ‹è¿™ä¸¤ç¯‡äºŒå‰æ ‘ï¼šå¬è¯´é€’å½’èƒ½åšçš„ï¼Œæ ˆä¹Ÿèƒ½åšï¼ (https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html)ï¼ŒäºŒå‰æ ‘ï¼šå‰ä¸­ååºè¿­ä»£æ–¹å¼ç»Ÿä¸€å†™æ³•(https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html)

è¿­ä»£æ³•ä¸­åºéå†ç¨åŠ æ”¹åŠ¨å°±å¯ä»¥äº†ï¼Œä»£ç å¦‚ä¸‹ï¼š

class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL; // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) {
                st.push(cur);
                cur = cur->left;                // å·¦
            } else {
                cur = st.top();                 // ä¸­
                st.pop();
                if (pre != NULL && cur->val <= pre->val)
                return false;
                pre = cur; //ä¿å­˜å‰ä¸€ä¸ªè®¿é—®çš„ç»“ç‚¹

                cur = cur->right;               // å³
            }
        }
        return true;
    }
};
åœ¨äºŒå‰æ ‘ï¼šäºŒå‰æœç´¢æ ‘ç™»åœºï¼ (https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html)ä¸­æˆ‘ä»¬åˆ†æ˜å†™å‡ºäº†ç—›å“­æµæ¶•çš„ç®€æ´è¿­ä»£æ³•ï¼Œæ€ä¹ˆåœ¨è¿™é‡Œä¸è¡Œäº†å‘¢ï¼Œå› ä¸ºæœ¬é¢˜æ˜¯è¦éªŒè¯äºŒå‰æœç´¢æ ‘å•Šã€‚

#æ€»ç»“
è¿™é“é¢˜ç›®æ˜¯ä¸€ä¸ªç®€å•é¢˜ï¼Œä½†å¯¹äºæ²¡æ¥è§¦è¿‡çš„åŒå­¦è¿˜æ˜¯æœ‰éš¾åº¦çš„ã€‚

æ‰€ä»¥åˆå­¦è€…åˆšå¼€å§‹å­¦ä¹ ç®—æ³•çš„æ—¶å€™ï¼Œçœ‹åˆ°ç®€å•é¢˜ç›®æ²¡æœ‰æ€è·¯å¾ˆæ­£å¸¸ï¼Œåƒä¸‡åˆ«æ€€ç–‘è‡ªå·±æ™ºå•†ï¼Œå­¦ä¹ è¿‡ç¨‹éƒ½æ˜¯è¿™æ ·çš„ï¼Œå¤§å®¶æ™ºå•†éƒ½å·®ä¸å¤šã€‚

åªè¦æŠŠåŸºæœ¬ç±»å‹çš„é¢˜ç›®éƒ½åšè¿‡ï¼Œæ€»ç»“è¿‡ä¹‹åï¼Œæ€è·¯è‡ªç„¶å°±å¼€é˜”äº†ï¼ŒåŠ æ²¹ğŸ’ª

#å…¶ä»–è¯­è¨€ç‰ˆæœ¬
#Java
//ä½¿ç”¨çµ±ä¸€è¿­ä»£æ³•
class Solution {
    public boolean isValidBST(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        if(root != null)
            stack.add(root);        
        while(!stack.isEmpty()){
            TreeNode curr = stack.peek();
            if(curr != null){
                stack.pop();
                if(curr.right != null)
                    stack.add(curr.right);
                stack.add(curr);
                stack.add(null);
                if(curr.left != null)
                    stack.add(curr.left);
            }else{
                stack.pop();
                TreeNode temp = stack.pop();
                if(pre != null && pre.val >= temp.val)
                    return false;
                pre = temp;
            }
        }
        return true;
    }
}
class Solution {
    // é€’å½’
    TreeNode max;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        // å·¦
        boolean left = isValidBST(root.left);
        if (!left) {
            return false;
        }
        // ä¸­
        if (max != null && root.val <= max.val) {
            return false;
        }
        max = root;
        // å³
        boolean right = isValidBST(root.right);
        return right;
    }
}

class Solution {
    // è¿­ä»£
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;// å·¦
            }
            // ä¸­ï¼Œå¤„ç†
            TreeNode pop = stack.pop();
            if (pre != null && pop.val <= pre.val) {
                return false;
            }
            pre = pop;

            root = pop.right;// å³
        }
        return true;
    }
}

// ç®€æ´å®ç°Â·é€’å½’è§£æ³•
class Solution {
    public boolean isValidBST(TreeNode root) {
        return validBST(Long.MIN_VALUE, Long.MAX_VALUE, root);
    }
    boolean validBST(long lower, long upper, TreeNode root) {
        if (root == null) return true;
        if (root.val <= lower || root.val >= upper) return false;
        return validBST(lower, root.val, root.left) && validBST(root.val, upper, root.right);
    }
}
// ç®€æ´å®ç°Â·ä¸­åºéå†
class Solution {
    private long prev = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        if (!isValidBST(root.left)) {
            return false;
        }
        if (root.val <= prev) { // ä¸æ»¡è¶³äºŒå‰æœç´¢æ ‘æ¡ä»¶
            return false;
        }
        prev = root.val;
        return isValidBST(root.right);
    }
}
#Python
é€’å½’æ³•ï¼ˆç‰ˆæœ¬ä¸€ï¼‰åˆ©ç”¨ä¸­åºé€’å¢æ€§è´¨ï¼Œè½¬æ¢æˆæ•°ç»„

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.vec = []

    def traversal(self, root):
        if root is None:
            return
        self.traversal(root.left)
        self.vec.append(root.val)  # å°†äºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºæœ‰åºæ•°ç»„
        self.traversal(root.right)

    def isValidBST(self, root):
        self.vec = []  # æ¸…ç©ºæ•°ç»„
        self.traversal(root)
        for i in range(1, len(self.vec)):
            # æ³¨æ„è¦å°äºç­‰äºï¼Œæœç´¢æ ‘é‡Œä¸èƒ½æœ‰ç›¸åŒå…ƒç´ 
            if self.vec[i] <= self.vec[i - 1]:
                return False
        return True

é€’å½’æ³•ï¼ˆç‰ˆæœ¬äºŒï¼‰è®¾å®šæå°å€¼ï¼Œè¿›è¡Œæ¯”è¾ƒ

class Solution:
    def __init__(self):
        self.maxVal = float('-inf')  # å› ä¸ºåå°æµ‹è¯•æ•°æ®ä¸­æœ‰intæœ€å°å€¼

    def isValidBST(self, root):
        if root is None:
            return True

        left = self.isValidBST(root.left)
        # ä¸­åºéå†ï¼ŒéªŒè¯éå†çš„å…ƒç´ æ˜¯ä¸æ˜¯ä»å°åˆ°å¤§
        if self.maxVal < root.val:
            self.maxVal = root.val
        else:
            return False
        right = self.isValidBST(root.right)

        return left and right

é€’å½’æ³•ï¼ˆç‰ˆæœ¬ä¸‰ï¼‰ç›´æ¥å–è¯¥æ ‘çš„æœ€å°å€¼

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.pre = None  # ç”¨æ¥è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹

    def isValidBST(self, root):
        if root is None:
            return True

        left = self.isValidBST(root.left)

        if self.pre is not None and self.pre.val >= root.val:
            return False
        self.pre = root  # è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹

        right = self.isValidBST(root.right)
        return left and right



è¿­ä»£æ³•

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root):
        stack = []
        cur = root
        pre = None  # è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹
        while cur is not None or len(stack) > 0:
            if cur is not None:
                stack.append(cur)
                cur = cur.left  # å·¦
            else:
                cur = stack.pop()  # ä¸­
                if pre is not None and cur.val <= pre.val:
                    return False
                pre = cur  # ä¿å­˜å‰ä¸€ä¸ªè®¿é—®çš„ç»“ç‚¹
                cur = cur.right  # å³
        return True