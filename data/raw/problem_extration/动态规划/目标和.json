{
  "id": "AP_0bddf3de",
  "title": "目标和",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/target-sum/",
  "description": "一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。\n\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划",
    "回溯"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "递归",
    "记忆化搜索",
    "状态转移",
    "背包问题"
  ],
  "difficulty": null,
  "solution_approach": "将目标和S转化为求一个子集的和left=(S+sum)/2的问题，其中sum是数组元素之和。然后利用动态规划或回溯法找到所有可能的方法数，使得选择的元素之和等于left。",
  "key_insights": [
    {
      "content": "通过数学推导，将原始问题转化为了寻找一个子集，其元素之和为(S + sum) / 2。这样就可以使用背包问题的解决方案来处理。"
    },
    {
      "content": "本题实际上是一个组合计数问题，即在给定集合中选取元素（每个元素只能选一次），让它们的和达到特定值。这可以通过动态规划有效地解决。"
    },
    {
      "content": "二维DP数组可以压缩成一维DP数组以节省空间，同时保持时间复杂度不变。"
    },
    {
      "content": "初始化时需要特别注意dp[0] = 1，表示不选取任何元素时只有一种方法使得和为0。"
    },
    {
      "content": "当遍历背包容量时，从大到小逆序遍历可以确保每个物品只被考虑一次。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "如果对背包问题不都熟悉先看这两篇：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {\n        if (sum == target) {\n            result.push_back(path);\n        }\n        // 如果 sum + candidates[i] > target 就终止遍历\n        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {\n            sum += candidates[i];\n            path.push_back(candidates[i]);\n            backtracking(candidates, target, sum, i + 1);\n            sum -= candidates[i];\n            path.pop_back();\n\n        }\n    }\npublic:\n    int findTargetSumWays(vector<int>& nums, int S) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (S > sum) return 0; // 此时没有方案\n        if ((S + sum) % 2) return 0; // 此时没有方案，两个int相加的时候要格外小心数值溢出的问题\n        int bagSize = (S + sum) / 2; // 转变为组合总和问题，bagsize就是要求的和\n\n        // 以下为回溯法代码\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end()); // 需要排序\n        backtracking(nums, bagSize, 0, 0);\n        return result.size();\n    }\n};",
          "description": "C++回溯算法求解目标和问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; // 此时没有方案\n        if ((target + sum) % 2 == 1) return 0; // 此时没有方案\n        int bagSize = (target + sum) / 2;\n        \n        vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0));\n        \n        // 初始化最上行\n        if (nums[0] <= bagSize) dp[0][nums[0]] = 1; \n        \n        // 初始化最左列，最左列其他数值在递推公式中就完成了赋值\n        dp[0][0] = 1; \n        \n        int numZero = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) numZero++;\n            dp[i][0] = (int) pow(2.0, numZero);\n        }\n        \n        // 以下遍历顺序行列可以颠倒\n        for (int i = 1; i < nums.size(); i++) { // 行，遍历物品\n            for (int j = 0; j <= bagSize; j++) { // 列，遍历背包\n                if (nums[i] > j) dp[i][j] = dp[i - 1][j]; \n                else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n            }\n        }\n        return dp[nums.size() - 1][bagSize];\n    }\n};",
          "description": "C++二维DP数组求解目标和问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; // 此时没有方案\n        if ((target + sum) % 2 == 1) return 0; // 此时没有方案\n        int bagSize = (target + sum) / 2;\n        vector<int> dp(bagSize + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n};",
          "description": "C++一维DP数组求解目标和问题"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) sum += nums[i];\n        \n        //如果target的绝对值大于sum，那么是没有方案的\n        if (Math.abs(target) > sum) return 0;\n        //如果(target+sum)除以2的余数不为0，也是没有方案的\n        if ((target + sum) % 2 == 1) return 0;\n        \n        int bagSize = (target + sum) / 2;\n        int[] dp = new int[bagSize + 1];\n        dp[0] = 1;\n        \n        for (int i = 0; i < nums.length; i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        \n        return dp[bagSize];\n    }\n}",
          "description": "Java一维DP数组求解目标和问题"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n        }\n        if(sum < Math.abs(target)){\n            return 0;\n        }\n        if((sum + target) % 2 != 0) {\n            return 0;\n        }\n        int left = (sum + target) / 2;\n        int[][] dp = new int[nums.length][left + 1];\n        if (nums[0] <= left) {\n            dp[0][nums[0]] = 1;\n        }\n        int numZeros = 0;\n        for(int i = 0; i < nums.length; i++) {\n            if(nums[i] == 0) {\n                numZeros++;\n            }\n            dp[i][0] = (int) Math.pow(2, numZeros);\n        }\n        for(int i = 1; i < nums.length; i++) {\n            for(int j = 1; j <= left; j++) {\n                if(nums[i] > j) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n                }\n            }\n        }\n        return dp[nums.length - 1][left];\n    }\n}",
          "description": "Java易于理解的二维数组版本求解目标和问题"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def backtracking(self, candidates, target, total, startIndex, path, result):\n        if total == target:\n            result.append(path[:])  # 将当前路径的副本添加到结果中\n        # 如果 sum + candidates[i] > target，则停止遍历\n        for i in range(startIndex, len(candidates)):\n            if total + candidates[i] > target:\n                break\n            total += candidates[i]\n            path.append(candidates[i])\n            self.backtracking(candidates, target, total, i + 1, path, result)\n            total -= candidates[i]\n            path.pop()\n\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total = sum(nums)\n        if target > total:\n            return 0  # 此时没有方案\n        if (target + total) % 2 != 0:\n            return 0  # 此时没有方案，两个整数相加时要注意数值溢出的问题\n        bagSize = (target + total) // 2  # 转化为组合总和问题，bagSize就是目标和\n\n        # 以下是回溯法代码\n        result = []\n        nums.sort()  # 需要对nums进行排序\n        self.backtracking(nums, bagSize, 0, 0, [], result)\n        return len(result)",
          "description": "Python回溯版求解目标和问题"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)  # 计算nums的总和\n        if abs(target) > total_sum:\n            return 0  # 此时没有方案\n        if (target + total_sum) % 2 == 1:\n            return 0  # 此时没有方案\n        target_sum = (target + total_sum) // 2  # 目标和\n        \n        # 创建二维动态规划数组，行表示选取的元素数量，列表示累加和\n        dp = [[0] * (target_sum + 1) for _ in range(len(nums))]\n        \n        # 初始化状态\n        dp[0][0] = 1\n        if nums[0] <= target_sum:\n            dp[0][nums[0]] = 1\n        numZero = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                numZero += 1\n            dp[i][0] = int(math.pow(2, numZero))\n        \n        # 动态规划过程\n        for i in range(1, len(nums)):\n            for j in range(target_sum + 1):\n                dp[i][j] = dp[i - 1][j]  # 不选取当前元素\n                if j >= nums[i - 1]:\n                    dp[i][j] += dp[i - 1][j - nums[i]]  # 选取当前元素\n        \n        return dp[len(nums)-1][target_sum]  # 返回达到目标和的方案数",
          "description": "Python二维DP数组求解目标和问题"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)  # 计算nums的总和\n        if abs(target) > total_sum:\n            return 0  # 此时没有方案\n        if (target + total_sum) % 2 == 1:\n            return 0  # 此时没有方案\n        target_sum = (target + total_sum) // 2  # 目标和\n        dp = [0] * (target_sum + 1)  # 创建动态规划数组，初始化为0\n        dp[0] = 1  # 当目标和为0时，只有一种方案，即什么都不选\n        for num in nums:\n            for j in range(target_sum, num - 1, -1):\n                dp[j] += dp[j - num]  # 状态转移方程，累加不同选择方式的数量\n        return dp[target_sum]  # 返回达到目标和的方案数",
          "description": "Python一维DP数组求解目标和问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "回溯算法",
      "text": "在回溯算法系列中，一起学过这道题目回溯算法：39. 组合总和 (https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)的录友应该感觉很熟悉，这不就是组合总和问题么？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {\n        if (sum == target) {\n            result.push_back(path);\n        }\n        // 如果 sum + candidates[i] > target 就终止遍历\n        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {\n            sum += candidates[i];\n            path.push_back(candidates[i]);\n            backtracking(candidates, target, sum, i + 1);\n            sum -= candidates[i];\n            path.pop_back();\n\n        }\n    }\npublic:\n    int findTargetSumWays(vector<int>& nums, int S) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (S > sum) return 0; // 此时没有方案\n        if ((S + sum) % 2) return 0; // 此时没有方案，两个int相加的时候要格外小心数值溢出的问题\n        int bagSize = (S + sum) / 2; // 转变为组合总和问题，bagsize就是要求的和\n\n        // 以下为回溯法代码\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end()); // 需要排序\n        backtracking(nums, bagSize, 0, 0);\n        return result.size();\n    }\n};",
          "description": "C++回溯算法求解目标和"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; // 此时没有方案\n        if ((target + sum) % 2 == 1) return 0; // 此时没有方案\n        int bagSize = (target + sum) / 2;\n\n        vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0));\n\n        // 初始化最上行\n        if (nums[0] <= bagSize) dp[0][nums[0]] = 1; \n\n        // 初始化最左列，最左列其他数值在递推公式中就完成了赋值\n        dp[0][0] = 1; \n\n        int numZero = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) numZero++;\n            dp[i][0] = (int) pow(2.0, numZero);\n        }\n\n        // 以下遍历顺序行列可以颠倒\n        for (int i = 1; i < nums.size(); i++) { // 行，遍历物品\n            for (int j = 0; j <= bagSize; j++) { // 列，遍历背包\n                if (nums[i] > j) dp[i][j] = dp[i - 1][j]; \n                else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n            }\n        }\n        return dp[nums.size() - 1][bagSize];\n    }\n};",
          "description": "C++二维DP数组求解目标和"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; // 此时没有方案\n        if ((target + sum) % 2 == 1) return 0; // 此时没有方案\n        int bagSize = (target + sum) / 2;\n        vector<int> dp(bagSize + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n};",
          "description": "C++一维DP数组求解目标和"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) sum += nums[i];\n\n        //如果target的绝对值大于sum，那么是没有方案的\n        if (Math.abs(target) > sum) return 0;\n        //如果(target+sum)除以2的余数不为0，也是没有方案的\n        if ((target + sum) % 2 == 1) return 0;\n\n        int bagSize = (target + sum) / 2;\n        int[] dp = new int[bagSize + 1];\n        dp[0] = 1;\n\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n\n        return dp[bagSize];\n    }\n}",
          "description": "Java一维DP数组求解目标和"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n\n        // 01背包应用之“有多少种不同的填满背包最大容量的方法“\n        // 易于理解的二维数组解法及详细注释\n\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n        }\n\n        // 注意nums[i] >= 0的题目条件，意味着sum也是所有nums[i]的绝对值之和\n        // 这里保证了sum + target一定是大于等于零的，也就是left大于等于零（毕竟我们定义left大于right）\n        if(sum < Math.abs(target)){\n            return 0;\n        }\n\n        // 利用二元一次方程组将left用target和sum表示出来（替换掉right组合），详见代码随想录对此题的分析\n        // 如果所求的left数组和为小数，则作为整数数组的nums里的任何元素自然是没有办法凑出这个小数的\n        if((sum + target) % 2 != 0) {\n            return 0;\n        }\n\n        int left = (sum + target) / 2;\n\n        // dp[i][j]：遍历到数组第i个数时， left为j时的能装满背包的方法总数\n        int[][] dp = new int[nums.length][left + 1];\n\n        // 初始化最上行（dp[0][j])，当nums[0] == j时（注意nums[0]和j都一定是大于等于零的，因此不需要判断等于-j时的情况），有唯一一种取法可取到j，dp[0][j]此时等于1\n        // 其他情况dp[0][j] = 0\n        // java整数数组默认初始值为0\n        if (nums[0] <= left) {\n            dp[0][nums[0]] = 1;\n        }\n\n        // 初始化最左列（dp[i][0])\n        // 当从nums数组的索引0到i的部分有n个0时（n > 0)，每个0可以取+/-，因此有2的n次方中可以取到j = 0的方案\n        // n = 0说明当前遍历到的数组部分没有0全为正数，因此只有一种方案可以取到j = 0（就是所有数都不取）\n        int numZeros = 0;\n        for(int i = 0; i < nums.length; i++) {\n            if(nums[i] == 0) {\n                numZeros++;\n            }\n            dp[i][0] = (int) Math.pow(2, numZeros);\n\n        }\n\n        // 递推公式分析：\n        // 当nums[i] > j时，这时候nums[i]一定不能取，所以是dp[i - 1][j]种方案数\n        // nums[i] <= j时，num[i]可取可不取，因此方案数是dp[i - 1][j] + dp[i - 1][j - nums[i]]\n        // 由递推公式可知，先遍历i或j都可\n        for(int i = 1; i < nums.length; i++) {\n            for(int j = 1; j <= left; j++) {\n                if(nums[i] > j) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n                }\n            }\n        }\n\n\n        return dp[nums.length - 1][left];\n\n    }\n}",
          "description": "Java易于理解的二维数组版本求解目标和"
        },
        {
          "language": "python",
          "code": "class Solution:\n\n    def backtracking(self, candidates, target, total, startIndex, path, result):\n        if total == target:\n            result.append(path[:])  # 将当前路径的副本添加到结果中\n        # 如果 sum + candidates[i] > target，则停止遍历\n        for i in range(startIndex, len(candidates)):\n            if total + candidates[i] > target:\n                break\n            total += candidates[i]\n            path.append(candidates[i])\n            self.backtracking(candidates, target, total, i + 1, path, result)\n            total -= candidates[i]\n            path.pop()\n\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total = sum(nums)\n        if target > total:\n            return 0  # 此时没有方案\n        if (target + total) % 2 != 0:\n            return 0  # 此时没有方案，两个整数相加时要注意数值溢出的问题\n        bagSize = (target + total) // 2  # 转化为组合总和问题，bagSize就是目标和\n\n        # 以下是回溯法代码\n        result = []\n        nums.sort()  # 需要对nums进行排序\n        self.backtracking(nums, bagSize, 0, 0, [], result)\n        return len(result)",
          "description": "Python回溯算法求解目标和"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)  # 计算nums的总和\n        if abs(target) > total_sum:\n            return 0  # 此时没有方案\n        if (target + total_sum) % 2 == 1:\n            return 0  # 此时没有方案\n        target_sum = (target + total_sum) // 2  # 目标和\n\n        # 创建二维动态规划数组，行表示选取的元素数量，列表示累加和\n        dp = [[0] * (target_sum + 1) for _ in range(len(nums) + 1)]\n        dp = [[0] * (target_sum + 1) for _ in range(len(nums))]\n\n        # 初始化状态\n        dp[0][0] = 1\n        if nums[0] <= target_sum:\n            dp[0][nums[0]] = 1\n        numZero = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                numZero += 1\n            dp[i][0] = int(math.pow(2, numZero))\n\n        # 动态规划过程\n        for i in range(1, len(nums)):\n            for j in range(target_sum + 1):\n                dp[i][j] = dp[i - 1][j]  # 不选取当前元素\n                if j >= nums[i - 1]:\n                    dp[i][j] += dp[i - 1][j - nums[i]]  # 选取当前元素\n\n        return dp[len(nums)-1][target_sum]  # 返回达到目标和的方案数",
          "description": "Python二维DP数组求解目标和"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)  # 计算nums的总和\n        if abs(target) > total_sum:\n            return 0  # 此时没有方案\n        if (target + total_sum) % 2 == 1:\n            return 0  # 此时没有方案\n        target_sum = (target + total_sum) // 2  # 目标和\n        dp = [0] * (target_sum + 1)  # 创建动态规划数组，初始化为0\n        dp[0] = 1  # 当目标和为0时，只有一种方案，即什么都不选\n        for num in nums:\n            for j in range(target_sum, num - 1, -1):\n                dp[j] += dp[j - num]  # 状态转移方程，累加不同选择方式的数量\n        return dp[target_sum]  # 返回达到目标和的方案数",
          "description": "Python一维DP数组求解目标和"
        }
      ],
      "subsections": []
    },
    {
      "name": "动态规划 （二维dp数组）",
      "text": "假设加法的总和为x，那么减法对应的总和就是sum - x。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {\n        if (sum == target) {\n            result.push_back(path);\n        }\n        // 如果 sum + candidates[i] > target 就终止遍历\n        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {\n            sum += candidates[i];\n            path.push_back(candidates[i]);\n            backtracking(candidates, target, sum, i + 1);\n            sum -= candidates[i];\n            path.pop_back();\n\n        }\n    }\npublic:\n    int findTargetSumWays(vector<int>& nums, int S) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (S > sum) return 0; // 此时没有方案\n        if ((S + sum) % 2) return 0; // 此时没有方案，两个int相加的时候要格外小心数值溢出的问题\n        int bagSize = (S + sum) / 2; // 转变为组合总和问题，bagsize就是要求的和\n\n        // 以下为回溯法代码\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end()); // 需要排序\n        backtracking(nums, bagSize, 0, 0);\n        return result.size();\n    }\n};",
          "description": "回溯算法"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; // 此时没有方案\n        if ((target + sum) % 2 == 1) return 0; // 此时没有方案\n        int bagSize = (target + sum) / 2;\n        \n        vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0));\n        \n        // 初始化最上行\n        if (nums[0] <= bagSize) dp[0][nums[0]] = 1; \n\n        // 初始化最左列，最左列其他数值在递推公式中就完成了赋值\n        dp[0][0] = 1; \n\n        int numZero = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) numZero++;\n            dp[i][0] = (int) pow(2.0, numZero);\n        }\n\n        // 以下遍历顺序行列可以颠倒\n        for (int i = 1; i < nums.size(); i++) { // 行，遍历物品\n            for (int j = 0; j <= bagSize; j++) { // 列，遍历背包\n                if (nums[i] > j) dp[i][j] = dp[i - 1][j]; \n                else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n            }\n        }\n        return dp[nums.size() - 1][bagSize];\n    }\n};",
          "description": "动态规划（二维dp数组）"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; // 此时没有方案\n        if ((target + sum) % 2 == 1) return 0; // 此时没有方案\n        int bagSize = (target + sum) / 2;\n        vector<int> dp(bagSize + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n};",
          "description": "动态规划（一维dp数组）"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) sum += nums[i];\n\n        //如果target的绝对值大于sum，那么是没有方案的\n        if (Math.abs(target) > sum) return 0;\n        //如果(target+sum)除以2的余数不为0，也是没有方案的\n        if ((target + sum) % 2 == 1) return 0;\n\n        int bagSize = (target + sum) / 2;\n        int[] dp = new int[bagSize + 1];\n        dp[0] = 1;\n\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n\n        return dp[bagSize];\n    }\n}",
          "description": "Java版本的一维DP解决方案"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def backtracking(self, candidates, target, total, startIndex, path, result):\n        if total == target:\n            result.append(path[:])  # 将当前路径的副本添加到结果中\n        # 如果 sum + candidates[i] > target，则停止遍历\n        for i in range(startIndex, len(candidates)):\n            if total + candidates[i] > target:\n                break\n            total += candidates[i]\n            path.append(candidates[i])\n            self.backtracking(candidates, target, total, i + 1, path, result)\n            total -= candidates[i]\n            path.pop()\n\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total = sum(nums)\n        if target > total:\n            return 0  # 此时没有方案\n        if (target + total) % 2 != 0:\n            return 0  # 此时没有方案，两个整数相加时要注意数值溢出的问题\n        bagSize = (target + total) // 2  # 转化为组合总和问题，bagSize就是目标和\n\n        # 以下是回溯法代码\n        result = []\n        nums.sort()  # 需要对nums进行排序\n        self.backtracking(nums, bagSize, 0, 0, [], result)\n        return len(result)",
          "description": "Python回溯版"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)  # 计算nums的总和\n        if abs(target) > total_sum:\n            return 0  # 此时没有方案\n        if (target + total_sum) % 2 == 1:\n            return 0  # 此时没有方案\n        target_sum = (target + total_sum) // 2  # 目标和\n        \n        # 创建二维动态规划数组，行表示选取的元素数量，列表示累加和\n        dp = [[0] * (target_sum + 1) for _ in range(len(nums))]\n        \n        # 初始化状态\n        dp[0][0] = 1\n        if nums[0] <= target_sum:\n            dp[0][nums[0]] = 1\n        numZero = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                numZero += 1\n            dp[i][0] = int(math.pow(2, numZero))\n        \n        # 动态规划过程\n        for i in range(1, len(nums)):\n            for j in range(target_sum + 1):\n                dp[i][j] = dp[i - 1][j]  # 不选取当前元素\n                if j >= nums[i]:\n                    dp[i][j] += dp[i - 1][j - nums[i]]  # 选取当前元素\n        \n        return dp[len(nums)-1][target_sum]  # 返回达到目标和的方案数",
          "description": "Python二维DP"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)  # 计算nums的总和\n        if abs(target) > total_sum:\n            return 0  # 此时没有方案\n        if (target + total_sum) % 2 == 1:\n            return 0  # 此时没有方案\n        target_sum = (target + total_sum) // 2  # 目标和\n        dp = [0] * (target_sum + 1)  # 创建动态规划数组，初始化为0\n        dp[0] = 1  # 当目标和为0时，只有一种方案，即什么都不选\n        for num in nums:\n            for j in range(target_sum, num - 1, -1):\n                dp[j] += dp[j - num]  # 状态转移方程，累加不同选择方式的数量\n        return dp[target_sum]  # 返回达到目标和的方案数",
          "description": "Python一维DP"
        }
      ],
      "subsections": []
    },
    {
      "name": "1. 确定dp数组以及下标的含义",
      "text": "先用 二维 dp数组求解本题，dp[i][j]：使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种方法。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) {int sum = 0;for (int i = 0; i < nums.size(); i++) sum += nums[i];if (abs(target) > sum) return 0;if ((target + sum) % 2 == 1) return 0;int bagSize = (target + sum) / 2;vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0));if (nums[0] <= bagSize) dp[0][nums[0]] = 1;dp[0][0] = 1;int numZero = 0;for (int i = 0; i < nums.size(); i++) {if (nums[i] == 0) numZero++;dp[i][0] = (int) pow(2.0, numZero);}for (int i = 1; i < nums.size(); i++) {for (int j = 0; j <= bagSize; j++) {if (nums[i] > j) dp[i][j] = dp[i - 1][j];else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];}}return dp[nums.size() - 1][bagSize];}};",
          "description": "二维DP数组求解目标和问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) {int sum = 0;for (int i = 0; i < nums.size(); i++) sum += nums[i];if (abs(target) > sum) return 0;if ((target + sum) % 2 == 1) return 0;int bagSize = (target + sum) / 2;vector<int> dp(bagSize + 1, 0);dp[0] = 1;for (int i = 0; i < nums.size(); i++) {for (int j = bagSize; j >= nums[i]; j--) {dp[j] += dp[j - nums[i]];}}return dp[bagSize];}};",
          "description": "一维DP数组求解目标和问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) {int sum = 0;for (int i = 0; i < nums.length; i++) sum += nums[i];if (Math.abs(target) > sum) return 0;if ((target + sum) % 2 == 1) return 0;int bagSize = (target + sum) / 2;int[] dp = new int[bagSize + 1];dp[0] = 1;for (int i = 0; i < nums.length; i++) {for (int j = bagSize; j >= nums[i]; j--) {dp[j] += dp[j - nums[i]];}}return dp[bagSize];}}",
          "description": "Java版一维DP数组求解目标和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums: List[int], target: int) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [0] * (target_sum + 1) dp[0] = 1 for num in nums: for j in range(target_sum, num - 1, -1): dp[j] += dp[j - num] return dp[target_sum]",
          "description": "Python版一维DP数组求解目标和问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "2. 确定递推公式",
      "text": "我们先手动推导一下，这个二维数组里面的数值。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; \n        if ((target + sum) % 2 == 1) return 0; \n        int bagSize = (target + sum) / 2;\n        vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0));\n        if (nums[0] <= bagSize) dp[0][nums[0]] = 1; \n        dp[0][0] = 1; \n        int numZero = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) numZero++;\n            dp[i][0] = (int) pow(2.0, numZero);\n        }\n        for (int i = 1; i < nums.size(); i++) { \n            for (int j = 0; j <= bagSize; j++) { \n                if (nums[i] > j) dp[i][j] = dp[i - 1][j]; \n                else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n            }\n        }\n        return dp[nums.size() - 1][bagSize];\n    }\n};",
          "description": "二维DP数组解决目标和问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; \n        if ((target + sum) % 2 == 1) return 0; \n        int bagSize = (target + sum) / 2;\n        vector<int> dp(bagSize + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n};",
          "description": "一维DP数组解决目标和问题"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) sum += nums[i];\n        if (Math.abs(target) > sum) return 0;\n        if ((target + sum) % 2 == 1) return 0;\n        int bagSize = (target + sum) / 2;\n        int[] dp = new int[bagSize + 1];\n        dp[0] = 1;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n}",
          "description": "Java实现的一维DP数组解决目标和问题"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)\n        if abs(target) > total_sum:\n            return 0\n        if (target + total_sum) % 2 == 1:\n            return 0\n        target_sum = (target + total_sum) // 2\n        dp = [0] * (target_sum + 1)\n        dp[0] = 1\n        for num in nums:\n            for j in range(target_sum, num - 1, -1):\n                dp[j] += dp[j - num]\n        return dp[target_sum]",
          "description": "Python实现的一维DP数组解决目标和问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "3. dp数组如何初始化",
      "text": "先明确递推的方向，如图，求解 dp[2][2] 是由 上方和左上方推出。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& candidates, int target, int sum, int startIndex) { if (sum == target) { result.push_back(path); } for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i + 1); sum -= candidates[i]; path.pop_back(); } } public: int findTargetSumWays(vector<int>& nums, int S) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (S > sum) return 0; if ((S + sum) % 2) return 0; int bagSize = (S + sum) / 2; result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, bagSize, 0, 0); return result.size(); }};",
          "description": "回溯算法求解目标和问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0)); if (nums[0] <= bagSize) dp[0][nums[0]] = 1; dp[0][0] = 1; int numZero = 0; for (int i = 0; i < nums.size(); i++) { if (nums[i] == 0) numZero++; dp[i][0] = (int) pow(2.0, numZero); } for (int i = 1; i < nums.size(); i++) { for (int j = 0; j <= bagSize; j++) { if (nums[i] > j) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; }} return dp[nums.size() - 1][bagSize];}};",
          "description": "二维DP数组求解目标和问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<int> dp(bagSize + 1, 0); dp[0] = 1; for (int i = 0; i < nums.size(); i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; }} return dp[bagSize];}};",
          "description": "一维DP数组求解目标和问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i < nums.length; i++) sum += nums[i]; if (Math.abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; int[] dp = new int[bagSize + 1]; dp[0] = 1; for (int i = 0; i < nums.length; i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; }} return dp[bagSize];}}",
          "description": "Java实现的一维DP数组求解目标和问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for(int i = 0; i < nums.length; i++) { sum += nums[i]; } if(sum < Math.abs(target)) { return 0; } if((sum + target) % 2 != 0) { return 0; } int left = (sum + target) / 2; int[][] dp = new int[nums.length][left + 1]; if (nums[0] <= left) { dp[0][nums[0]] = 1; } int numZeros = 0; for(int i = 0; i < nums.length; i++) { if(nums[i] == 0) { numZeros++; } dp[i][0] = (int) Math.pow(2, numZeros); } for(int i = 1; i < nums.length; i++) { for(int j = 1; j <= left; j++) { if(nums[i] > j) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } } return dp[nums.length - 1][left];}}",
          "description": "易于理解的二维数组版本Java实现求解目标和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def backtracking(self, candidates, target, total, startIndex, path, result): if total == target: result.append(path[:]) for i in range(startIndex, len(candidates)): if total + candidates[i] > target: break total += candidates[i] path.append(candidates[i]) self.backtracking(candidates, target, total, i + 1, path, result) total -= candidates[i] path.pop() def findTargetSumWays(self, nums: List[int], target: int) -> int: total = sum(nums) if target > total: return 0 if (target + total) % 2 != 0: return 0 bagSize = (target + total) // 2 result = [] nums.sort() self.backtracking(nums, bagSize, 0, 0, [], result) return len(result)",
          "description": "Python回溯版求解目标和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums: List[int], target: int) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [[0] * (target_sum + 1) for _ in range(len(nums))] dp[0][0] = 1 if nums[0] <= target_sum: dp[0][nums[0]] = 1 numZero = 0 for i in range(len(nums)): if nums[i] == 0: numZero += 1 dp[i][0] = int(math.pow(2, numZero)) for i in range(1, len(nums)): for j in range(target_sum + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i]: dp[i][j] += dp[i - 1][j - nums[i]] return dp[len(nums)-1][target_sum]",
          "description": "二维DP数组Python实现求解目标和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums: List[int], target: int) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [0] * (target_sum + 1) dp[0] = 1 for num in nums: for j in range(target_sum, num - 1, -1): dp[j] += dp[j - num] return dp[target_sum]",
          "description": "一维DP数组Python实现求解目标和问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "4. 确定遍历顺序",
      "text": "在明确递推方向时，我们知道 当前值 是由上方和左上方推出。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {\n        if (sum == target) {\n            result.push_back(path);\n        }\n        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {\n            sum += candidates[i];\n            path.push_back(candidates[i]);\n            backtracking(candidates, target, sum, i + 1);\n            sum -= candidates[i];\n            path.pop_back();\n        }\n    }\npublic:\n    int findTargetSumWays(vector<int>& nums, int S) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (S > sum) return 0;\n        if ((S + sum) % 2) return 0;\n        int bagSize = (S + sum) / 2;\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end());\n        backtracking(nums, bagSize, 0, 0);\n        return result.size();\n    }\n};",
          "description": "回溯算法解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0;\n        if ((target + sum) % 2 == 1) return 0;\n        int bagSize = (target + sum) / 2;\n        vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0));\n        if (nums[0] <= bagSize) dp[0][nums[0]] = 1;\n        dp[0][0] = 1;\n        int numZero = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) numZero++;\n            dp[i][0] = (int) pow(2.0, numZero);\n        }\n        for (int i = 1; i < nums.size(); i++) {\n            for (int j = 0; j <= bagSize; j++) {\n                if (nums[i] > j) dp[i][j] = dp[i - 1][j];\n                else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n            }\n        }\n        return dp[nums.size() - 1][bagSize];\n    }\n};",
          "description": "二维DP数组解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0;\n        if ((target + sum) % 2 == 1) return 0;\n        int bagSize = (target + sum) / 2;\n        vector<int> dp(bagSize + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n};",
          "description": "一维DP数组解法"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) sum += nums[i];\n        if (Math.abs(target) > sum) return 0;\n        if ((target + sum) % 2 == 1) return 0;\n        int bagSize = (target + sum) / 2;\n        int[] dp = new int[bagSize + 1];\n        dp[0] = 1;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n}",
          "description": "Java版一维DP数组解法"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n        }\n        if(sum < Math.abs(target)) {\n            return 0;\n        }\n        if((sum + target) % 2 != 0) {\n            return 0;\n        }\n        int left = (sum + target) / 2;\n        int[][] dp = new int[nums.length][left + 1];\n        if (nums[0] <= left) {\n            dp[0][nums[0]] = 1;\n        }\n        int numZeros = 0;\n        for(int i = 0; i < nums.length; i++) {\n            if(nums[i] == 0) {\n                numZeros++;\n            }\n            dp[i][0] = (int) Math.pow(2, numZeros);\n        }\n        for(int i = 1; i < nums.length; i++) {\n            for(int j = 1; j <= left; j++) {\n                if(nums[i] > j) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n                }\n            }\n        }\n        return dp[nums.length - 1][left];\n    }\n}",
          "description": "易于理解的二维数组版本Java解法"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def backtracking(self, candidates, target, total, startIndex, path, result):\n        if total == target:\n            result.append(path[:])\n        for i in range(startIndex, len(candidates)):\n            if total + candidates[i] > target:\n                break\n            total += candidates[i]\n            path.append(candidates[i])\n            self.backtracking(candidates, target, total, i + 1, path, result)\n            total -= candidates[i]\n            path.pop()\n\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total = sum(nums)\n        if target > total:\n            return 0\n        if (target + total) % 2 != 0:\n            return 0\n        bagSize = (target + total) // 2\n        result = []\n        nums.sort()\n        self.backtracking(nums, bagSize, 0, 0, [], result)\n        return len(result)",
          "description": "Python回溯算法解法"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)\n        if abs(target) > total_sum:\n            return 0\n        if (target + total_sum) % 2 == 1:\n            return 0\n        target_sum = (target + total_sum) // 2\n        dp = [[0] * (target_sum + 1) for _ in range(len(nums) + 1)]\n        dp[0][0] = 1\n        if nums[0] <= target_sum:\n            dp[0][nums[0]] = 1\n        numZero = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                numZero += 1\n            dp[i][0] = int(math.pow(2, numZero))\n        for i in range(1, len(nums)):\n            for j in range(target_sum + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= nums[i - 1]:\n                    dp[i][j] += dp[i - 1][j - nums[i]]\n        return dp[len(nums)-1][target_sum]",
          "description": "Python二维DP数组解法"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)\n        if abs(target) > total_sum:\n            return 0\n        if (target + total_sum) % 2 == 1:\n            return 0\n        target_sum = (target + total_sum) // 2\n        dp = [0] * (target_sum + 1)\n        dp[0] = 1\n        for num in nums:\n            for j in range(target_sum, num - 1, -1):\n                dp[j] += dp[j - num]\n        return dp[target_sum]",
          "description": "Python一维DP数组解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "5. 举例推导dp数组",
      "text": "输入：nums: [1, 1, 1, 1, 1], target: 3",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {\n        if (sum == target) {\n            result.push_back(path);\n        }\n        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {\n            sum += candidates[i];\n            path.push_back(candidates[i]);\n            backtracking(candidates, target, sum, i + 1);\n            sum -= candidates[i];\n            path.pop_back();\n        }\n    }\npublic:\n    int findTargetSumWays(vector<int>& nums, int S) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (S > sum) return 0;\n        if ((S + sum) % 2) return 0;\n        int bagSize = (S + sum) / 2;\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end());\n        backtracking(nums, bagSize, 0, 0);\n        return result.size();\n    }\n};",
          "description": "回溯算法解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0;\n        if ((target + sum) % 2 == 1) return 0;\n        int bagSize = (target + sum) / 2;\n        vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0));\n        if (nums[0] <= bagSize) dp[0][nums[0]] = 1;\n        dp[0][0] = 1;\n        int numZero = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) numZero++;\n            dp[i][0] = (int) pow(2.0, numZero);\n        }\n        for (int i = 1; i < nums.size(); i++) {\n            for (int j = 0; j <= bagSize; j++) {\n                if (nums[i] > j) dp[i][j] = dp[i - 1][j]; \n                else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n            }\n        }\n        return dp[nums.size() - 1][bagSize];\n    }\n};",
          "description": "二维DP数组解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0;\n        if ((target + sum) % 2 == 1) return 0;\n        int bagSize = (target + sum) / 2;\n        vector<int> dp(bagSize + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n};",
          "description": "一维DP数组解法"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) sum += nums[i];\n        if (Math.abs(target) > sum) return 0;\n        if ((target + sum) % 2 == 1) return 0;\n        int bagSize = (target + sum) / 2;\n        int[] dp = new int[bagSize + 1];\n        dp[0] = 1;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n}",
          "description": "Java版一维DP数组解法"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)\n        if abs(target) > total_sum:\n            return 0\n        if (target + total_sum) % 2 == 1:\n            return 0\n        target_sum = (target + total_sum) // 2\n        dp = [0] * (target_sum + 1)\n        dp[0] = 1\n        for num in nums:\n            for j in range(target_sum, num - 1, -1):\n                dp[j] += dp[j - num]\n        return dp[target_sum]",
          "description": "Python版一维DP数组解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "动态规划 （一维dp数组）",
      "text": "将二维dp数组压缩成一维dp数组，我们在 01背包理论基础（滚动数组） (https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)讲过滚动数组，原理是一样的，即重复利用每一行的数值。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& candidates, int target, int sum, int startIndex) { if (sum == target) { result.push_back(path); } for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i + 1); sum -= candidates[i]; path.pop_back(); } } public: int findTargetSumWays(vector<int>& nums, int S) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (S > sum) return 0; if ((S + sum) % 2) return 0; int bagSize = (S + sum) / 2; result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, bagSize, 0, 0); return result.size(); }};",
          "description": "回溯算法解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0)); if (nums[0] <= bagSize) dp[0][nums[0]] = 1; dp[0][0] = 1; int numZero = 0; for (int i = 0; i < nums.size(); i++) { if (nums[i] == 0) numZero++; dp[i][0] = (int) pow(2.0, numZero); } for (int i = 1; i < nums.size(); i++) { for (int j = 0; j <= bagSize; j++) { if (nums[i] > j) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } return dp[nums.size() - 1][bagSize];}};",
          "description": "二维DP数组解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<int> dp(bagSize + 1, 0); dp[0] = 1; for (int i = 0; i < nums.size(); i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize];}};",
          "description": "一维DP数组解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i < nums.length; i++) sum += nums[i]; if (Math.abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; int[] dp = new int[bagSize + 1]; dp[0] = 1; for (int i = 0; i < nums.length; i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize];}}",
          "description": "Java版一维DP数组解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for(int i = 0; i < nums.length; i++) { sum += nums[i]; } if(sum < Math.abs(target)){ return 0; } if((sum + target) % 2 != 0) { return 0; } int left = (sum + target) / 2; int[][] dp = new int[nums.length][left + 1]; if (nums[0] <= left) { dp[0][nums[0]] = 1; } int numZeros = 0; for(int i = 0; i < nums.length; i++) { if(nums[i] == 0) { numZeros++; } dp[i][0] = (int) Math.pow(2, numZeros); } for(int i = 1; i < nums.length; i++) { for(int j = 1; j <= left; j++) { if(nums[i] > j) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } } return dp[nums.length - 1][left];}}",
          "description": "Java版二维DP数组解法"
        },
        {
          "language": "python",
          "code": "class Solution: def backtracking(self, candidates, target, total, startIndex, path, result): if total == target: result.append(path[:]) for i in range(startIndex, len(candidates)): if total + candidates[i] > target: break total += candidates[i] path.append(candidates[i]) self.backtracking(candidates, target, total, i + 1, path, result) total -= candidates[i] path.pop() def findTargetSumWays(self, nums: List[int], target: int) -> int: total = sum(nums) if target > total: return 0 if (target + total) % 2 != 0: return 0 bagSize = (target + total) // 2 result = [] nums.sort() self.backtracking(nums, bagSize, 0, 0, [], result) return len(result)",
          "description": "Python版回溯算法解法"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums: List[int], target: int) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [[0] * (target_sum + 1) for _ in range(len(nums))] dp[0][0] = 1 if nums[0] <= target_sum: dp[0][nums[0]] = 1 numZero = 0 for i in range(len(nums)): if nums[i] == 0: numZero += 1 dp[i][0] = int(math.pow(2, numZero)) for i in range(1, len(nums)): for j in range(target_sum + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i]: dp[i][j] += dp[i - 1][j - nums[i]] return dp[len(nums)-1][target_sum]",
          "description": "Python版二维DP数组解法"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums: List[int], target: int) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [0] * (target_sum + 1) dp[0] = 1 for num in nums: for j in range(target_sum, num - 1, -1): dp[j] += dp[j - num] return dp[target_sum]",
          "description": "Python版一维DP数组解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "2. 确定递推公式",
      "text": "我们先手动推导一下，这个二维数组里面的数值。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& candidates, int target, int sum, int startIndex) { if (sum == target) { result.push_back(path); } for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i + 1); sum -= candidates[i]; path.pop_back(); } } public: int findTargetSumWays(vector<int>& nums, int S) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (S > sum) return 0; if ((S + sum) % 2) return 0; int bagSize = (S + sum) / 2; result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, bagSize, 0, 0); return result.size(); } };",
          "description": "回溯算法实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0)); if (nums[0] <= bagSize) dp[0][nums[0]] = 1; dp[0][0] = 1; int numZero = 0; for (int i = 0; i < nums.size(); i++) { if (nums[i] == 0) numZero++; dp[i][0] = (int) pow(2.0, numZero); } for (int i = 1; i < nums.size(); i++) { for (int j = 0; j <= bagSize; j++) { if (nums[i] > j) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } return dp[nums.size() - 1][bagSize]; }};",
          "description": "二维DP数组实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<int> dp(bagSize + 1, 0); dp[0] = 1; for (int i = 0; i < nums.size(); i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize]; }};",
          "description": "一维DP数组实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i < nums.length; i++) sum += nums[i]; if (Math.abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; int[] dp = new int[bagSize + 1]; dp[0] = 1; for (int i = 0; i < nums.length; i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize];}}",
          "description": "Java版一维DP数组实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for(int i = 0; i < nums.length; i++) { sum += nums[i]; } if(sum < Math.abs(target)){ return 0; } if((sum + target) % 2 != 0) { return 0; } int left = (sum + target) / 2; int[][] dp = new int[nums.length][left + 1]; if (nums[0] <= left) { dp[0][nums[0]] = 1; } int numZeros = 0; for(int i = 0; i < nums.length; i++) { if(nums[i] == 0) { numZeros++; } dp[i][0] = (int) Math.pow(2, numZeros); } for(int i = 1; i < nums.length; i++) { for(int j = 1; j <= left; j++) { if(nums[i] > j) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } } return dp[nums.length - 1][left];}}",
          "description": "易于理解的Java版二维DP数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def backtracking(self, candidates, target, total, startIndex, path, result): if total == target: result.append(path[:]) for i in range(startIndex, len(candidates)): if total + candidates[i] > target: break total += candidates[i] path.append(candidates[i]) self.backtracking(candidates, target, total, i + 1, path, result) total -= candidates[i] path.pop() def findTargetSumWays(self, nums, target): total = sum(nums) if target > total: return 0 if (target + total) % 2 != 0: return 0 bagSize = (target + total) // 2 result = [] nums.sort() self.backtracking(nums, bagSize, 0, 0, [], result) return len(result)",
          "description": "Python版回溯算法实现"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums, target): total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [[0] * (target_sum + 1) for _ in range(len(nums))] dp[0][0] = 1 if nums[0] <= target_sum: dp[0][nums[0]] = 1 numZero = 0 for i in range(len(nums)): if nums[i] == 0: numZero += 1 dp[i][0] = int(math.pow(2, numZero)) for i in range(1, len(nums)): for j in range(target_sum + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i]: dp[i][j] += dp[i - 1][j - nums[i]] return dp[len(nums)-1][target_sum]",
          "description": "Python版二维DP数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums, target): total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [0] * (target_sum + 1) dp[0] = 1 for num in nums: for j in range(target_sum, num - 1, -1): dp[j] += dp[j - num] return dp[target_sum]",
          "description": "Python版一维DP数组实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "3. dp数组如何初始化",
      "text": "先明确递推的方向，如图，求解 dp[2][2] 是由 上方和左上方推出。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& candidates, int target, int sum, int startIndex) { if (sum == target) { result.push_back(path); } for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i + 1); sum -= candidates[i]; path.pop_back(); } } public: int findTargetSumWays(vector<int>& nums, int S) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (S > sum) return 0; if ((S + sum) % 2) return 0; int bagSize = (S + sum) / 2; result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, bagSize, 0, 0); return result.size(); }};",
          "description": "回溯算法求解目标和问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0)); if (nums[0] <= bagSize) dp[0][nums[0]] = 1; dp[0][0] = 1; int numZero = 0; for (int i = 0; i < nums.size(); i++) { if (nums[i] == 0) numZero++; dp[i][0] = (int) pow(2.0, numZero); } for (int i = 1; i < nums.size(); i++) { for (int j = 0; j <= bagSize; j++) { if (nums[i] > j) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } return dp[nums.size() - 1][bagSize];}};",
          "description": "二维DP数组求解目标和问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<int> dp(bagSize + 1, 0); dp[0] = 1; for (int i = 0; i < nums.size(); i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize];}};",
          "description": "一维DP数组求解目标和问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i < nums.length; i++) sum += nums[i]; if (Math.abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; int[] dp = new int[bagSize + 1]; dp[0] = 1; for (int i = 0; i < nums.length; i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize];}}",
          "description": "Java版本一维DP数组求解目标和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def backtracking(self, candidates, target, total, startIndex, path, result): if total == target: result.append(path[:]) for i in range(startIndex, len(candidates)): if total + candidates[i] > target: break total += candidates[i] path.append(candidates[i]) self.backtracking(candidates, target, total, i + 1, path, result) total -= candidates[i] path.pop() def findTargetSumWays(self, nums, target): total = sum(nums) if target > total: return 0 if (target + total) % 2 != 0: return 0 bagSize = (target + total) // 2 result = [] nums.sort() self.backtracking(nums, bagSize, 0, 0, [], result) return len(result)",
          "description": "Python版本回溯算法求解目标和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums, target): total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [[0] * (target_sum + 1) for _ in range(len(nums))] dp[0][0] = 1 if nums[0] <= target_sum: dp[0][nums[0]] = 1 numZero = 0 for i in range(len(nums)): if nums[i] == 0: numZero += 1 dp[i][0] = int(math.pow(2, numZero)) for i in range(1, len(nums)): for j in range(target_sum + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i]: dp[i][j] += dp[i - 1][j - nums[i]] return dp[len(nums)-1][target_sum]",
          "description": "Python版本二维DP数组求解目标和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums, target): total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [0] * (target_sum + 1) dp[0] = 1 for num in nums: for j in range(target_sum, num - 1, -1): dp[j] += dp[j - num] return dp[target_sum]",
          "description": "Python版本一维DP数组求解目标和问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "4. 确定遍历顺序",
      "text": "在明确递推方向时，我们知道 当前值 是由上方和左上方推出。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& candidates, int target, int sum, int startIndex) { if (sum == target) { result.push_back(path); } for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i + 1); sum -= candidates[i]; path.pop_back(); } } public: int findTargetSumWays(vector<int>& nums, int S) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (S > sum) return 0; if ((S + sum) % 2) return 0; int bagSize = (S + sum) / 2; result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, bagSize, 0, 0); return result.size(); }};",
          "description": "回溯算法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0)); if (nums[0] <= bagSize) dp[0][nums[0]] = 1; dp[0][0] = 1; int numZero = 0; for (int i = 0; i < nums.size(); i++) { if (nums[i] == 0) numZero++; dp[i][0] = (int) pow(2.0, numZero); } for (int i = 1; i < nums.size(); i++) { for (int j = 0; j <= bagSize; j++) { if (nums[i] > j) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } return dp[nums.size() - 1][bagSize];}};",
          "description": "二维DP数组"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<int> dp(bagSize + 1, 0); dp[0] = 1; for (int i = 0; i < nums.size(); i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize];}};",
          "description": "一维DP数组"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i < nums.length; i++) sum += nums[i]; if (Math.abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; int[] dp = new int[bagSize + 1]; dp[0] = 1; for (int i = 0; i < nums.length; i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize];}}",
          "description": "一维DP数组"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for(int i = 0; i < nums.length; i++) { sum += nums[i]; } if(sum < Math.abs(target)) { return 0; } if((sum + target) % 2 != 0) { return 0; } int left = (sum + target) / 2; int[][] dp = new int[nums.length][left + 1]; if (nums[0] <= left) { dp[0][nums[0]] = 1; } int numZeros = 0; for(int i = 0; i < nums.length; i++) { if(nums[i] == 0) { numZeros++; } dp[i][0] = (int) Math.pow(2, numZeros); } for(int i = 1; i < nums.length; i++) { for(int j = 1; j <= left; j++) { if(nums[i] > j) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } } return dp[nums.length - 1][left];}}",
          "description": "二维DP数组"
        },
        {
          "language": "python",
          "code": "class Solution: def backtracking(self, candidates, target, total, startIndex, path, result): if total == target: result.append(path[:]) for i in range(startIndex, len(candidates)): if total + candidates[i] > target: break total += candidates[i] path.append(candidates[i]) self.backtracking(candidates, target, total, i + 1, path, result) total -= candidates[i] path.pop() def findTargetSumWays(self, nums, target) -> int: total = sum(nums) if target > total: return 0 if (target + total) % 2 != 0: return 0 bagSize = (target + total) // 2 result = [] nums.sort() self.backtracking(nums, bagSize, 0, 0, [], result) return len(result)",
          "description": "回溯算法"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums, target) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [[0] * (target_sum + 1) for _ in range(len(nums))] dp[0][0] = 1 if nums[0] <= target_sum: dp[0][nums[0]] = 1 numZero = 0 for i in range(len(nums)): if nums[i] == 0: numZero += 1 dp[i][0] = int(math.pow(2, numZero)) for i in range(1, len(nums)): for j in range(target_sum + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i]: dp[i][j] += dp[i - 1][j - nums[i]] return dp[len(nums)-1][target_sum]",
          "description": "二维DP数组"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums, target) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [0] * (target_sum + 1) dp[0] = 1 for num in nums: for j in range(target_sum, num - 1, -1): dp[j] += dp[j - num] return dp[target_sum]",
          "description": "一维DP数组"
        }
      ],
      "subsections": []
    },
    {
      "name": "5. 举例推导dp数组",
      "text": "输入：nums: [1, 1, 1, 1, 1], target: 3",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& candidates, int target, int sum, int startIndex) { if (sum == target) { result.push_back(path); } for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i + 1); sum -= candidates[i]; path.pop_back(); } } public: int findTargetSumWays(vector<int>& nums, int S) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (S > sum) return 0; if ((S + sum) % 2) return 0; int bagSize = (S + sum) / 2; result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, bagSize, 0, 0); return result.size(); }};",
          "description": "回溯算法版本"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0)); if (nums[0] <= bagSize) dp[0][nums[0]] = 1; dp[0][0] = 1; int numZero = 0; for (int i = 0; i < nums.size(); i++) { if (nums[i] == 0) numZero++; dp[i][0] = (int) pow(2.0, numZero); } for (int i = 1; i < nums.size(); i++) { for (int j = 0; j <= bagSize; j++) { if (nums[i] > j) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } return dp[nums.size() - 1][bagSize];}};",
          "description": "二维DP数组版本"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<int> dp(bagSize + 1, 0); dp[0] = 1; for (int i = 0; i < nums.size(); i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize];}};",
          "description": "一维DP数组版本"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i < nums.length; i++) sum += nums[i]; if (Math.abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; int[] dp = new int[bagSize + 1]; dp[0] = 1; for (int i = 0; i < nums.length; i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize];}}",
          "description": "Java一维DP数组版本"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i < nums.length; i++) sum += nums[i]; if (sum < Math.abs(target)) return 0; if ((sum + target) % 2 != 0) return 0; int left = (sum + target) / 2; int[][] dp = new int[nums.length][left + 1]; if (nums[0] <= left) dp[0][nums[0]] = 1; int numZeros = 0; for (int i = 0; i < nums.length; i++) { if (nums[i] == 0) numZeros++; dp[i][0] = (int) Math.pow(2, numZeros); } for (int i = 1; i < nums.length; i++) { for (int j = 1; j <= left; j++) { if (nums[i] > j) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } return dp[nums.length - 1][left];}}",
          "description": "Java易于理解的二维数组版本"
        },
        {
          "language": "python",
          "code": "class Solution: def backtracking(self, candidates, target, total, startIndex, path, result): if total == target: result.append(path[:]) for i in range(startIndex, len(candidates)): if total + candidates[i] > target: break total += candidates[i] path.append(candidates[i]) self.backtracking(candidates, target, total, i + 1, path, result) total -= candidates[i] path.pop() def findTargetSumWays(self, nums, target): total = sum(nums) if target > total: return 0 if (target + total) % 2 != 0: return 0 bagSize = (target + total) // 2 result = [] nums.sort() self.backtracking(nums, bagSize, 0, 0, [], result) return len(result)",
          "description": "Python回溯版本"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums, target): total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [[0] * (target_sum + 1) for _ in range(len(nums))] dp[0][0] = 1 if nums[0] <= target_sum: dp[0][nums[0]] = 1 numZero = 0 for i in range(len(nums)): if nums[i] == 0: numZero += 1 dp[i][0] = int(math.pow(2, numZero)) for i in range(1, len(nums)): for j in range(target_sum + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i]: dp[i][j] += dp[i - 1][j - nums[i]] return dp[len(nums)-1][target_sum]",
          "description": "Python二维DP版本"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums, target): total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [0] * (target_sum + 1) dp[0] = 1 for num in nums: for j in range(target_sum, num - 1, -1): dp[j] += dp[j - num] return dp[target_sum]",
          "description": "Python一维DP版本"
        }
      ],
      "subsections": []
    },
    {
      "name": "拓展",
      "text": "关于一维dp数组的递推公式解释，也可以从以下维度来理解。 （但还是从二维DP数组到一维DP数组这样更容易理解一些）",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& candidates, int target, int sum, int startIndex) { if (sum == target) { result.push_back(path); } for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i + 1); sum -= candidates[i]; path.pop_back(); } } public: int findTargetSumWays(vector<int>& nums, int S) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (S > sum) return 0; if ((S + sum) % 2) return 0; int bagSize = (S + sum) / 2; result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, bagSize, 0, 0); return result.size(); }};",
          "description": "回溯算法实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0)); if (nums[0] <= bagSize) dp[0][nums[0]] = 1; dp[0][0] = 1; int numZero = 0; for (int i = 0; i < nums.size(); i++) { if (nums[i] == 0) numZero++; dp[i][0] = (int) pow(2.0, numZero); } for (int i = 1; i < nums.size(); i++) { for (int j = 0; j <= bagSize; j++) { if (nums[i] > j) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } return dp[nums.size() - 1][bagSize]; }};",
          "description": "二维DP数组实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<int> dp(bagSize + 1, 0); dp[0] = 1; for (int i = 0; i < nums.size(); i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize]; }};",
          "description": "一维DP数组实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i < nums.length; i++) sum += nums[i]; if (Math.abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; int[] dp = new int[bagSize + 1]; dp[0] = 1; for (int i = 0; i < nums.length; i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize];}}",
          "description": "Java版本一维DP数组实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for(int i = 0; i < nums.length; i++) { sum += nums[i]; } if(sum < Math.abs(target)){ return 0; } if((sum + target) % 2 != 0) { return 0; } int left = (sum + target) / 2; int[][] dp = new int[nums.length][left + 1]; if (nums[0] <= left) { dp[0][nums[0]] = 1; } int numZeros = 0; for(int i = 0; i < nums.length; i++) { if(nums[i] == 0) { numZeros++; } dp[i][0] = (int) Math.pow(2, numZeros); } for(int i = 1; i < nums.length; i++) { for(int j = 1; j <= left; j++) { if(nums[i] > j) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } } return dp[nums.length - 1][left];}}",
          "description": "Java版本易于理解的二维DP数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def backtracking(self, candidates, target, total, startIndex, path, result): if total == target: result.append(path[:]) for i in range(startIndex, len(candidates)): if total + candidates[i] > target: break total += candidates[i] path.append(candidates[i]) self.backtracking(candidates, target, total, i + 1, path, result) total -= candidates[i] path.pop() def findTargetSumWays(self, nums: List[int], target: int) -> int: total = sum(nums) if target > total: return 0 if (target + total) % 2 != 0: return 0 bagSize = (target + total) // 2 result = [] nums.sort() self.backtracking(nums, bagSize, 0, 0, [], result) return len(result)",
          "description": "Python版本回溯算法实现"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums: List[int], target: int) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [[0] * (target_sum + 1) for _ in range(len(nums))] dp[0][0] = 1 if nums[0] <= target_sum: dp[0][nums[0]] = 1 numZero = 0 for i in range(len(nums)): if nums[i] == 0: numZero += 1 dp[i][0] = int(math.pow(2, numZero)) for i in range(1, len(nums)): for j in range(target_sum + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i - 1]: dp[i][j] += dp[i - 1][j - nums[i]] return dp[len(nums)-1][target_sum]",
          "description": "Python版本二维DP数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums: List[int], target: int) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [0] * (target_sum + 1) dp[0] = 1 for num in nums: for j in range(target_sum, num - 1, -1): dp[j] += dp[j - num] return dp[target_sum]",
          "description": "Python版本一维DP数组实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "此时 大家应该不禁想起，我们之前讲过的回溯算法：39. 组合总和 (https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)是不是应该也可以用dp来做啊？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& candidates, int target, int sum, int startIndex) { if (sum == target) { result.push_back(path); } for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i + 1); sum -= candidates[i]; path.pop_back(); } }public: int findTargetSumWays(vector<int>& nums, int S) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (S > sum) return 0; if ((S + sum) % 2) return 0; int bagSize = (S + sum) / 2; result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, bagSize, 0, 0); return result.size(); }};",
          "description": "回溯算法实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0)); if (nums[0] <= bagSize) dp[0][nums[0]] = 1; dp[0][0] = 1; int numZero = 0; for (int i = 0; i < nums.size(); i++) { if (nums[i] == 0) numZero++; dp[i][0] = (int) pow(2.0, numZero); } for (int i = 1; i < nums.size(); i++) { for (int j = 0; j <= bagSize; j++) { if (nums[i] > j) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } return dp[nums.size() - 1][bagSize]; }};",
          "description": "二维DP数组实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<int> dp(bagSize + 1, 0); dp[0] = 1; for (int i = 0; i < nums.size(); i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize]; }};",
          "description": "一维DP数组实现"
        },
        {
          "language": "java",
          "code": "class Solution { public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i < nums.length; i++) sum += nums[i]; if (Math.abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; int[] dp = new int[bagSize + 1]; dp[0] = 1; for (int i = 0; i < nums.length; i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize]; }}",
          "description": "Java版一维DP数组实现"
        },
        {
          "language": "java",
          "code": "class Solution { public int findTargetSumWays(int[] nums, int target) { int sum = 0; for(int i = 0; i < nums.length; i++) { sum += nums[i]; } if(sum < Math.abs(target)){ return 0; } if((sum + target) % 2 != 0) { return 0; } int left = (sum + target) / 2; int[][] dp = new int[nums.length][left + 1]; if (nums[0] <= left) { dp[0][nums[0]] = 1; } int numZeros = 0; for(int i = 0; i < nums.length; i++) { if(nums[i] == 0) { numZeros++; } dp[i][0] = (int) Math.pow(2, numZeros); } for(int i = 1; i < nums.length; i++) { for(int j = 1; j <= left; j++) { if(nums[i] > j) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } } return dp[nums.length - 1][left]; }}",
          "description": "Java版二维DP数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def backtracking(self, candidates, target, total, startIndex, path, result): if total == target: result.append(path[:]) for i in range(startIndex, len(candidates)): if total + candidates[i] > target: break total += candidates[i] path.append(candidates[i]) self.backtracking(candidates, target, total, i + 1, path, result) total -= candidates[i] path.pop() def findTargetSumWays(self, nums, target) -> int: total = sum(nums) if target > total: return 0 if (target + total) % 2 != 0: return 0 bagSize = (target + total) // 2 result = [] nums.sort() self.backtracking(nums, bagSize, 0, 0, [], result) return len(result)",
          "description": "Python版回溯算法实现"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums, target) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [[0] * (target_sum + 1) for _ in range(len(nums))] dp[0][0] = 1 if nums[0] <= target_sum: dp[0][nums[0]] = 1 numZero = 0 for i in range(len(nums)): if nums[i] == 0: numZero += 1 dp[i][0] = int(math.pow(2, numZero)) for i in range(1, len(nums)): for j in range(target_sum + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i]: dp[i][j] += dp[i - 1][j - nums[i]] return dp[len(nums)-1][target_sum]",
          "description": "Python版二维DP数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def findTargetSumWays(self, nums, target) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [0] * (target_sum + 1) dp[0] = 1 for num in nums: for j in range(target_sum, num - 1, -1): dp[j] += dp[j - num] return dp[target_sum]",
          "description": "Python版一维DP数组实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "public int findTargetSumWays(int[] nums, int target) {int sum = 0;for (int i = 0; i < nums.length; i++) sum += nums[i];if (Math.abs(target) > sum) return 0;if ((target + sum) % 2 == 1) return 0;int bagSize = (target + sum) / 2;int[] dp = new int[bagSize + 1];dp[0] = 1;for (int i = 0; i < nums.length; i++) {for (int j = bagSize; j >= nums[i]; j--) {dp[j] += dp[j - nums[i]];}}return dp[bagSize];}",
          "description": "Java实现的一维动态规划解法"
        },
        {
          "language": "java",
          "code": "public int findTargetSumWays(int[] nums, int target) {int sum = 0;for(int i = 0; i < nums.length; i++) {sum += nums[i];}if(sum < Math.abs(target)) {return 0;}if((sum + target) % 2 != 0) {return 0;}int left = (sum + target) / 2;int[][] dp = new int[nums.length][left + 1];if (nums[0] <= left) {dp[0][nums[0]] = 1;}int numZeros = 0;for(int i = 0; i < nums.length; i++) {if(nums[i] == 0) {numZeros++;}dp[i][0] = (int) Math.pow(2, numZeros);}for(int i = 1; i < nums.length; i++) {for(int j = 1; j <= left; j++) {if(nums[i] > j) {dp[i][j] = dp[i - 1][j];} else {dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];}}}return dp[nums.length - 1][left];}",
          "description": "Java实现的二维动态规划解法"
        },
        {
          "language": "python",
          "code": "def findTargetSumWays(self, nums: List[int], target: int) -> int:total_sum = sum(nums)if abs(target) > total_sum:return 0if (target + total_sum) % 2 == 1:return 0target_sum = (target + total_sum) // 2dp = [0] * (target_sum + 1)dp[0] = 1for num in nums:for j in range(target_sum, num - 1, -1):dp[j] += dp[j - num]return dp[target_sum]",
          "description": "Python实现的一维动态规划解法"
        },
        {
          "language": "python",
          "code": "def findTargetSumWays(self, nums: List[int], target: int) -> int:total_sum = sum(nums)if abs(target) > total_sum:return 0if (target + total_sum) % 2 == 1:return 0target_sum = (target + total_sum) // 2dp = [[0] * (target_sum + 1) for _ in range(len(nums))]dp[0][0] = 1if nums[0] <= target_sum:dp[0][nums[0]] = 1numZero = 0for i in range(len(nums)):if nums[i] == 0:numZero += 1dp[i][0] = int(math.pow(2, numZero))for i in range(1, len(nums)):for j in range(target_sum + 1):dp[i][j] = dp[i - 1][j]if j >= nums[i - 1]:dp[i][j] += dp[i - 1][j - nums[i]]return dp[len(nums)-1][target_sum]",
          "description": "Python实现的二维动态规划解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {\n        if (sum == target) {\n            result.push_back(path);\n        }\n        // 如果 sum + candidates[i] > target 就终止遍历\n        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {\n            sum += candidates[i];\n            path.push_back(candidates[i]);\n            backtracking(candidates, target, sum, i + 1);\n            sum -= candidates[i];\n            path.pop_back();\n\n        }\n    }\npublic:\n    int findTargetSumWays(vector<int>& nums, int S) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (S > sum) return 0; // 此时没有方案\n        if ((S + sum) % 2) return 0; // 此时没有方案，两个int相加的时候要格外小心数值溢出的问题\n        int bagSize = (S + sum) / 2; // 转变为组合总和问题，bagsize就是要求的和\n\n        // 以下为回溯法代码\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end()); // 需要排序\n        backtracking(nums, bagSize, 0, 0);\n        return result.size();\n    }\n};",
          "description": "使用回溯算法解决目标和问题。"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; // 此时没有方案\n        if ((target + sum) % 2 == 1) return 0; // 此时没有方案\n        int bagSize = (target + sum) / 2;\n        \n        vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0));\n        \n        // 初始化最上行\n        if (nums[0] <= bagSize) dp[0][nums[0]] = 1; \n\n        // 初始化最左列，最左列其他数值在递推公式中就完成了赋值\n        dp[0][0] = 1; \n\n        int numZero = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) numZero++;\n            dp[i][0] = (int) pow(2.0, numZero);\n        }\n\n        // 以下遍历顺序行列可以颠倒\n        for (int i = 1; i < nums.size(); i++) { // 行，遍历物品\n            for (int j = 0; j <= bagSize; j++) { // 列，遍历背包\n                if (nums[i] > j) dp[i][j] = dp[i - 1][j]; \n                else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n            }\n        }\n        return dp[nums.size() - 1][bagSize];\n    }\n};",
          "description": "使用二维动态规划数组解决目标和问题。"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; // 此时没有方案\n        if ((target + sum) % 2 == 1) return 0; // 此时没有方案\n        int bagSize = (target + sum) / 2;\n        vector<int> dp(bagSize + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n};",
          "description": "使用一维动态规划数组压缩方式解决目标和问题。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) sum += nums[i];\n\n        //如果target的绝对值大于sum，那么是没有方案的\n        if (Math.abs(target) > sum) return 0;\n        //如果(target+sum)除以2的余数不为0，也是没有方案的\n        if ((target + sum) % 2 == 1) return 0;\n\n        int bagSize = (target + sum) / 2;\n        int[] dp = new int[bagSize + 1];\n        dp[0] = 1;\n\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n\n        return dp[bagSize];\n    }\n}",
          "description": "Java版本的一维动态规划数组实现。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def backtracking(self, candidates, target, total, startIndex, path, result):\n        if total == target:\n            result.append(path[:])  # 将当前路径的副本添加到结果中\n        # 如果 sum + candidates[i] > target，则停止遍历\n        for i in range(startIndex, len(candidates)):\n            if total + candidates[i] > target:\n                break\n            total += candidates[i]\n            path.append(candidates[i])\n            self.backtracking(candidates, target, total, i + 1, path, result)\n            total -= candidates[i]\n            path.pop()\n\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total = sum(nums)\n        if target > total:\n            return 0  # 此时没有方案\n        if (target + total) % 2 != 0:\n            return 0  # 此时没有方案，两个整数相加时要注意数值溢出的问题\n        bagSize = (target + total) // 2  # 转化为组合总和问题，bagSize就是目标和\n\n        # 以下是回溯法代码\n        result = []\n        nums.sort()  # 需要对nums进行排序\n        self.backtracking(nums, bagSize, 0, 0, [], result)\n        return len(result)",
          "description": "Python版本的回溯算法实现。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)  # 计算nums的总和\n        if abs(target) > total_sum:\n            return 0  # 此时没有方案\n        if (target + total_sum) % 2 == 1:\n            return 0  # 此时没有方案\n        target_sum = (target + total_sum) // 2  # 目标和\n\n        dp = [0] * (target_sum + 1)  # 创建动态规划数组，初始化为0\n        dp[0] = 1  # 当目标和为0时，只有一种方案，即什么都不选\n        for num in nums:\n            for j in range(target_sum, num - 1, -1):\n                dp[j] += dp[j - num]  # 状态转移方程，累加不同选择方式的数量\n        return dp[target_sum]  # 返回达到目标和的方案数",
          "description": "Python版本的一维动态规划数组实现。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "回溯版",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {\n        if (sum == target) {\n            result.push_back(path);\n        }\n        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {\n            sum += candidates[i];\n            path.push_back(candidates[i]);\n            backtracking(candidates, target, sum, i + 1);\n            sum -= candidates[i];\n            path.pop_back();\n        }\n    }\npublic:\n    int findTargetSumWays(vector<int>& nums, int S) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (S > sum) return 0; \n        if ((S + sum) % 2) return 0; \n        int bagSize = (S + sum) / 2; \n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end()); \n        backtracking(nums, bagSize, 0, 0);\n        return result.size();\n    }\n};",
          "description": "使用回溯法尝试找到所有可以达到目标和的组合，但此方法会超时。"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; \n        if ((target + sum) % 2 == 1) return 0; \n        int bagSize = (target + sum) / 2; \n        vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0));\n        if (nums[0] <= bagSize) dp[0][nums[0]] = 1; \n        dp[0][0] = 1; \n        int numZero = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) numZero++;\n            dp[i][0] = (int) pow(2.0, numZero);\n        }\n        for (int i = 1; i < nums.size(); i++) { \n            for (int j = 0; j <= bagSize; j++) { \n                if (nums[i] > j) dp[i][j] = dp[i - 1][j]; \n                else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n            }\n        }\n        return dp[nums.size() - 1][bagSize];\n    }\n};",
          "description": "二维动态规划实现，通过计算背包问题来解决目标和的问题。"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; \n        if ((target + sum) % 2 == 1) return 0; \n        int bagSize = (target + sum) / 2; \n        vector<int> dp(bagSize + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n};",
          "description": "一维动态规划实现，通过压缩状态空间优化了空间复杂度。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) sum += nums[i];\n        if (Math.abs(target) > sum) return 0;\n        if ((target + sum) % 2 == 1) return 0;\n        int bagSize = (target + sum) / 2;\n        int[] dp = new int[bagSize + 1];\n        dp[0] = 1;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n}",
          "description": "Java版本的一维动态规划解决方案。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def backtracking(self, candidates, target, total, startIndex, path, result):\n        if total == target:\n            result.append(path[:])  \n        for i in range(startIndex, len(candidates)):\n            if total + candidates[i] > target:\n                break\n            total += candidates[i]\n            path.append(candidates[i])\n            self.backtracking(candidates, target, total, i + 1, path, result)\n            total -= candidates[i]\n            path.pop()\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total = sum(nums)\n        if target > total:\n            return 0  \n        if (target + total) % 2 != 0:\n            return 0  \n        bagSize = (target + total) // 2  \n        result = []\n        nums.sort()\n        self.backtracking(nums, bagSize, 0, 0, [], result)\n        return len(result)",
          "description": "Python版本的回溯算法尝试解决目标和问题，但可能会超时。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)  \n        if abs(target) > total_sum:\n            return 0  \n        if (target + total_sum) % 2 == 1:\n            return 0  \n        target_sum = (target + total_sum) // 2  \n        dp = [[0] * (target_sum + 1) for _ in range(len(nums))]\n        dp[0][0] = 1\n        if nums[0] <= target_sum:\n            dp[0][nums[0]] = 1\n        numZero = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                numZero += 1\n            dp[i][0] = int(math.pow(2, numZero))\n        for i in range(1, len(nums)):\n            for j in range(target_sum + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= nums[i - 1]:\n                    dp[i][j] += dp[i - 1][j - nums[i]]\n        return dp[len(nums)-1][target_sum]",
          "description": "Python版本的二维动态规划解法。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)  \n        if abs(target) > total_sum:\n            return 0  \n        if (target + total_sum) % 2 == 1:\n            return 0  \n        target_sum = (target + total_sum) // 2  \n        dp = [0] * (target_sum + 1)  \n        dp[0] = 1  \n        for num in nums:\n            for j in range(target_sum, num - 1, -1):\n                dp[j] += dp[j - num]  \n        return dp[target_sum]",
          "description": "Python版本的一维动态规划解法，空间效率更高。"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n × m)",
    "space_complexity": "O(m)",
    "explanation": "n为正数个数，m为背包容量"
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {private: vector<vector<int>> result; vector<int> path; void backtracking(vector<int>& candidates, int target, int sum, int startIndex) { if (sum == target) { result.push_back(path); } for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i + 1); sum -= candidates[i]; path.pop_back(); } } public: int findTargetSumWays(vector<int>& nums, int S) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (S > sum) return 0; if ((S + sum) % 2) return 0; int bagSize = (S + sum) / 2; result.clear(); path.clear(); sort(nums.begin(), nums.end()); backtracking(nums, bagSize, 0, 0); return result.size(); }};",
      "description": "回溯算法实现"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0)); if (nums[0] <= bagSize) dp[0][nums[0]] = 1; dp[0][0] = 1; int numZero = 0; for (int i = 0; i < nums.size(); i++) { if (nums[i] == 0) numZero++; dp[i][0] = (int) pow(2.0, numZero); } for (int i = 1; i < nums.size(); i++) { for (int j = 0; j <= bagSize; j++) { if (nums[i] > j) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]; } } return dp[nums.size() - 1][bagSize];}};",
      "description": "二维DP数组实现"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int findTargetSumWays(vector<int>& nums, int target) { int sum = 0; for (int i = 0; i < nums.size(); i++) sum += nums[i]; if (abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; vector<int> dp(bagSize + 1, 0); dp[0] = 1; for (int i = 0; i < nums.size(); i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize];}};",
      "description": "一维DP数组实现"
    },
    {
      "language": "java",
      "code": "class Solution {public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int i = 0; i < nums.length; i++) sum += nums[i]; if (Math.abs(target) > sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize = (target + sum) / 2; int[] dp = new int[bagSize + 1]; dp[0] = 1; for (int i = 0; i < nums.length; i++) { for (int j = bagSize; j >= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize];}}",
      "description": "一维DP数组Java实现"
    },
    {
      "language": "python",
      "code": "class Solution: def backtracking(self, candidates, target, total, startIndex, path, result): if total == target: result.append(path[:]) for i in range(startIndex, len(candidates)): if total + candidates[i] > target: break total += candidates[i] path.append(candidates[i]) self.backtracking(candidates, target, total, i + 1, path, result) total -= candidates[i] path.pop() def findTargetSumWays(self, nums: List[int], target: int) -> int: total = sum(nums) if target > total: return 0 if (target + total) % 2 != 0: return 0 bagSize = (target + total) // 2 result = [] nums.sort() self.backtracking(nums, bagSize, 0, 0, [], result) return len(result)",
      "description": "回溯算法Python实现"
    },
    {
      "language": "python",
      "code": "class Solution: def findTargetSumWays(self, nums: List[int], target: int) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [[0] * (target_sum + 1) for _ in range(len(nums))] dp[0][0] = 1 if nums[0] <= target_sum: dp[0][nums[0]] = 1 numZero = 0 for i in range(len(nums)): if nums[i] == 0: numZero += 1 dp[i][0] = int(math.pow(2, numZero)) for i in range(1, len(nums)): for j in range(target_sum + 1): dp[i][j] = dp[i - 1][j] if j >= nums[i]: dp[i][j] += dp[i - 1][j - nums[i]] return dp[len(nums)-1][target_sum]",
      "description": "二维DP数组Python实现"
    },
    {
      "language": "python",
      "code": "class Solution: def findTargetSumWays(self, nums: List[int], target: int) -> int: total_sum = sum(nums) if abs(target) > total_sum: return 0 if (target + total_sum) % 2 == 1: return 0 target_sum = (target + total_sum) // 2 dp = [0] * (target_sum + 1) dp[0] = 1 for num in nums: for j in range(target_sum, num - 1, -1): dp[j] += dp[j - num] return dp[target_sum]",
      "description": "一维DP数组Python实现"
    }
  ],
  "common_mistakes": [
    "忘记检查(S + sum)是否能被2整除，这是判断是否有解的关键。",
    "忽略输入边界条件，如S过大以至于无法通过任何方式达成。",
    "直接使用回溯法可能导致超时，需要优化或改用其他方法如动态规划。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240808161747.png",
      "description": "这张图片展示了背包问题的动态规划解法，通过二维数组记录不同物品在不同背包重量下的最优解。",
      "context": "该图展示了仅考虑物品0时，不同背包容量下装满背包的方法数量。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240808162052.png",
      "description": "这张图片展示了动态规划解决背包问题的过程，表格记录了在不同背包容量下选择不同物品时的最大价值。",
      "context": "这张图展示了在考虑物品0和物品1的情况下，不同背包容量被装满的方法数量。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240808162533.png",
      "description": "这张图片展示了动态规划解决背包问题的过程，表格记录了在不同背包容量下选择不同物品时的最大价值。",
      "context": "该图展示了考虑物品0、物品1和物品2时，不同背包容量下装满背包的方法数量。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240808163312.png",
      "description": "这张图片展示了使用动态规划解决背包问题的过程，表格记录了在不同背包容量下选择物品的最大价值。",
      "context": "该图展示了通过不同组合方式装满指定容量背包的方法数量，特别是强调了dp[2][2]值为3的具体实现方式。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240826111946.png",
      "description": "这张图片展示了三种不同的物品组合方式，每种组合包含两个物品，可能用于说明背包问题中的选择策略或状态转移过程。",
      "context": "该图片展示了当背包容量为2时，选择放入物品0和物品1、物品0和物品2、以及物品1和物品2这三种组合方式来达到dp[2][2] = 3的方法。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240826112805.png",
      "description": "这张图片展示了一个简单的数据结构示意图，包含两个堆叠的元素（物品0和物品1），可能用于解释栈或队列的基本概念。",
      "context": "这张图片展示了背包容量为2时，只考虑物品0和物品1的装载方法，对应于dp[1][2]的情况。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240826113043.png",
      "description": "这张图片展示了两个独立的容器，分别装有“物品0”和“物品1”，可能用于解释背包问题或类似的算法问题中的物品选择与分配。",
      "context": "该图展示了在考虑物品2的情况下，容量为1的背包被装满的方法数，以及如何通过这些方法推导出容量为2的背包中包含或不包含物品2时的装满方法总数。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240826113258.png",
      "description": "这张图片展示了三种不同的物品堆叠方式，可能用于解释背包问题或类似优化问题中的状态转移过程。",
      "context": "该图片展示了在计算容量为2的背包有几种装满方法时，如何通过考虑是否放入物品2来确定dp[2][2]的值。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240826115800.png",
      "description": "这张图片展示了动态规划解决背包问题的过程，通过二维数组记录不同物品在不同背包容量下的最优解。",
      "context": "该图展示了如何通过上方和左上方的值来求解dp[2][2]，帮助理解二维数组中元素间的关系及递推方向。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240827103507.png",
      "description": "这张图片展示了一个动态规划问题的二维表格，用于解决背包问题，其中行代表物品，列代表背包容量。",
      "context": "该图展示了二维数组dp的初始化情况，特别是最上行和最左列（用红色标出），为理解递推公式的应用提供了直观示例。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240827105427.png",
      "description": "这张图片展示了动态规划解决背包问题的过程，通过二维数组记录不同物品和背包容量下的最优解。",
      "context": "该图片展示了在动态规划问题中，从上到下、从左到右的遍历顺序对于正确填充dp数组的重要性。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240827110933.png",
      "description": "这张图片展示了动态规划算法在解决背包问题时的状态转移过程，通过二维数组记录不同物品和背包容量下的最优解。",
      "context": "这张图片展示了当遍历顺序为先从上到下再从左到右时，求解dp[2][2]值过程中矩阵的状态。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240827111013.png",
      "description": "这张图片展示了动态规划算法在解决背包问题时的状态转移过程，通过二维数组记录不同容量下最大价值的更新。",
      "context": "该图片展示了当先从左到右、再从上到下遍历时，矩阵中dp[2][2]值的计算过程，以此说明不同遍历顺序对dp值求解无影响。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240827111612.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20240827111612.png",
      "context": "该图片展示了给定示例中dp数组的状态变化过程，帮助理解如何通过特定的遍历顺序来推导出dp[2][2]等值的变化。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210125120743274.jpg",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20210125120743274.jpg",
      "context": "该图片展示了在给定示例中dp数组的状态变化过程，帮助理解一维动态规划解决特定问题时的数值演变。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240808161747.png",
      "description": "GIF展示了通过逐步添加物品来填充不同容量背包的方法数量变化过程。",
      "context": "该GIF动画展示了仅考虑物品0时，如何逐步填充二维数组来表示不同背包容量下的装包方法数。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240808162052.png",
      "description": "GIF展示了在考虑物品0和物品1时，不同背包容量下装满背包的方法个数变化过程。",
      "context": "此GIF展示了在考虑物品0和物品1的情况下，不同背包容量被装满的方法数量变化。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240808162533.png",
      "description": "GIF展示了通过逐步添加物品来填充不同容量背包的过程，以及每一步可选方案的数量变化。",
      "context": "该GIF动画展示了如何通过考虑不同的物品组合来填充不同容量背包的过程，以此说明动态规划中状态转移的原理。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240808163312.png",
      "description": "GIF展示了动态规划算法中，通过不同选择（是否放入特定物品）计算装满给定容量背包的方法数的过程。",
      "context": "GIF动画展示了如何通过考虑是否放入特定物品来推导出装满给定容量背包的方法数量。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240826111946.png",
      "description": "GIF展示了装满容量为2的背包时，选择不同物品组合（放物品0和1、放物品0和2、放物品1和2）的方法过程。",
      "context": "此GIF展示了在给定背包容量为2的情况下，通过选择不同组合的物品（物品0与物品1、物品0与物品2、物品1与物品2）来达到装满背包的三种方法。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240826112805.png",
      "description": "展示了在考虑物品0和物品1的情况下，容量为2的背包有几种填充方法的过程。",
      "context": "该GIF动画展示了当背包容量为2且只考虑物品0和物品1时，装满背包的不同方法。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240826113043.png",
      "description": "GIF展示了在背包问题中，当考虑放入物品2时，如何通过先空出物品2所需容量来计算装满背包的方法数。",
      "context": "该GIF动画展示了在考虑是否放入物品2的情况下，计算容量为2的背包被装满的不同方法数的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240826113258.png",
      "description": "GIF展示了在给定背包容量下，考虑放入或不放入特定物品时，动态规划数组状态更新的过程。",
      "context": "GIF动画展示了在计算容量为2的背包有几种装满方法时，如何通过加入物品2来体现两种不同的填充方式，并直观地解释了dp[2][2] = dp[1][2] + dp[1][1]这一递推公式的含义。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240827103507.png",
      "description": "GIF展示了二维数组dp的初始化过程，特别标注了最上行与最左列的基础值设定。",
      "context": "GIF动画展示了二维数组dp的初始化过程，特别是最上行和最左列的设定，其中红色部分强调了初始化的基础值。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240827105427.png",
      "description": "GIF展示了二维DP数组从上到下、从左到右填充的过程，用于演示基于之前数值推导当前值的算法执行过程。",
      "context": "GIF动画展示了在动态规划问题中，按照从上到下、从左到右的顺序遍历二维数组以确保每个状态都能基于其上方和左上方的状态被正确推导的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240827110933.png",
      "description": "GIF展示了二维DP数组在不同遍历顺序下的填充过程，说明了无论从上到下再从左到右还是从左到右再从上到下遍历，都不会影响特定单元格的最终值。",
      "context": "GIF动画展示了在01背包问题中，当采用从上到下、再从左到右的遍历方式时DP数组（动态规划数组）逐步填充的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240827111013.png",
      "description": "GIF展示了二维DP数组在先从左到右再从上到下遍历时的状态变化过程。",
      "context": "此GIF动画展示了在给定遍历顺序下，动态规划数组dp的状态变化过程，帮助理解如何逐步填充dp数组以解决特定问题。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240827111612.png",
      "description": "GIF展示了dp数组状态随输入数据变化的过程。",
      "context": "GIF动画展示了在给定输入条件下，dp数组状态随算法执行而逐步变化的过程，帮助理解递推公式的应用及遍历顺序对结果的影响。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210125120743274.jpg",
      "description": "GIF展示了01背包问题中一维dp数组随着遍历物品和背包容量变化而更新的状态过程。",
      "context": "GIF动画展示了在解决01背包问题时，一维dp数组随遍历过程的状态变化。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\目标和.txt",
  "extracted_at": "2025-07-20T23:34:31.294652",
  "raw_content": "目标和\n力扣题目链接(https://leetcode.cn/problems/target-sum/)\n\n难度：中等\n\n给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。\n\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n\n示例：\n\n输入：nums: [1, 1, 1, 1, 1], S: 3\n输出：5\n解释：\n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n一共有5种方法让最终目标和为3。\n\n提示：\n\n数组非空，且长度不会超过 20 。\n初始的数组的和不会超过 1000 。\n保证返回的最终结果能被 32 位整数存下。\n\n#思路\n如果对背包问题不都熟悉先看这两篇：\n\n动态规划：关于01背包问题，你该了解这些！(https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)\n动态规划：关于01背包问题，你该了解这些！（滚动数组）(https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)\n如果跟着「代码随想录」一起学过回溯算法系列 (https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html的录友，看到这道题，应该有一种直觉，就是感觉好像回溯法可以暴搜出来。\n\n事实确实如此，下面我也会给出相应的代码，只不过会超时。\n\n这道题目咋眼一看和动态规划背包啥的也没啥关系。\n\n本题要如何使表达式结果为target，\n\n既然为target，那么就一定有 left组合 - right组合 = target。\n\nleft + right = sum，而sum是固定的。right = sum - left\n\nleft - (sum - left) = target 推导出 left = (target + sum)/2 。\n\ntarget是固定的，sum是固定的，left就可以求出来。\n\n此时问题就是在集合nums中找出和为left的组合。\n\n#回溯算法\n在回溯算法系列中，一起学过这道题目回溯算法：39. 组合总和 (https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)的录友应该感觉很熟悉，这不就是组合总和问题么？\n\n此时可以套组合总和的回溯法代码，几乎不用改动。\n\n当然，也可以转变成序列区间选+ 或者 -，使用回溯法，那就是另一个解法。\n\n我也把代码给出来吧，大家可以了解一下，回溯的解法，以下是本题转变为组合总和问题的回溯法代码：\n\nclass Solution {\nprivate:\n    vector<vector<int>> result;\n    vector<int> path;\n    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {\n        if (sum == target) {\n            result.push_back(path);\n        }\n        // 如果 sum + candidates[i] > target 就终止遍历\n        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {\n            sum += candidates[i];\n            path.push_back(candidates[i]);\n            backtracking(candidates, target, sum, i + 1);\n            sum -= candidates[i];\n            path.pop_back();\n\n        }\n    }\npublic:\n    int findTargetSumWays(vector<int>& nums, int S) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (S > sum) return 0; // 此时没有方案\n        if ((S + sum) % 2) return 0; // 此时没有方案，两个int相加的时候要格外小心数值溢出的问题\n        int bagSize = (S + sum) / 2; // 转变为组合总和问题，bagsize就是要求的和\n\n        // 以下为回溯法代码\n        result.clear();\n        path.clear();\n        sort(nums.begin(), nums.end()); // 需要排序\n        backtracking(nums, bagSize, 0, 0);\n        return result.size();\n    }\n};\n当然以上代码超时了。\n\n也可以使用记忆化回溯，但这里我就不在回溯上下功夫了，直接看动规吧\n\n#动态规划 （二维dp数组）\n假设加法的总和为x，那么减法对应的总和就是sum - x。\n\n所以我们要求的是 x - (sum - x) = target\n\nx = (target + sum) / 2\n\n此时问题就转化为，用nums装满容量为x的背包，有几种方法。\n\n这里的x，就是bagSize，也就是我们后面要求的背包容量。\n\n大家看到(target + sum) / 2 应该担心计算的过程中向下取整有没有影响。\n\n这么担心就对了，例如sum是5，target是2 的话其实就是无解的，所以：\n\n（C++代码中，输入的S 就是题目描述的 target）\nif ((target + sum) % 2 == 1) return 0; // 此时没有方案\n同时如果target 的绝对值已经大于sum，那么也是没有方案的。\n\nif (abs(target) > sum) return 0; // 此时没有方案\n因为每个物品（题目中的1）只用一次！\n\n这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少。\n\n本题则是装满有几种方法。其实这就是一个组合问题了。\n\n#1. 确定dp数组以及下标的含义\n先用 二维 dp数组求解本题，dp[i][j]：使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种方法。\n\n01背包为什么这么定义dp数组，我在0-1背包理论基础 (https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)中 确定dp数组的含义里讲解过。\n\n#2. 确定递推公式\n我们先手动推导一下，这个二维数组里面的数值。\n\n先只考虑物品0，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240808161747.png\n\n（这里的所有物品，都是题目中的数字1）。\n\n装满背包容量为0 的方法个数是1，即 放0件物品。\n\n装满背包容量为1 的方法个数是1，即 放物品0。\n\n装满背包容量为2 的方法个数是0，目前没有办法能装满容量为2的背包。\n\n接下来 考虑 物品0 和 物品1，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240808162052.png\n\n装满背包容量为0 的方法个数是1，即 放0件物品。\n\n装满背包容量为1 的方法个数是2，即 放物品0 或者 放物品1。\n\n装满背包容量为2 的方法个数是1，即 放物品0 和 放物品1。\n\n其他容量都不能装满，所以方法是0。\n\n接下来 考虑 物品0 、物品1 和 物品2 ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240808162533.png\n\n装满背包容量为0 的方法个数是1，即 放0件物品。\n\n装满背包容量为1 的方法个数是3，即 放物品0 或者 放物品1 或者 放物品2。\n\n装满背包容量为2 的方法个数是3，即 放物品0 和 放物品1、放物品0 和 物品2、放物品1 和 物品2。\n\n装满背包容量为3的方法个数是1，即 放物品0 和 物品1 和 物品2。\n\n通过以上举例，我们来看 dp[2][2] 可以有哪些方向推出来。\n\n如图红色部分：\n\nhttps://file1.kamacoder.com/i/algo/20240808163312.png\n\ndp[2][2] = 3，即 放物品0 和 放物品1、放物品0 和 物品 2、放物品1 和 物品2， 如图所示，三种方法：\n\nhttps://file1.kamacoder.com/i/algo/20240826111946.png\n\n容量为2 的背包，如果不放 物品2 有几种方法呢？\n\n有 dp[1][2] 种方法，即 背包容量为2，只考虑物品0 和 物品1 ，有 dp[1][2] 种方法，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240826112805.png\n\n容量为2 的背包， 如果放 物品2 有几种方法呢？\n\n首先 要在背包里 先把物品2的容量空出来， 装满 刨除物品2容量 的背包 有几种方法呢？\n\n刨除物品2容量后的背包容量为 1。\n\n此时装满背包容量为1 有 dp[1][1] 种方法，即： 不放物品2，背包容量为1，只考虑物品 0 和 物品 1，有 dp[1][1] 种方法。\n\n如图：\n\nhttps://file1.kamacoder.com/i/algo/20240826113043.png\n\n有录友可能疑惑，这里计算的是放满 容量为2的背包 有几种方法，那物品2去哪了？\n\n在上面图中，你把物品2补上就好，同样是两种方法。\n\ndp[2][2] = 容量为2的背包不放物品2有几种方法 + 容量为2的背包放物品2有几种方法\n\n所以 dp[2][2] = dp[1][2] + dp[1][1] ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240826113258.png\n\n以上过程，抽象化如下：\n\n不放物品i：即背包容量为j，里面不放物品i，装满有dp[i - 1][j]中方法。\n\n放物品i： 即：先空出物品i的容量，背包容量为（j - 物品i容量），放满背包有 dp[i - 1][j - 物品i容量] 种方法。\n\n本题中，物品i的容量是nums[i]，价值也是nums[i]。\n\n递推公式：dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n\n考到这个递推公式，我们应该注意到，j - nums[i] 作为数组下标，如果 j - nums[i] 小于零呢？\n\n说明背包容量装不下 物品i，所以此时装满背包的方法值 等于 不放物品i的装满背包的方法，即：dp[i][j] = dp[i - 1][j];\n\n所以递推公式：\n\nif (nums[i] > j) dp[i][j] = dp[i - 1][j]; \nelse dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n#3. dp数组如何初始化\n先明确递推的方向，如图，求解 dp[2][2] 是由 上方和左上方推出。\n\nhttps://file1.kamacoder.com/i/algo/20240826115800.png\n\n那么二维数组的最上行 和 最左列一定要初始化，这是递推公式推导的基础，如图红色部分：\n\nhttps://file1.kamacoder.com/i/algo/20240827103507.png\n\n关于dp[0][0]的值，在上面的递推公式讲解中已经讲过，装满背包容量为0 的方法数量是1，即 放0件物品。\n\n那么最上行dp[0][j] 如何初始化呢？\n\ndp[0][j]：只放物品0， 把容量为j的背包填满有几种方法。\n\n只有背包容量为 物品0 的容量的时候，方法为1，正好装满。\n\n其他情况下，要不是装不满，要不是装不下。\n\n所以初始化：dp[0][nums[0]] = 1 ，其他均为0 。\n\n表格最左列也要初始化，dp[i][0] : 背包容量为0， 放物品0 到 物品i，装满有几种方法。\n\n都是有一种方法，就是放0件物品。\n\n即 dp[i][0] = 1\n\n但这里有例外，就是如果 物品数值就是0呢？\n\n如果有两个物品，物品0为0， 物品1为0，装满背包容量为0的方法有几种。\n\n放0件物品\n放物品0\n放物品1\n放物品0 和 物品1\n此时是有4种方法。\n\n其实就是算数组里有t个0，然后按照组合数量求，即 2^t 。\n\n初始化如下：\n\nint numZero = 0;\nfor (int i = 0; i < nums.size(); i++) {\n    if (nums[i] == 0) numZero++;\n    dp[i][0] = (int) pow(2.0, numZero);\n}\n#4. 确定遍历顺序\n在明确递推方向时，我们知道 当前值 是由上方和左上方推出。\n\n那么我们的遍历顺序一定是 从上到下，从左到右。\n\n因为只有这样，我们才能基于之前的数值做推导。\n\n例如下图，如果上方没数值，左上方没数值，就无法推出 dp[2][2]。\n\nhttps://file1.kamacoder.com/i/algo/20240827105427.png\n\n那么是先 从上到下 ，再从左到右遍历，例如这样：\n\nfor (int i = 1; i < nums.size(); i++) { // 行，遍历物品\n    for (int j = 0; j <= bagSize; j++) { // 列，遍历背包\n    }\n}\n还是先 从左到右，再从上到下呢，例如这样：\n\nfor (int j = 0; j <= bagSize; j++) { // 列，遍历背包\n    for (int i = 1; i < nums.size(); i++) { // 行，遍历物品\n    }\n}\n其实以上两种遍历都可以！ （但仅针对二维DP数组是这样的）\n\n这一点我在 01背包理论基础 (https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)中的 遍历顺序部分讲过。\n\n这里我再画图讲一下，以求dp[2][2]为例，当先从上到下，再从左到右遍历，矩阵是这样：\n\nhttps://file1.kamacoder.com/i/algo/20240827110933.png\n\n当先从左到右，再从上到下遍历，矩阵是这样：\n\nhttps://file1.kamacoder.com/i/algo/20240827111013.png\n\n这里大家可以看出，无论是以上哪种遍历，都不影响 dp[2][2]的求值，用来 推导 dp[2][2] 的数值都在。\n\n#5. 举例推导dp数组\n输入：nums: [1, 1, 1, 1, 1], target: 3\n\nbagSize = (target + sum) / 2 = (3 + 5) / 2 = 4\n\ndp数组状态变化如下：\n\nhttps://file1.kamacoder.com/i/algo/20240827111612.png\n\n这么大的矩阵，我们是可以自己手动模拟出来的。\n\n在模拟的过程中，既可以帮我们寻找规律，也可以帮我们验证 递推公式加遍历顺序是不是按照我们想象的结果推进的。\n\n最后二维dp数组的C++代码如下：\n\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; // 此时没有方案\n        if ((target + sum) % 2 == 1) return 0; // 此时没有方案\n        int bagSize = (target + sum) / 2;\n        \n        vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0));\n        \n        // 初始化最上行\n        if (nums[0] <= bagSize) dp[0][nums[0]] = 1; \n\n        // 初始化最左列，最左列其他数值在递推公式中就完成了赋值\n        dp[0][0] = 1; \n\n        int numZero = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) numZero++;\n            dp[i][0] = (int) pow(2.0, numZero);\n        }\n\n        // 以下遍历顺序行列可以颠倒\n        for (int i = 1; i < nums.size(); i++) { // 行，遍历物品\n            for (int j = 0; j <= bagSize; j++) { // 列，遍历背包\n                if (nums[i] > j) dp[i][j] = dp[i - 1][j]; \n                else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n            }\n        }\n        return dp[nums.size() - 1][bagSize];\n    }\n};\n#动态规划 （一维dp数组）\n将二维dp数组压缩成一维dp数组，我们在 01背包理论基础（滚动数组） (https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)讲过滚动数组，原理是一样的，即重复利用每一行的数值。\n\n既然是重复利用每一行，就是将二维数组压缩成一行。\n\ndp[i][j] 去掉 行的维度，即 dp[j]，表示：填满j（包括j）这么大容积的包，有dp[j]种方法。\n\n#2. 确定递推公式\n二维DP数组递推公式： dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n\n去掉维度i 之后，递推公式：dp[j] = dp[j] + dp[j - nums[i]] ，即：dp[j] += dp[j - nums[i]]\n\n这个公式在后面在讲解背包解决排列组合问题的时候还会用到！\n\n#3. dp数组如何初始化\n在上面 二维dp数组中，我们讲解过 dp[0][0] 初始为1，这里dp[0] 同样初始为1 ,即装满背包为0的方法有一种，放0件物品。\n\n#4. 确定遍历顺序\n在动态规划：关于01背包问题，你该了解这些！（滚动数组） (https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)中，我们系统讲过对于01背包问题一维dp的遍历。\n\n遍历物品放在外循环，遍历背包在内循环，且内循环倒序（为了保证物品只使用一次）。\n\n#5. 举例推导dp数组\n输入：nums: [1, 1, 1, 1, 1], target: 3\n\nbagSize = (target + sum) / 2 = (3 + 5) / 2 = 4\n\ndp数组状态变化如下：\n\nhttps://file1.kamacoder.com/i/algo/20210125120743274.jpg\n\n大家可以和 二维dp数组的打印结果做一下对比。\n\n一维DP的C++代码如下：\n\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) sum += nums[i];\n        if (abs(target) > sum) return 0; // 此时没有方案\n        if ((target + sum) % 2 == 1) return 0; // 此时没有方案\n        int bagSize = (target + sum) / 2;\n        vector<int> dp(bagSize + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[bagSize];\n    }\n};\n\n时间复杂度：O(n × m)，n为正数个数，m为背包容量\n空间复杂度：O(m)，m为背包容量\n#拓展\n关于一维dp数组的递推公式解释，也可以从以下维度来理解。 （但还是从二维DP数组到一维DP数组这样更容易理解一些）\n\n确定递推公式\n有哪些来源可以推出dp[j]呢？\n\n只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。\n\n例如：dp[j]，j 为5，\n\n已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。\n已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。\n已经有一个3（nums[i]） 的话，有 dp[2]种方法 凑成 容量为5的背包\n已经有一个4（nums[i]） 的话，有 dp[1]种方法 凑成 容量为5的背包\n已经有一个5 （nums[i]）的话，有 dp[0]种方法 凑成 容量为5的背包\n那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。\n\n所以求组合类问题的公式，都是类似这种：\n\ndp[j] += dp[j - nums[i]]\n#总结\n此时 大家应该不禁想起，我们之前讲过的回溯算法：39. 组合总和 (https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)是不是应该也可以用dp来做啊？\n\n是可以求的，如果仅仅是求个数的话，就可以用dp，但回溯算法：39. 组合总和 (https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)要求的是把所有组合列出来，还是要使用回溯法暴搜的。\n\n本题还是有点难度，理解上从二维DP数组更容易理解，做题上直接用一维DP更简洁一些。\n\n大家可以选择哪种方式自己更容易理解。\n\n在后面得题目中，在求装满背包有几种方法的情况下，递推公式一般为：\n\ndp[j] += dp[j - nums[i]];\n我们在讲解完全背包的时候，还会用到这个递推公式！\n\n#其他语言版本\n#Java\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) sum += nums[i];\n\n        //如果target的绝对值大于sum，那么是没有方案的\n        if (Math.abs(target) > sum) return 0;\n        //如果(target+sum)除以2的余数不为0，也是没有方案的\n        if ((target + sum) % 2 == 1) return 0;\n\n        int bagSize = (target + sum) / 2;\n        int[] dp = new int[bagSize + 1];\n        dp[0] = 1;\n\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = bagSize; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n\n        return dp[bagSize];\n    }\n}\n易于理解的二维数组版本：\n\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n\n        // 01背包应用之“有多少种不同的填满背包最大容量的方法“\n        // 易于理解的二维数组解法及详细注释\n\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n        }\n\n        // 注意nums[i] >= 0的题目条件，意味着sum也是所有nums[i]的绝对值之和\n        // 这里保证了sum + target一定是大于等于零的，也就是left大于等于零（毕竟我们定义left大于right）\n        if(sum < Math.abs(target)){\n            return 0;\n        }\n\n        // 利用二元一次方程组将left用target和sum表示出来（替换掉right组合），详见代码随想录对此题的分析\n        // 如果所求的left数组和为小数，则作为整数数组的nums里的任何元素自然是没有办法凑出这个小数的\n        if((sum + target) % 2 != 0) {\n            return 0;\n        }\n\n        int left = (sum + target) / 2;\n        \n        // dp[i][j]：遍历到数组第i个数时， left为j时的能装满背包的方法总数\n        int[][] dp = new int[nums.length][left + 1];\n\n        // 初始化最上行（dp[0][j])，当nums[0] == j时（注意nums[0]和j都一定是大于等于零的，因此不需要判断等于-j时的情况），有唯一一种取法可取到j，dp[0][j]此时等于1\n        // 其他情况dp[0][j] = 0\n        // java整数数组默认初始值为0\n        if (nums[0] <= left) {\n            dp[0][nums[0]] = 1;\n        }\n\n        // 初始化最左列（dp[i][0])\n        // 当从nums数组的索引0到i的部分有n个0时（n > 0)，每个0可以取+/-，因此有2的n次方中可以取到j = 0的方案\n        // n = 0说明当前遍历到的数组部分没有0全为正数，因此只有一种方案可以取到j = 0（就是所有数都不取）\n        int numZeros = 0;\n        for(int i = 0; i < nums.length; i++) {\n            if(nums[i] == 0) {\n                numZeros++;\n            }\n            dp[i][0] = (int) Math.pow(2, numZeros);\n\n        }\n\n        // 递推公式分析：\n        // 当nums[i] > j时，这时候nums[i]一定不能取，所以是dp[i - 1][j]种方案数\n        // nums[i] <= j时，num[i]可取可不取，因此方案数是dp[i - 1][j] + dp[i - 1][j - nums[i]]\n        // 由递推公式可知，先遍历i或j都可\n        for(int i = 1; i < nums.length; i++) {\n            for(int j = 1; j <= left; j++) {\n                if(nums[i] > j) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];\n                }\n            }\n        }\n\n\n        return dp[nums.length - 1][left];\n        \n    }\n}\n#Python\n回溯版\n\nclass Solution:\n\n\n    def backtracking(self, candidates, target, total, startIndex, path, result):\n        if total == target:\n            result.append(path[:])  # 将当前路径的副本添加到结果中\n        # 如果 sum + candidates[i] > target，则停止遍历\n        for i in range(startIndex, len(candidates)):\n            if total + candidates[i] > target:\n                break\n            total += candidates[i]\n            path.append(candidates[i])\n            self.backtracking(candidates, target, total, i + 1, path, result)\n            total -= candidates[i]\n            path.pop()\n\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total = sum(nums)\n        if target > total:\n            return 0  # 此时没有方案\n        if (target + total) % 2 != 0:\n            return 0  # 此时没有方案，两个整数相加时要注意数值溢出的问题\n        bagSize = (target + total) // 2  # 转化为组合总和问题，bagSize就是目标和\n\n        # 以下是回溯法代码\n        result = []\n        nums.sort()  # 需要对nums进行排序\n        self.backtracking(nums, bagSize, 0, 0, [], result)\n        return len(result)\n\n二维DP\n\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)  # 计算nums的总和\n        if abs(target) > total_sum:\n            return 0  # 此时没有方案\n        if (target + total_sum) % 2 == 1:\n            return 0  # 此时没有方案\n        target_sum = (target + total_sum) // 2  # 目标和\n\n        # 创建二维动态规划数组，行表示选取的元素数量，列表示累加和\n        dp = [[0] * (target_sum + 1) for _ in range(len(nums) + 1)]\n        dp = [[0] * (target_sum + 1) for _ in range(len(nums))]\n\n        # 初始化状态\n        dp[0][0] = 1\n        if nums[0] <= target_sum:\n            dp[0][nums[0]] = 1\n        numZero = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                numZero += 1\n            dp[i][0] = int(math.pow(2, numZero))\n\n        # 动态规划过程\n        for i in range(1, len(nums)):\n            for j in range(target_sum + 1):\n                dp[i][j] = dp[i - 1][j]  # 不选取当前元素\n                if j >= nums[i - 1]:\n                    dp[i][j] += dp[i - 1][j - nums[i]]  # 选取当前元素\n\n        return dp[len(nums)-1][target_sum]  # 返回达到目标和的方案数\n\n\n一维DP\n\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)  # 计算nums的总和\n        if abs(target) > total_sum:\n            return 0  # 此时没有方案\n        if (target + total_sum) % 2 == 1:\n            return 0  # 此时没有方案\n        target_sum = (target + total_sum) // 2  # 目标和\n        dp = [0] * (target_sum + 1)  # 创建动态规划数组，初始化为0\n        dp[0] = 1  # 当目标和为0时，只有一种方案，即什么都不选\n        for num in nums:\n            for j in range(target_sum, num - 1, -1):\n                dp[j] += dp[j - num]  # 状态转移方程，累加不同选择方式的数量\n        return dp[target_sum]  # 返回达到目标和的方案数"
}