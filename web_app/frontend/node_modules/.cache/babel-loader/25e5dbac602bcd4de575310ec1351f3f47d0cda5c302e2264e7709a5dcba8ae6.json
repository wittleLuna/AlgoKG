{"ast":null,"code":"/**\n * vis-network\n * https://visjs.github.io/vis-network/\n *\n * A dynamic, browser-based visualization library.\n *\n * @version 9.1.13\n * @date    2025-06-28T12:43:17.849Z\n *\n * @copyright (c) 2011-2017 Almende B.V, http://almende.com\n * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs\n *\n * @license\n * vis.js is dual licensed under both\n *\n *   1. The Apache 2.0 License\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *   and\n *\n *   2. The MIT License\n *      http://opensource.org/licenses/MIT\n *\n * vis.js may be distributed under either license.\n */\n!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports, require(\"vis-data/peer/umd/vis-data.js\")) : \"function\" == typeof define && define.amd ? define([\"exports\", \"vis-data/peer/umd/vis-data.js\"], e) : e((t = \"undefined\" != typeof globalThis ? globalThis : t || self).vis = t.vis || {}, t.vis);\n}(this, function (t, e) {\n  var i = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\n  function o(t) {\n    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n  }\n  var s = function (t) {\n      return t && t.Math === Math && t;\n    },\n    n = s(\"object\" == typeof globalThis && globalThis) || s(\"object\" == typeof window && window) || s(\"object\" == typeof self && self) || s(\"object\" == typeof i && i) || function () {\n      return this;\n    }() || i || Function(\"return this\")(),\n    r = function (t) {\n      try {\n        return !!t();\n      } catch (t) {\n        return !0;\n      }\n    },\n    a = !r(function () {\n      var t = function () {}.bind();\n      return \"function\" != typeof t || t.hasOwnProperty(\"prototype\");\n    }),\n    h = a,\n    d = Function.prototype,\n    l = d.apply,\n    c = d.call,\n    u = \"object\" == typeof Reflect && Reflect.apply || (h ? c.bind(l) : function () {\n      return c.apply(l, arguments);\n    }),\n    p = a,\n    g = Function.prototype,\n    f = g.call,\n    m = p && g.bind.bind(f, f),\n    y = p ? m : function (t) {\n      return function () {\n        return f.apply(t, arguments);\n      };\n    },\n    b = y,\n    v = b({}.toString),\n    w = b(\"\".slice),\n    _ = function (t) {\n      return w(v(t), 8, -1);\n    },\n    x = _,\n    E = y,\n    O = function (t) {\n      if (\"Function\" === x(t)) return E(t);\n    },\n    C = \"object\" == typeof document && document.all,\n    k = {\n      all: C,\n      IS_HTMLDDA: void 0 === C && void 0 !== C\n    },\n    S = k.all,\n    T = k.IS_HTMLDDA ? function (t) {\n      return \"function\" == typeof t || t === S;\n    } : function (t) {\n      return \"function\" == typeof t;\n    },\n    M = {},\n    D = !r(function () {\n      return 7 !== Object.defineProperty({}, 1, {\n        get: function () {\n          return 7;\n        }\n      })[1];\n    }),\n    I = a,\n    P = Function.prototype.call,\n    B = I ? P.bind(P) : function () {\n      return P.apply(P, arguments);\n    },\n    F = {},\n    z = {}.propertyIsEnumerable,\n    N = Object.getOwnPropertyDescriptor,\n    A = N && !z.call({\n      1: 2\n    }, 1);\n  F.f = A ? function (t) {\n    var e = N(this, t);\n    return !!e && e.enumerable;\n  } : z;\n  var R,\n    j,\n    L = function (t, e) {\n      return {\n        enumerable: !(1 & t),\n        configurable: !(2 & t),\n        writable: !(4 & t),\n        value: e\n      };\n    },\n    H = r,\n    W = _,\n    V = Object,\n    q = y(\"\".split),\n    U = H(function () {\n      return !V(\"z\").propertyIsEnumerable(0);\n    }) ? function (t) {\n      return \"String\" === W(t) ? q(t, \"\") : V(t);\n    } : V,\n    Y = function (t) {\n      return null == t;\n    },\n    X = Y,\n    K = TypeError,\n    G = function (t) {\n      if (X(t)) throw new K(\"Can't call method on \" + t);\n      return t;\n    },\n    Z = U,\n    Q = G,\n    $ = function (t) {\n      return Z(Q(t));\n    },\n    J = T,\n    tt = k.all,\n    et = k.IS_HTMLDDA ? function (t) {\n      return \"object\" == typeof t ? null !== t : J(t) || t === tt;\n    } : function (t) {\n      return \"object\" == typeof t ? null !== t : J(t);\n    },\n    it = {},\n    ot = it,\n    st = n,\n    nt = T,\n    rt = function (t) {\n      return nt(t) ? t : void 0;\n    },\n    at = function (t, e) {\n      return arguments.length < 2 ? rt(ot[t]) || rt(st[t]) : ot[t] && ot[t][e] || st[t] && st[t][e];\n    },\n    ht = y({}.isPrototypeOf),\n    dt = \"undefined\" != typeof navigator && String(navigator.userAgent) || \"\",\n    lt = n,\n    ct = dt,\n    ut = lt.process,\n    pt = lt.Deno,\n    gt = ut && ut.versions || pt && pt.version,\n    ft = gt && gt.v8;\n  ft && (j = (R = ft.split(\".\"))[0] > 0 && R[0] < 4 ? 1 : +(R[0] + R[1])), !j && ct && (!(R = ct.match(/Edge\\/(\\d+)/)) || R[1] >= 74) && (R = ct.match(/Chrome\\/(\\d+)/)) && (j = +R[1]);\n  var mt = j,\n    yt = mt,\n    bt = r,\n    vt = n.String,\n    wt = !!Object.getOwnPropertySymbols && !bt(function () {\n      var t = Symbol(\"symbol detection\");\n      return !vt(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && yt && yt < 41;\n    }),\n    _t = wt && !Symbol.sham && \"symbol\" == typeof Symbol.iterator,\n    xt = at,\n    Et = T,\n    Ot = ht,\n    Ct = Object,\n    kt = _t ? function (t) {\n      return \"symbol\" == typeof t;\n    } : function (t) {\n      var e = xt(\"Symbol\");\n      return Et(e) && Ot(e.prototype, Ct(t));\n    },\n    St = String,\n    Tt = function (t) {\n      try {\n        return St(t);\n      } catch (t) {\n        return \"Object\";\n      }\n    },\n    Mt = T,\n    Dt = Tt,\n    It = TypeError,\n    Pt = function (t) {\n      if (Mt(t)) return t;\n      throw new It(Dt(t) + \" is not a function\");\n    },\n    Bt = Pt,\n    Ft = Y,\n    zt = function (t, e) {\n      var i = t[e];\n      return Ft(i) ? void 0 : Bt(i);\n    },\n    Nt = B,\n    At = T,\n    Rt = et,\n    jt = TypeError,\n    Lt = {\n      exports: {}\n    },\n    Ht = n,\n    Wt = Object.defineProperty,\n    Vt = function (t, e) {\n      try {\n        Wt(Ht, t, {\n          value: e,\n          configurable: !0,\n          writable: !0\n        });\n      } catch (i) {\n        Ht[t] = e;\n      }\n      return e;\n    },\n    qt = \"__core-js_shared__\",\n    Ut = n[qt] || Vt(qt, {}),\n    Yt = Ut;\n  (Lt.exports = function (t, e) {\n    return Yt[t] || (Yt[t] = void 0 !== e ? e : {});\n  })(\"versions\", []).push({\n    version: \"3.33.0\",\n    mode: \"pure\",\n    copyright: \"Â© 2014-2023 Denis Pushkarev (zloirock.ru)\",\n    license: \"https://github.com/zloirock/core-js/blob/v3.33.0/LICENSE\",\n    source: \"https://github.com/zloirock/core-js\"\n  });\n  var Xt = Lt.exports,\n    Kt = G,\n    Gt = Object,\n    Zt = function (t) {\n      return Gt(Kt(t));\n    },\n    Qt = Zt,\n    $t = y({}.hasOwnProperty),\n    Jt = Object.hasOwn || function (t, e) {\n      return $t(Qt(t), e);\n    },\n    te = y,\n    ee = 0,\n    ie = Math.random(),\n    oe = te(1..toString),\n    se = function (t) {\n      return \"Symbol(\" + (void 0 === t ? \"\" : t) + \")_\" + oe(++ee + ie, 36);\n    },\n    ne = Xt,\n    re = Jt,\n    ae = se,\n    he = wt,\n    de = _t,\n    le = n.Symbol,\n    ce = ne(\"wks\"),\n    ue = de ? le.for || le : le && le.withoutSetter || ae,\n    pe = function (t) {\n      return re(ce, t) || (ce[t] = he && re(le, t) ? le[t] : ue(\"Symbol.\" + t)), ce[t];\n    },\n    ge = B,\n    fe = et,\n    me = kt,\n    ye = zt,\n    be = function (t, e) {\n      var i, o;\n      if (\"string\" === e && At(i = t.toString) && !Rt(o = Nt(i, t))) return o;\n      if (At(i = t.valueOf) && !Rt(o = Nt(i, t))) return o;\n      if (\"string\" !== e && At(i = t.toString) && !Rt(o = Nt(i, t))) return o;\n      throw new jt(\"Can't convert object to primitive value\");\n    },\n    ve = TypeError,\n    we = pe(\"toPrimitive\"),\n    _e = function (t, e) {\n      if (!fe(t) || me(t)) return t;\n      var i,\n        o = ye(t, we);\n      if (o) {\n        if (void 0 === e && (e = \"default\"), i = ge(o, t, e), !fe(i) || me(i)) return i;\n        throw new ve(\"Can't convert object to primitive value\");\n      }\n      return void 0 === e && (e = \"number\"), be(t, e);\n    },\n    xe = kt,\n    Ee = function (t) {\n      var e = _e(t, \"string\");\n      return xe(e) ? e : e + \"\";\n    },\n    Oe = et,\n    Ce = n.document,\n    ke = Oe(Ce) && Oe(Ce.createElement),\n    Se = function (t) {\n      return ke ? Ce.createElement(t) : {};\n    },\n    Te = Se,\n    Me = !D && !r(function () {\n      return 7 !== Object.defineProperty(Te(\"div\"), \"a\", {\n        get: function () {\n          return 7;\n        }\n      }).a;\n    }),\n    De = D,\n    Ie = B,\n    Pe = F,\n    Be = L,\n    Fe = $,\n    ze = Ee,\n    Ne = Jt,\n    Ae = Me,\n    Re = Object.getOwnPropertyDescriptor;\n  M.f = De ? Re : function (t, e) {\n    if (t = Fe(t), e = ze(e), Ae) try {\n      return Re(t, e);\n    } catch (t) {}\n    if (Ne(t, e)) return Be(!Ie(Pe.f, t, e), t[e]);\n  };\n  var je = r,\n    Le = T,\n    He = /#|\\.prototype\\./,\n    We = function (t, e) {\n      var i = qe[Ve(t)];\n      return i === Ye || i !== Ue && (Le(e) ? je(e) : !!e);\n    },\n    Ve = We.normalize = function (t) {\n      return String(t).replace(He, \".\").toLowerCase();\n    },\n    qe = We.data = {},\n    Ue = We.NATIVE = \"N\",\n    Ye = We.POLYFILL = \"P\",\n    Xe = We,\n    Ke = Pt,\n    Ge = a,\n    Ze = O(O.bind),\n    Qe = function (t, e) {\n      return Ke(t), void 0 === e ? t : Ge ? Ze(t, e) : function () {\n        return t.apply(e, arguments);\n      };\n    },\n    $e = {},\n    Je = D && r(function () {\n      return 42 !== Object.defineProperty(function () {}, \"prototype\", {\n        value: 42,\n        writable: !1\n      }).prototype;\n    }),\n    ti = et,\n    ei = String,\n    ii = TypeError,\n    oi = function (t) {\n      if (ti(t)) return t;\n      throw new ii(ei(t) + \" is not an object\");\n    },\n    si = D,\n    ni = Me,\n    ri = Je,\n    ai = oi,\n    hi = Ee,\n    di = TypeError,\n    li = Object.defineProperty,\n    ci = Object.getOwnPropertyDescriptor,\n    ui = \"enumerable\",\n    pi = \"configurable\",\n    gi = \"writable\";\n  $e.f = si ? ri ? function (t, e, i) {\n    if (ai(t), e = hi(e), ai(i), \"function\" == typeof t && \"prototype\" === e && \"value\" in i && gi in i && !i[gi]) {\n      var o = ci(t, e);\n      o && o[gi] && (t[e] = i.value, i = {\n        configurable: pi in i ? i[pi] : o[pi],\n        enumerable: ui in i ? i[ui] : o[ui],\n        writable: !1\n      });\n    }\n    return li(t, e, i);\n  } : li : function (t, e, i) {\n    if (ai(t), e = hi(e), ai(i), ni) try {\n      return li(t, e, i);\n    } catch (t) {}\n    if (\"get\" in i || \"set\" in i) throw new di(\"Accessors not supported\");\n    return \"value\" in i && (t[e] = i.value), t;\n  };\n  var fi = $e,\n    mi = L,\n    yi = D ? function (t, e, i) {\n      return fi.f(t, e, mi(1, i));\n    } : function (t, e, i) {\n      return t[e] = i, t;\n    },\n    bi = n,\n    vi = u,\n    wi = O,\n    _i = T,\n    xi = M.f,\n    Ei = Xe,\n    Oi = it,\n    Ci = Qe,\n    ki = yi,\n    Si = Jt,\n    Ti = function (t) {\n      var e = function (i, o, s) {\n        if (this instanceof e) {\n          switch (arguments.length) {\n            case 0:\n              return new t();\n            case 1:\n              return new t(i);\n            case 2:\n              return new t(i, o);\n          }\n          return new t(i, o, s);\n        }\n        return vi(t, this, arguments);\n      };\n      return e.prototype = t.prototype, e;\n    },\n    Mi = function (t, e) {\n      var i,\n        o,\n        s,\n        n,\n        r,\n        a,\n        h,\n        d,\n        l,\n        c = t.target,\n        u = t.global,\n        p = t.stat,\n        g = t.proto,\n        f = u ? bi : p ? bi[c] : (bi[c] || {}).prototype,\n        m = u ? Oi : Oi[c] || ki(Oi, c, {})[c],\n        y = m.prototype;\n      for (n in e) o = !(i = Ei(u ? n : c + (p ? \".\" : \"#\") + n, t.forced)) && f && Si(f, n), a = m[n], o && (h = t.dontCallGetSet ? (l = xi(f, n)) && l.value : f[n]), r = o && h ? h : e[n], o && typeof a == typeof r || (d = t.bind && o ? Ci(r, bi) : t.wrap && o ? Ti(r) : g && _i(r) ? wi(r) : r, (t.sham || r && r.sham || a && a.sham) && ki(d, \"sham\", !0), ki(m, n, d), g && (Si(Oi, s = c + \"Prototype\") || ki(Oi, s, {}), ki(Oi[s], n, r), t.real && y && (i || !y[n]) && ki(y, n, r)));\n    },\n    Di = Math.ceil,\n    Ii = Math.floor,\n    Pi = Math.trunc || function (t) {\n      var e = +t;\n      return (e > 0 ? Ii : Di)(e);\n    },\n    Bi = function (t) {\n      var e = +t;\n      return e != e || 0 === e ? 0 : Pi(e);\n    },\n    Fi = Bi,\n    zi = Math.max,\n    Ni = Math.min,\n    Ai = function (t, e) {\n      var i = Fi(t);\n      return i < 0 ? zi(i + e, 0) : Ni(i, e);\n    },\n    Ri = Bi,\n    ji = Math.min,\n    Li = function (t) {\n      return t > 0 ? ji(Ri(t), 9007199254740991) : 0;\n    },\n    Hi = function (t) {\n      return Li(t.length);\n    },\n    Wi = $,\n    Vi = Ai,\n    qi = Hi,\n    Ui = function (t) {\n      return function (e, i, o) {\n        var s,\n          n = Wi(e),\n          r = qi(n),\n          a = Vi(o, r);\n        if (t && i != i) {\n          for (; r > a;) if ((s = n[a++]) != s) return !0;\n        } else for (; r > a; a++) if ((t || a in n) && n[a] === i) return t || a || 0;\n        return !t && -1;\n      };\n    },\n    Yi = {\n      includes: Ui(!0),\n      indexOf: Ui(!1)\n    },\n    Xi = {},\n    Ki = Jt,\n    Gi = $,\n    Zi = Yi.indexOf,\n    Qi = Xi,\n    $i = y([].push),\n    Ji = function (t, e) {\n      var i,\n        o = Gi(t),\n        s = 0,\n        n = [];\n      for (i in o) !Ki(Qi, i) && Ki(o, i) && $i(n, i);\n      for (; e.length > s;) Ki(o, i = e[s++]) && (~Zi(n, i) || $i(n, i));\n      return n;\n    },\n    to = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"],\n    eo = Ji,\n    io = to,\n    oo = Object.keys || function (t) {\n      return eo(t, io);\n    },\n    so = {};\n  so.f = Object.getOwnPropertySymbols;\n  var no = D,\n    ro = y,\n    ao = B,\n    ho = r,\n    lo = oo,\n    co = so,\n    uo = F,\n    po = Zt,\n    go = U,\n    fo = Object.assign,\n    mo = Object.defineProperty,\n    yo = ro([].concat),\n    bo = !fo || ho(function () {\n      if (no && 1 !== fo({\n        b: 1\n      }, fo(mo({}, \"a\", {\n        enumerable: !0,\n        get: function () {\n          mo(this, \"b\", {\n            value: 3,\n            enumerable: !1\n          });\n        }\n      }), {\n        b: 2\n      })).b) return !0;\n      var t = {},\n        e = {},\n        i = Symbol(\"assign detection\"),\n        o = \"abcdefghijklmnopqrst\";\n      return t[i] = 7, o.split(\"\").forEach(function (t) {\n        e[t] = t;\n      }), 7 !== fo({}, t)[i] || lo(fo({}, e)).join(\"\") !== o;\n    }) ? function (t, e) {\n      for (var i = po(t), o = arguments.length, s = 1, n = co.f, r = uo.f; o > s;) for (var a, h = go(arguments[s++]), d = n ? yo(lo(h), n(h)) : lo(h), l = d.length, c = 0; l > c;) a = d[c++], no && !ao(r, h, a) || (i[a] = h[a]);\n      return i;\n    } : fo,\n    vo = bo;\n  Mi({\n    target: \"Object\",\n    stat: !0,\n    arity: 2,\n    forced: Object.assign !== vo\n  }, {\n    assign: vo\n  });\n  var wo = o(it.Object.assign),\n    _o = y([].slice),\n    xo = y,\n    Eo = Pt,\n    Oo = et,\n    Co = Jt,\n    ko = _o,\n    So = a,\n    To = Function,\n    Mo = xo([].concat),\n    Do = xo([].join),\n    Io = {},\n    Po = So ? To.bind : function (t) {\n      var e = Eo(this),\n        i = e.prototype,\n        o = ko(arguments, 1),\n        s = function () {\n          var i = Mo(o, ko(arguments));\n          return this instanceof s ? function (t, e, i) {\n            if (!Co(Io, e)) {\n              for (var o = [], s = 0; s < e; s++) o[s] = \"a[\" + s + \"]\";\n              Io[e] = To(\"C,a\", \"return new C(\" + Do(o, \",\") + \")\");\n            }\n            return Io[e](t, i);\n          }(e, i.length, i) : e.apply(t, i);\n        };\n      return Oo(i) && (s.prototype = i), s;\n    },\n    Bo = Po;\n  Mi({\n    target: \"Function\",\n    proto: !0,\n    forced: Function.bind !== Bo\n  }, {\n    bind: Bo\n  });\n  var Fo = it,\n    zo = function (t) {\n      return Fo[t + \"Prototype\"];\n    },\n    No = zo(\"Function\").bind,\n    Ao = ht,\n    Ro = No,\n    jo = Function.prototype,\n    Lo = function (t) {\n      var e = t.bind;\n      return t === jo || Ao(jo, t) && e === jo.bind ? Ro : e;\n    },\n    Ho = o(Lo);\n  function Wo(t, e, i, o) {\n    t.beginPath(), t.arc(e, i, o, 0, 2 * Math.PI, !1), t.closePath();\n  }\n  function Vo(t, e, i, o, s, n) {\n    const r = Math.PI / 180;\n    o - 2 * n < 0 && (n = o / 2), s - 2 * n < 0 && (n = s / 2), t.beginPath(), t.moveTo(e + n, i), t.lineTo(e + o - n, i), t.arc(e + o - n, i + n, n, 270 * r, 360 * r, !1), t.lineTo(e + o, i + s - n), t.arc(e + o - n, i + s - n, n, 0, 90 * r, !1), t.lineTo(e + n, i + s), t.arc(e + n, i + s - n, n, 90 * r, 180 * r, !1), t.lineTo(e, i + n), t.arc(e + n, i + n, n, 180 * r, 270 * r, !1), t.closePath();\n  }\n  function qo(t, e, i, o, s) {\n    const n = .5522848,\n      r = o / 2 * n,\n      a = s / 2 * n,\n      h = e + o,\n      d = i + s,\n      l = e + o / 2,\n      c = i + s / 2;\n    t.beginPath(), t.moveTo(e, c), t.bezierCurveTo(e, c - a, l - r, i, l, i), t.bezierCurveTo(l + r, i, h, c - a, h, c), t.bezierCurveTo(h, c + a, l + r, d, l, d), t.bezierCurveTo(l - r, d, e, c + a, e, c), t.closePath();\n  }\n  function Uo(t, e, i, o, s) {\n    const n = s * (1 / 3),\n      r = .5522848,\n      a = o / 2 * r,\n      h = n / 2 * r,\n      d = e + o,\n      l = i + n,\n      c = e + o / 2,\n      u = i + n / 2,\n      p = i + (s - n / 2),\n      g = i + s;\n    t.beginPath(), t.moveTo(d, u), t.bezierCurveTo(d, u + h, c + a, l, c, l), t.bezierCurveTo(c - a, l, e, u + h, e, u), t.bezierCurveTo(e, u - h, c - a, i, c, i), t.bezierCurveTo(c + a, i, d, u - h, d, u), t.lineTo(d, p), t.bezierCurveTo(d, p + h, c + a, g, c, g), t.bezierCurveTo(c - a, g, e, p + h, e, p), t.lineTo(e, u);\n  }\n  function Yo(t, e, i, o, s, n) {\n    t.beginPath(), t.moveTo(e, i);\n    const r = n.length,\n      a = o - e,\n      h = s - i,\n      d = h / a;\n    let l = Math.sqrt(a * a + h * h),\n      c = 0,\n      u = !0,\n      p = 0,\n      g = +n[0];\n    for (; l >= .1;) g = +n[c++ % r], g > l && (g = l), p = Math.sqrt(g * g / (1 + d * d)), p = a < 0 ? -p : p, e += p, i += d * p, !0 === u ? t.lineTo(e, i) : t.moveTo(e, i), l -= g, u = !u;\n  }\n  const Xo = {\n    circle: Wo,\n    dashedLine: Yo,\n    database: Uo,\n    diamond: function (t, e, i, o) {\n      t.beginPath(), t.lineTo(e, i + o), t.lineTo(e + o, i), t.lineTo(e, i - o), t.lineTo(e - o, i), t.closePath();\n    },\n    ellipse: qo,\n    ellipse_vis: qo,\n    hexagon: function (t, e, i, o) {\n      t.beginPath();\n      const s = 2 * Math.PI / 6;\n      t.moveTo(e + o, i);\n      for (let n = 1; n < 6; n++) t.lineTo(e + o * Math.cos(s * n), i + o * Math.sin(s * n));\n      t.closePath();\n    },\n    roundRect: Vo,\n    square: function (t, e, i, o) {\n      t.beginPath(), t.rect(e - o, i - o, 2 * o, 2 * o), t.closePath();\n    },\n    star: function (t, e, i, o) {\n      t.beginPath(), i += .1 * (o *= .82);\n      for (let s = 0; s < 10; s++) {\n        const n = s % 2 == 0 ? 1.3 * o : .5 * o;\n        t.lineTo(e + n * Math.sin(2 * s * Math.PI / 10), i - n * Math.cos(2 * s * Math.PI / 10));\n      }\n      t.closePath();\n    },\n    triangle: function (t, e, i, o) {\n      t.beginPath(), i += .275 * (o *= 1.15);\n      const s = 2 * o,\n        n = s / 2,\n        r = Math.sqrt(3) / 6 * s,\n        a = Math.sqrt(s * s - n * n);\n      t.moveTo(e, i - (a - r)), t.lineTo(e + n, i + r), t.lineTo(e - n, i + r), t.lineTo(e, i - (a - r)), t.closePath();\n    },\n    triangleDown: function (t, e, i, o) {\n      t.beginPath(), i -= .275 * (o *= 1.15);\n      const s = 2 * o,\n        n = s / 2,\n        r = Math.sqrt(3) / 6 * s,\n        a = Math.sqrt(s * s - n * n);\n      t.moveTo(e, i + (a - r)), t.lineTo(e + n, i - r), t.lineTo(e - n, i - r), t.lineTo(e, i + (a - r)), t.closePath();\n    }\n  };\n  var Ko = {\n    exports: {}\n  };\n  !function (t) {\n    function e(t) {\n      if (t) return function (t) {\n        for (var i in e.prototype) t[i] = e.prototype[i];\n        return t;\n      }(t);\n    }\n    t.exports = e, e.prototype.on = e.prototype.addEventListener = function (t, e) {\n      return this._callbacks = this._callbacks || {}, (this._callbacks[\"$\" + t] = this._callbacks[\"$\" + t] || []).push(e), this;\n    }, e.prototype.once = function (t, e) {\n      function i() {\n        this.off(t, i), e.apply(this, arguments);\n      }\n      return i.fn = e, this.on(t, i), this;\n    }, e.prototype.off = e.prototype.removeListener = e.prototype.removeAllListeners = e.prototype.removeEventListener = function (t, e) {\n      if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;\n      var i,\n        o = this._callbacks[\"$\" + t];\n      if (!o) return this;\n      if (1 == arguments.length) return delete this._callbacks[\"$\" + t], this;\n      for (var s = 0; s < o.length; s++) if ((i = o[s]) === e || i.fn === e) {\n        o.splice(s, 1);\n        break;\n      }\n      return 0 === o.length && delete this._callbacks[\"$\" + t], this;\n    }, e.prototype.emit = function (t) {\n      this._callbacks = this._callbacks || {};\n      for (var e = new Array(arguments.length - 1), i = this._callbacks[\"$\" + t], o = 1; o < arguments.length; o++) e[o - 1] = arguments[o];\n      if (i) {\n        o = 0;\n        for (var s = (i = i.slice(0)).length; o < s; ++o) i[o].apply(this, e);\n      }\n      return this;\n    }, e.prototype.listeners = function (t) {\n      return this._callbacks = this._callbacks || {}, this._callbacks[\"$\" + t] || [];\n    }, e.prototype.hasListeners = function (t) {\n      return !!this.listeners(t).length;\n    };\n  }(Ko);\n  var Go = o(Ko.exports),\n    Zo = _,\n    Qo = Array.isArray || function (t) {\n      return \"Array\" === Zo(t);\n    },\n    $o = TypeError,\n    Jo = function (t) {\n      if (t > 9007199254740991) throw $o(\"Maximum allowed index exceeded\");\n      return t;\n    },\n    ts = Ee,\n    es = $e,\n    is = L,\n    os = function (t, e, i) {\n      var o = ts(e);\n      o in t ? es.f(t, o, is(0, i)) : t[o] = i;\n    },\n    ss = {};\n  ss[pe(\"toStringTag\")] = \"z\";\n  var ns = \"[object z]\" === String(ss),\n    rs = ns,\n    as = T,\n    hs = _,\n    ds = pe(\"toStringTag\"),\n    ls = Object,\n    cs = \"Arguments\" === hs(function () {\n      return arguments;\n    }()),\n    us = rs ? hs : function (t) {\n      var e, i, o;\n      return void 0 === t ? \"Undefined\" : null === t ? \"Null\" : \"string\" == typeof (i = function (t, e) {\n        try {\n          return t[e];\n        } catch (t) {}\n      }(e = ls(t), ds)) ? i : cs ? hs(e) : \"Object\" === (o = hs(e)) && as(e.callee) ? \"Arguments\" : o;\n    },\n    ps = T,\n    gs = Ut,\n    fs = y(Function.toString);\n  ps(gs.inspectSource) || (gs.inspectSource = function (t) {\n    return fs(t);\n  });\n  var ms = gs.inspectSource,\n    ys = y,\n    bs = r,\n    vs = T,\n    ws = us,\n    _s = ms,\n    xs = function () {},\n    Es = [],\n    Os = at(\"Reflect\", \"construct\"),\n    Cs = /^\\s*(?:class|function)\\b/,\n    ks = ys(Cs.exec),\n    Ss = !Cs.test(xs),\n    Ts = function (t) {\n      if (!vs(t)) return !1;\n      try {\n        return Os(xs, Es, t), !0;\n      } catch (t) {\n        return !1;\n      }\n    },\n    Ms = function (t) {\n      if (!vs(t)) return !1;\n      switch (ws(t)) {\n        case \"AsyncFunction\":\n        case \"GeneratorFunction\":\n        case \"AsyncGeneratorFunction\":\n          return !1;\n      }\n      try {\n        return Ss || !!ks(Cs, _s(t));\n      } catch (t) {\n        return !0;\n      }\n    };\n  Ms.sham = !0;\n  var Ds = !Os || bs(function () {\n      var t;\n      return Ts(Ts.call) || !Ts(Object) || !Ts(function () {\n        t = !0;\n      }) || t;\n    }) ? Ms : Ts,\n    Is = Qo,\n    Ps = Ds,\n    Bs = et,\n    Fs = pe(\"species\"),\n    zs = Array,\n    Ns = function (t) {\n      var e;\n      return Is(t) && (e = t.constructor, (Ps(e) && (e === zs || Is(e.prototype)) || Bs(e) && null === (e = e[Fs])) && (e = void 0)), void 0 === e ? zs : e;\n    },\n    As = function (t, e) {\n      return new (Ns(t))(0 === e ? 0 : e);\n    },\n    Rs = r,\n    js = mt,\n    Ls = pe(\"species\"),\n    Hs = function (t) {\n      return js >= 51 || !Rs(function () {\n        var e = [];\n        return (e.constructor = {})[Ls] = function () {\n          return {\n            foo: 1\n          };\n        }, 1 !== e[t](Boolean).foo;\n      });\n    },\n    Ws = Mi,\n    Vs = r,\n    qs = Qo,\n    Us = et,\n    Ys = Zt,\n    Xs = Hi,\n    Ks = Jo,\n    Gs = os,\n    Zs = As,\n    Qs = Hs,\n    $s = mt,\n    Js = pe(\"isConcatSpreadable\"),\n    tn = $s >= 51 || !Vs(function () {\n      var t = [];\n      return t[Js] = !1, t.concat()[0] !== t;\n    }),\n    en = function (t) {\n      if (!Us(t)) return !1;\n      var e = t[Js];\n      return void 0 !== e ? !!e : qs(t);\n    };\n  Ws({\n    target: \"Array\",\n    proto: !0,\n    arity: 1,\n    forced: !tn || !Qs(\"concat\")\n  }, {\n    concat: function (t) {\n      var e,\n        i,\n        o,\n        s,\n        n,\n        r = Ys(this),\n        a = Zs(r, 0),\n        h = 0;\n      for (e = -1, o = arguments.length; e < o; e++) if (en(n = -1 === e ? r : arguments[e])) for (s = Xs(n), Ks(h + s), i = 0; i < s; i++, h++) i in n && Gs(a, h, n[i]);else Ks(h + 1), Gs(a, h++, n);\n      return a.length = h, a;\n    }\n  });\n  var on = us,\n    sn = String,\n    nn = function (t) {\n      if (\"Symbol\" === on(t)) throw new TypeError(\"Cannot convert a Symbol value to a string\");\n      return sn(t);\n    },\n    rn = {},\n    an = D,\n    hn = Je,\n    dn = $e,\n    ln = oi,\n    cn = $,\n    un = oo;\n  rn.f = an && !hn ? Object.defineProperties : function (t, e) {\n    ln(t);\n    for (var i, o = cn(e), s = un(e), n = s.length, r = 0; n > r;) dn.f(t, i = s[r++], o[i]);\n    return t;\n  };\n  var pn,\n    gn = at(\"document\", \"documentElement\"),\n    fn = se,\n    mn = Xt(\"keys\"),\n    yn = function (t) {\n      return mn[t] || (mn[t] = fn(t));\n    },\n    bn = oi,\n    vn = rn,\n    wn = to,\n    _n = Xi,\n    xn = gn,\n    En = Se,\n    On = \"prototype\",\n    Cn = \"script\",\n    kn = yn(\"IE_PROTO\"),\n    Sn = function () {},\n    Tn = function (t) {\n      return \"<\" + Cn + \">\" + t + \"</\" + Cn + \">\";\n    },\n    Mn = function (t) {\n      t.write(Tn(\"\")), t.close();\n      var e = t.parentWindow.Object;\n      return t = null, e;\n    },\n    Dn = function () {\n      try {\n        pn = new ActiveXObject(\"htmlfile\");\n      } catch (t) {}\n      var t, e, i;\n      Dn = \"undefined\" != typeof document ? document.domain && pn ? Mn(pn) : (e = En(\"iframe\"), i = \"java\" + Cn + \":\", e.style.display = \"none\", xn.appendChild(e), e.src = String(i), (t = e.contentWindow.document).open(), t.write(Tn(\"document.F=Object\")), t.close(), t.F) : Mn(pn);\n      for (var o = wn.length; o--;) delete Dn[On][wn[o]];\n      return Dn();\n    };\n  _n[kn] = !0;\n  var In = Object.create || function (t, e) {\n      var i;\n      return null !== t ? (Sn[On] = bn(t), i = new Sn(), Sn[On] = null, i[kn] = t) : i = Dn(), void 0 === e ? i : vn.f(i, e);\n    },\n    Pn = {},\n    Bn = Ji,\n    Fn = to.concat(\"length\", \"prototype\");\n  Pn.f = Object.getOwnPropertyNames || function (t) {\n    return Bn(t, Fn);\n  };\n  var zn = {},\n    Nn = Ai,\n    An = Hi,\n    Rn = os,\n    jn = Array,\n    Ln = Math.max,\n    Hn = function (t, e, i) {\n      for (var o = An(t), s = Nn(e, o), n = Nn(void 0 === i ? o : i, o), r = jn(Ln(n - s, 0)), a = 0; s < n; s++, a++) Rn(r, a, t[s]);\n      return r.length = a, r;\n    },\n    Wn = _,\n    Vn = $,\n    qn = Pn.f,\n    Un = Hn,\n    Yn = \"object\" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\n  zn.f = function (t) {\n    return Yn && \"Window\" === Wn(t) ? function (t) {\n      try {\n        return qn(t);\n      } catch (t) {\n        return Un(Yn);\n      }\n    }(t) : qn(Vn(t));\n  };\n  var Xn = yi,\n    Kn = function (t, e, i, o) {\n      return o && o.enumerable ? t[e] = i : Xn(t, e, i), t;\n    },\n    Gn = $e,\n    Zn = function (t, e, i) {\n      return Gn.f(t, e, i);\n    },\n    Qn = {},\n    $n = pe;\n  Qn.f = $n;\n  var Jn,\n    tr,\n    er,\n    ir = it,\n    or = Jt,\n    sr = Qn,\n    nr = $e.f,\n    rr = function (t) {\n      var e = ir.Symbol || (ir.Symbol = {});\n      or(e, t) || nr(e, t, {\n        value: sr.f(t)\n      });\n    },\n    ar = B,\n    hr = at,\n    dr = pe,\n    lr = Kn,\n    cr = function () {\n      var t = hr(\"Symbol\"),\n        e = t && t.prototype,\n        i = e && e.valueOf,\n        o = dr(\"toPrimitive\");\n      e && !e[o] && lr(e, o, function (t) {\n        return ar(i, this);\n      }, {\n        arity: 1\n      });\n    },\n    ur = us,\n    pr = ns ? {}.toString : function () {\n      return \"[object \" + ur(this) + \"]\";\n    },\n    gr = ns,\n    fr = $e.f,\n    mr = yi,\n    yr = Jt,\n    br = pr,\n    vr = pe(\"toStringTag\"),\n    wr = function (t, e, i, o) {\n      if (t) {\n        var s = i ? t : t.prototype;\n        yr(s, vr) || fr(s, vr, {\n          configurable: !0,\n          value: e\n        }), o && !gr && mr(s, \"toString\", br);\n      }\n    },\n    _r = T,\n    xr = n.WeakMap,\n    Er = _r(xr) && /native code/.test(String(xr)),\n    Or = Er,\n    Cr = n,\n    kr = et,\n    Sr = yi,\n    Tr = Jt,\n    Mr = Ut,\n    Dr = yn,\n    Ir = Xi,\n    Pr = \"Object already initialized\",\n    Br = Cr.TypeError,\n    Fr = Cr.WeakMap;\n  if (Or || Mr.state) {\n    var zr = Mr.state || (Mr.state = new Fr());\n    zr.get = zr.get, zr.has = zr.has, zr.set = zr.set, Jn = function (t, e) {\n      if (zr.has(t)) throw new Br(Pr);\n      return e.facade = t, zr.set(t, e), e;\n    }, tr = function (t) {\n      return zr.get(t) || {};\n    }, er = function (t) {\n      return zr.has(t);\n    };\n  } else {\n    var Nr = Dr(\"state\");\n    Ir[Nr] = !0, Jn = function (t, e) {\n      if (Tr(t, Nr)) throw new Br(Pr);\n      return e.facade = t, Sr(t, Nr, e), e;\n    }, tr = function (t) {\n      return Tr(t, Nr) ? t[Nr] : {};\n    }, er = function (t) {\n      return Tr(t, Nr);\n    };\n  }\n  var Ar = {\n      set: Jn,\n      get: tr,\n      has: er,\n      enforce: function (t) {\n        return er(t) ? tr(t) : Jn(t, {});\n      },\n      getterFor: function (t) {\n        return function (e) {\n          var i;\n          if (!kr(e) || (i = tr(e)).type !== t) throw new Br(\"Incompatible receiver, \" + t + \" required\");\n          return i;\n        };\n      }\n    },\n    Rr = Qe,\n    jr = U,\n    Lr = Zt,\n    Hr = Hi,\n    Wr = As,\n    Vr = y([].push),\n    qr = function (t) {\n      var e = 1 === t,\n        i = 2 === t,\n        o = 3 === t,\n        s = 4 === t,\n        n = 6 === t,\n        r = 7 === t,\n        a = 5 === t || n;\n      return function (h, d, l, c) {\n        for (var u, p, g = Lr(h), f = jr(g), m = Rr(d, l), y = Hr(f), b = 0, v = c || Wr, w = e ? v(h, y) : i || r ? v(h, 0) : void 0; y > b; b++) if ((a || b in f) && (p = m(u = f[b], b, g), t)) if (e) w[b] = p;else if (p) switch (t) {\n          case 3:\n            return !0;\n          case 5:\n            return u;\n          case 6:\n            return b;\n          case 2:\n            Vr(w, u);\n        } else switch (t) {\n          case 4:\n            return !1;\n          case 7:\n            Vr(w, u);\n        }\n        return n ? -1 : o || s ? s : w;\n      };\n    },\n    Ur = {\n      forEach: qr(0),\n      map: qr(1),\n      filter: qr(2),\n      some: qr(3),\n      every: qr(4),\n      find: qr(5),\n      findIndex: qr(6),\n      filterReject: qr(7)\n    },\n    Yr = Mi,\n    Xr = n,\n    Kr = B,\n    Gr = y,\n    Zr = D,\n    Qr = wt,\n    $r = r,\n    Jr = Jt,\n    ta = ht,\n    ea = oi,\n    ia = $,\n    oa = Ee,\n    sa = nn,\n    na = L,\n    ra = In,\n    aa = oo,\n    ha = Pn,\n    da = zn,\n    la = so,\n    ca = M,\n    ua = $e,\n    pa = rn,\n    ga = F,\n    fa = Kn,\n    ma = Zn,\n    ya = Xt,\n    ba = Xi,\n    va = se,\n    wa = pe,\n    _a = Qn,\n    xa = rr,\n    Ea = cr,\n    Oa = wr,\n    Ca = Ar,\n    ka = Ur.forEach,\n    Sa = yn(\"hidden\"),\n    Ta = \"Symbol\",\n    Ma = \"prototype\",\n    Da = Ca.set,\n    Ia = Ca.getterFor(Ta),\n    Pa = Object[Ma],\n    Ba = Xr.Symbol,\n    Fa = Ba && Ba[Ma],\n    za = Xr.RangeError,\n    Na = Xr.TypeError,\n    Aa = Xr.QObject,\n    Ra = ca.f,\n    ja = ua.f,\n    La = da.f,\n    Ha = ga.f,\n    Wa = Gr([].push),\n    Va = ya(\"symbols\"),\n    qa = ya(\"op-symbols\"),\n    Ua = ya(\"wks\"),\n    Ya = !Aa || !Aa[Ma] || !Aa[Ma].findChild,\n    Xa = function (t, e, i) {\n      var o = Ra(Pa, e);\n      o && delete Pa[e], ja(t, e, i), o && t !== Pa && ja(Pa, e, o);\n    },\n    Ka = Zr && $r(function () {\n      return 7 !== ra(ja({}, \"a\", {\n        get: function () {\n          return ja(this, \"a\", {\n            value: 7\n          }).a;\n        }\n      })).a;\n    }) ? Xa : ja,\n    Ga = function (t, e) {\n      var i = Va[t] = ra(Fa);\n      return Da(i, {\n        type: Ta,\n        tag: t,\n        description: e\n      }), Zr || (i.description = e), i;\n    },\n    Za = function (t, e, i) {\n      t === Pa && Za(qa, e, i), ea(t);\n      var o = oa(e);\n      return ea(i), Jr(Va, o) ? (i.enumerable ? (Jr(t, Sa) && t[Sa][o] && (t[Sa][o] = !1), i = ra(i, {\n        enumerable: na(0, !1)\n      })) : (Jr(t, Sa) || ja(t, Sa, na(1, {})), t[Sa][o] = !0), Ka(t, o, i)) : ja(t, o, i);\n    },\n    Qa = function (t, e) {\n      ea(t);\n      var i = ia(e),\n        o = aa(i).concat(eh(i));\n      return ka(o, function (e) {\n        Zr && !Kr($a, i, e) || Za(t, e, i[e]);\n      }), t;\n    },\n    $a = function (t) {\n      var e = oa(t),\n        i = Kr(Ha, this, e);\n      return !(this === Pa && Jr(Va, e) && !Jr(qa, e)) && (!(i || !Jr(this, e) || !Jr(Va, e) || Jr(this, Sa) && this[Sa][e]) || i);\n    },\n    Ja = function (t, e) {\n      var i = ia(t),\n        o = oa(e);\n      if (i !== Pa || !Jr(Va, o) || Jr(qa, o)) {\n        var s = Ra(i, o);\n        return !s || !Jr(Va, o) || Jr(i, Sa) && i[Sa][o] || (s.enumerable = !0), s;\n      }\n    },\n    th = function (t) {\n      var e = La(ia(t)),\n        i = [];\n      return ka(e, function (t) {\n        Jr(Va, t) || Jr(ba, t) || Wa(i, t);\n      }), i;\n    },\n    eh = function (t) {\n      var e = t === Pa,\n        i = La(e ? qa : ia(t)),\n        o = [];\n      return ka(i, function (t) {\n        !Jr(Va, t) || e && !Jr(Pa, t) || Wa(o, Va[t]);\n      }), o;\n    };\n  Qr || (Ba = function () {\n    if (ta(Fa, this)) throw new Na(\"Symbol is not a constructor\");\n    var t = arguments.length && void 0 !== arguments[0] ? sa(arguments[0]) : void 0,\n      e = va(t),\n      i = function (t) {\n        this === Pa && Kr(i, qa, t), Jr(this, Sa) && Jr(this[Sa], e) && (this[Sa][e] = !1);\n        var o = na(1, t);\n        try {\n          Ka(this, e, o);\n        } catch (t) {\n          if (!(t instanceof za)) throw t;\n          Xa(this, e, o);\n        }\n      };\n    return Zr && Ya && Ka(Pa, e, {\n      configurable: !0,\n      set: i\n    }), Ga(e, t);\n  }, fa(Fa = Ba[Ma], \"toString\", function () {\n    return Ia(this).tag;\n  }), fa(Ba, \"withoutSetter\", function (t) {\n    return Ga(va(t), t);\n  }), ga.f = $a, ua.f = Za, pa.f = Qa, ca.f = Ja, ha.f = da.f = th, la.f = eh, _a.f = function (t) {\n    return Ga(wa(t), t);\n  }, Zr && ma(Fa, \"description\", {\n    configurable: !0,\n    get: function () {\n      return Ia(this).description;\n    }\n  })), Yr({\n    global: !0,\n    constructor: !0,\n    wrap: !0,\n    forced: !Qr,\n    sham: !Qr\n  }, {\n    Symbol: Ba\n  }), ka(aa(Ua), function (t) {\n    xa(t);\n  }), Yr({\n    target: Ta,\n    stat: !0,\n    forced: !Qr\n  }, {\n    useSetter: function () {\n      Ya = !0;\n    },\n    useSimple: function () {\n      Ya = !1;\n    }\n  }), Yr({\n    target: \"Object\",\n    stat: !0,\n    forced: !Qr,\n    sham: !Zr\n  }, {\n    create: function (t, e) {\n      return void 0 === e ? ra(t) : Qa(ra(t), e);\n    },\n    defineProperty: Za,\n    defineProperties: Qa,\n    getOwnPropertyDescriptor: Ja\n  }), Yr({\n    target: \"Object\",\n    stat: !0,\n    forced: !Qr\n  }, {\n    getOwnPropertyNames: th\n  }), Ea(), Oa(Ba, Ta), ba[Sa] = !0;\n  var ih = wt && !!Symbol.for && !!Symbol.keyFor,\n    oh = Mi,\n    sh = at,\n    nh = Jt,\n    rh = nn,\n    ah = Xt,\n    hh = ih,\n    dh = ah(\"string-to-symbol-registry\"),\n    lh = ah(\"symbol-to-string-registry\");\n  oh({\n    target: \"Symbol\",\n    stat: !0,\n    forced: !hh\n  }, {\n    for: function (t) {\n      var e = rh(t);\n      if (nh(dh, e)) return dh[e];\n      var i = sh(\"Symbol\")(e);\n      return dh[e] = i, lh[i] = e, i;\n    }\n  });\n  var ch = Mi,\n    uh = Jt,\n    ph = kt,\n    gh = Tt,\n    fh = ih,\n    mh = Xt(\"symbol-to-string-registry\");\n  ch({\n    target: \"Symbol\",\n    stat: !0,\n    forced: !fh\n  }, {\n    keyFor: function (t) {\n      if (!ph(t)) throw new TypeError(gh(t) + \" is not a symbol\");\n      if (uh(mh, t)) return mh[t];\n    }\n  });\n  var yh = Qo,\n    bh = T,\n    vh = _,\n    wh = nn,\n    _h = y([].push),\n    xh = Mi,\n    Eh = at,\n    Oh = u,\n    Ch = B,\n    kh = y,\n    Sh = r,\n    Th = T,\n    Mh = kt,\n    Dh = _o,\n    Ih = function (t) {\n      if (bh(t)) return t;\n      if (yh(t)) {\n        for (var e = t.length, i = [], o = 0; o < e; o++) {\n          var s = t[o];\n          \"string\" == typeof s ? _h(i, s) : \"number\" != typeof s && \"Number\" !== vh(s) && \"String\" !== vh(s) || _h(i, wh(s));\n        }\n        var n = i.length,\n          r = !0;\n        return function (t, e) {\n          if (r) return r = !1, e;\n          if (yh(this)) return e;\n          for (var o = 0; o < n; o++) if (i[o] === t) return e;\n        };\n      }\n    },\n    Ph = wt,\n    Bh = String,\n    Fh = Eh(\"JSON\", \"stringify\"),\n    zh = kh(/./.exec),\n    Nh = kh(\"\".charAt),\n    Ah = kh(\"\".charCodeAt),\n    Rh = kh(\"\".replace),\n    jh = kh(1..toString),\n    Lh = /[\\uD800-\\uDFFF]/g,\n    Hh = /^[\\uD800-\\uDBFF]$/,\n    Wh = /^[\\uDC00-\\uDFFF]$/,\n    Vh = !Ph || Sh(function () {\n      var t = Eh(\"Symbol\")(\"stringify detection\");\n      return \"[null]\" !== Fh([t]) || \"{}\" !== Fh({\n        a: t\n      }) || \"{}\" !== Fh(Object(t));\n    }),\n    qh = Sh(function () {\n      return '\"\\\\udf06\\\\ud834\"' !== Fh(\"\\udf06\\ud834\") || '\"\\\\udead\"' !== Fh(\"\\udead\");\n    }),\n    Uh = function (t, e) {\n      var i = Dh(arguments),\n        o = Ih(e);\n      if (Th(o) || void 0 !== t && !Mh(t)) return i[1] = function (t, e) {\n        if (Th(o) && (e = Ch(o, this, Bh(t), e)), !Mh(e)) return e;\n      }, Oh(Fh, null, i);\n    },\n    Yh = function (t, e, i) {\n      var o = Nh(i, e - 1),\n        s = Nh(i, e + 1);\n      return zh(Hh, t) && !zh(Wh, s) || zh(Wh, t) && !zh(Hh, o) ? \"\\\\u\" + jh(Ah(t, 0), 16) : t;\n    };\n  Fh && xh({\n    target: \"JSON\",\n    stat: !0,\n    arity: 3,\n    forced: Vh || qh\n  }, {\n    stringify: function (t, e, i) {\n      var o = Dh(arguments),\n        s = Oh(Vh ? Uh : Fh, null, o);\n      return qh && \"string\" == typeof s ? Rh(s, Lh, Yh) : s;\n    }\n  });\n  var Xh = so,\n    Kh = Zt;\n  Mi({\n    target: \"Object\",\n    stat: !0,\n    forced: !wt || r(function () {\n      Xh.f(1);\n    })\n  }, {\n    getOwnPropertySymbols: function (t) {\n      var e = Xh.f;\n      return e ? e(Kh(t)) : [];\n    }\n  }), rr(\"asyncIterator\"), rr(\"hasInstance\"), rr(\"isConcatSpreadable\"), rr(\"iterator\"), rr(\"match\"), rr(\"matchAll\"), rr(\"replace\"), rr(\"search\"), rr(\"species\"), rr(\"split\");\n  var Gh = cr;\n  rr(\"toPrimitive\"), Gh();\n  var Zh = at,\n    Qh = wr;\n  rr(\"toStringTag\"), Qh(Zh(\"Symbol\"), \"Symbol\"), rr(\"unscopables\"), wr(n.JSON, \"JSON\", !0);\n  var $h,\n    Jh,\n    td,\n    ed = it.Symbol,\n    id = {},\n    od = D,\n    sd = Jt,\n    nd = Function.prototype,\n    rd = od && Object.getOwnPropertyDescriptor,\n    ad = sd(nd, \"name\"),\n    hd = {\n      EXISTS: ad,\n      PROPER: ad && \"something\" === function () {}.name,\n      CONFIGURABLE: ad && (!od || od && rd(nd, \"name\").configurable)\n    },\n    dd = !r(function () {\n      function t() {}\n      return t.prototype.constructor = null, Object.getPrototypeOf(new t()) !== t.prototype;\n    }),\n    ld = Jt,\n    cd = T,\n    ud = Zt,\n    pd = dd,\n    gd = yn(\"IE_PROTO\"),\n    fd = Object,\n    md = fd.prototype,\n    yd = pd ? fd.getPrototypeOf : function (t) {\n      var e = ud(t);\n      if (ld(e, gd)) return e[gd];\n      var i = e.constructor;\n      return cd(i) && e instanceof i ? i.prototype : e instanceof fd ? md : null;\n    },\n    bd = r,\n    vd = T,\n    wd = et,\n    _d = In,\n    xd = yd,\n    Ed = Kn,\n    Od = pe(\"iterator\"),\n    Cd = !1;\n  [].keys && (\"next\" in (td = [].keys()) ? (Jh = xd(xd(td))) !== Object.prototype && ($h = Jh) : Cd = !0);\n  var kd = !wd($h) || bd(function () {\n    var t = {};\n    return $h[Od].call(t) !== t;\n  });\n  vd(($h = kd ? {} : _d($h))[Od]) || Ed($h, Od, function () {\n    return this;\n  });\n  var Sd = {\n      IteratorPrototype: $h,\n      BUGGY_SAFARI_ITERATORS: Cd\n    },\n    Td = Sd.IteratorPrototype,\n    Md = In,\n    Dd = L,\n    Id = wr,\n    Pd = id,\n    Bd = function () {\n      return this;\n    },\n    Fd = Mi,\n    zd = B,\n    Nd = hd,\n    Ad = function (t, e, i, o) {\n      var s = e + \" Iterator\";\n      return t.prototype = Md(Td, {\n        next: Dd(+!o, i)\n      }), Id(t, s, !1, !0), Pd[s] = Bd, t;\n    },\n    Rd = yd,\n    jd = wr,\n    Ld = Kn,\n    Hd = id,\n    Wd = Sd,\n    Vd = Nd.PROPER,\n    qd = Wd.BUGGY_SAFARI_ITERATORS,\n    Ud = pe(\"iterator\"),\n    Yd = \"keys\",\n    Xd = \"values\",\n    Kd = \"entries\",\n    Gd = function () {\n      return this;\n    },\n    Zd = function (t, e, i, o, s, n, r) {\n      Ad(i, e, o);\n      var a,\n        h,\n        d,\n        l = function (t) {\n          if (t === s && f) return f;\n          if (!qd && t && t in p) return p[t];\n          switch (t) {\n            case Yd:\n            case Xd:\n            case Kd:\n              return function () {\n                return new i(this, t);\n              };\n          }\n          return function () {\n            return new i(this);\n          };\n        },\n        c = e + \" Iterator\",\n        u = !1,\n        p = t.prototype,\n        g = p[Ud] || p[\"@@iterator\"] || s && p[s],\n        f = !qd && g || l(s),\n        m = \"Array\" === e && p.entries || g;\n      if (m && (a = Rd(m.call(new t()))) !== Object.prototype && a.next && (jd(a, c, !0, !0), Hd[c] = Gd), Vd && s === Xd && g && g.name !== Xd && (u = !0, f = function () {\n        return zd(g, this);\n      }), s) if (h = {\n        values: l(Xd),\n        keys: n ? f : l(Yd),\n        entries: l(Kd)\n      }, r) for (d in h) (qd || u || !(d in p)) && Ld(p, d, h[d]);else Fd({\n        target: e,\n        proto: !0,\n        forced: qd || u\n      }, h);\n      return r && p[Ud] !== f && Ld(p, Ud, f, {\n        name: s\n      }), Hd[e] = f, h;\n    },\n    Qd = function (t, e) {\n      return {\n        value: t,\n        done: e\n      };\n    },\n    $d = $,\n    Jd = id,\n    tl = Ar;\n  $e.f;\n  var el = Zd,\n    il = Qd,\n    ol = \"Array Iterator\",\n    sl = tl.set,\n    nl = tl.getterFor(ol);\n  el(Array, \"Array\", function (t, e) {\n    sl(this, {\n      type: ol,\n      target: $d(t),\n      index: 0,\n      kind: e\n    });\n  }, function () {\n    var t = nl(this),\n      e = t.target,\n      i = t.kind,\n      o = t.index++;\n    if (!e || o >= e.length) return t.target = void 0, il(void 0, !0);\n    switch (i) {\n      case \"keys\":\n        return il(o, !1);\n      case \"values\":\n        return il(e[o], !1);\n    }\n    return il([o, e[o]], !1);\n  }, \"values\"), Jd.Arguments = Jd.Array;\n  var rl = {\n      CSSRuleList: 0,\n      CSSStyleDeclaration: 0,\n      CSSValueList: 0,\n      ClientRectList: 0,\n      DOMRectList: 0,\n      DOMStringList: 0,\n      DOMTokenList: 1,\n      DataTransferItemList: 0,\n      FileList: 0,\n      HTMLAllCollection: 0,\n      HTMLCollection: 0,\n      HTMLFormElement: 0,\n      HTMLSelectElement: 0,\n      MediaList: 0,\n      MimeTypeArray: 0,\n      NamedNodeMap: 0,\n      NodeList: 1,\n      PaintRequestList: 0,\n      Plugin: 0,\n      PluginArray: 0,\n      SVGLengthList: 0,\n      SVGNumberList: 0,\n      SVGPathSegList: 0,\n      SVGPointList: 0,\n      SVGStringList: 0,\n      SVGTransformList: 0,\n      SourceBufferList: 0,\n      StyleSheetList: 0,\n      TextTrackCueList: 0,\n      TextTrackList: 0,\n      TouchList: 0\n    },\n    al = n,\n    hl = us,\n    dl = yi,\n    ll = id,\n    cl = pe(\"toStringTag\");\n  for (var ul in rl) {\n    var pl = al[ul],\n      gl = pl && pl.prototype;\n    gl && hl(gl) !== cl && dl(gl, cl, ul), ll[ul] = ll.Array;\n  }\n  var fl = ed,\n    ml = o(fl),\n    yl = Mi,\n    bl = Qo,\n    vl = Ds,\n    wl = et,\n    _l = Ai,\n    xl = Hi,\n    El = $,\n    Ol = os,\n    Cl = pe,\n    kl = _o,\n    Sl = Hs(\"slice\"),\n    Tl = Cl(\"species\"),\n    Ml = Array,\n    Dl = Math.max;\n  yl({\n    target: \"Array\",\n    proto: !0,\n    forced: !Sl\n  }, {\n    slice: function (t, e) {\n      var i,\n        o,\n        s,\n        n = El(this),\n        r = xl(n),\n        a = _l(t, r),\n        h = _l(void 0 === e ? r : e, r);\n      if (bl(n) && (i = n.constructor, (vl(i) && (i === Ml || bl(i.prototype)) || wl(i) && null === (i = i[Tl])) && (i = void 0), i === Ml || void 0 === i)) return kl(n, a, h);\n      for (o = new (void 0 === i ? Ml : i)(Dl(h - a, 0)), s = 0; a < h; a++, s++) a in n && Ol(o, s, n[a]);\n      return o.length = s, o;\n    }\n  });\n  var Il = zo(\"Array\").slice,\n    Pl = ht,\n    Bl = Il,\n    Fl = Array.prototype,\n    zl = function (t) {\n      var e = t.slice;\n      return t === Fl || Pl(Fl, t) && e === Fl.slice ? Bl : e;\n    },\n    Nl = o(zl),\n    Al = at,\n    Rl = Pn,\n    jl = so,\n    Ll = oi,\n    Hl = y([].concat),\n    Wl = Al(\"Reflect\", \"ownKeys\") || function (t) {\n      var e = Rl.f(Ll(t)),\n        i = jl.f;\n      return i ? Hl(e, i(t)) : e;\n    };\n  Mi({\n    target: \"Array\",\n    stat: !0\n  }, {\n    isArray: Qo\n  });\n  var Vl = o(it.Array.isArray),\n    ql = Ur.map;\n  Mi({\n    target: \"Array\",\n    proto: !0,\n    forced: !Hs(\"map\")\n  }, {\n    map: function (t) {\n      return ql(this, t, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n  var Ul = zo(\"Array\").map,\n    Yl = ht,\n    Xl = Ul,\n    Kl = Array.prototype,\n    Gl = function (t) {\n      var e = t.map;\n      return t === Kl || Yl(Kl, t) && e === Kl.map ? Xl : e;\n    },\n    Zl = o(Gl),\n    Ql = Zt,\n    $l = oo;\n  Mi({\n    target: \"Object\",\n    stat: !0,\n    forced: r(function () {\n      $l(1);\n    })\n  }, {\n    keys: function (t) {\n      return $l(Ql(t));\n    }\n  });\n  var Jl = o(it.Object.keys),\n    tc = Mi,\n    ec = Date,\n    ic = y(ec.prototype.getTime);\n  tc({\n    target: \"Date\",\n    stat: !0\n  }, {\n    now: function () {\n      return ic(new ec());\n    }\n  });\n  var oc = o(it.Date.now),\n    sc = r,\n    nc = function (t, e) {\n      var i = [][t];\n      return !!i && sc(function () {\n        i.call(null, e || function () {\n          return 1;\n        }, 1);\n      });\n    },\n    rc = Ur.forEach,\n    ac = nc(\"forEach\") ? [].forEach : function (t) {\n      return rc(this, t, arguments.length > 1 ? arguments[1] : void 0);\n    };\n  Mi({\n    target: \"Array\",\n    proto: !0,\n    forced: [].forEach !== ac\n  }, {\n    forEach: ac\n  });\n  var hc = zo(\"Array\").forEach,\n    dc = us,\n    lc = Jt,\n    cc = ht,\n    uc = hc,\n    pc = Array.prototype,\n    gc = {\n      DOMTokenList: !0,\n      NodeList: !0\n    },\n    fc = function (t) {\n      var e = t.forEach;\n      return t === pc || cc(pc, t) && e === pc.forEach || lc(gc, dc(t)) ? uc : e;\n    },\n    mc = o(fc),\n    yc = Mi,\n    bc = Qo,\n    vc = y([].reverse),\n    wc = [1, 2];\n  yc({\n    target: \"Array\",\n    proto: !0,\n    forced: String(wc) === String(wc.reverse())\n  }, {\n    reverse: function () {\n      return bc(this) && (this.length = this.length), vc(this);\n    }\n  });\n  var _c = zo(\"Array\").reverse,\n    xc = ht,\n    Ec = _c,\n    Oc = Array.prototype,\n    Cc = function (t) {\n      var e = t.reverse;\n      return t === Oc || xc(Oc, t) && e === Oc.reverse ? Ec : e;\n    },\n    kc = o(Cc),\n    Sc = D,\n    Tc = Qo,\n    Mc = TypeError,\n    Dc = Object.getOwnPropertyDescriptor,\n    Ic = Sc && !function () {\n      if (void 0 !== this) return !0;\n      try {\n        Object.defineProperty([], \"length\", {\n          writable: !1\n        }).length = 1;\n      } catch (t) {\n        return t instanceof TypeError;\n      }\n    }(),\n    Pc = Tt,\n    Bc = TypeError,\n    Fc = function (t, e) {\n      if (!delete t[e]) throw new Bc(\"Cannot delete property \" + Pc(e) + \" of \" + Pc(t));\n    },\n    zc = Mi,\n    Nc = Zt,\n    Ac = Ai,\n    Rc = Bi,\n    jc = Hi,\n    Lc = Ic ? function (t, e) {\n      if (Tc(t) && !Dc(t, \"length\").writable) throw new Mc(\"Cannot set read only .length\");\n      return t.length = e;\n    } : function (t, e) {\n      return t.length = e;\n    },\n    Hc = Jo,\n    Wc = As,\n    Vc = os,\n    qc = Fc,\n    Uc = Hs(\"splice\"),\n    Yc = Math.max,\n    Xc = Math.min;\n  zc({\n    target: \"Array\",\n    proto: !0,\n    forced: !Uc\n  }, {\n    splice: function (t, e) {\n      var i,\n        o,\n        s,\n        n,\n        r,\n        a,\n        h = Nc(this),\n        d = jc(h),\n        l = Ac(t, d),\n        c = arguments.length;\n      for (0 === c ? i = o = 0 : 1 === c ? (i = 0, o = d - l) : (i = c - 2, o = Xc(Yc(Rc(e), 0), d - l)), Hc(d + i - o), s = Wc(h, o), n = 0; n < o; n++) (r = l + n) in h && Vc(s, n, h[r]);\n      if (s.length = o, i < o) {\n        for (n = l; n < d - o; n++) a = n + i, (r = n + o) in h ? h[a] = h[r] : qc(h, a);\n        for (n = d; n > d - o + i; n--) qc(h, n - 1);\n      } else if (i > o) for (n = d - o; n > l; n--) a = n + i - 1, (r = n + o - 1) in h ? h[a] = h[r] : qc(h, a);\n      for (n = 0; n < i; n++) h[n + l] = arguments[n + 2];\n      return Lc(h, d - o + i), s;\n    }\n  });\n  var Kc = zo(\"Array\").splice,\n    Gc = ht,\n    Zc = Kc,\n    Qc = Array.prototype,\n    $c = function (t) {\n      var e = t.splice;\n      return t === Qc || Gc(Qc, t) && e === Qc.splice ? Zc : e;\n    },\n    Jc = o($c),\n    tu = Yi.includes;\n  Mi({\n    target: \"Array\",\n    proto: !0,\n    forced: r(function () {\n      return !Array(1).includes();\n    })\n  }, {\n    includes: function (t) {\n      return tu(this, t, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n  var eu = zo(\"Array\").includes,\n    iu = et,\n    ou = _,\n    su = pe(\"match\"),\n    nu = function (t) {\n      var e;\n      return iu(t) && (void 0 !== (e = t[su]) ? !!e : \"RegExp\" === ou(t));\n    },\n    ru = TypeError,\n    au = pe(\"match\"),\n    hu = Mi,\n    du = function (t) {\n      if (nu(t)) throw new ru(\"The method doesn't accept regular expressions\");\n      return t;\n    },\n    lu = G,\n    cu = nn,\n    uu = function (t) {\n      var e = /./;\n      try {\n        \"/./\"[t](e);\n      } catch (i) {\n        try {\n          return e[au] = !1, \"/./\"[t](e);\n        } catch (t) {}\n      }\n      return !1;\n    },\n    pu = y(\"\".indexOf);\n  hu({\n    target: \"String\",\n    proto: !0,\n    forced: !uu(\"includes\")\n  }, {\n    includes: function (t) {\n      return !!~pu(cu(lu(this)), cu(du(t)), arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n  var gu = zo(\"String\").includes,\n    fu = ht,\n    mu = eu,\n    yu = gu,\n    bu = Array.prototype,\n    vu = String.prototype,\n    wu = function (t) {\n      var e = t.includes;\n      return t === bu || fu(bu, t) && e === bu.includes ? mu : \"string\" == typeof t || t === vu || fu(vu, t) && e === vu.includes ? yu : e;\n    },\n    _u = o(wu),\n    xu = Zt,\n    Eu = yd,\n    Ou = dd;\n  Mi({\n    target: \"Object\",\n    stat: !0,\n    forced: r(function () {\n      Eu(1);\n    }),\n    sham: !Ou\n  }, {\n    getPrototypeOf: function (t) {\n      return Eu(xu(t));\n    }\n  });\n  var Cu = o(it.Object.getPrototypeOf),\n    ku = zo(\"Array\").concat,\n    Su = ht,\n    Tu = ku,\n    Mu = Array.prototype,\n    Du = function (t) {\n      var e = t.concat;\n      return t === Mu || Su(Mu, t) && e === Mu.concat ? Tu : e;\n    },\n    Iu = o(Du),\n    Pu = Ur.filter;\n  Mi({\n    target: \"Array\",\n    proto: !0,\n    forced: !Hs(\"filter\")\n  }, {\n    filter: function (t) {\n      return Pu(this, t, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n  var Bu = zo(\"Array\").filter,\n    Fu = ht,\n    zu = Bu,\n    Nu = Array.prototype,\n    Au = function (t) {\n      var e = t.filter;\n      return t === Nu || Fu(Nu, t) && e === Nu.filter ? zu : e;\n    },\n    Ru = o(Au),\n    ju = D,\n    Lu = r,\n    Hu = y,\n    Wu = yd,\n    Vu = oo,\n    qu = $,\n    Uu = Hu(F.f),\n    Yu = Hu([].push),\n    Xu = ju && Lu(function () {\n      var t = Object.create(null);\n      return t[2] = 2, !Uu(t, 2);\n    }),\n    Ku = function (t) {\n      return function (e) {\n        for (var i, o = qu(e), s = Vu(o), n = Xu && null === Wu(o), r = s.length, a = 0, h = []; r > a;) i = s[a++], ju && !(n ? i in o : Uu(o, i)) || Yu(h, t ? [i, o[i]] : o[i]);\n        return h;\n      };\n    },\n    Gu = {\n      entries: Ku(!0),\n      values: Ku(!1)\n    }.values;\n  Mi({\n    target: \"Object\",\n    stat: !0\n  }, {\n    values: function (t) {\n      return Gu(t);\n    }\n  });\n  var Zu = o(it.Object.values),\n    Qu = \"\\t\\n\\v\\f\\r Â áââââââââââââ¯âã\\u2028\\u2029\\ufeff\",\n    $u = G,\n    Ju = nn,\n    tp = Qu,\n    ep = y(\"\".replace),\n    ip = RegExp(\"^[\" + tp + \"]+\"),\n    op = RegExp(\"(^|[^\" + tp + \"])[\" + tp + \"]+$\"),\n    sp = function (t) {\n      return function (e) {\n        var i = Ju($u(e));\n        return 1 & t && (i = ep(i, ip, \"\")), 2 & t && (i = ep(i, op, \"$1\")), i;\n      };\n    },\n    np = {\n      start: sp(1),\n      end: sp(2),\n      trim: sp(3)\n    },\n    rp = n,\n    ap = r,\n    hp = y,\n    dp = nn,\n    lp = np.trim,\n    cp = Qu,\n    up = rp.parseInt,\n    pp = rp.Symbol,\n    gp = pp && pp.iterator,\n    fp = /^[+-]?0x/i,\n    mp = hp(fp.exec),\n    yp = 8 !== up(cp + \"08\") || 22 !== up(cp + \"0x16\") || gp && !ap(function () {\n      up(Object(gp));\n    }) ? function (t, e) {\n      var i = lp(dp(t));\n      return up(i, e >>> 0 || (mp(fp, i) ? 16 : 10));\n    } : up;\n  Mi({\n    global: !0,\n    forced: parseInt !== yp\n  }, {\n    parseInt: yp\n  });\n  var bp = o(it.parseInt),\n    vp = Mi,\n    wp = Yi.indexOf,\n    _p = nc,\n    xp = O([].indexOf),\n    Ep = !!xp && 1 / xp([1], 1, -0) < 0;\n  vp({\n    target: \"Array\",\n    proto: !0,\n    forced: Ep || !_p(\"indexOf\")\n  }, {\n    indexOf: function (t) {\n      var e = arguments.length > 1 ? arguments[1] : void 0;\n      return Ep ? xp(this, t, e) || 0 : wp(this, t, e);\n    }\n  });\n  var Op = zo(\"Array\").indexOf,\n    Cp = ht,\n    kp = Op,\n    Sp = Array.prototype,\n    Tp = function (t) {\n      var e = t.indexOf;\n      return t === Sp || Cp(Sp, t) && e === Sp.indexOf ? kp : e;\n    },\n    Mp = o(Tp);\n  Mi({\n    target: \"Object\",\n    stat: !0,\n    sham: !D\n  }, {\n    create: In\n  });\n  var Dp = it.Object,\n    Ip = o(function (t, e) {\n      return Dp.create(t, e);\n    }),\n    Pp = it,\n    Bp = u;\n  Pp.JSON || (Pp.JSON = {\n    stringify: JSON.stringify\n  });\n  var Fp = function (t, e, i) {\n      return Bp(Pp.JSON.stringify, null, arguments);\n    },\n    zp = o(Fp),\n    Np = \"function\" == typeof Bun && Bun && \"string\" == typeof Bun.version,\n    Ap = TypeError,\n    Rp = n,\n    jp = u,\n    Lp = T,\n    Hp = Np,\n    Wp = dt,\n    Vp = _o,\n    qp = function (t, e) {\n      if (t < e) throw new Ap(\"Not enough arguments\");\n      return t;\n    },\n    Up = Rp.Function,\n    Yp = /MSIE .\\./.test(Wp) || Hp && function () {\n      var t = Rp.Bun.version.split(\".\");\n      return t.length < 3 || \"0\" === t[0] && (t[1] < 3 || \"3\" === t[1] && \"0\" === t[2]);\n    }(),\n    Xp = function (t, e) {\n      var i = e ? 2 : 1;\n      return Yp ? function (o, s) {\n        var n = qp(arguments.length, 1) > i,\n          r = Lp(o) ? o : Up(o),\n          a = n ? Vp(arguments, i) : [],\n          h = n ? function () {\n            jp(r, this, a);\n          } : r;\n        return e ? t(h, s) : t(h);\n      } : t;\n    },\n    Kp = Mi,\n    Gp = n,\n    Zp = Xp(Gp.setInterval, !0);\n  Kp({\n    global: !0,\n    bind: !0,\n    forced: Gp.setInterval !== Zp\n  }, {\n    setInterval: Zp\n  });\n  var Qp = Mi,\n    $p = n,\n    Jp = Xp($p.setTimeout, !0);\n  Qp({\n    global: !0,\n    bind: !0,\n    forced: $p.setTimeout !== Jp\n  }, {\n    setTimeout: Jp\n  });\n  var tg = o(it.setTimeout),\n    eg = Zt,\n    ig = Ai,\n    og = Hi,\n    sg = function (t) {\n      for (var e = eg(this), i = og(e), o = arguments.length, s = ig(o > 1 ? arguments[1] : void 0, i), n = o > 2 ? arguments[2] : void 0, r = void 0 === n ? i : ig(n, i); r > s;) e[s++] = t;\n      return e;\n    };\n  Mi({\n    target: \"Array\",\n    proto: !0\n  }, {\n    fill: sg\n  });\n  var ng,\n    rg = zo(\"Array\").fill,\n    ag = ht,\n    hg = rg,\n    dg = Array.prototype,\n    lg = function (t) {\n      var e = t.fill;\n      return t === dg || ag(dg, t) && e === dg.fill ? hg : e;\n    },\n    cg = o(lg);\n  /*! Hammer.JS - v2.0.17-rc - 2019-12-16\n  \t * http://naver.github.io/egjs\n  \t *\n  \t * Forked By Naver egjs\n  \t * Copyright (c) hammerjs\n  \t * Licensed under the MIT license */\n  function ug() {\n    return ug = Object.assign || function (t) {\n      for (var e = 1; e < arguments.length; e++) {\n        var i = arguments[e];\n        for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);\n      }\n      return t;\n    }, ug.apply(this, arguments);\n  }\n  function pg(t, e) {\n    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n  }\n  function gg(t) {\n    if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return t;\n  }\n  ng = \"function\" != typeof Object.assign ? function (t) {\n    if (null == t) throw new TypeError(\"Cannot convert undefined or null to object\");\n    for (var e = Object(t), i = 1; i < arguments.length; i++) {\n      var o = arguments[i];\n      if (null != o) for (var s in o) o.hasOwnProperty(s) && (e[s] = o[s]);\n    }\n    return e;\n  } : Object.assign;\n  var fg,\n    mg = ng,\n    yg = [\"\", \"webkit\", \"Moz\", \"MS\", \"ms\", \"o\"],\n    bg = \"undefined\" == typeof document ? {\n      style: {}\n    } : document.createElement(\"div\"),\n    vg = Math.round,\n    wg = Math.abs,\n    _g = Date.now;\n  function xg(t, e) {\n    for (var i, o, s = e[0].toUpperCase() + e.slice(1), n = 0; n < yg.length;) {\n      if ((o = (i = yg[n]) ? i + s : e) in t) return o;\n      n++;\n    }\n  }\n  fg = \"undefined\" == typeof window ? {} : window;\n  var Eg = xg(bg.style, \"touchAction\"),\n    Og = void 0 !== Eg;\n  var Cg = \"compute\",\n    kg = \"auto\",\n    Sg = \"manipulation\",\n    Tg = \"none\",\n    Mg = \"pan-x\",\n    Dg = \"pan-y\",\n    Ig = function () {\n      if (!Og) return !1;\n      var t = {},\n        e = fg.CSS && fg.CSS.supports;\n      return [\"auto\", \"manipulation\", \"pan-y\", \"pan-x\", \"pan-x pan-y\", \"none\"].forEach(function (i) {\n        return t[i] = !e || fg.CSS.supports(\"touch-action\", i);\n      }), t;\n    }(),\n    Pg = \"ontouchstart\" in fg,\n    Bg = void 0 !== xg(fg, \"PointerEvent\"),\n    Fg = Pg && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),\n    zg = \"touch\",\n    Ng = \"mouse\",\n    Ag = 25,\n    Rg = 1,\n    jg = 4,\n    Lg = 8,\n    Hg = 1,\n    Wg = 2,\n    Vg = 4,\n    qg = 8,\n    Ug = 16,\n    Yg = Wg | Vg,\n    Xg = qg | Ug,\n    Kg = Yg | Xg,\n    Gg = [\"x\", \"y\"],\n    Zg = [\"clientX\", \"clientY\"];\n  function Qg(t, e, i) {\n    var o;\n    if (t) if (t.forEach) t.forEach(e, i);else if (void 0 !== t.length) for (o = 0; o < t.length;) e.call(i, t[o], o, t), o++;else for (o in t) t.hasOwnProperty(o) && e.call(i, t[o], o, t);\n  }\n  function $g(t, e) {\n    return \"function\" == typeof t ? t.apply(e && e[0] || void 0, e) : t;\n  }\n  function Jg(t, e) {\n    return t.indexOf(e) > -1;\n  }\n  var tf = function () {\n    function t(t, e) {\n      this.manager = t, this.set(e);\n    }\n    var e = t.prototype;\n    return e.set = function (t) {\n      t === Cg && (t = this.compute()), Og && this.manager.element.style && Ig[t] && (this.manager.element.style[Eg] = t), this.actions = t.toLowerCase().trim();\n    }, e.update = function () {\n      this.set(this.manager.options.touchAction);\n    }, e.compute = function () {\n      var t = [];\n      return Qg(this.manager.recognizers, function (e) {\n        $g(e.options.enable, [e]) && (t = t.concat(e.getTouchAction()));\n      }), function (t) {\n        if (Jg(t, Tg)) return Tg;\n        var e = Jg(t, Mg),\n          i = Jg(t, Dg);\n        return e && i ? Tg : e || i ? e ? Mg : Dg : Jg(t, Sg) ? Sg : kg;\n      }(t.join(\" \"));\n    }, e.preventDefaults = function (t) {\n      var e = t.srcEvent,\n        i = t.offsetDirection;\n      if (this.manager.session.prevented) e.preventDefault();else {\n        var o = this.actions,\n          s = Jg(o, Tg) && !Ig[Tg],\n          n = Jg(o, Dg) && !Ig[Dg],\n          r = Jg(o, Mg) && !Ig[Mg];\n        if (s) {\n          var a = 1 === t.pointers.length,\n            h = t.distance < 2,\n            d = t.deltaTime < 250;\n          if (a && h && d) return;\n        }\n        if (!r || !n) return s || n && i & Yg || r && i & Xg ? this.preventSrc(e) : void 0;\n      }\n    }, e.preventSrc = function (t) {\n      this.manager.session.prevented = !0, t.preventDefault();\n    }, t;\n  }();\n  function ef(t, e) {\n    for (; t;) {\n      if (t === e) return !0;\n      t = t.parentNode;\n    }\n    return !1;\n  }\n  function of(t) {\n    var e = t.length;\n    if (1 === e) return {\n      x: vg(t[0].clientX),\n      y: vg(t[0].clientY)\n    };\n    for (var i = 0, o = 0, s = 0; s < e;) i += t[s].clientX, o += t[s].clientY, s++;\n    return {\n      x: vg(i / e),\n      y: vg(o / e)\n    };\n  }\n  function sf(t) {\n    for (var e = [], i = 0; i < t.pointers.length;) e[i] = {\n      clientX: vg(t.pointers[i].clientX),\n      clientY: vg(t.pointers[i].clientY)\n    }, i++;\n    return {\n      timeStamp: _g(),\n      pointers: e,\n      center: of(e),\n      deltaX: t.deltaX,\n      deltaY: t.deltaY\n    };\n  }\n  function nf(t, e, i) {\n    i || (i = Gg);\n    var o = e[i[0]] - t[i[0]],\n      s = e[i[1]] - t[i[1]];\n    return Math.sqrt(o * o + s * s);\n  }\n  function rf(t, e, i) {\n    i || (i = Gg);\n    var o = e[i[0]] - t[i[0]],\n      s = e[i[1]] - t[i[1]];\n    return 180 * Math.atan2(s, o) / Math.PI;\n  }\n  function af(t, e) {\n    return t === e ? Hg : wg(t) >= wg(e) ? t < 0 ? Wg : Vg : e < 0 ? qg : Ug;\n  }\n  function hf(t, e, i) {\n    return {\n      x: e / t || 0,\n      y: i / t || 0\n    };\n  }\n  function df(t, e) {\n    var i = t.session,\n      o = e.pointers,\n      s = o.length;\n    i.firstInput || (i.firstInput = sf(e)), s > 1 && !i.firstMultiple ? i.firstMultiple = sf(e) : 1 === s && (i.firstMultiple = !1);\n    var n = i.firstInput,\n      r = i.firstMultiple,\n      a = r ? r.center : n.center,\n      h = e.center = of(o);\n    e.timeStamp = _g(), e.deltaTime = e.timeStamp - n.timeStamp, e.angle = rf(a, h), e.distance = nf(a, h), function (t, e) {\n      var i = e.center,\n        o = t.offsetDelta || {},\n        s = t.prevDelta || {},\n        n = t.prevInput || {};\n      e.eventType !== Rg && n.eventType !== jg || (s = t.prevDelta = {\n        x: n.deltaX || 0,\n        y: n.deltaY || 0\n      }, o = t.offsetDelta = {\n        x: i.x,\n        y: i.y\n      }), e.deltaX = s.x + (i.x - o.x), e.deltaY = s.y + (i.y - o.y);\n    }(i, e), e.offsetDirection = af(e.deltaX, e.deltaY);\n    var d,\n      l,\n      c = hf(e.deltaTime, e.deltaX, e.deltaY);\n    e.overallVelocityX = c.x, e.overallVelocityY = c.y, e.overallVelocity = wg(c.x) > wg(c.y) ? c.x : c.y, e.scale = r ? (d = r.pointers, nf((l = o)[0], l[1], Zg) / nf(d[0], d[1], Zg)) : 1, e.rotation = r ? function (t, e) {\n      return rf(e[1], e[0], Zg) + rf(t[1], t[0], Zg);\n    }(r.pointers, o) : 0, e.maxPointers = i.prevInput ? e.pointers.length > i.prevInput.maxPointers ? e.pointers.length : i.prevInput.maxPointers : e.pointers.length, function (t, e) {\n      var i,\n        o,\n        s,\n        n,\n        r = t.lastInterval || e,\n        a = e.timeStamp - r.timeStamp;\n      if (e.eventType !== Lg && (a > Ag || void 0 === r.velocity)) {\n        var h = e.deltaX - r.deltaX,\n          d = e.deltaY - r.deltaY,\n          l = hf(a, h, d);\n        o = l.x, s = l.y, i = wg(l.x) > wg(l.y) ? l.x : l.y, n = af(h, d), t.lastInterval = e;\n      } else i = r.velocity, o = r.velocityX, s = r.velocityY, n = r.direction;\n      e.velocity = i, e.velocityX = o, e.velocityY = s, e.direction = n;\n    }(i, e);\n    var u,\n      p = t.element,\n      g = e.srcEvent;\n    ef(u = g.composedPath ? g.composedPath()[0] : g.path ? g.path[0] : g.target, p) && (p = u), e.target = p;\n  }\n  function lf(t, e, i) {\n    var o = i.pointers.length,\n      s = i.changedPointers.length,\n      n = e & Rg && o - s == 0,\n      r = e & (jg | Lg) && o - s == 0;\n    i.isFirst = !!n, i.isFinal = !!r, n && (t.session = {}), i.eventType = e, df(t, i), t.emit(\"hammer.input\", i), t.recognize(i), t.session.prevInput = i;\n  }\n  function cf(t) {\n    return t.trim().split(/\\s+/g);\n  }\n  function uf(t, e, i) {\n    Qg(cf(e), function (e) {\n      t.addEventListener(e, i, !1);\n    });\n  }\n  function pf(t, e, i) {\n    Qg(cf(e), function (e) {\n      t.removeEventListener(e, i, !1);\n    });\n  }\n  function gf(t) {\n    var e = t.ownerDocument || t;\n    return e.defaultView || e.parentWindow || window;\n  }\n  var ff = function () {\n    function t(t, e) {\n      var i = this;\n      this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function (e) {\n        $g(t.options.enable, [t]) && i.handler(e);\n      }, this.init();\n    }\n    var e = t.prototype;\n    return e.handler = function () {}, e.init = function () {\n      this.evEl && uf(this.element, this.evEl, this.domHandler), this.evTarget && uf(this.target, this.evTarget, this.domHandler), this.evWin && uf(gf(this.element), this.evWin, this.domHandler);\n    }, e.destroy = function () {\n      this.evEl && pf(this.element, this.evEl, this.domHandler), this.evTarget && pf(this.target, this.evTarget, this.domHandler), this.evWin && pf(gf(this.element), this.evWin, this.domHandler);\n    }, t;\n  }();\n  function mf(t, e, i) {\n    if (t.indexOf && !i) return t.indexOf(e);\n    for (var o = 0; o < t.length;) {\n      if (i && t[o][i] == e || !i && t[o] === e) return o;\n      o++;\n    }\n    return -1;\n  }\n  var yf = {\n      pointerdown: Rg,\n      pointermove: 2,\n      pointerup: jg,\n      pointercancel: Lg,\n      pointerout: Lg\n    },\n    bf = {\n      2: zg,\n      3: \"pen\",\n      4: Ng,\n      5: \"kinect\"\n    },\n    vf = \"pointerdown\",\n    wf = \"pointermove pointerup pointercancel\";\n  fg.MSPointerEvent && !fg.PointerEvent && (vf = \"MSPointerDown\", wf = \"MSPointerMove MSPointerUp MSPointerCancel\");\n  var _f = function (t) {\n    function e() {\n      var i,\n        o = e.prototype;\n      return o.evEl = vf, o.evWin = wf, (i = t.apply(this, arguments) || this).store = i.manager.session.pointerEvents = [], i;\n    }\n    return pg(e, t), e.prototype.handler = function (t) {\n      var e = this.store,\n        i = !1,\n        o = t.type.toLowerCase().replace(\"ms\", \"\"),\n        s = yf[o],\n        n = bf[t.pointerType] || t.pointerType,\n        r = n === zg,\n        a = mf(e, t.pointerId, \"pointerId\");\n      s & Rg && (0 === t.button || r) ? a < 0 && (e.push(t), a = e.length - 1) : s & (jg | Lg) && (i = !0), a < 0 || (e[a] = t, this.callback(this.manager, s, {\n        pointers: e,\n        changedPointers: [t],\n        pointerType: n,\n        srcEvent: t\n      }), i && e.splice(a, 1));\n    }, e;\n  }(ff);\n  function xf(t) {\n    return Array.prototype.slice.call(t, 0);\n  }\n  function Ef(t, e, i) {\n    for (var o = [], s = [], n = 0; n < t.length;) {\n      var r = e ? t[n][e] : t[n];\n      mf(s, r) < 0 && o.push(t[n]), s[n] = r, n++;\n    }\n    return i && (o = e ? o.sort(function (t, i) {\n      return t[e] > i[e];\n    }) : o.sort()), o;\n  }\n  var Of = {\n      touchstart: Rg,\n      touchmove: 2,\n      touchend: jg,\n      touchcancel: Lg\n    },\n    Cf = function (t) {\n      function e() {\n        var i;\n        return e.prototype.evTarget = \"touchstart touchmove touchend touchcancel\", (i = t.apply(this, arguments) || this).targetIds = {}, i;\n      }\n      return pg(e, t), e.prototype.handler = function (t) {\n        var e = Of[t.type],\n          i = kf.call(this, t, e);\n        i && this.callback(this.manager, e, {\n          pointers: i[0],\n          changedPointers: i[1],\n          pointerType: zg,\n          srcEvent: t\n        });\n      }, e;\n    }(ff);\n  function kf(t, e) {\n    var i,\n      o,\n      s = xf(t.touches),\n      n = this.targetIds;\n    if (e & (2 | Rg) && 1 === s.length) return n[s[0].identifier] = !0, [s, s];\n    var r = xf(t.changedTouches),\n      a = [],\n      h = this.target;\n    if (o = s.filter(function (t) {\n      return ef(t.target, h);\n    }), e === Rg) for (i = 0; i < o.length;) n[o[i].identifier] = !0, i++;\n    for (i = 0; i < r.length;) n[r[i].identifier] && a.push(r[i]), e & (jg | Lg) && delete n[r[i].identifier], i++;\n    return a.length ? [Ef(o.concat(a), \"identifier\", !0), a] : void 0;\n  }\n  var Sf = {\n      mousedown: Rg,\n      mousemove: 2,\n      mouseup: jg\n    },\n    Tf = function (t) {\n      function e() {\n        var i,\n          o = e.prototype;\n        return o.evEl = \"mousedown\", o.evWin = \"mousemove mouseup\", (i = t.apply(this, arguments) || this).pressed = !1, i;\n      }\n      return pg(e, t), e.prototype.handler = function (t) {\n        var e = Sf[t.type];\n        e & Rg && 0 === t.button && (this.pressed = !0), 2 & e && 1 !== t.which && (e = jg), this.pressed && (e & jg && (this.pressed = !1), this.callback(this.manager, e, {\n          pointers: [t],\n          changedPointers: [t],\n          pointerType: Ng,\n          srcEvent: t\n        }));\n      }, e;\n    }(ff),\n    Mf = 2500;\n  function Df(t) {\n    var e = t.changedPointers[0];\n    if (e.identifier === this.primaryTouch) {\n      var i = {\n          x: e.clientX,\n          y: e.clientY\n        },\n        o = this.lastTouches;\n      this.lastTouches.push(i);\n      setTimeout(function () {\n        var t = o.indexOf(i);\n        t > -1 && o.splice(t, 1);\n      }, Mf);\n    }\n  }\n  function If(t, e) {\n    t & Rg ? (this.primaryTouch = e.changedPointers[0].identifier, Df.call(this, e)) : t & (jg | Lg) && Df.call(this, e);\n  }\n  function Pf(t) {\n    for (var e = t.srcEvent.clientX, i = t.srcEvent.clientY, o = 0; o < this.lastTouches.length; o++) {\n      var s = this.lastTouches[o],\n        n = Math.abs(e - s.x),\n        r = Math.abs(i - s.y);\n      if (n <= 25 && r <= 25) return !0;\n    }\n    return !1;\n  }\n  var Bf = function () {\n    return function (t) {\n      function e(e, i) {\n        var o;\n        return (o = t.call(this, e, i) || this).handler = function (t, e, i) {\n          var s = i.pointerType === zg,\n            n = i.pointerType === Ng;\n          if (!(n && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) {\n            if (s) If.call(gg(gg(o)), e, i);else if (n && Pf.call(gg(gg(o)), i)) return;\n            o.callback(t, e, i);\n          }\n        }, o.touch = new Cf(o.manager, o.handler), o.mouse = new Tf(o.manager, o.handler), o.primaryTouch = null, o.lastTouches = [], o;\n      }\n      return pg(e, t), e.prototype.destroy = function () {\n        this.touch.destroy(), this.mouse.destroy();\n      }, e;\n    }(ff);\n  }();\n  function Ff(t, e, i) {\n    return !!Array.isArray(t) && (Qg(t, i[e], i), !0);\n  }\n  var zf = 32,\n    Nf = 1;\n  function Af(t, e) {\n    var i = e.manager;\n    return i ? i.get(t) : t;\n  }\n  function Rf(t) {\n    return 16 & t ? \"cancel\" : 8 & t ? \"end\" : 4 & t ? \"move\" : 2 & t ? \"start\" : \"\";\n  }\n  var jf = function () {\n      function t(t) {\n        void 0 === t && (t = {}), this.options = ug({\n          enable: !0\n        }, t), this.id = Nf++, this.manager = null, this.state = 1, this.simultaneous = {}, this.requireFail = [];\n      }\n      var e = t.prototype;\n      return e.set = function (t) {\n        return mg(this.options, t), this.manager && this.manager.touchAction.update(), this;\n      }, e.recognizeWith = function (t) {\n        if (Ff(t, \"recognizeWith\", this)) return this;\n        var e = this.simultaneous;\n        return e[(t = Af(t, this)).id] || (e[t.id] = t, t.recognizeWith(this)), this;\n      }, e.dropRecognizeWith = function (t) {\n        return Ff(t, \"dropRecognizeWith\", this) || (t = Af(t, this), delete this.simultaneous[t.id]), this;\n      }, e.requireFailure = function (t) {\n        if (Ff(t, \"requireFailure\", this)) return this;\n        var e = this.requireFail;\n        return -1 === mf(e, t = Af(t, this)) && (e.push(t), t.requireFailure(this)), this;\n      }, e.dropRequireFailure = function (t) {\n        if (Ff(t, \"dropRequireFailure\", this)) return this;\n        t = Af(t, this);\n        var e = mf(this.requireFail, t);\n        return e > -1 && this.requireFail.splice(e, 1), this;\n      }, e.hasRequireFailures = function () {\n        return this.requireFail.length > 0;\n      }, e.canRecognizeWith = function (t) {\n        return !!this.simultaneous[t.id];\n      }, e.emit = function (t) {\n        var e = this,\n          i = this.state;\n        function o(i) {\n          e.manager.emit(i, t);\n        }\n        i < 8 && o(e.options.event + Rf(i)), o(e.options.event), t.additionalEvent && o(t.additionalEvent), i >= 8 && o(e.options.event + Rf(i));\n      }, e.tryEmit = function (t) {\n        if (this.canEmit()) return this.emit(t);\n        this.state = zf;\n      }, e.canEmit = function () {\n        for (var t = 0; t < this.requireFail.length;) {\n          if (!(33 & this.requireFail[t].state)) return !1;\n          t++;\n        }\n        return !0;\n      }, e.recognize = function (t) {\n        var e = mg({}, t);\n        if (!$g(this.options.enable, [this, e])) return this.reset(), void (this.state = zf);\n        56 & this.state && (this.state = 1), this.state = this.process(e), 30 & this.state && this.tryEmit(e);\n      }, e.process = function (t) {}, e.getTouchAction = function () {}, e.reset = function () {}, t;\n    }(),\n    Lf = function (t) {\n      function e(e) {\n        var i;\n        return void 0 === e && (e = {}), (i = t.call(this, ug({\n          event: \"tap\",\n          pointers: 1,\n          taps: 1,\n          interval: 300,\n          time: 250,\n          threshold: 9,\n          posThreshold: 10\n        }, e)) || this).pTime = !1, i.pCenter = !1, i._timer = null, i._input = null, i.count = 0, i;\n      }\n      pg(e, t);\n      var i = e.prototype;\n      return i.getTouchAction = function () {\n        return [Sg];\n      }, i.process = function (t) {\n        var e = this,\n          i = this.options,\n          o = t.pointers.length === i.pointers,\n          s = t.distance < i.threshold,\n          n = t.deltaTime < i.time;\n        if (this.reset(), t.eventType & Rg && 0 === this.count) return this.failTimeout();\n        if (s && n && o) {\n          if (t.eventType !== jg) return this.failTimeout();\n          var r = !this.pTime || t.timeStamp - this.pTime < i.interval,\n            a = !this.pCenter || nf(this.pCenter, t.center) < i.posThreshold;\n          if (this.pTime = t.timeStamp, this.pCenter = t.center, a && r ? this.count += 1 : this.count = 1, this._input = t, 0 === this.count % i.taps) return this.hasRequireFailures() ? (this._timer = setTimeout(function () {\n            e.state = 8, e.tryEmit();\n          }, i.interval), 2) : 8;\n        }\n        return zf;\n      }, i.failTimeout = function () {\n        var t = this;\n        return this._timer = setTimeout(function () {\n          t.state = zf;\n        }, this.options.interval), zf;\n      }, i.reset = function () {\n        clearTimeout(this._timer);\n      }, i.emit = function () {\n        8 === this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));\n      }, e;\n    }(jf),\n    Hf = function (t) {\n      function e(e) {\n        return void 0 === e && (e = {}), t.call(this, ug({\n          pointers: 1\n        }, e)) || this;\n      }\n      pg(e, t);\n      var i = e.prototype;\n      return i.attrTest = function (t) {\n        var e = this.options.pointers;\n        return 0 === e || t.pointers.length === e;\n      }, i.process = function (t) {\n        var e = this.state,\n          i = t.eventType,\n          o = 6 & e,\n          s = this.attrTest(t);\n        return o && (i & Lg || !s) ? 16 | e : o || s ? i & jg ? 8 | e : 2 & e ? 4 | e : 2 : zf;\n      }, e;\n    }(jf);\n  function Wf(t) {\n    return t === Ug ? \"down\" : t === qg ? \"up\" : t === Wg ? \"left\" : t === Vg ? \"right\" : \"\";\n  }\n  var Vf = function (t) {\n      function e(e) {\n        var i;\n        return void 0 === e && (e = {}), (i = t.call(this, ug({\n          event: \"pan\",\n          threshold: 10,\n          pointers: 1,\n          direction: Kg\n        }, e)) || this).pX = null, i.pY = null, i;\n      }\n      pg(e, t);\n      var i = e.prototype;\n      return i.getTouchAction = function () {\n        var t = this.options.direction,\n          e = [];\n        return t & Yg && e.push(Dg), t & Xg && e.push(Mg), e;\n      }, i.directionTest = function (t) {\n        var e = this.options,\n          i = !0,\n          o = t.distance,\n          s = t.direction,\n          n = t.deltaX,\n          r = t.deltaY;\n        return s & e.direction || (e.direction & Yg ? (s = 0 === n ? Hg : n < 0 ? Wg : Vg, i = n !== this.pX, o = Math.abs(t.deltaX)) : (s = 0 === r ? Hg : r < 0 ? qg : Ug, i = r !== this.pY, o = Math.abs(t.deltaY))), t.direction = s, i && o > e.threshold && s & e.direction;\n      }, i.attrTest = function (t) {\n        return Hf.prototype.attrTest.call(this, t) && (2 & this.state || !(2 & this.state) && this.directionTest(t));\n      }, i.emit = function (e) {\n        this.pX = e.deltaX, this.pY = e.deltaY;\n        var i = Wf(e.direction);\n        i && (e.additionalEvent = this.options.event + i), t.prototype.emit.call(this, e);\n      }, e;\n    }(Hf),\n    qf = function (t) {\n      function e(e) {\n        return void 0 === e && (e = {}), t.call(this, ug({\n          event: \"swipe\",\n          threshold: 10,\n          velocity: .3,\n          direction: Yg | Xg,\n          pointers: 1\n        }, e)) || this;\n      }\n      pg(e, t);\n      var i = e.prototype;\n      return i.getTouchAction = function () {\n        return Vf.prototype.getTouchAction.call(this);\n      }, i.attrTest = function (e) {\n        var i,\n          o = this.options.direction;\n        return o & (Yg | Xg) ? i = e.overallVelocity : o & Yg ? i = e.overallVelocityX : o & Xg && (i = e.overallVelocityY), t.prototype.attrTest.call(this, e) && o & e.offsetDirection && e.distance > this.options.threshold && e.maxPointers === this.options.pointers && wg(i) > this.options.velocity && e.eventType & jg;\n      }, i.emit = function (t) {\n        var e = Wf(t.offsetDirection);\n        e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t);\n      }, e;\n    }(Hf),\n    Uf = function (t) {\n      function e(e) {\n        return void 0 === e && (e = {}), t.call(this, ug({\n          event: \"pinch\",\n          threshold: 0,\n          pointers: 2\n        }, e)) || this;\n      }\n      pg(e, t);\n      var i = e.prototype;\n      return i.getTouchAction = function () {\n        return [Tg];\n      }, i.attrTest = function (e) {\n        return t.prototype.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || 2 & this.state);\n      }, i.emit = function (e) {\n        if (1 !== e.scale) {\n          var i = e.scale < 1 ? \"in\" : \"out\";\n          e.additionalEvent = this.options.event + i;\n        }\n        t.prototype.emit.call(this, e);\n      }, e;\n    }(Hf),\n    Yf = function (t) {\n      function e(e) {\n        return void 0 === e && (e = {}), t.call(this, ug({\n          event: \"rotate\",\n          threshold: 0,\n          pointers: 2\n        }, e)) || this;\n      }\n      pg(e, t);\n      var i = e.prototype;\n      return i.getTouchAction = function () {\n        return [Tg];\n      }, i.attrTest = function (e) {\n        return t.prototype.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || 2 & this.state);\n      }, e;\n    }(Hf),\n    Xf = function (t) {\n      function e(e) {\n        var i;\n        return void 0 === e && (e = {}), (i = t.call(this, ug({\n          event: \"press\",\n          pointers: 1,\n          time: 251,\n          threshold: 9\n        }, e)) || this)._timer = null, i._input = null, i;\n      }\n      pg(e, t);\n      var i = e.prototype;\n      return i.getTouchAction = function () {\n        return [kg];\n      }, i.process = function (t) {\n        var e = this,\n          i = this.options,\n          o = t.pointers.length === i.pointers,\n          s = t.distance < i.threshold,\n          n = t.deltaTime > i.time;\n        if (this._input = t, !s || !o || t.eventType & (jg | Lg) && !n) this.reset();else if (t.eventType & Rg) this.reset(), this._timer = setTimeout(function () {\n          e.state = 8, e.tryEmit();\n        }, i.time);else if (t.eventType & jg) return 8;\n        return zf;\n      }, i.reset = function () {\n        clearTimeout(this._timer);\n      }, i.emit = function (t) {\n        8 === this.state && (t && t.eventType & jg ? this.manager.emit(this.options.event + \"up\", t) : (this._input.timeStamp = _g(), this.manager.emit(this.options.event, this._input)));\n      }, e;\n    }(jf),\n    Kf = {\n      domEvents: !1,\n      touchAction: Cg,\n      enable: !0,\n      inputTarget: null,\n      inputClass: null,\n      cssProps: {\n        userSelect: \"none\",\n        touchSelect: \"none\",\n        touchCallout: \"none\",\n        contentZooming: \"none\",\n        userDrag: \"none\",\n        tapHighlightColor: \"rgba(0,0,0,0)\"\n      }\n    },\n    Gf = [[Yf, {\n      enable: !1\n    }], [Uf, {\n      enable: !1\n    }, [\"rotate\"]], [qf, {\n      direction: Yg\n    }], [Vf, {\n      direction: Yg\n    }, [\"swipe\"]], [Lf], [Lf, {\n      event: \"doubletap\",\n      taps: 2\n    }, [\"tap\"]], [Xf]];\n  function Zf(t, e) {\n    var i,\n      o = t.element;\n    o.style && (Qg(t.options.cssProps, function (s, n) {\n      i = xg(o.style, n), e ? (t.oldCssProps[i] = o.style[i], o.style[i] = s) : o.style[i] = t.oldCssProps[i] || \"\";\n    }), e || (t.oldCssProps = {}));\n  }\n  var Qf = function () {\n      function t(t, e) {\n        var i,\n          o = this;\n        this.options = mg({}, Kf, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = new ((i = this).options.inputClass || (Bg ? _f : Fg ? Cf : Pg ? Bf : Tf))(i, lf), this.touchAction = new tf(this, this.options.touchAction), Zf(this, !0), Qg(this.options.recognizers, function (t) {\n          var e = o.add(new t[0](t[1]));\n          t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]);\n        }, this);\n      }\n      var e = t.prototype;\n      return e.set = function (t) {\n        return mg(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this;\n      }, e.stop = function (t) {\n        this.session.stopped = t ? 2 : 1;\n      }, e.recognize = function (t) {\n        var e = this.session;\n        if (!e.stopped) {\n          var i;\n          this.touchAction.preventDefaults(t);\n          var o = this.recognizers,\n            s = e.curRecognizer;\n          (!s || s && 8 & s.state) && (e.curRecognizer = null, s = null);\n          for (var n = 0; n < o.length;) i = o[n], 2 === e.stopped || s && i !== s && !i.canRecognizeWith(s) ? i.reset() : i.recognize(t), !s && 14 & i.state && (e.curRecognizer = i, s = i), n++;\n        }\n      }, e.get = function (t) {\n        if (t instanceof jf) return t;\n        for (var e = this.recognizers, i = 0; i < e.length; i++) if (e[i].options.event === t) return e[i];\n        return null;\n      }, e.add = function (t) {\n        if (Ff(t, \"add\", this)) return this;\n        var e = this.get(t.options.event);\n        return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t;\n      }, e.remove = function (t) {\n        if (Ff(t, \"remove\", this)) return this;\n        var e = this.get(t);\n        if (t) {\n          var i = this.recognizers,\n            o = mf(i, e);\n          -1 !== o && (i.splice(o, 1), this.touchAction.update());\n        }\n        return this;\n      }, e.on = function (t, e) {\n        if (void 0 === t || void 0 === e) return this;\n        var i = this.handlers;\n        return Qg(cf(t), function (t) {\n          i[t] = i[t] || [], i[t].push(e);\n        }), this;\n      }, e.off = function (t, e) {\n        if (void 0 === t) return this;\n        var i = this.handlers;\n        return Qg(cf(t), function (t) {\n          e ? i[t] && i[t].splice(mf(i[t], e), 1) : delete i[t];\n        }), this;\n      }, e.emit = function (t, e) {\n        this.options.domEvents && function (t, e) {\n          var i = document.createEvent(\"Event\");\n          i.initEvent(t, !0, !0), i.gesture = e, e.target.dispatchEvent(i);\n        }(t, e);\n        var i = this.handlers[t] && this.handlers[t].slice();\n        if (i && i.length) {\n          e.type = t, e.preventDefault = function () {\n            e.srcEvent.preventDefault();\n          };\n          for (var o = 0; o < i.length;) i[o](e), o++;\n        }\n      }, e.destroy = function () {\n        this.element && Zf(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;\n      }, t;\n    }(),\n    $f = {\n      touchstart: Rg,\n      touchmove: 2,\n      touchend: jg,\n      touchcancel: Lg\n    },\n    Jf = function (t) {\n      function e() {\n        var i,\n          o = e.prototype;\n        return o.evTarget = \"touchstart\", o.evWin = \"touchstart touchmove touchend touchcancel\", (i = t.apply(this, arguments) || this).started = !1, i;\n      }\n      return pg(e, t), e.prototype.handler = function (t) {\n        var e = $f[t.type];\n        if (e === Rg && (this.started = !0), this.started) {\n          var i = tm.call(this, t, e);\n          e & (jg | Lg) && i[0].length - i[1].length == 0 && (this.started = !1), this.callback(this.manager, e, {\n            pointers: i[0],\n            changedPointers: i[1],\n            pointerType: zg,\n            srcEvent: t\n          });\n        }\n      }, e;\n    }(ff);\n  function tm(t, e) {\n    var i = xf(t.touches),\n      o = xf(t.changedTouches);\n    return e & (jg | Lg) && (i = Ef(i.concat(o), \"identifier\", !0)), [i, o];\n  }\n  function em(t, e, i) {\n    var o = \"DEPRECATED METHOD: \" + e + \"\\n\" + i + \" AT \\n\";\n    return function () {\n      var e = new Error(\"get-stack-trace\"),\n        i = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, \"\").replace(/^\\s+at\\s+/gm, \"\").replace(/^Object.<anonymous>\\s*\\(/gm, \"{anonymous}()@\") : \"Unknown Stack Trace\",\n        s = window.console && (window.console.warn || window.console.log);\n      return s && s.call(window.console, o, i), t.apply(this, arguments);\n    };\n  }\n  var im = em(function (t, e, i) {\n      for (var o = Object.keys(e), s = 0; s < o.length;) (!i || i && void 0 === t[o[s]]) && (t[o[s]] = e[o[s]]), s++;\n      return t;\n    }, \"extend\", \"Use `assign`.\"),\n    om = em(function (t, e) {\n      return im(t, e, !0);\n    }, \"merge\", \"Use `assign`.\");\n  function sm(t, e, i) {\n    var o,\n      s = e.prototype;\n    (o = t.prototype = Object.create(s)).constructor = t, o._super = s, i && mg(o, i);\n  }\n  function nm(t, e) {\n    return function () {\n      return t.apply(e, arguments);\n    };\n  }\n  var rm = function () {\n    var t = function (t, e) {\n      return void 0 === e && (e = {}), new Qf(t, ug({\n        recognizers: Gf.concat()\n      }, e));\n    };\n    return t.VERSION = \"2.0.17-rc\", t.DIRECTION_ALL = Kg, t.DIRECTION_DOWN = Ug, t.DIRECTION_LEFT = Wg, t.DIRECTION_RIGHT = Vg, t.DIRECTION_UP = qg, t.DIRECTION_HORIZONTAL = Yg, t.DIRECTION_VERTICAL = Xg, t.DIRECTION_NONE = Hg, t.DIRECTION_DOWN = Ug, t.INPUT_START = Rg, t.INPUT_MOVE = 2, t.INPUT_END = jg, t.INPUT_CANCEL = Lg, t.STATE_POSSIBLE = 1, t.STATE_BEGAN = 2, t.STATE_CHANGED = 4, t.STATE_ENDED = 8, t.STATE_RECOGNIZED = 8, t.STATE_CANCELLED = 16, t.STATE_FAILED = zf, t.Manager = Qf, t.Input = ff, t.TouchAction = tf, t.TouchInput = Cf, t.MouseInput = Tf, t.PointerEventInput = _f, t.TouchMouseInput = Bf, t.SingleTouchInput = Jf, t.Recognizer = jf, t.AttrRecognizer = Hf, t.Tap = Lf, t.Pan = Vf, t.Swipe = qf, t.Pinch = Uf, t.Rotate = Yf, t.Press = Xf, t.on = uf, t.off = pf, t.each = Qg, t.merge = om, t.extend = im, t.bindFn = nm, t.assign = mg, t.inherit = sm, t.bindFn = nm, t.prefixed = xg, t.toArray = xf, t.inArray = mf, t.uniqueArray = Ef, t.splitStr = cf, t.boolOrFn = $g, t.hasParent = ef, t.addEventListeners = uf, t.removeEventListeners = pf, t.defaults = mg({}, Kf, {\n      preset: Gf\n    }), t;\n  }();\n  rm.defaults;\n  var am = rm;\n  function hm() {\n    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];\n    return function (t) {\n      let [e, i, o] = function () {\n          const t = function () {\n            let t = 4022871197;\n            return function (e) {\n              const i = e.toString();\n              for (let e = 0; e < i.length; e++) {\n                t += i.charCodeAt(e);\n                let o = .02519603282416938 * t;\n                t = o >>> 0, o -= t, o *= t, t = o >>> 0, o -= t, t += 4294967296 * o;\n              }\n              return 2.3283064365386963e-10 * (t >>> 0);\n            };\n          }();\n          let e = t(\" \"),\n            i = t(\" \"),\n            o = t(\" \");\n          for (let s = 0; s < arguments.length; s++) e -= t(s < 0 || arguments.length <= s ? void 0 : arguments[s]), e < 0 && (e += 1), i -= t(s < 0 || arguments.length <= s ? void 0 : arguments[s]), i < 0 && (i += 1), o -= t(s < 0 || arguments.length <= s ? void 0 : arguments[s]), o < 0 && (o += 1);\n          return [e, i, o];\n        }(t),\n        s = 1;\n      const n = () => {\n        const t = 2091639 * e + 2.3283064365386963e-10 * s;\n        return e = i, i = o, o = t - (s = 0 | t);\n      };\n      return n.uint32 = () => 4294967296 * n(), n.fract53 = () => n() + 11102230246251565e-32 * (2097152 * n() | 0), n.algorithm = \"Alea\", n.seed = t, n.version = \"0.9\", n;\n    }(e.length ? e : [oc()]);\n  }\n  ml(\"DELETE\");\n  const dm = \"undefined\" != typeof window ? window.Hammer || am : function () {\n    return function () {\n      const t = () => {};\n      return {\n        on: t,\n        off: t,\n        destroy: t,\n        emit: t,\n        get: () => ({\n          set: t\n        })\n      };\n    }();\n  };\n  function lm(t) {\n    var e;\n    this._cleanupQueue = [], this.active = !1, this._dom = {\n      container: t,\n      overlay: document.createElement(\"div\")\n    }, this._dom.overlay.classList.add(\"vis-overlay\"), this._dom.container.appendChild(this._dom.overlay), this._cleanupQueue.push(() => {\n      this._dom.overlay.parentNode.removeChild(this._dom.overlay);\n    });\n    const i = dm(this._dom.overlay);\n    i.on(\"tap\", Ho(e = this._onTapOverlay).call(e, this)), this._cleanupQueue.push(() => {\n      i.destroy();\n    });\n    const o = [\"tap\", \"doubletap\", \"press\", \"pinch\", \"pan\", \"panstart\", \"panmove\", \"panend\"];\n    mc(o).call(o, t => {\n      i.on(t, t => {\n        t.srcEvent.stopPropagation();\n      });\n    }), document && document.body && (this._onClick = e => {\n      (function (t, e) {\n        for (; t;) {\n          if (t === e) return !0;\n          t = t.parentNode;\n        }\n        return !1;\n      })(e.target, t) || this.deactivate();\n    }, document.body.addEventListener(\"click\", this._onClick), this._cleanupQueue.push(() => {\n      document.body.removeEventListener(\"click\", this._onClick);\n    })), this._escListener = t => {\n      (\"key\" in t ? \"Escape\" === t.key : 27 === t.keyCode) && this.deactivate();\n    };\n  }\n  Go(lm.prototype), lm.current = null, lm.prototype.destroy = function () {\n    this.deactivate();\n    for (const i of kc(t = Jc(e = this._cleanupQueue).call(e, 0)).call(t)) {\n      var t, e;\n      i();\n    }\n  }, lm.prototype.activate = function () {\n    lm.current && lm.current.deactivate(), lm.current = this, this.active = !0, this._dom.overlay.style.display = \"none\", this._dom.container.classList.add(\"vis-active\"), this.emit(\"change\"), this.emit(\"activate\"), document.body.addEventListener(\"keydown\", this._escListener);\n  }, lm.prototype.deactivate = function () {\n    this.active = !1, this._dom.overlay.style.display = \"block\", this._dom.container.classList.remove(\"vis-active\"), document.body.removeEventListener(\"keydown\", this._escListener), this.emit(\"change\"), this.emit(\"deactivate\");\n  }, lm.prototype._onTapOverlay = function (t) {\n    this.activate(), t.srcEvent.stopPropagation();\n  };\n  const cm = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i,\n    um = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,\n    pm = /^rgb\\( *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *\\)$/i,\n    gm = /^rgba\\( *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *([01]|0?\\.\\d+) *\\)$/i;\n  function fm(t) {\n    if (t) for (; !0 === t.hasChildNodes();) {\n      const e = t.firstChild;\n      e && (fm(e), t.removeChild(e));\n    }\n  }\n  function mm(t) {\n    return t instanceof String || \"string\" == typeof t;\n  }\n  function ym(t) {\n    return \"object\" == typeof t && null !== t;\n  }\n  function bm(t, e, i, o) {\n    let s = !1;\n    !0 === o && (s = null === e[i] && void 0 !== t[i]), s ? delete t[i] : t[i] = e[i];\n  }\n  function vm(t, e) {\n    let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n    for (const o in t) if (void 0 !== e[o]) if (null === e[o] || \"object\" != typeof e[o]) bm(t, e, o, i);else {\n      const s = t[o],\n        n = e[o];\n      ym(s) && ym(n) && vm(s, n, i);\n    }\n  }\n  function wm(t, e, i) {\n    let o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];\n    if (Vl(i)) throw new TypeError(\"Arrays are not supported by deepExtend\");\n    for (let s = 0; s < t.length; s++) {\n      const n = t[s];\n      if (Object.prototype.hasOwnProperty.call(i, n)) if (i[n] && i[n].constructor === Object) void 0 === e[n] && (e[n] = {}), e[n].constructor === Object ? xm(e[n], i[n], !1, o) : bm(e, i, n, o);else {\n        if (Vl(i[n])) throw new TypeError(\"Arrays are not supported by deepExtend\");\n        bm(e, i, n, o);\n      }\n    }\n    return e;\n  }\n  function _m(t, e, i) {\n    let o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];\n    if (Vl(i)) throw new TypeError(\"Arrays are not supported by deepExtend\");\n    for (const s in i) if (Object.prototype.hasOwnProperty.call(i, s) && !_u(t).call(t, s)) if (i[s] && i[s].constructor === Object) void 0 === e[s] && (e[s] = {}), e[s].constructor === Object ? xm(e[s], i[s]) : bm(e, i, s, o);else if (Vl(i[s])) {\n      e[s] = [];\n      for (let t = 0; t < i[s].length; t++) e[s].push(i[s][t]);\n    } else bm(e, i, s, o);\n    return e;\n  }\n  function xm(t, e) {\n    let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n      o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];\n    for (const n in e) if (Object.prototype.hasOwnProperty.call(e, n) || !0 === i) if (\"object\" == typeof e[n] && null !== e[n] && Cu(e[n]) === Object.prototype) void 0 === t[n] ? t[n] = xm({}, e[n], i) : \"object\" == typeof t[n] && null !== t[n] && Cu(t[n]) === Object.prototype ? xm(t[n], e[n], i) : bm(t, e, n, o);else if (Vl(e[n])) {\n      var s;\n      t[n] = Nl(s = e[n]).call(s);\n    } else bm(t, e, n, o);\n    return t;\n  }\n  function Em(t, e) {\n    return [...t, e];\n  }\n  function Om(t) {\n    return t.getBoundingClientRect().top;\n  }\n  function Cm(t, e) {\n    if (Vl(t)) {\n      const i = t.length;\n      for (let o = 0; o < i; o++) e(t[o], o, t);\n    } else for (const i in t) Object.prototype.hasOwnProperty.call(t, i) && e(t[i], i, t);\n  }\n  function km(t) {\n    let e;\n    switch (t.length) {\n      case 3:\n      case 4:\n        return e = um.exec(t), e ? {\n          r: bp(e[1] + e[1], 16),\n          g: bp(e[2] + e[2], 16),\n          b: bp(e[3] + e[3], 16)\n        } : null;\n      case 6:\n      case 7:\n        return e = cm.exec(t), e ? {\n          r: bp(e[1], 16),\n          g: bp(e[2], 16),\n          b: bp(e[3], 16)\n        } : null;\n      default:\n        return null;\n    }\n  }\n  function Sm(t, e) {\n    if (_u(t).call(t, \"rgba\")) return t;\n    if (_u(t).call(t, \"rgb\")) {\n      const i = t.substr(Mp(t).call(t, \"(\") + 1).replace(\")\", \"\").split(\",\");\n      return \"rgba(\" + i[0] + \",\" + i[1] + \",\" + i[2] + \",\" + e + \")\";\n    }\n    {\n      const i = km(t);\n      return null == i ? t : \"rgba(\" + i.r + \",\" + i.g + \",\" + i.b + \",\" + e + \")\";\n    }\n  }\n  function Tm(t, e, i) {\n    var o;\n    return \"#\" + Nl(o = ((1 << 24) + (t << 16) + (e << 8) + i).toString(16)).call(o, 1);\n  }\n  function Mm(t, e) {\n    if (mm(t)) {\n      let e = t;\n      if (Fm(e)) {\n        var i;\n        const t = Zl(i = e.substr(4).substr(0, e.length - 5).split(\",\")).call(i, function (t) {\n          return bp(t);\n        });\n        e = Tm(t[0], t[1], t[2]);\n      }\n      if (!0 === Bm(e)) {\n        const t = function (t) {\n            const e = km(t);\n            if (!e) throw new TypeError(\"'\".concat(t, \"' is not a valid color.\"));\n            return Dm(e.r, e.g, e.b);\n          }(e),\n          i = {\n            h: t.h,\n            s: .8 * t.s,\n            v: Math.min(1, 1.02 * t.v)\n          },\n          o = {\n            h: t.h,\n            s: Math.min(1, 1.25 * t.s),\n            v: .8 * t.v\n          },\n          s = Pm(o.h, o.s, o.v),\n          n = Pm(i.h, i.s, i.v);\n        return {\n          background: e,\n          border: s,\n          highlight: {\n            background: n,\n            border: s\n          },\n          hover: {\n            background: n,\n            border: s\n          }\n        };\n      }\n      return {\n        background: e,\n        border: e,\n        highlight: {\n          background: e,\n          border: e\n        },\n        hover: {\n          background: e,\n          border: e\n        }\n      };\n    }\n    if (e) {\n      return {\n        background: t.background || e.background,\n        border: t.border || e.border,\n        highlight: mm(t.highlight) ? {\n          border: t.highlight,\n          background: t.highlight\n        } : {\n          background: t.highlight && t.highlight.background || e.highlight.background,\n          border: t.highlight && t.highlight.border || e.highlight.border\n        },\n        hover: mm(t.hover) ? {\n          border: t.hover,\n          background: t.hover\n        } : {\n          border: t.hover && t.hover.border || e.hover.border,\n          background: t.hover && t.hover.background || e.hover.background\n        }\n      };\n    }\n    return {\n      background: t.background || void 0,\n      border: t.border || void 0,\n      highlight: mm(t.highlight) ? {\n        border: t.highlight,\n        background: t.highlight\n      } : {\n        background: t.highlight && t.highlight.background || void 0,\n        border: t.highlight && t.highlight.border || void 0\n      },\n      hover: mm(t.hover) ? {\n        border: t.hover,\n        background: t.hover\n      } : {\n        border: t.hover && t.hover.border || void 0,\n        background: t.hover && t.hover.background || void 0\n      }\n    };\n  }\n  function Dm(t, e, i) {\n    t /= 255, e /= 255, i /= 255;\n    const o = Math.min(t, Math.min(e, i)),\n      s = Math.max(t, Math.max(e, i));\n    if (o === s) return {\n      h: 0,\n      s: 0,\n      v: o\n    };\n    return {\n      h: 60 * ((t === o ? 3 : i === o ? 1 : 5) - (t === o ? e - i : i === o ? t - e : i - t) / (s - o)) / 360,\n      s: (s - o) / s,\n      v: s\n    };\n  }\n  function Im(t, e, i) {\n    let o, s, n;\n    const r = Math.floor(6 * t),\n      a = 6 * t - r,\n      h = i * (1 - e),\n      d = i * (1 - a * e),\n      l = i * (1 - (1 - a) * e);\n    switch (r % 6) {\n      case 0:\n        o = i, s = l, n = h;\n        break;\n      case 1:\n        o = d, s = i, n = h;\n        break;\n      case 2:\n        o = h, s = i, n = l;\n        break;\n      case 3:\n        o = h, s = d, n = i;\n        break;\n      case 4:\n        o = l, s = h, n = i;\n        break;\n      case 5:\n        o = i, s = h, n = d;\n    }\n    return {\n      r: Math.floor(255 * o),\n      g: Math.floor(255 * s),\n      b: Math.floor(255 * n)\n    };\n  }\n  function Pm(t, e, i) {\n    const o = Im(t, e, i);\n    return Tm(o.r, o.g, o.b);\n  }\n  function Bm(t) {\n    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t);\n  }\n  function Fm(t) {\n    return pm.test(t);\n  }\n  function zm(t) {\n    if (null === t || \"object\" != typeof t) return null;\n    if (t instanceof Element) return t;\n    const e = Ip(t);\n    for (const i in t) Object.prototype.hasOwnProperty.call(t, i) && \"object\" == typeof t[i] && (e[i] = zm(t[i]));\n    return e;\n  }\n  function Nm(t, e, i) {\n    let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};\n    const s = function (t) {\n        return null != t;\n      },\n      n = function (t) {\n        return null !== t && \"object\" == typeof t;\n      };\n    if (!n(t)) throw new Error(\"Parameter mergeTarget must be an object\");\n    if (!n(e)) throw new Error(\"Parameter options must be an object\");\n    if (!s(i)) throw new Error(\"Parameter option must have a value\");\n    if (!n(o)) throw new Error(\"Parameter globalOptions must be an object\");\n    const r = e[i],\n      a = n(o) && !function (t) {\n        for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1;\n        return !0;\n      }(o) ? o[i] : void 0,\n      h = a ? a.enabled : void 0;\n    if (void 0 === r) return;\n    if (\"boolean\" == typeof r) return n(t[i]) || (t[i] = {}), void (t[i].enabled = r);\n    if (null === r && !n(t[i])) {\n      if (!s(a)) return;\n      t[i] = Ip(a);\n    }\n    if (!n(r)) return;\n    let d = !0;\n    void 0 !== r.enabled ? d = r.enabled : void 0 !== h && (d = a.enabled), function (t, e, i) {\n      n(t[i]) || (t[i] = {});\n      const o = e[i],\n        s = t[i];\n      for (const t in o) Object.prototype.hasOwnProperty.call(o, t) && (s[t] = o[t]);\n    }(t, e, i), t[i].enabled = d;\n  }\n  const Am = {\n    linear: t => t,\n    easeInQuad: t => t * t,\n    easeOutQuad: t => t * (2 - t),\n    easeInOutQuad: t => t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1,\n    easeInCubic: t => t * t * t,\n    easeOutCubic: t => --t * t * t + 1,\n    easeInOutCubic: t => t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,\n    easeInQuart: t => t * t * t * t,\n    easeOutQuart: t => 1 - --t * t * t * t,\n    easeInOutQuart: t => t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t,\n    easeInQuint: t => t * t * t * t * t,\n    easeOutQuint: t => 1 + --t * t * t * t * t,\n    easeInOutQuint: t => t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t\n  };\n  function Rm(t, e) {\n    let i;\n    Vl(e) || (e = [e]);\n    for (const o of t) if (o) {\n      i = o[e[0]];\n      for (let t = 1; t < e.length; t++) i && (i = i[e[t]]);\n      if (void 0 !== i) break;\n    }\n    return i;\n  }\n  const jm = {\n    black: \"#000000\",\n    navy: \"#000080\",\n    darkblue: \"#00008B\",\n    mediumblue: \"#0000CD\",\n    blue: \"#0000FF\",\n    darkgreen: \"#006400\",\n    green: \"#008000\",\n    teal: \"#008080\",\n    darkcyan: \"#008B8B\",\n    deepskyblue: \"#00BFFF\",\n    darkturquoise: \"#00CED1\",\n    mediumspringgreen: \"#00FA9A\",\n    lime: \"#00FF00\",\n    springgreen: \"#00FF7F\",\n    aqua: \"#00FFFF\",\n    cyan: \"#00FFFF\",\n    midnightblue: \"#191970\",\n    dodgerblue: \"#1E90FF\",\n    lightseagreen: \"#20B2AA\",\n    forestgreen: \"#228B22\",\n    seagreen: \"#2E8B57\",\n    darkslategray: \"#2F4F4F\",\n    limegreen: \"#32CD32\",\n    mediumseagreen: \"#3CB371\",\n    turquoise: \"#40E0D0\",\n    royalblue: \"#4169E1\",\n    steelblue: \"#4682B4\",\n    darkslateblue: \"#483D8B\",\n    mediumturquoise: \"#48D1CC\",\n    indigo: \"#4B0082\",\n    darkolivegreen: \"#556B2F\",\n    cadetblue: \"#5F9EA0\",\n    cornflowerblue: \"#6495ED\",\n    mediumaquamarine: \"#66CDAA\",\n    dimgray: \"#696969\",\n    slateblue: \"#6A5ACD\",\n    olivedrab: \"#6B8E23\",\n    slategray: \"#708090\",\n    lightslategray: \"#778899\",\n    mediumslateblue: \"#7B68EE\",\n    lawngreen: \"#7CFC00\",\n    chartreuse: \"#7FFF00\",\n    aquamarine: \"#7FFFD4\",\n    maroon: \"#800000\",\n    purple: \"#800080\",\n    olive: \"#808000\",\n    gray: \"#808080\",\n    skyblue: \"#87CEEB\",\n    lightskyblue: \"#87CEFA\",\n    blueviolet: \"#8A2BE2\",\n    darkred: \"#8B0000\",\n    darkmagenta: \"#8B008B\",\n    saddlebrown: \"#8B4513\",\n    darkseagreen: \"#8FBC8F\",\n    lightgreen: \"#90EE90\",\n    mediumpurple: \"#9370D8\",\n    darkviolet: \"#9400D3\",\n    palegreen: \"#98FB98\",\n    darkorchid: \"#9932CC\",\n    yellowgreen: \"#9ACD32\",\n    sienna: \"#A0522D\",\n    brown: \"#A52A2A\",\n    darkgray: \"#A9A9A9\",\n    lightblue: \"#ADD8E6\",\n    greenyellow: \"#ADFF2F\",\n    paleturquoise: \"#AFEEEE\",\n    lightsteelblue: \"#B0C4DE\",\n    powderblue: \"#B0E0E6\",\n    firebrick: \"#B22222\",\n    darkgoldenrod: \"#B8860B\",\n    mediumorchid: \"#BA55D3\",\n    rosybrown: \"#BC8F8F\",\n    darkkhaki: \"#BDB76B\",\n    silver: \"#C0C0C0\",\n    mediumvioletred: \"#C71585\",\n    indianred: \"#CD5C5C\",\n    peru: \"#CD853F\",\n    chocolate: \"#D2691E\",\n    tan: \"#D2B48C\",\n    lightgrey: \"#D3D3D3\",\n    palevioletred: \"#D87093\",\n    thistle: \"#D8BFD8\",\n    orchid: \"#DA70D6\",\n    goldenrod: \"#DAA520\",\n    crimson: \"#DC143C\",\n    gainsboro: \"#DCDCDC\",\n    plum: \"#DDA0DD\",\n    burlywood: \"#DEB887\",\n    lightcyan: \"#E0FFFF\",\n    lavender: \"#E6E6FA\",\n    darksalmon: \"#E9967A\",\n    violet: \"#EE82EE\",\n    palegoldenrod: \"#EEE8AA\",\n    lightcoral: \"#F08080\",\n    khaki: \"#F0E68C\",\n    aliceblue: \"#F0F8FF\",\n    honeydew: \"#F0FFF0\",\n    azure: \"#F0FFFF\",\n    sandybrown: \"#F4A460\",\n    wheat: \"#F5DEB3\",\n    beige: \"#F5F5DC\",\n    whitesmoke: \"#F5F5F5\",\n    mintcream: \"#F5FFFA\",\n    ghostwhite: \"#F8F8FF\",\n    salmon: \"#FA8072\",\n    antiquewhite: \"#FAEBD7\",\n    linen: \"#FAF0E6\",\n    lightgoldenrodyellow: \"#FAFAD2\",\n    oldlace: \"#FDF5E6\",\n    red: \"#FF0000\",\n    fuchsia: \"#FF00FF\",\n    magenta: \"#FF00FF\",\n    deeppink: \"#FF1493\",\n    orangered: \"#FF4500\",\n    tomato: \"#FF6347\",\n    hotpink: \"#FF69B4\",\n    coral: \"#FF7F50\",\n    darkorange: \"#FF8C00\",\n    lightsalmon: \"#FFA07A\",\n    orange: \"#FFA500\",\n    lightpink: \"#FFB6C1\",\n    pink: \"#FFC0CB\",\n    gold: \"#FFD700\",\n    peachpuff: \"#FFDAB9\",\n    navajowhite: \"#FFDEAD\",\n    moccasin: \"#FFE4B5\",\n    bisque: \"#FFE4C4\",\n    mistyrose: \"#FFE4E1\",\n    blanchedalmond: \"#FFEBCD\",\n    papayawhip: \"#FFEFD5\",\n    lavenderblush: \"#FFF0F5\",\n    seashell: \"#FFF5EE\",\n    cornsilk: \"#FFF8DC\",\n    lemonchiffon: \"#FFFACD\",\n    floralwhite: \"#FFFAF0\",\n    snow: \"#FFFAFA\",\n    yellow: \"#FFFF00\",\n    lightyellow: \"#FFFFE0\",\n    ivory: \"#FFFFF0\",\n    white: \"#FFFFFF\"\n  };\n  let Lm = class {\n    constructor() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;\n      this.pixelRatio = t, this.generated = !1, this.centerCoordinates = {\n        x: 144.5,\n        y: 144.5\n      }, this.r = 289 * .49, this.color = {\n        r: 255,\n        g: 255,\n        b: 255,\n        a: 1\n      }, this.hueCircle = void 0, this.initialColor = {\n        r: 255,\n        g: 255,\n        b: 255,\n        a: 1\n      }, this.previousColor = void 0, this.applied = !1, this.updateCallback = () => {}, this.closeCallback = () => {}, this._create();\n    }\n    insertTo(t) {\n      void 0 !== this.hammer && (this.hammer.destroy(), this.hammer = void 0), this.container = t, this.container.appendChild(this.frame), this._bindHammer(), this._setSize();\n    }\n    setUpdateCallback(t) {\n      if (\"function\" != typeof t) throw new Error(\"Function attempted to set as colorPicker update callback is not a function.\");\n      this.updateCallback = t;\n    }\n    setCloseCallback(t) {\n      if (\"function\" != typeof t) throw new Error(\"Function attempted to set as colorPicker closing callback is not a function.\");\n      this.closeCallback = t;\n    }\n    _isColorString(t) {\n      if (\"string\" == typeof t) return jm[t];\n    }\n    setColor(t) {\n      let e,\n        i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      if (\"none\" === t) return;\n      const o = this._isColorString(t);\n      if (void 0 !== o && (t = o), !0 === mm(t)) {\n        if (!0 === Fm(t)) {\n          const i = t.substr(4).substr(0, t.length - 5).split(\",\");\n          e = {\n            r: i[0],\n            g: i[1],\n            b: i[2],\n            a: 1\n          };\n        } else if (!0 === function (t) {\n          return gm.test(t);\n        }(t)) {\n          const i = t.substr(5).substr(0, t.length - 6).split(\",\");\n          e = {\n            r: i[0],\n            g: i[1],\n            b: i[2],\n            a: i[3]\n          };\n        } else if (!0 === Bm(t)) {\n          const i = km(t);\n          e = {\n            r: i.r,\n            g: i.g,\n            b: i.b,\n            a: 1\n          };\n        }\n      } else if (t instanceof Object && void 0 !== t.r && void 0 !== t.g && void 0 !== t.b) {\n        const i = void 0 !== t.a ? t.a : \"1.0\";\n        e = {\n          r: t.r,\n          g: t.g,\n          b: t.b,\n          a: i\n        };\n      }\n      if (void 0 === e) throw new Error(\"Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: \" + zp(t));\n      this._setColor(e, i);\n    }\n    show() {\n      void 0 !== this.closeCallback && (this.closeCallback(), this.closeCallback = void 0), this.applied = !1, this.frame.style.display = \"block\", this._generateHueCircle();\n    }\n    _hide() {\n      !0 === (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]) && (this.previousColor = wo({}, this.color)), !0 === this.applied && this.updateCallback(this.initialColor), this.frame.style.display = \"none\", tg(() => {\n        void 0 !== this.closeCallback && (this.closeCallback(), this.closeCallback = void 0);\n      }, 0);\n    }\n    _save() {\n      this.updateCallback(this.color), this.applied = !1, this._hide();\n    }\n    _apply() {\n      this.applied = !0, this.updateCallback(this.color), this._updatePicker(this.color);\n    }\n    _loadLast() {\n      void 0 !== this.previousColor ? this.setColor(this.previousColor, !1) : alert(\"There is no last color to load...\");\n    }\n    _setColor(t) {\n      !0 === (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) && (this.initialColor = wo({}, t)), this.color = t;\n      const e = Dm(t.r, t.g, t.b),\n        i = 2 * Math.PI,\n        o = this.r * e.s,\n        s = this.centerCoordinates.x + o * Math.sin(i * e.h),\n        n = this.centerCoordinates.y + o * Math.cos(i * e.h);\n      this.colorPickerSelector.style.left = s - .5 * this.colorPickerSelector.clientWidth + \"px\", this.colorPickerSelector.style.top = n - .5 * this.colorPickerSelector.clientHeight + \"px\", this._updatePicker(t);\n    }\n    _setOpacity(t) {\n      this.color.a = t / 100, this._updatePicker(this.color);\n    }\n    _setBrightness(t) {\n      const e = Dm(this.color.r, this.color.g, this.color.b);\n      e.v = t / 100;\n      const i = Im(e.h, e.s, e.v);\n      i.a = this.color.a, this.color = i, this._updatePicker();\n    }\n    _updatePicker() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.color;\n      const e = Dm(t.r, t.g, t.b),\n        i = this.colorPickerCanvas.getContext(\"2d\");\n      void 0 === this.pixelRation && (this.pixelRatio = (window.devicePixelRatio || 1) / (i.webkitBackingStorePixelRatio || i.mozBackingStorePixelRatio || i.msBackingStorePixelRatio || i.oBackingStorePixelRatio || i.backingStorePixelRatio || 1)), i.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n      const o = this.colorPickerCanvas.clientWidth,\n        s = this.colorPickerCanvas.clientHeight;\n      i.clearRect(0, 0, o, s), i.putImageData(this.hueCircle, 0, 0), i.fillStyle = \"rgba(0,0,0,\" + (1 - e.v) + \")\", i.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r), cg(i).call(i), this.brightnessRange.value = 100 * e.v, this.opacityRange.value = 100 * t.a, this.initialColorDiv.style.backgroundColor = \"rgba(\" + this.initialColor.r + \",\" + this.initialColor.g + \",\" + this.initialColor.b + \",\" + this.initialColor.a + \")\", this.newColorDiv.style.backgroundColor = \"rgba(\" + this.color.r + \",\" + this.color.g + \",\" + this.color.b + \",\" + this.color.a + \")\";\n    }\n    _setSize() {\n      this.colorPickerCanvas.style.width = \"100%\", this.colorPickerCanvas.style.height = \"100%\", this.colorPickerCanvas.width = 289 * this.pixelRatio, this.colorPickerCanvas.height = 289 * this.pixelRatio;\n    }\n    _create() {\n      var t, e, i, o;\n      if (this.frame = document.createElement(\"div\"), this.frame.className = \"vis-color-picker\", this.colorPickerDiv = document.createElement(\"div\"), this.colorPickerSelector = document.createElement(\"div\"), this.colorPickerSelector.className = \"vis-selector\", this.colorPickerDiv.appendChild(this.colorPickerSelector), this.colorPickerCanvas = document.createElement(\"canvas\"), this.colorPickerDiv.appendChild(this.colorPickerCanvas), this.colorPickerCanvas.getContext) {\n        const t = this.colorPickerCanvas.getContext(\"2d\");\n        this.pixelRatio = (window.devicePixelRatio || 1) / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1), this.colorPickerCanvas.getContext(\"2d\").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n      } else {\n        const t = document.createElement(\"DIV\");\n        t.style.color = \"red\", t.style.fontWeight = \"bold\", t.style.padding = \"10px\", t.innerText = \"Error: your browser does not support HTML canvas\", this.colorPickerCanvas.appendChild(t);\n      }\n      this.colorPickerDiv.className = \"vis-color\", this.opacityDiv = document.createElement(\"div\"), this.opacityDiv.className = \"vis-opacity\", this.brightnessDiv = document.createElement(\"div\"), this.brightnessDiv.className = \"vis-brightness\", this.arrowDiv = document.createElement(\"div\"), this.arrowDiv.className = \"vis-arrow\", this.opacityRange = document.createElement(\"input\");\n      try {\n        this.opacityRange.type = \"range\", this.opacityRange.min = \"0\", this.opacityRange.max = \"100\";\n      } catch (t) {}\n      this.opacityRange.value = \"100\", this.opacityRange.className = \"vis-range\", this.brightnessRange = document.createElement(\"input\");\n      try {\n        this.brightnessRange.type = \"range\", this.brightnessRange.min = \"0\", this.brightnessRange.max = \"100\";\n      } catch (t) {}\n      this.brightnessRange.value = \"100\", this.brightnessRange.className = \"vis-range\", this.opacityDiv.appendChild(this.opacityRange), this.brightnessDiv.appendChild(this.brightnessRange);\n      const s = this;\n      this.opacityRange.onchange = function () {\n        s._setOpacity(this.value);\n      }, this.opacityRange.oninput = function () {\n        s._setOpacity(this.value);\n      }, this.brightnessRange.onchange = function () {\n        s._setBrightness(this.value);\n      }, this.brightnessRange.oninput = function () {\n        s._setBrightness(this.value);\n      }, this.brightnessLabel = document.createElement(\"div\"), this.brightnessLabel.className = \"vis-label vis-brightness\", this.brightnessLabel.innerText = \"brightness:\", this.opacityLabel = document.createElement(\"div\"), this.opacityLabel.className = \"vis-label vis-opacity\", this.opacityLabel.innerText = \"opacity:\", this.newColorDiv = document.createElement(\"div\"), this.newColorDiv.className = \"vis-new-color\", this.newColorDiv.innerText = \"new\", this.initialColorDiv = document.createElement(\"div\"), this.initialColorDiv.className = \"vis-initial-color\", this.initialColorDiv.innerText = \"initial\", this.cancelButton = document.createElement(\"div\"), this.cancelButton.className = \"vis-button vis-cancel\", this.cancelButton.innerText = \"cancel\", this.cancelButton.onclick = Ho(t = this._hide).call(t, this, !1), this.applyButton = document.createElement(\"div\"), this.applyButton.className = \"vis-button vis-apply\", this.applyButton.innerText = \"apply\", this.applyButton.onclick = Ho(e = this._apply).call(e, this), this.saveButton = document.createElement(\"div\"), this.saveButton.className = \"vis-button vis-save\", this.saveButton.innerText = \"save\", this.saveButton.onclick = Ho(i = this._save).call(i, this), this.loadButton = document.createElement(\"div\"), this.loadButton.className = \"vis-button vis-load\", this.loadButton.innerText = \"load last\", this.loadButton.onclick = Ho(o = this._loadLast).call(o, this), this.frame.appendChild(this.colorPickerDiv), this.frame.appendChild(this.arrowDiv), this.frame.appendChild(this.brightnessLabel), this.frame.appendChild(this.brightnessDiv), this.frame.appendChild(this.opacityLabel), this.frame.appendChild(this.opacityDiv), this.frame.appendChild(this.newColorDiv), this.frame.appendChild(this.initialColorDiv), this.frame.appendChild(this.cancelButton), this.frame.appendChild(this.applyButton), this.frame.appendChild(this.saveButton), this.frame.appendChild(this.loadButton);\n    }\n    _bindHammer() {\n      this.drag = {}, this.pinch = {}, this.hammer = new dm(this.colorPickerCanvas), this.hammer.get(\"pinch\").set({\n        enable: !0\n      }), this.hammer.on(\"hammer.input\", t => {\n        t.isFirst && this._moveSelector(t);\n      }), this.hammer.on(\"tap\", t => {\n        this._moveSelector(t);\n      }), this.hammer.on(\"panstart\", t => {\n        this._moveSelector(t);\n      }), this.hammer.on(\"panmove\", t => {\n        this._moveSelector(t);\n      }), this.hammer.on(\"panend\", t => {\n        this._moveSelector(t);\n      });\n    }\n    _generateHueCircle() {\n      if (!1 === this.generated) {\n        const t = this.colorPickerCanvas.getContext(\"2d\");\n        void 0 === this.pixelRation && (this.pixelRatio = (window.devicePixelRatio || 1) / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1)), t.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n        const e = this.colorPickerCanvas.clientWidth,\n          i = this.colorPickerCanvas.clientHeight;\n        let o, s, n, r;\n        t.clearRect(0, 0, e, i), this.centerCoordinates = {\n          x: .5 * e,\n          y: .5 * i\n        }, this.r = .49 * e;\n        const a = 2 * Math.PI / 360,\n          h = 1 / 360,\n          d = 1 / this.r;\n        let l;\n        for (n = 0; n < 360; n++) for (r = 0; r < this.r; r++) o = this.centerCoordinates.x + r * Math.sin(a * n), s = this.centerCoordinates.y + r * Math.cos(a * n), l = Im(n * h, r * d, 1), t.fillStyle = \"rgb(\" + l.r + \",\" + l.g + \",\" + l.b + \")\", t.fillRect(o - .5, s - .5, 2, 2);\n        t.strokeStyle = \"rgba(0,0,0,1)\", t.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r), t.stroke(), this.hueCircle = t.getImageData(0, 0, e, i);\n      }\n      this.generated = !0;\n    }\n    _moveSelector(t) {\n      const e = this.colorPickerDiv.getBoundingClientRect(),\n        i = t.center.x - e.left,\n        o = t.center.y - e.top,\n        s = .5 * this.colorPickerDiv.clientHeight,\n        n = .5 * this.colorPickerDiv.clientWidth,\n        r = i - n,\n        a = o - s,\n        h = Math.atan2(r, a),\n        d = .98 * Math.min(Math.sqrt(r * r + a * a), n),\n        l = Math.cos(h) * d + s,\n        c = Math.sin(h) * d + n;\n      this.colorPickerSelector.style.top = l - .5 * this.colorPickerSelector.clientHeight + \"px\", this.colorPickerSelector.style.left = c - .5 * this.colorPickerSelector.clientWidth + \"px\";\n      let u = h / (2 * Math.PI);\n      u = u < 0 ? u + 1 : u;\n      const p = d / this.r,\n        g = Dm(this.color.r, this.color.g, this.color.b);\n      g.h = u, g.s = p;\n      const f = Im(g.h, g.s, g.v);\n      f.a = this.color.a, this.color = f, this.initialColorDiv.style.backgroundColor = \"rgba(\" + this.initialColor.r + \",\" + this.initialColor.g + \",\" + this.initialColor.b + \",\" + this.initialColor.a + \")\", this.newColorDiv.style.backgroundColor = \"rgba(\" + this.color.r + \",\" + this.color.g + \",\" + this.color.b + \",\" + this.color.a + \")\";\n    }\n  };\n  function Hm() {\n    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];\n    if (e.length < 1) throw new TypeError(\"Invalid arguments.\");\n    if (1 === e.length) return document.createTextNode(e[0]);\n    {\n      const t = document.createElement(e[0]);\n      return t.appendChild(Hm(...Nl(e).call(e, 1))), t;\n    }\n  }\n  let Wm,\n    Vm = !1;\n  const qm = \"background: #FFeeee; color: #dd0000\";\n  const Um = lm,\n    Ym = class {\n      constructor(t, e, i) {\n        let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,\n          s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : () => !1;\n        this.parent = t, this.changedOptions = [], this.container = e, this.allowCreation = !1, this.hideOption = s, this.options = {}, this.initialized = !1, this.popupCounter = 0, this.defaultOptions = {\n          enabled: !1,\n          filter: !0,\n          container: void 0,\n          showButton: !0\n        }, wo(this.options, this.defaultOptions), this.configureOptions = i, this.moduleOptions = {}, this.domElements = [], this.popupDiv = {}, this.popupLimit = 5, this.popupHistory = {}, this.colorPicker = new Lm(o), this.wrapper = void 0;\n      }\n      setOptions(t) {\n        if (void 0 !== t) {\n          this.popupHistory = {}, this._removePopup();\n          let e = !0;\n          if (\"string\" == typeof t) this.options.filter = t;else if (Vl(t)) this.options.filter = t.join();else if (\"object\" == typeof t) {\n            if (null == t) throw new TypeError(\"options cannot be null\");\n            void 0 !== t.container && (this.options.container = t.container), void 0 !== Ru(t) && (this.options.filter = Ru(t)), void 0 !== t.showButton && (this.options.showButton = t.showButton), void 0 !== t.enabled && (e = t.enabled);\n          } else \"boolean\" == typeof t ? (this.options.filter = !0, e = t) : \"function\" == typeof t && (this.options.filter = t, e = !0);\n          !1 === Ru(this.options) && (e = !1), this.options.enabled = e;\n        }\n        this._clean();\n      }\n      setModuleOptions(t) {\n        this.moduleOptions = t, !0 === this.options.enabled && (this._clean(), void 0 !== this.options.container && (this.container = this.options.container), this._create());\n      }\n      _create() {\n        this._clean(), this.changedOptions = [];\n        const t = Ru(this.options);\n        let e = 0,\n          i = !1;\n        for (const o in this.configureOptions) Object.prototype.hasOwnProperty.call(this.configureOptions, o) && (this.allowCreation = !1, i = !1, \"function\" == typeof t ? (i = t(o, []), i = i || this._handleObject(this.configureOptions[o], [o], !0)) : !0 !== t && -1 === Mp(t).call(t, o) || (i = !0), !1 !== i && (this.allowCreation = !0, e > 0 && this._makeItem([]), this._makeHeader(o), this._handleObject(this.configureOptions[o], [o])), e++);\n        this._makeButton(), this._push();\n      }\n      _push() {\n        this.wrapper = document.createElement(\"div\"), this.wrapper.className = \"vis-configuration-wrapper\", this.container.appendChild(this.wrapper);\n        for (let t = 0; t < this.domElements.length; t++) this.wrapper.appendChild(this.domElements[t]);\n        this._showPopupIfNeeded();\n      }\n      _clean() {\n        for (let t = 0; t < this.domElements.length; t++) this.wrapper.removeChild(this.domElements[t]);\n        void 0 !== this.wrapper && (this.container.removeChild(this.wrapper), this.wrapper = void 0), this.domElements = [], this._removePopup();\n      }\n      _getValue(t) {\n        let e = this.moduleOptions;\n        for (let i = 0; i < t.length; i++) {\n          if (void 0 === e[t[i]]) {\n            e = void 0;\n            break;\n          }\n          e = e[t[i]];\n        }\n        return e;\n      }\n      _makeItem(t) {\n        if (!0 === this.allowCreation) {\n          const s = document.createElement(\"div\");\n          s.className = \"vis-configuration vis-config-item vis-config-s\" + t.length;\n          for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), o = 1; o < e; o++) i[o - 1] = arguments[o];\n          return mc(i).call(i, t => {\n            s.appendChild(t);\n          }), this.domElements.push(s), this.domElements.length;\n        }\n        return 0;\n      }\n      _makeHeader(t) {\n        const e = document.createElement(\"div\");\n        e.className = \"vis-configuration vis-config-header\", e.innerText = t, this._makeItem([], e);\n      }\n      _makeLabel(t, e) {\n        let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n        const o = document.createElement(\"div\");\n        if (o.className = \"vis-configuration vis-config-label vis-config-s\" + e.length, !0 === i) {\n          for (; o.firstChild;) o.removeChild(o.firstChild);\n          o.appendChild(Hm(\"i\", \"b\", t));\n        } else o.innerText = t + \":\";\n        return o;\n      }\n      _makeDropdown(t, e, i) {\n        const o = document.createElement(\"select\");\n        o.className = \"vis-configuration vis-config-select\";\n        let s = 0;\n        void 0 !== e && -1 !== Mp(t).call(t, e) && (s = Mp(t).call(t, e));\n        for (let e = 0; e < t.length; e++) {\n          const i = document.createElement(\"option\");\n          i.value = t[e], e === s && (i.selected = \"selected\"), i.innerText = t[e], o.appendChild(i);\n        }\n        const n = this;\n        o.onchange = function () {\n          n._update(this.value, i);\n        };\n        const r = this._makeLabel(i[i.length - 1], i);\n        this._makeItem(i, r, o);\n      }\n      _makeRange(t, e, i) {\n        const o = t[0],\n          s = t[1],\n          n = t[2],\n          r = t[3],\n          a = document.createElement(\"input\");\n        a.className = \"vis-configuration vis-config-range\";\n        try {\n          a.type = \"range\", a.min = s, a.max = n;\n        } catch (t) {}\n        a.step = r;\n        let h = \"\",\n          d = 0;\n        if (void 0 !== e) {\n          const t = 1.2;\n          e < 0 && e * t < s ? (a.min = Math.ceil(e * t), d = a.min, h = \"range increased\") : e / t < s && (a.min = Math.ceil(e / t), d = a.min, h = \"range increased\"), e * t > n && 1 !== n && (a.max = Math.ceil(e * t), d = a.max, h = \"range increased\"), a.value = e;\n        } else a.value = o;\n        const l = document.createElement(\"input\");\n        l.className = \"vis-configuration vis-config-rangeinput\", l.value = a.value;\n        const c = this;\n        a.onchange = function () {\n          l.value = this.value, c._update(Number(this.value), i);\n        }, a.oninput = function () {\n          l.value = this.value;\n        };\n        const u = this._makeLabel(i[i.length - 1], i),\n          p = this._makeItem(i, u, a, l);\n        \"\" !== h && this.popupHistory[p] !== d && (this.popupHistory[p] = d, this._setupPopup(h, p));\n      }\n      _makeButton() {\n        if (!0 === this.options.showButton) {\n          const t = document.createElement(\"div\");\n          t.className = \"vis-configuration vis-config-button\", t.innerText = \"generate options\", t.onclick = () => {\n            this._printOptions();\n          }, t.onmouseover = () => {\n            t.className = \"vis-configuration vis-config-button hover\";\n          }, t.onmouseout = () => {\n            t.className = \"vis-configuration vis-config-button\";\n          }, this.optionsContainer = document.createElement(\"div\"), this.optionsContainer.className = \"vis-configuration vis-config-option-container\", this.domElements.push(this.optionsContainer), this.domElements.push(t);\n        }\n      }\n      _setupPopup(t, e) {\n        if (!0 === this.initialized && !0 === this.allowCreation && this.popupCounter < this.popupLimit) {\n          const i = document.createElement(\"div\");\n          i.id = \"vis-configuration-popup\", i.className = \"vis-configuration-popup\", i.innerText = t, i.onclick = () => {\n            this._removePopup();\n          }, this.popupCounter += 1, this.popupDiv = {\n            html: i,\n            index: e\n          };\n        }\n      }\n      _removePopup() {\n        void 0 !== this.popupDiv.html && (this.popupDiv.html.parentNode.removeChild(this.popupDiv.html), clearTimeout(this.popupDiv.hideTimeout), clearTimeout(this.popupDiv.deleteTimeout), this.popupDiv = {});\n      }\n      _showPopupIfNeeded() {\n        if (void 0 !== this.popupDiv.html) {\n          const t = this.domElements[this.popupDiv.index].getBoundingClientRect();\n          this.popupDiv.html.style.left = t.left + \"px\", this.popupDiv.html.style.top = t.top - 30 + \"px\", document.body.appendChild(this.popupDiv.html), this.popupDiv.hideTimeout = tg(() => {\n            this.popupDiv.html.style.opacity = 0;\n          }, 1500), this.popupDiv.deleteTimeout = tg(() => {\n            this._removePopup();\n          }, 1800);\n        }\n      }\n      _makeCheckbox(t, e, i) {\n        const o = document.createElement(\"input\");\n        o.type = \"checkbox\", o.className = \"vis-configuration vis-config-checkbox\", o.checked = t, void 0 !== e && (o.checked = e, e !== t && (\"object\" == typeof t ? e !== t.enabled && this.changedOptions.push({\n          path: i,\n          value: e\n        }) : this.changedOptions.push({\n          path: i,\n          value: e\n        })));\n        const s = this;\n        o.onchange = function () {\n          s._update(this.checked, i);\n        };\n        const n = this._makeLabel(i[i.length - 1], i);\n        this._makeItem(i, n, o);\n      }\n      _makeTextInput(t, e, i) {\n        const o = document.createElement(\"input\");\n        o.type = \"text\", o.className = \"vis-configuration vis-config-text\", o.value = e, e !== t && this.changedOptions.push({\n          path: i,\n          value: e\n        });\n        const s = this;\n        o.onchange = function () {\n          s._update(this.value, i);\n        };\n        const n = this._makeLabel(i[i.length - 1], i);\n        this._makeItem(i, n, o);\n      }\n      _makeColorField(t, e, i) {\n        const o = t[1],\n          s = document.createElement(\"div\");\n        \"none\" !== (e = void 0 === e ? o : e) ? (s.className = \"vis-configuration vis-config-colorBlock\", s.style.backgroundColor = e) : s.className = \"vis-configuration vis-config-colorBlock none\", e = void 0 === e ? o : e, s.onclick = () => {\n          this._showColorPicker(e, s, i);\n        };\n        const n = this._makeLabel(i[i.length - 1], i);\n        this._makeItem(i, n, s);\n      }\n      _showColorPicker(t, e, i) {\n        e.onclick = function () {}, this.colorPicker.insertTo(e), this.colorPicker.show(), this.colorPicker.setColor(t), this.colorPicker.setUpdateCallback(t => {\n          const o = \"rgba(\" + t.r + \",\" + t.g + \",\" + t.b + \",\" + t.a + \")\";\n          e.style.backgroundColor = o, this._update(o, i);\n        }), this.colorPicker.setCloseCallback(() => {\n          e.onclick = () => {\n            this._showColorPicker(t, e, i);\n          };\n        });\n      }\n      _handleObject(t) {\n        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],\n          i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n          o = !1;\n        const s = Ru(this.options);\n        let n = !1;\n        for (const r in t) if (Object.prototype.hasOwnProperty.call(t, r)) {\n          o = !0;\n          const a = t[r],\n            h = Em(e, r);\n          if (\"function\" == typeof s && (o = s(r, e), !1 === o && !Vl(a) && \"string\" != typeof a && \"boolean\" != typeof a && a instanceof Object && (this.allowCreation = !1, o = this._handleObject(a, h, !0), this.allowCreation = !1 === i)), !1 !== o) {\n            n = !0;\n            const t = this._getValue(h);\n            if (Vl(a)) this._handleArray(a, t, h);else if (\"string\" == typeof a) this._makeTextInput(a, t, h);else if (\"boolean\" == typeof a) this._makeCheckbox(a, t, h);else if (a instanceof Object) {\n              if (!this.hideOption(e, r, this.moduleOptions)) if (void 0 !== a.enabled) {\n                const t = Em(h, \"enabled\"),\n                  e = this._getValue(t);\n                if (!0 === e) {\n                  const t = this._makeLabel(r, h, !0);\n                  this._makeItem(h, t), n = this._handleObject(a, h) || n;\n                } else this._makeCheckbox(a, e, h);\n              } else {\n                const t = this._makeLabel(r, h, !0);\n                this._makeItem(h, t), n = this._handleObject(a, h) || n;\n              }\n            } else console.error(\"dont know how to handle\", a, r, h);\n          }\n        }\n        return n;\n      }\n      _handleArray(t, e, i) {\n        \"string\" == typeof t[0] && \"color\" === t[0] ? (this._makeColorField(t, e, i), t[1] !== e && this.changedOptions.push({\n          path: i,\n          value: e\n        })) : \"string\" == typeof t[0] ? (this._makeDropdown(t, e, i), t[0] !== e && this.changedOptions.push({\n          path: i,\n          value: e\n        })) : \"number\" == typeof t[0] && (this._makeRange(t, e, i), t[0] !== e && this.changedOptions.push({\n          path: i,\n          value: Number(e)\n        }));\n      }\n      _update(t, e) {\n        const i = this._constructOptions(t, e);\n        this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit && this.parent.body.emitter.emit(\"configChange\", i), this.initialized = !0, this.parent.setOptions(i);\n      }\n      _constructOptions(t, e) {\n        let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n          o = i;\n        t = \"false\" !== (t = \"true\" === t || t) && t;\n        for (let i = 0; i < e.length; i++) \"global\" !== e[i] && (void 0 === o[e[i]] && (o[e[i]] = {}), i !== e.length - 1 ? o = o[e[i]] : o[e[i]] = t);\n        return i;\n      }\n      _printOptions() {\n        const t = this.getOptions();\n        for (; this.optionsContainer.firstChild;) this.optionsContainer.removeChild(this.optionsContainer.firstChild);\n        this.optionsContainer.appendChild(Hm(\"pre\", \"const options = \" + zp(t, null, 2)));\n      }\n      getOptions() {\n        const t = {};\n        for (let e = 0; e < this.changedOptions.length; e++) this._constructOptions(this.changedOptions[e].value, this.changedOptions[e].path, t);\n        return t;\n      }\n    },\n    Xm = dm,\n    Km = class {\n      constructor(t, e) {\n        this.container = t, this.overflowMethod = e || \"cap\", this.x = 0, this.y = 0, this.padding = 5, this.hidden = !1, this.frame = document.createElement(\"div\"), this.frame.className = \"vis-tooltip\", this.container.appendChild(this.frame);\n      }\n      setPosition(t, e) {\n        this.x = bp(t), this.y = bp(e);\n      }\n      setText(t) {\n        if (t instanceof Element) {\n          for (; this.frame.firstChild;) this.frame.removeChild(this.frame.firstChild);\n          this.frame.appendChild(t);\n        } else this.frame.innerText = t;\n      }\n      show(t) {\n        if (void 0 === t && (t = !0), !0 === t) {\n          const t = this.frame.clientHeight,\n            e = this.frame.clientWidth,\n            i = this.frame.parentNode.clientHeight,\n            o = this.frame.parentNode.clientWidth;\n          let s = 0,\n            n = 0;\n          if (\"flip\" == this.overflowMethod) {\n            let i = !1,\n              r = !0;\n            this.y - t < this.padding && (r = !1), this.x + e > o - this.padding && (i = !0), s = i ? this.x - e : this.x, n = r ? this.y - t : this.y;\n          } else n = this.y - t, n + t + this.padding > i && (n = i - t - this.padding), n < this.padding && (n = this.padding), s = this.x, s + e + this.padding > o && (s = o - e - this.padding), s < this.padding && (s = this.padding);\n          this.frame.style.left = s + \"px\", this.frame.style.top = n + \"px\", this.frame.style.visibility = \"visible\", this.hidden = !1;\n        } else this.hide();\n      }\n      hide() {\n        this.hidden = !0, this.frame.style.left = \"0\", this.frame.style.top = \"0\", this.frame.style.visibility = \"hidden\";\n      }\n      destroy() {\n        this.frame.parentNode.removeChild(this.frame);\n      }\n    },\n    Gm = qm,\n    Zm = class t {\n      static validate(e, i, o) {\n        Vm = !1, Wm = i;\n        let s = i;\n        return void 0 !== o && (s = i[o]), t.parse(e, s, []), Vm;\n      }\n      static parse(e, i, o) {\n        for (const s in e) Object.prototype.hasOwnProperty.call(e, s) && t.check(s, e, i, o);\n      }\n      static check(e, i, o, s) {\n        if (void 0 === o[e] && void 0 === o.__any__) return void t.getSuggestion(e, o, s);\n        let n = e,\n          r = !0;\n        void 0 === o[e] && void 0 !== o.__any__ && (n = \"__any__\", r = \"object\" === t.getType(i[e]));\n        let a = o[n];\n        r && void 0 !== a.__type__ && (a = a.__type__), t.checkFields(e, i, o, n, a, s);\n      }\n      static checkFields(e, i, o, s, n, r) {\n        const a = function (i) {\n            console.error(\"%c\" + i + t.printLocation(r, e), qm);\n          },\n          h = t.getType(i[e]),\n          d = n[h];\n        void 0 !== d ? \"array\" === t.getType(d) && -1 === Mp(d).call(d, i[e]) ? (a('Invalid option detected in \"' + e + '\". Allowed values are:' + t.print(d) + ' not \"' + i[e] + '\". '), Vm = !0) : \"object\" === h && \"__any__\" !== s && (r = Em(r, e), t.parse(i[e], o[s], r)) : void 0 === n.any && (a('Invalid type received for \"' + e + '\". Expected: ' + t.print(Jl(n)) + \". Received [\" + h + '] \"' + i[e] + '\"'), Vm = !0);\n      }\n      static getType(t) {\n        const e = typeof t;\n        return \"object\" === e ? null === t ? \"null\" : t instanceof Boolean ? \"boolean\" : t instanceof Number ? \"number\" : t instanceof String ? \"string\" : Vl(t) ? \"array\" : t instanceof Date ? \"date\" : void 0 !== t.nodeType ? \"dom\" : !0 === t._isAMomentObject ? \"moment\" : \"object\" : \"number\" === e ? \"number\" : \"boolean\" === e ? \"boolean\" : \"string\" === e ? \"string\" : void 0 === e ? \"undefined\" : e;\n      }\n      static getSuggestion(e, i, o) {\n        const s = t.findInOptions(e, i, o, !1),\n          n = t.findInOptions(e, Wm, [], !0);\n        let r;\n        r = void 0 !== s.indexMatch ? \" in \" + t.printLocation(s.path, e, \"\") + 'Perhaps it was incomplete? Did you mean: \"' + s.indexMatch + '\"?\\n\\n' : n.distance <= 4 && s.distance > n.distance ? \" in \" + t.printLocation(s.path, e, \"\") + \"Perhaps it was misplaced? Matching option found at: \" + t.printLocation(n.path, n.closestMatch, \"\") : s.distance <= 8 ? '. Did you mean \"' + s.closestMatch + '\"?' + t.printLocation(s.path, e) : \". Did you mean one of these: \" + t.print(Jl(i)) + t.printLocation(o, e), console.error('%cUnknown option detected: \"' + e + '\"' + r, qm), Vm = !0;\n      }\n      static findInOptions(e, i, o) {\n        let s = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],\n          n = 1e9,\n          r = \"\",\n          a = [];\n        const h = e.toLowerCase();\n        let d;\n        for (const u in i) {\n          let p;\n          if (void 0 !== i[u].__type__ && !0 === s) {\n            const s = t.findInOptions(e, i[u], Em(o, u));\n            n > s.distance && (r = s.closestMatch, a = s.path, n = s.distance, d = s.indexMatch);\n          } else {\n            var l;\n            -1 !== Mp(l = u.toLowerCase()).call(l, h) && (d = u), p = t.levenshteinDistance(e, u), n > p && (r = u, a = Nl(c = o).call(c), n = p);\n          }\n        }\n        var c;\n        return {\n          closestMatch: r,\n          path: a,\n          distance: n,\n          indexMatch: d\n        };\n      }\n      static printLocation(t, e) {\n        let i = \"\\n\\n\" + (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : \"Problem value found at: \\n\") + \"options = {\\n\";\n        for (let e = 0; e < t.length; e++) {\n          for (let t = 0; t < e + 1; t++) i += \"  \";\n          i += t[e] + \": {\\n\";\n        }\n        for (let e = 0; e < t.length + 1; e++) i += \"  \";\n        i += e + \"\\n\";\n        for (let e = 0; e < t.length + 1; e++) {\n          for (let o = 0; o < t.length - e; o++) i += \"  \";\n          i += \"}\\n\";\n        }\n        return i + \"\\n\\n\";\n      }\n      static print(t) {\n        return zp(t).replace(/(\")|(\\[)|(\\])|(,\"__type__\")/g, \"\").replace(/(,)/g, \", \");\n      }\n      static levenshteinDistance(t, e) {\n        if (0 === t.length) return e.length;\n        if (0 === e.length) return t.length;\n        const i = [];\n        let o, s;\n        for (o = 0; o <= e.length; o++) i[o] = [o];\n        for (s = 0; s <= t.length; s++) i[0][s] = s;\n        for (o = 1; o <= e.length; o++) for (s = 1; s <= t.length; s++) e.charAt(o - 1) == t.charAt(s - 1) ? i[o][s] = i[o - 1][s - 1] : i[o][s] = Math.min(i[o - 1][s - 1] + 1, Math.min(i[o][s - 1] + 1, i[o - 1][s] + 1));\n        return i[e.length][t.length];\n      }\n    };\n  function Qm(t) {\n    return iy = t, function () {\n      var t = {};\n      oy = 0, void (sy = iy.charAt(0)), fy(), \"strict\" === ny && (t.strict = !0, fy());\n      \"graph\" !== ny && \"digraph\" !== ny || (t.type = ny, fy());\n      ry === ty.IDENTIFIER && (t.id = ny, fy());\n      if (\"{\" != ny) throw _y(\"Angle bracket { expected\");\n      if (fy(), my(t), \"}\" != ny) throw _y(\"Angle bracket } expected\");\n      if (fy(), \"\" !== ny) throw _y(\"End of file expected\");\n      return fy(), delete t.node, delete t.edge, delete t.graph, t;\n    }();\n  }\n  var $m = {\n      fontsize: \"font.size\",\n      fontcolor: \"font.color\",\n      labelfontcolor: \"font.color\",\n      fontname: \"font.face\",\n      color: [\"color.border\", \"color.background\"],\n      fillcolor: \"color.background\",\n      tooltip: \"title\",\n      labeltooltip: \"title\"\n    },\n    Jm = Ip($m);\n  Jm.color = \"color.color\", Jm.style = \"dashes\";\n  var ty = {\n      NULL: 0,\n      DELIMITER: 1,\n      IDENTIFIER: 2,\n      UNKNOWN: 3\n    },\n    ey = {\n      \"{\": !0,\n      \"}\": !0,\n      \"[\": !0,\n      \"]\": !0,\n      \";\": !0,\n      \"=\": !0,\n      \",\": !0,\n      \"->\": !0,\n      \"--\": !0\n    },\n    iy = \"\",\n    oy = 0,\n    sy = \"\",\n    ny = \"\",\n    ry = ty.NULL;\n  function ay() {\n    oy++, sy = iy.charAt(oy);\n  }\n  function hy() {\n    return iy.charAt(oy + 1);\n  }\n  function dy(t) {\n    var e = t.charCodeAt(0);\n    return e < 47 ? 35 === e || 46 === e : e < 59 ? e > 47 : e < 91 ? e > 64 : e < 96 ? 95 === e : e < 123 && e > 96;\n  }\n  function ly(t, e) {\n    if (t || (t = {}), e) for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);\n    return t;\n  }\n  function cy(t, e, i) {\n    for (var o = e.split(\".\"), s = t; o.length;) {\n      var n = o.shift();\n      o.length ? (s[n] || (s[n] = {}), s = s[n]) : s[n] = i;\n    }\n  }\n  function uy(t, e) {\n    for (var i, o, s = null, n = [t], r = t; r.parent;) n.push(r.parent), r = r.parent;\n    if (r.nodes) for (i = 0, o = r.nodes.length; i < o; i++) if (e.id === r.nodes[i].id) {\n      s = r.nodes[i];\n      break;\n    }\n    for (s || (s = {\n      id: e.id\n    }, t.node && (s.attr = ly(s.attr, t.node))), i = n.length - 1; i >= 0; i--) {\n      var a,\n        h = n[i];\n      h.nodes || (h.nodes = []), -1 === Mp(a = h.nodes).call(a, s) && h.nodes.push(s);\n    }\n    e.attr && (s.attr = ly(s.attr, e.attr));\n  }\n  function py(t, e) {\n    if (t.edges || (t.edges = []), t.edges.push(e), t.edge) {\n      var i = ly({}, t.edge);\n      e.attr = ly(i, e.attr);\n    }\n  }\n  function gy(t, e, i, o, s) {\n    var n = {\n      from: e,\n      to: i,\n      type: o\n    };\n    return t.edge && (n.attr = ly({}, t.edge)), n.attr = ly(n.attr || {}, s), null != s && s.hasOwnProperty(\"arrows\") && null != s.arrows && (n.arrows = {\n      to: {\n        enabled: !0,\n        type: s.arrows.type\n      }\n    }, s.arrows = null), n;\n  }\n  function fy() {\n    for (ry = ty.NULL, ny = \"\"; \" \" === sy || \"\\t\" === sy || \"\\n\" === sy || \"\\r\" === sy;) ay();\n    do {\n      var t = !1;\n      if (\"#\" === sy) {\n        for (var e = oy - 1; \" \" === iy.charAt(e) || \"\\t\" === iy.charAt(e);) e--;\n        if (\"\\n\" === iy.charAt(e) || \"\" === iy.charAt(e)) {\n          for (; \"\" != sy && \"\\n\" != sy;) ay();\n          t = !0;\n        }\n      }\n      if (\"/\" === sy && \"/\" === hy()) {\n        for (; \"\" != sy && \"\\n\" != sy;) ay();\n        t = !0;\n      }\n      if (\"/\" === sy && \"*\" === hy()) {\n        for (; \"\" != sy;) {\n          if (\"*\" === sy && \"/\" === hy()) {\n            ay(), ay();\n            break;\n          }\n          ay();\n        }\n        t = !0;\n      }\n      for (; \" \" === sy || \"\\t\" === sy || \"\\n\" === sy || \"\\r\" === sy;) ay();\n    } while (t);\n    if (\"\" !== sy) {\n      var i = sy + hy();\n      if (ey[i]) return ry = ty.DELIMITER, ny = i, ay(), void ay();\n      if (ey[sy]) return ry = ty.DELIMITER, ny = sy, void ay();\n      if (dy(sy) || \"-\" === sy) {\n        for (ny += sy, ay(); dy(sy);) ny += sy, ay();\n        return \"false\" === ny ? ny = !1 : \"true\" === ny ? ny = !0 : isNaN(Number(ny)) || (ny = Number(ny)), void (ry = ty.IDENTIFIER);\n      }\n      if ('\"' === sy) {\n        for (ay(); \"\" != sy && ('\"' != sy || '\"' === sy && '\"' === hy());) '\"' === sy ? (ny += sy, ay()) : \"\\\\\" === sy && \"n\" === hy() ? (ny += \"\\n\", ay()) : ny += sy, ay();\n        if ('\"' != sy) throw _y('End of string \" expected');\n        return ay(), void (ry = ty.IDENTIFIER);\n      }\n      for (ry = ty.UNKNOWN; \"\" != sy;) ny += sy, ay();\n      throw new SyntaxError('Syntax error in part \"' + xy(ny, 30) + '\"');\n    }\n    ry = ty.DELIMITER;\n  }\n  function my(t) {\n    for (; \"\" !== ny && \"}\" != ny;) yy(t), \";\" === ny && fy();\n  }\n  function yy(t) {\n    var e = by(t);\n    if (e) vy(t, e);else {\n      var i = function (t) {\n        if (\"node\" === ny) return fy(), t.node = wy(), \"node\";\n        if (\"edge\" === ny) return fy(), t.edge = wy(), \"edge\";\n        if (\"graph\" === ny) return fy(), t.graph = wy(), \"graph\";\n        return null;\n      }(t);\n      if (!i) {\n        if (ry != ty.IDENTIFIER) throw _y(\"Identifier expected\");\n        var o = ny;\n        if (fy(), \"=\" === ny) {\n          if (fy(), ry != ty.IDENTIFIER) throw _y(\"Identifier expected\");\n          t[o] = ny, fy();\n        } else !function (t, e) {\n          var i = {\n              id: e\n            },\n            o = wy();\n          o && (i.attr = o);\n          uy(t, i), vy(t, e);\n        }(t, o);\n      }\n    }\n  }\n  function by(t) {\n    var e = null;\n    if (\"subgraph\" === ny && ((e = {}).type = \"subgraph\", fy(), ry === ty.IDENTIFIER && (e.id = ny, fy())), \"{\" === ny) {\n      if (fy(), e || (e = {}), e.parent = t, e.node = t.node, e.edge = t.edge, e.graph = t.graph, my(e), \"}\" != ny) throw _y(\"Angle bracket } expected\");\n      fy(), delete e.node, delete e.edge, delete e.graph, delete e.parent, t.subgraphs || (t.subgraphs = []), t.subgraphs.push(e);\n    }\n    return e;\n  }\n  function vy(t, e) {\n    for (; \"->\" === ny || \"--\" === ny;) {\n      var i,\n        o = ny;\n      fy();\n      var s = by(t);\n      if (s) i = s;else {\n        if (ry != ty.IDENTIFIER) throw _y(\"Identifier or subgraph expected\");\n        uy(t, {\n          id: i = ny\n        }), fy();\n      }\n      py(t, gy(t, e, i, o, wy())), e = i;\n    }\n  }\n  function wy() {\n    for (var t, e, i = null, o = {\n        dashed: !0,\n        solid: !1,\n        dotted: [1, 5]\n      }, s = {\n        dot: \"circle\",\n        box: \"box\",\n        crow: \"crow\",\n        curve: \"curve\",\n        icurve: \"inv_curve\",\n        normal: \"triangle\",\n        inv: \"inv_triangle\",\n        diamond: \"diamond\",\n        tee: \"bar\",\n        vee: \"vee\"\n      }, n = new Array(), r = new Array(); \"[\" === ny;) {\n      for (fy(), i = {}; \"\" !== ny && \"]\" != ny;) {\n        if (ry != ty.IDENTIFIER) throw _y(\"Attribute name expected\");\n        var a = ny;\n        if (fy(), \"=\" != ny) throw _y(\"Equal sign = expected\");\n        if (fy(), ry != ty.IDENTIFIER) throw _y(\"Attribute value expected\");\n        var h = ny;\n        \"style\" === a && (h = o[h]), \"arrowhead\" === a && (a = \"arrows\", h = {\n          to: {\n            enabled: !0,\n            type: s[h]\n          }\n        }), \"arrowtail\" === a && (a = \"arrows\", h = {\n          from: {\n            enabled: !0,\n            type: s[h]\n          }\n        }), n.push({\n          attr: i,\n          name: a,\n          value: h\n        }), r.push(a), fy(), \",\" == ny && fy();\n      }\n      if (\"]\" != ny) throw _y(\"Bracket ] expected\");\n      fy();\n    }\n    if (_u(r).call(r, \"dir\")) {\n      var d = {\n        arrows: {}\n      };\n      for (t = 0; t < n.length; t++) if (\"arrows\" === n[t].name) {\n        if (null != n[t].value.to) d.arrows.to = t;else {\n          if (null == n[t].value.from) throw _y(\"Invalid value of arrows\");\n          d.arrows.from = t;\n        }\n      } else \"dir\" === n[t].name && (d.dir = t);\n      var l,\n        c,\n        u = n[d.dir].value;\n      if (!_u(r).call(r, \"arrows\")) if (\"both\" === u) n.push({\n        attr: n[d.dir].attr,\n        name: \"arrows\",\n        value: {\n          to: {\n            enabled: !0\n          }\n        }\n      }), d.arrows.to = n.length - 1, n.push({\n        attr: n[d.dir].attr,\n        name: \"arrows\",\n        value: {\n          from: {\n            enabled: !0\n          }\n        }\n      }), d.arrows.from = n.length - 1;else if (\"forward\" === u) n.push({\n        attr: n[d.dir].attr,\n        name: \"arrows\",\n        value: {\n          to: {\n            enabled: !0\n          }\n        }\n      }), d.arrows.to = n.length - 1;else if (\"back\" === u) n.push({\n        attr: n[d.dir].attr,\n        name: \"arrows\",\n        value: {\n          from: {\n            enabled: !0\n          }\n        }\n      }), d.arrows.from = n.length - 1;else {\n        if (\"none\" !== u) throw _y('Invalid dir type \"' + u + '\"');\n        n.push({\n          attr: n[d.dir].attr,\n          name: \"arrows\",\n          value: \"\"\n        }), d.arrows.to = n.length - 1;\n      }\n      if (\"both\" === u) d.arrows.to && d.arrows.from ? (c = n[d.arrows.to].value.to.type, l = n[d.arrows.from].value.from.type, n[d.arrows.to] = {\n        attr: n[d.arrows.to].attr,\n        name: n[d.arrows.to].name,\n        value: {\n          to: {\n            enabled: !0,\n            type: c\n          },\n          from: {\n            enabled: !0,\n            type: l\n          }\n        }\n      }, Jc(n).call(n, d.arrows.from, 1)) : d.arrows.to ? (c = n[d.arrows.to].value.to.type, l = \"arrow\", n[d.arrows.to] = {\n        attr: n[d.arrows.to].attr,\n        name: n[d.arrows.to].name,\n        value: {\n          to: {\n            enabled: !0,\n            type: c\n          },\n          from: {\n            enabled: !0,\n            type: l\n          }\n        }\n      }) : d.arrows.from && (c = \"arrow\", l = n[d.arrows.from].value.from.type, n[d.arrows.from] = {\n        attr: n[d.arrows.from].attr,\n        name: n[d.arrows.from].name,\n        value: {\n          to: {\n            enabled: !0,\n            type: c\n          },\n          from: {\n            enabled: !0,\n            type: l\n          }\n        }\n      });else if (\"back\" === u) d.arrows.to && d.arrows.from ? (c = \"\", l = n[d.arrows.from].value.from.type, n[d.arrows.from] = {\n        attr: n[d.arrows.from].attr,\n        name: n[d.arrows.from].name,\n        value: {\n          to: {\n            enabled: !0,\n            type: c\n          },\n          from: {\n            enabled: !0,\n            type: l\n          }\n        }\n      }) : d.arrows.to ? (c = \"\", l = \"arrow\", d.arrows.from = d.arrows.to, n[d.arrows.from] = {\n        attr: n[d.arrows.from].attr,\n        name: n[d.arrows.from].name,\n        value: {\n          to: {\n            enabled: !0,\n            type: c\n          },\n          from: {\n            enabled: !0,\n            type: l\n          }\n        }\n      }) : d.arrows.from && (c = \"\", l = n[d.arrows.from].value.from.type, n[d.arrows.to] = {\n        attr: n[d.arrows.from].attr,\n        name: n[d.arrows.from].name,\n        value: {\n          to: {\n            enabled: !0,\n            type: c\n          },\n          from: {\n            enabled: !0,\n            type: l\n          }\n        }\n      }), n[d.arrows.from] = {\n        attr: n[d.arrows.from].attr,\n        name: n[d.arrows.from].name,\n        value: {\n          from: {\n            enabled: !0,\n            type: n[d.arrows.from].value.from.type\n          }\n        }\n      };else if (\"none\" === u) {\n        var p;\n        n[p = d.arrows.to ? d.arrows.to : d.arrows.from] = {\n          attr: n[p].attr,\n          name: n[p].name,\n          value: \"\"\n        };\n      } else {\n        if (\"forward\" !== u) throw _y('Invalid dir type \"' + u + '\"');\n        d.arrows.to && d.arrows.from || d.arrows.to ? (c = n[d.arrows.to].value.to.type, l = \"\", n[d.arrows.to] = {\n          attr: n[d.arrows.to].attr,\n          name: n[d.arrows.to].name,\n          value: {\n            to: {\n              enabled: !0,\n              type: c\n            },\n            from: {\n              enabled: !0,\n              type: l\n            }\n          }\n        }) : d.arrows.from && (c = \"arrow\", l = \"\", d.arrows.to = d.arrows.from, n[d.arrows.to] = {\n          attr: n[d.arrows.to].attr,\n          name: n[d.arrows.to].name,\n          value: {\n            to: {\n              enabled: !0,\n              type: c\n            },\n            from: {\n              enabled: !0,\n              type: l\n            }\n          }\n        }), n[d.arrows.to] = {\n          attr: n[d.arrows.to].attr,\n          name: n[d.arrows.to].name,\n          value: {\n            to: {\n              enabled: !0,\n              type: n[d.arrows.to].value.to.type\n            }\n          }\n        };\n      }\n      Jc(n).call(n, d.dir, 1);\n    }\n    if (_u(r).call(r, \"penwidth\")) {\n      var g = [];\n      for (e = n.length, t = 0; t < e; t++) \"width\" !== n[t].name && (\"penwidth\" === n[t].name && (n[t].name = \"width\"), g.push(n[t]));\n      n = g;\n    }\n    for (e = n.length, t = 0; t < e; t++) cy(n[t].attr, n[t].name, n[t].value);\n    return i;\n  }\n  function _y(t) {\n    return new SyntaxError(t + ', got \"' + xy(ny, 30) + '\" (char ' + oy + \")\");\n  }\n  function xy(t, e) {\n    return t.length <= e ? t : t.substr(0, 27) + \"...\";\n  }\n  function Ey(t, e, i) {\n    for (var o = e.split(\".\"), s = o.pop(), n = t, r = 0; r < o.length; r++) {\n      var a = o[r];\n      a in n || (n[a] = {}), n = n[a];\n    }\n    return n[s] = i, t;\n  }\n  function Oy(t, e) {\n    var i = {};\n    for (var o in t) if (t.hasOwnProperty(o)) {\n      var s = e[o];\n      Vl(s) ? mc(s).call(s, function (e) {\n        Ey(i, e, t[o]);\n      }) : Ey(i, \"string\" == typeof s ? s : o, t[o]);\n    }\n    return i;\n  }\n  function Cy(t) {\n    var e,\n      i = Qm(t),\n      o = {\n        nodes: [],\n        edges: [],\n        options: {}\n      };\n    i.nodes && mc(e = i.nodes).call(e, function (t) {\n      var e = {\n        id: t.id,\n        label: String(t.label || t.id)\n      };\n      ly(e, Oy(t.attr, $m)), e.image && (e.shape = \"image\"), o.nodes.push(e);\n    });\n    if (i.edges) {\n      var s,\n        n = function (t) {\n          var e = {\n            from: t.from,\n            to: t.to\n          };\n          return ly(e, Oy(t.attr, Jm)), null == e.arrows && \"->\" === t.type && (e.arrows = \"to\"), e;\n        };\n      mc(s = i.edges).call(s, function (t) {\n        var e, i, s, r, a, h, d;\n        (e = t.from instanceof Object ? t.from.nodes : {\n          id: t.from\n        }, i = t.to instanceof Object ? t.to.nodes : {\n          id: t.to\n        }, t.from instanceof Object && t.from.edges) && mc(s = t.from.edges).call(s, function (t) {\n          var e = n(t);\n          o.edges.push(e);\n        });\n        (a = i, h = function (e, i) {\n          var s = gy(o, e.id, i.id, t.type, t.attr),\n            r = n(s);\n          o.edges.push(r);\n        }, Vl(r = e) ? mc(r).call(r, function (t) {\n          Vl(a) ? mc(a).call(a, function (e) {\n            h(t, e);\n          }) : h(t, a);\n        }) : Vl(a) ? mc(a).call(a, function (t) {\n          h(r, t);\n        }) : h(r, a), t.to instanceof Object && t.to.edges) && mc(d = t.to.edges).call(d, function (t) {\n          var e = n(t);\n          o.edges.push(e);\n        });\n      });\n    }\n    return i.attr && (o.options = i.attr), o;\n  }\n  var ky = Object.freeze({\n    __proto__: null,\n    DOTToGraph: Cy,\n    parseDOT: Qm\n  });\n  function Sy(t, e) {\n    var i;\n    const o = {\n      edges: {\n        inheritColor: !1\n      },\n      nodes: {\n        fixed: !1,\n        parseColor: !1\n      }\n    };\n    null != e && (null != e.fixed && (o.nodes.fixed = e.fixed), null != e.parseColor && (o.nodes.parseColor = e.parseColor), null != e.inheritColor && (o.edges.inheritColor = e.inheritColor));\n    const s = t.edges,\n      n = Zl(s).call(s, t => {\n        const e = {\n          from: t.source,\n          id: t.id,\n          to: t.target\n        };\n        return null != t.attributes && (e.attributes = t.attributes), null != t.label && (e.label = t.label), null != t.attributes && null != t.attributes.title && (e.title = t.attributes.title), \"Directed\" === t.type && (e.arrows = \"to\"), t.color && !1 === o.edges.inheritColor && (e.color = t.color), e;\n      });\n    return {\n      nodes: Zl(i = t.nodes).call(i, t => {\n        const e = {\n          id: t.id,\n          fixed: o.nodes.fixed && null != t.x && null != t.y\n        };\n        return null != t.attributes && (e.attributes = t.attributes), null != t.label && (e.label = t.label), null != t.size && (e.size = t.size), null != t.attributes && null != t.attributes.title && (e.title = t.attributes.title), null != t.title && (e.title = t.title), null != t.x && (e.x = t.x), null != t.y && (e.y = t.y), null != t.color && (!0 === o.nodes.parseColor ? e.color = t.color : e.color = {\n          background: t.color,\n          border: t.color,\n          highlight: {\n            background: t.color,\n            border: t.color\n          },\n          hover: {\n            background: t.color,\n            border: t.color\n          }\n        }), e;\n      }),\n      edges: n\n    };\n  }\n  var Ty = Object.freeze({\n    __proto__: null,\n    parseGephi: Sy\n  });\n  var My = Object.freeze({\n    __proto__: null,\n    cn: {\n      addDescription: \"åå»ç©ºç½å¤æ¾ç½®æ°èç¹ã\",\n      addEdge: \"æ·»å è¿æ¥çº¿\",\n      addNode: \"æ·»å èç¹\",\n      back: \"è¿å\",\n      close: \"éé\",\n      createEdgeError: \"æ æ³å°è¿æ¥çº¿è¿æ¥å°ç¾¤éã\",\n      del: \"å é¤éå®\",\n      deleteClusterError: \"æ æ³å é¤ç¾¤éã\",\n      edgeDescription: \"åå»æä¸ªèç¹å¹¶å°è¯¥è¿æ¥çº¿æå¨å°å¦ä¸ä¸ªèç¹ä»¥è¿æ¥å®ä»¬ã\",\n      edit: \"ç¼è¾\",\n      editClusterError: \"æ æ³ç¼è¾ç¾¤éã\",\n      editEdge: \"ç¼è¾è¿æ¥çº¿\",\n      editEdgeDescription: \"åå»æ§å¶èç¹å¹¶å°å®ä»¬æå°èç¹ä¸è¿æ¥ã\",\n      editNode: \"ç¼è¾èç¹\"\n    },\n    cs: {\n      addDescription: \"KluknutÃ­m do prÃ¡zdnÃ©ho prostoru mÅ¯Å¾ete pÅidat novÃ½ vrchol.\",\n      addEdge: \"PÅidat hranu\",\n      addNode: \"PÅidat vrchol\",\n      back: \"ZpÄt\",\n      close: \"ZavÅÃ­t\",\n      createEdgeError: \"Nelze pÅipojit hranu ke shluku.\",\n      del: \"Smazat vÃ½bÄr\",\n      deleteClusterError: \"Nelze mazat shluky.\",\n      edgeDescription: \"PÅetaÅ¾enÃ­m z jednoho vrcholu do druhÃ©ho mÅ¯Å¾ete spojit tyto vrcholy novou hranou.\",\n      edit: \"Upravit\",\n      editClusterError: \"Nelze upravovat shluky.\",\n      editEdge: \"Upravit hranu\",\n      editEdgeDescription: \"PÅetaÅ¾enÃ­m kontrolnÃ­ho vrcholu hrany ji mÅ¯Å¾ete pÅipojit k jinÃ©mu vrcholu.\",\n      editNode: \"Upravit vrchol\"\n    },\n    de: {\n      addDescription: \"Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.\",\n      addEdge: \"Kante hinzufÃ¼gen\",\n      addNode: \"Knoten hinzufÃ¼gen\",\n      back: \"ZurÃ¼ck\",\n      close: \"SchlieÃen\",\n      createEdgeError: \"Es ist nicht mÃ¶glich, Kanten mit Clustern zu verbinden.\",\n      del: \"LÃ¶sche Auswahl\",\n      deleteClusterError: \"Cluster kÃ¶nnen nicht gelÃ¶scht werden.\",\n      edgeDescription: \"Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.\",\n      edit: \"Editieren\",\n      editClusterError: \"Cluster kÃ¶nnen nicht editiert werden.\",\n      editEdge: \"Kante editieren\",\n      editEdgeDescription: \"Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.\",\n      editNode: \"Knoten editieren\"\n    },\n    en: {\n      addDescription: \"Click in an empty space to place a new node.\",\n      addEdge: \"Add Edge\",\n      addNode: \"Add Node\",\n      back: \"Back\",\n      close: \"Close\",\n      createEdgeError: \"Cannot link edges to a cluster.\",\n      del: \"Delete selected\",\n      deleteClusterError: \"Clusters cannot be deleted.\",\n      edgeDescription: \"Click on a node and drag the edge to another node to connect them.\",\n      edit: \"Edit\",\n      editClusterError: \"Clusters cannot be edited.\",\n      editEdge: \"Edit Edge\",\n      editEdgeDescription: \"Click on the control points and drag them to a node to connect to it.\",\n      editNode: \"Edit Node\"\n    },\n    es: {\n      addDescription: \"Haga clic en un lugar vacÃ­o para colocar un nuevo nodo.\",\n      addEdge: \"AÃ±adir arista\",\n      addNode: \"AÃ±adir nodo\",\n      back: \"AtrÃ¡s\",\n      close: \"Cerrar\",\n      createEdgeError: \"No se puede conectar una arista a un grupo.\",\n      del: \"Eliminar selecciÃ³n\",\n      deleteClusterError: \"No es posible eliminar grupos.\",\n      edgeDescription: \"Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.\",\n      edit: \"Editar\",\n      editClusterError: \"No es posible editar grupos.\",\n      editEdge: \"Editar arista\",\n      editEdgeDescription: \"Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.\",\n      editNode: \"Editar nodo\"\n    },\n    fr: {\n      addDescription: \"Cliquez dans un endroit vide pour placer un nÅud.\",\n      addEdge: \"Ajouter un lien\",\n      addNode: \"Ajouter un nÅud\",\n      back: \"Retour\",\n      close: \"Fermer\",\n      createEdgeError: \"Impossible de crÃ©er un lien vers un cluster.\",\n      del: \"Effacer la sÃ©lection\",\n      deleteClusterError: \"Les clusters ne peuvent pas Ãªtre effacÃ©s.\",\n      edgeDescription: \"Cliquez sur un nÅud et glissez le lien vers un autre nÅud pour les connecter.\",\n      edit: \"Ãditer\",\n      editClusterError: \"Les clusters ne peuvent pas Ãªtre Ã©ditÃ©s.\",\n      editEdge: \"Ãditer le lien\",\n      editEdgeDescription: \"Cliquez sur les points de contrÃ´le et glissez-les pour connecter un nÅud.\",\n      editNode: \"Ãditer le nÅud\"\n    },\n    it: {\n      addDescription: \"Clicca per aggiungere un nuovo nodo\",\n      addEdge: \"Aggiungi un vertice\",\n      addNode: \"Aggiungi un nodo\",\n      back: \"Indietro\",\n      close: \"Chiudere\",\n      createEdgeError: \"Non si possono collegare vertici ad un cluster\",\n      del: \"Cancella la selezione\",\n      deleteClusterError: \"I cluster non possono essere cancellati\",\n      edgeDescription: \"Clicca su un nodo e trascinalo ad un altro nodo per connetterli.\",\n      edit: \"Modifica\",\n      editClusterError: \"I clusters non possono essere modificati.\",\n      editEdge: \"Modifica il vertice\",\n      editEdgeDescription: \"Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.\",\n      editNode: \"Modifica il nodo\"\n    },\n    nl: {\n      addDescription: \"Klik op een leeg gebied om een nieuwe node te maken.\",\n      addEdge: \"Link toevoegen\",\n      addNode: \"Node toevoegen\",\n      back: \"Terug\",\n      close: \"Sluiten\",\n      createEdgeError: \"Kan geen link maken naar een cluster.\",\n      del: \"Selectie verwijderen\",\n      deleteClusterError: \"Clusters kunnen niet worden verwijderd.\",\n      edgeDescription: \"Klik op een node en sleep de link naar een andere node om ze te verbinden.\",\n      edit: \"Wijzigen\",\n      editClusterError: \"Clusters kunnen niet worden aangepast.\",\n      editEdge: \"Link wijzigen\",\n      editEdgeDescription: \"Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.\",\n      editNode: \"Node wijzigen\"\n    },\n    pt: {\n      addDescription: \"Clique em um espaÃ§o em branco para adicionar um novo nÃ³\",\n      addEdge: \"Adicionar aresta\",\n      addNode: \"Adicionar nÃ³\",\n      back: \"Voltar\",\n      close: \"Fechar\",\n      createEdgeError: \"NÃ£o foi possÃ­vel linkar arestas a um cluster.\",\n      del: \"Remover selecionado\",\n      deleteClusterError: \"Clusters nÃ£o puderam ser removidos.\",\n      edgeDescription: \"Clique em um nÃ³ e arraste a aresta atÃ© outro nÃ³ para conectÃ¡-los\",\n      edit: \"Editar\",\n      editClusterError: \"Clusters nÃ£o puderam ser editados.\",\n      editEdge: \"Editar aresta\",\n      editEdgeDescription: \"Clique nos pontos de controle e os arraste para um nÃ³ para conectÃ¡-los\",\n      editNode: \"Editar nÃ³\"\n    },\n    ru: {\n      addDescription: \"ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð² ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ð¾Ðµ Ð¼ÐµÑÑÐ¾, ÑÑÐ¾Ð±Ñ Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ Ð½Ð¾Ð²ÑÐ¹ ÑÐ·ÐµÐ».\",\n      addEdge: \"ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ ÑÐµÐ±ÑÐ¾\",\n      addNode: \"ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ ÑÐ·ÐµÐ»\",\n      back: \"ÐÐ°Ð·Ð°Ð´\",\n      close: \"ÐÐ°ÐºÑÑÐ²Ð°ÑÑ\",\n      createEdgeError: \"ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸ÑÑ ÑÐµÐ±ÑÐ° Ð² ÐºÐ»Ð°ÑÑÐµÑ.\",\n      del: \"Ð£Ð´Ð°Ð»Ð¸ÑÑ Ð²ÑÐ±ÑÐ°Ð½Ð½Ð¾Ðµ\",\n      deleteClusterError: \"ÐÐ»Ð°ÑÑÐµÑÑ Ð½Ðµ Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ ÑÐ´Ð°Ð»ÐµÐ½Ñ\",\n      edgeDescription: \"ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð½Ð° ÑÐ·ÐµÐ» Ð¸ Ð¿ÑÐ¾ÑÑÐ½Ð¸ÑÐµ ÑÐµÐ±ÑÐ¾ Ðº Ð´ÑÑÐ³Ð¾Ð¼Ñ ÑÐ·Ð»Ñ, ÑÑÐ¾Ð±Ñ ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸ÑÑ Ð¸Ñ.\",\n      edit: \"Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ\",\n      editClusterError: \"ÐÐ»Ð°ÑÑÐµÑÑ Ð½ÐµÐ´Ð¾ÑÑÑÐ¿Ð½Ñ Ð´Ð»Ñ ÑÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ.\",\n      editEdge: \"Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐµÐ±ÑÐ¾\",\n      editEdgeDescription: \"ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð½Ð° ÐºÐ¾Ð½ÑÑÐ¾Ð»ÑÐ½ÑÐµ ÑÐ¾ÑÐºÐ¸ Ð¸ Ð¿ÐµÑÐµÑÐ°ÑÐ¸ÑÐµ Ð¸Ñ Ð² ÑÐ·ÐµÐ», ÑÑÐ¾Ð±Ñ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ¸ÑÑÑÑ Ðº Ð½ÐµÐ¼Ñ.\",\n      editNode: \"Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ·ÐµÐ»\"\n    },\n    uk: {\n      addDescription: \"KÐ»ÑÐºÐ½ÑÑÑ Ð½Ð° Ð²ÑÐ»ÑÐ½Ðµ Ð¼ÑÑÑÐµ, ÑÐ¾Ð± Ð´Ð¾Ð´Ð°ÑÐ¸ Ð½Ð¾Ð²Ð¸Ð¹ Ð²ÑÐ·Ð¾Ð».\",\n      addEdge: \"ÐÐ¾Ð´Ð°ÑÐ¸ ÐºÑÐ°Ð¹\",\n      addNode: \"ÐÐ¾Ð´Ð°ÑÐ¸ Ð²ÑÐ·Ð¾Ð»\",\n      back: \"ÐÐ°Ð·Ð°Ð´\",\n      close: \"ÐÐ°ÐºÑÐ¸ÑÐ¸\",\n      createEdgeError: \"ÐÐµ Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð¾Ð±'ÑÐ´Ð½Ð°ÑÐ¸ ÐºÑÐ°Ñ Ð² Ð³ÑÑÐ¿Ñ.\",\n      del: \"ÐÐ¸Ð´Ð°Ð»Ð¸ÑÐ¸ Ð¾Ð±ÑÐ°Ð½Ðµ\",\n      deleteClusterError: \"ÐÑÑÐ¿Ð¸ Ð½Ðµ Ð¼Ð¾Ð¶ÑÑÑ Ð±ÑÑÐ¸ Ð²Ð¸Ð´Ð°Ð»ÐµÐ½Ñ.\",\n      edgeDescription: \"ÐÐ»ÑÐºÐ½ÑÑÑ Ð½Ð° Ð²ÑÐ·Ð¾Ð» Ñ Ð¿ÐµÑÐµÑÑÐ³Ð½ÑÑÑ ÐºÑÐ°Ð¹ Ð´Ð¾ ÑÐ½ÑÐ¾Ð³Ð¾ Ð²ÑÐ·Ð»Ð°, ÑÐ¾Ð± ÑÑ Ð·'ÑÐ´Ð½Ð°ÑÐ¸.\",\n      edit: \"Ð ÐµÐ´Ð°Ð³ÑÐ²Ð°ÑÐ¸\",\n      editClusterError: \"ÐÑÑÐ¿Ð¸ Ð½ÐµÐ´Ð¾ÑÑÑÐ¿Ð½Ñ Ð´Ð»Ñ ÑÐµÐ´Ð°Ð³ÑÐ²Ð°Ð½Ð½Ñ.\",\n      editEdge: \"Ð ÐµÐ´Ð°Ð³ÑÐ²Ð°ÑÐ¸ ÐºÑÐ°Ð¹\",\n      editEdgeDescription: \"ÐÐ»ÑÐºÐ½ÑÑÑ Ð½Ð° ÐºÐ¾Ð½ÑÑÐ¾Ð»ÑÐ½Ñ ÑÐ¾ÑÐºÐ¸ Ñ Ð¿ÐµÑÐµÑÑÐ³Ð½ÑÑÑ ÑÑ Ñ Ð²ÑÐ·Ð¾Ð», ÑÐ¾Ð± Ð¿ÑÐ´ÐºÐ»ÑÑÐ¸ÑÐ¸ÑÑ Ð´Ð¾ Ð½ÑÐ¾Ð³Ð¾.\",\n      editNode: \"Ð ÐµÐ´Ð°Ð³ÑÐ²Ð°ÑÐ¸ Ð²ÑÐ·Ð¾Ð»\"\n    }\n  });\n  class Dy {\n    constructor() {\n      this.NUM_ITERATIONS = 4, this.image = new Image(), this.canvas = document.createElement(\"canvas\");\n    }\n    init() {\n      if (this.initialized()) return;\n      this.src = this.image.src;\n      const t = this.image.width,\n        e = this.image.height;\n      this.width = t, this.height = e;\n      const i = Math.floor(e / 2),\n        o = Math.floor(e / 4),\n        s = Math.floor(e / 8),\n        n = Math.floor(e / 16),\n        r = Math.floor(t / 2),\n        a = Math.floor(t / 4),\n        h = Math.floor(t / 8),\n        d = Math.floor(t / 16);\n      this.canvas.width = 3 * a, this.canvas.height = i, this.coordinates = [[0, 0, r, i], [r, 0, a, o], [r, o, h, s], [5 * h, o, d, n]], this._fillMipMap();\n    }\n    initialized() {\n      return void 0 !== this.coordinates;\n    }\n    _fillMipMap() {\n      const t = this.canvas.getContext(\"2d\"),\n        e = this.coordinates[0];\n      t.drawImage(this.image, e[0], e[1], e[2], e[3]);\n      for (let e = 1; e < this.NUM_ITERATIONS; e++) {\n        const i = this.coordinates[e - 1],\n          o = this.coordinates[e];\n        t.drawImage(this.canvas, i[0], i[1], i[2], i[3], o[0], o[1], o[2], o[3]);\n      }\n    }\n    drawImageAtPosition(t, e, i, o, s, n) {\n      if (this.initialized()) if (e > 2) {\n        e *= .5;\n        let r = 0;\n        for (; e > 2 && r < this.NUM_ITERATIONS;) e *= .5, r += 1;\n        r >= this.NUM_ITERATIONS && (r = this.NUM_ITERATIONS - 1);\n        const a = this.coordinates[r];\n        t.drawImage(this.canvas, a[0], a[1], a[2], a[3], i, o, s, n);\n      } else t.drawImage(this.image, i, o, s, n);\n    }\n  }\n  class Iy {\n    constructor(t) {\n      this.images = {}, this.imageBroken = {}, this.callback = t;\n    }\n    _tryloadBrokenUrl(t, e, i) {\n      void 0 !== t && void 0 !== i && (void 0 !== e ? (i.image.onerror = () => {\n        console.error(\"Could not load brokenImage:\", e);\n      }, i.image.src = e) : console.warn(\"No broken url image defined\"));\n    }\n    _redrawWithImage(t) {\n      this.callback && this.callback(t);\n    }\n    load(t, e) {\n      const i = this.images[t];\n      if (i) return i;\n      const o = new Dy();\n      return this.images[t] = o, o.image.onload = () => {\n        this._fixImageCoordinates(o.image), o.init(), this._redrawWithImage(o);\n      }, o.image.onerror = () => {\n        console.error(\"Could not load image:\", t), this._tryloadBrokenUrl(t, e, o);\n      }, o.image.src = t, o;\n    }\n    _fixImageCoordinates(t) {\n      0 === t.width && (document.body.appendChild(t), t.width = t.offsetWidth, t.height = t.offsetHeight, document.body.removeChild(t));\n    }\n  }\n  var Py = {\n      exports: {}\n    },\n    By = r(function () {\n      if (\"function\" == typeof ArrayBuffer) {\n        var t = new ArrayBuffer(8);\n        Object.isExtensible(t) && Object.defineProperty(t, \"a\", {\n          value: 8\n        });\n      }\n    }),\n    Fy = r,\n    zy = et,\n    Ny = _,\n    Ay = By,\n    Ry = Object.isExtensible,\n    jy = Fy(function () {\n      Ry(1);\n    }) || Ay ? function (t) {\n      return !!zy(t) && (!Ay || \"ArrayBuffer\" !== Ny(t)) && (!Ry || Ry(t));\n    } : Ry,\n    Ly = !r(function () {\n      return Object.isExtensible(Object.preventExtensions({}));\n    }),\n    Hy = Mi,\n    Wy = y,\n    Vy = Xi,\n    qy = et,\n    Uy = Jt,\n    Yy = $e.f,\n    Xy = Pn,\n    Ky = zn,\n    Gy = jy,\n    Zy = Ly,\n    Qy = !1,\n    $y = se(\"meta\"),\n    Jy = 0,\n    tb = function (t) {\n      Yy(t, $y, {\n        value: {\n          objectID: \"O\" + Jy++,\n          weakData: {}\n        }\n      });\n    },\n    eb = Py.exports = {\n      enable: function () {\n        eb.enable = function () {}, Qy = !0;\n        var t = Xy.f,\n          e = Wy([].splice),\n          i = {};\n        i[$y] = 1, t(i).length && (Xy.f = function (i) {\n          for (var o = t(i), s = 0, n = o.length; s < n; s++) if (o[s] === $y) {\n            e(o, s, 1);\n            break;\n          }\n          return o;\n        }, Hy({\n          target: \"Object\",\n          stat: !0,\n          forced: !0\n        }, {\n          getOwnPropertyNames: Ky.f\n        }));\n      },\n      fastKey: function (t, e) {\n        if (!qy(t)) return \"symbol\" == typeof t ? t : (\"string\" == typeof t ? \"S\" : \"P\") + t;\n        if (!Uy(t, $y)) {\n          if (!Gy(t)) return \"F\";\n          if (!e) return \"E\";\n          tb(t);\n        }\n        return t[$y].objectID;\n      },\n      getWeakData: function (t, e) {\n        if (!Uy(t, $y)) {\n          if (!Gy(t)) return !0;\n          if (!e) return !1;\n          tb(t);\n        }\n        return t[$y].weakData;\n      },\n      onFreeze: function (t) {\n        return Zy && Qy && Gy(t) && !Uy(t, $y) && tb(t), t;\n      }\n    };\n  Vy[$y] = !0;\n  var ib = Py.exports,\n    ob = id,\n    sb = pe(\"iterator\"),\n    nb = Array.prototype,\n    rb = us,\n    ab = zt,\n    hb = Y,\n    db = id,\n    lb = pe(\"iterator\"),\n    cb = function (t) {\n      if (!hb(t)) return ab(t, lb) || ab(t, \"@@iterator\") || db[rb(t)];\n    },\n    ub = B,\n    pb = Pt,\n    gb = oi,\n    fb = Tt,\n    mb = cb,\n    yb = TypeError,\n    bb = B,\n    vb = oi,\n    wb = zt,\n    _b = Qe,\n    xb = B,\n    Eb = oi,\n    Ob = Tt,\n    Cb = function (t) {\n      return void 0 !== t && (ob.Array === t || nb[sb] === t);\n    },\n    kb = Hi,\n    Sb = ht,\n    Tb = function (t, e) {\n      var i = arguments.length < 2 ? mb(t) : e;\n      if (pb(i)) return gb(ub(i, t));\n      throw new yb(fb(t) + \" is not iterable\");\n    },\n    Mb = cb,\n    Db = function (t, e, i) {\n      var o, s;\n      vb(t);\n      try {\n        if (!(o = wb(t, \"return\"))) {\n          if (\"throw\" === e) throw i;\n          return i;\n        }\n        o = bb(o, t);\n      } catch (t) {\n        s = !0, o = t;\n      }\n      if (\"throw\" === e) throw i;\n      if (s) throw o;\n      return vb(o), i;\n    },\n    Ib = TypeError,\n    Pb = function (t, e) {\n      this.stopped = t, this.result = e;\n    },\n    Bb = Pb.prototype,\n    Fb = function (t, e, i) {\n      var o,\n        s,\n        n,\n        r,\n        a,\n        h,\n        d,\n        l = i && i.that,\n        c = !(!i || !i.AS_ENTRIES),\n        u = !(!i || !i.IS_RECORD),\n        p = !(!i || !i.IS_ITERATOR),\n        g = !(!i || !i.INTERRUPTED),\n        f = _b(e, l),\n        m = function (t) {\n          return o && Db(o, \"normal\", t), new Pb(!0, t);\n        },\n        y = function (t) {\n          return c ? (Eb(t), g ? f(t[0], t[1], m) : f(t[0], t[1])) : g ? f(t, m) : f(t);\n        };\n      if (u) o = t.iterator;else if (p) o = t;else {\n        if (!(s = Mb(t))) throw new Ib(Ob(t) + \" is not iterable\");\n        if (Cb(s)) {\n          for (n = 0, r = kb(t); r > n; n++) if ((a = y(t[n])) && Sb(Bb, a)) return a;\n          return new Pb(!1);\n        }\n        o = Tb(t, s);\n      }\n      for (h = u ? t.next : o.next; !(d = xb(h, o)).done;) {\n        try {\n          a = y(d.value);\n        } catch (t) {\n          Db(o, \"throw\", t);\n        }\n        if (\"object\" == typeof a && a && Sb(Bb, a)) return a;\n      }\n      return new Pb(!1);\n    },\n    zb = ht,\n    Nb = TypeError,\n    Ab = function (t, e) {\n      if (zb(e, t)) return t;\n      throw new Nb(\"Incorrect invocation\");\n    },\n    Rb = Mi,\n    jb = n,\n    Lb = ib,\n    Hb = r,\n    Wb = yi,\n    Vb = Fb,\n    qb = Ab,\n    Ub = T,\n    Yb = et,\n    Xb = Y,\n    Kb = wr,\n    Gb = $e.f,\n    Zb = Ur.forEach,\n    Qb = D,\n    $b = Ar.set,\n    Jb = Ar.getterFor,\n    tv = function (t, e, i) {\n      var o,\n        s = -1 !== t.indexOf(\"Map\"),\n        n = -1 !== t.indexOf(\"Weak\"),\n        r = s ? \"set\" : \"add\",\n        a = jb[t],\n        h = a && a.prototype,\n        d = {};\n      if (Qb && Ub(a) && (n || h.forEach && !Hb(function () {\n        new a().entries().next();\n      }))) {\n        var l = (o = e(function (e, i) {\n            $b(qb(e, l), {\n              type: t,\n              collection: new a()\n            }), Xb(i) || Vb(i, e[r], {\n              that: e,\n              AS_ENTRIES: s\n            });\n          })).prototype,\n          c = Jb(t);\n        Zb([\"add\", \"clear\", \"delete\", \"forEach\", \"get\", \"has\", \"set\", \"keys\", \"values\", \"entries\"], function (t) {\n          var e = \"add\" === t || \"set\" === t;\n          !(t in h) || n && \"clear\" === t || Wb(l, t, function (i, o) {\n            var s = c(this).collection;\n            if (!e && n && !Yb(i)) return \"get\" === t && void 0;\n            var r = s[t](0 === i ? 0 : i, o);\n            return e ? this : r;\n          });\n        }), n || Gb(l, \"size\", {\n          configurable: !0,\n          get: function () {\n            return c(this).collection.size;\n          }\n        });\n      } else o = i.getConstructor(e, t, s, r), Lb.enable();\n      return Kb(o, t, !1, !0), d[t] = o, Rb({\n        global: !0,\n        forced: !0\n      }, d), n || i.setStrong(o, t, s), o;\n    },\n    ev = Kn,\n    iv = function (t, e, i) {\n      for (var o in e) i && i.unsafe && t[o] ? t[o] = e[o] : ev(t, o, e[o], i);\n      return t;\n    },\n    ov = at,\n    sv = Zn,\n    nv = D,\n    rv = pe(\"species\"),\n    av = In,\n    hv = Zn,\n    dv = iv,\n    lv = Qe,\n    cv = Ab,\n    uv = Y,\n    pv = Fb,\n    gv = Zd,\n    fv = Qd,\n    mv = function (t) {\n      var e = ov(t);\n      nv && e && !e[rv] && sv(e, rv, {\n        configurable: !0,\n        get: function () {\n          return this;\n        }\n      });\n    },\n    yv = D,\n    bv = ib.fastKey,\n    vv = Ar.set,\n    wv = Ar.getterFor,\n    _v = {\n      getConstructor: function (t, e, i, o) {\n        var s = t(function (t, s) {\n            cv(t, n), vv(t, {\n              type: e,\n              index: av(null),\n              first: void 0,\n              last: void 0,\n              size: 0\n            }), yv || (t.size = 0), uv(s) || pv(s, t[o], {\n              that: t,\n              AS_ENTRIES: i\n            });\n          }),\n          n = s.prototype,\n          r = wv(e),\n          a = function (t, e, i) {\n            var o,\n              s,\n              n = r(t),\n              a = h(t, e);\n            return a ? a.value = i : (n.last = a = {\n              index: s = bv(e, !0),\n              key: e,\n              value: i,\n              previous: o = n.last,\n              next: void 0,\n              removed: !1\n            }, n.first || (n.first = a), o && (o.next = a), yv ? n.size++ : t.size++, \"F\" !== s && (n.index[s] = a)), t;\n          },\n          h = function (t, e) {\n            var i,\n              o = r(t),\n              s = bv(e);\n            if (\"F\" !== s) return o.index[s];\n            for (i = o.first; i; i = i.next) if (i.key === e) return i;\n          };\n        return dv(n, {\n          clear: function () {\n            for (var t = r(this), e = t.index, i = t.first; i;) i.removed = !0, i.previous && (i.previous = i.previous.next = void 0), delete e[i.index], i = i.next;\n            t.first = t.last = void 0, yv ? t.size = 0 : this.size = 0;\n          },\n          delete: function (t) {\n            var e = this,\n              i = r(e),\n              o = h(e, t);\n            if (o) {\n              var s = o.next,\n                n = o.previous;\n              delete i.index[o.index], o.removed = !0, n && (n.next = s), s && (s.previous = n), i.first === o && (i.first = s), i.last === o && (i.last = n), yv ? i.size-- : e.size--;\n            }\n            return !!o;\n          },\n          forEach: function (t) {\n            for (var e, i = r(this), o = lv(t, arguments.length > 1 ? arguments[1] : void 0); e = e ? e.next : i.first;) for (o(e.value, e.key, this); e && e.removed;) e = e.previous;\n          },\n          has: function (t) {\n            return !!h(this, t);\n          }\n        }), dv(n, i ? {\n          get: function (t) {\n            var e = h(this, t);\n            return e && e.value;\n          },\n          set: function (t, e) {\n            return a(this, 0 === t ? 0 : t, e);\n          }\n        } : {\n          add: function (t) {\n            return a(this, t = 0 === t ? 0 : t, t);\n          }\n        }), yv && hv(n, \"size\", {\n          configurable: !0,\n          get: function () {\n            return r(this).size;\n          }\n        }), s;\n      },\n      setStrong: function (t, e, i) {\n        var o = e + \" Iterator\",\n          s = wv(e),\n          n = wv(o);\n        gv(t, e, function (t, e) {\n          vv(this, {\n            type: o,\n            target: t,\n            state: s(t),\n            kind: e,\n            last: void 0\n          });\n        }, function () {\n          for (var t = n(this), e = t.kind, i = t.last; i && i.removed;) i = i.previous;\n          return t.target && (t.last = i = i ? i.next : t.state.first) ? fv(\"keys\" === e ? i.key : \"values\" === e ? i.value : [i.key, i.value], !1) : (t.target = void 0, fv(void 0, !0));\n        }, i ? \"entries\" : \"values\", !i, !0), mv(e);\n      }\n    };\n  tv(\"Map\", function (t) {\n    return function () {\n      return t(this, arguments.length ? arguments[0] : void 0);\n    };\n  }, _v);\n  var xv = y,\n    Ev = Bi,\n    Ov = nn,\n    Cv = G,\n    kv = xv(\"\".charAt),\n    Sv = xv(\"\".charCodeAt),\n    Tv = xv(\"\".slice),\n    Mv = function (t) {\n      return function (e, i) {\n        var o,\n          s,\n          n = Ov(Cv(e)),\n          r = Ev(i),\n          a = n.length;\n        return r < 0 || r >= a ? t ? \"\" : void 0 : (o = Sv(n, r)) < 55296 || o > 56319 || r + 1 === a || (s = Sv(n, r + 1)) < 56320 || s > 57343 ? t ? kv(n, r) : o : t ? Tv(n, r, r + 2) : s - 56320 + (o - 55296 << 10) + 65536;\n      };\n    },\n    Dv = {\n      codeAt: Mv(!1),\n      charAt: Mv(!0)\n    }.charAt,\n    Iv = nn,\n    Pv = Ar,\n    Bv = Zd,\n    Fv = Qd,\n    zv = \"String Iterator\",\n    Nv = Pv.set,\n    Av = Pv.getterFor(zv);\n  Bv(String, \"String\", function (t) {\n    Nv(this, {\n      type: zv,\n      string: Iv(t),\n      index: 0\n    });\n  }, function () {\n    var t,\n      e = Av(this),\n      i = e.string,\n      o = e.index;\n    return o >= i.length ? Fv(void 0, !0) : (t = Dv(i, o), e.index += t.length, Fv(t, !1));\n  });\n  var Rv = o(it.Map);\n  class jv {\n    constructor() {\n      this.clear(), this._defaultIndex = 0, this._groupIndex = 0, this._defaultGroups = [{\n        border: \"#2B7CE9\",\n        background: \"#97C2FC\",\n        highlight: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        },\n        hover: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        }\n      }, {\n        border: \"#FFA500\",\n        background: \"#FFFF00\",\n        highlight: {\n          border: \"#FFA500\",\n          background: \"#FFFFA3\"\n        },\n        hover: {\n          border: \"#FFA500\",\n          background: \"#FFFFA3\"\n        }\n      }, {\n        border: \"#FA0A10\",\n        background: \"#FB7E81\",\n        highlight: {\n          border: \"#FA0A10\",\n          background: \"#FFAFB1\"\n        },\n        hover: {\n          border: \"#FA0A10\",\n          background: \"#FFAFB1\"\n        }\n      }, {\n        border: \"#41A906\",\n        background: \"#7BE141\",\n        highlight: {\n          border: \"#41A906\",\n          background: \"#A1EC76\"\n        },\n        hover: {\n          border: \"#41A906\",\n          background: \"#A1EC76\"\n        }\n      }, {\n        border: \"#E129F0\",\n        background: \"#EB7DF4\",\n        highlight: {\n          border: \"#E129F0\",\n          background: \"#F0B3F5\"\n        },\n        hover: {\n          border: \"#E129F0\",\n          background: \"#F0B3F5\"\n        }\n      }, {\n        border: \"#7C29F0\",\n        background: \"#AD85E4\",\n        highlight: {\n          border: \"#7C29F0\",\n          background: \"#D3BDF0\"\n        },\n        hover: {\n          border: \"#7C29F0\",\n          background: \"#D3BDF0\"\n        }\n      }, {\n        border: \"#C37F00\",\n        background: \"#FFA807\",\n        highlight: {\n          border: \"#C37F00\",\n          background: \"#FFCA66\"\n        },\n        hover: {\n          border: \"#C37F00\",\n          background: \"#FFCA66\"\n        }\n      }, {\n        border: \"#4220FB\",\n        background: \"#6E6EFD\",\n        highlight: {\n          border: \"#4220FB\",\n          background: \"#9B9BFD\"\n        },\n        hover: {\n          border: \"#4220FB\",\n          background: \"#9B9BFD\"\n        }\n      }, {\n        border: \"#FD5A77\",\n        background: \"#FFC0CB\",\n        highlight: {\n          border: \"#FD5A77\",\n          background: \"#FFD1D9\"\n        },\n        hover: {\n          border: \"#FD5A77\",\n          background: \"#FFD1D9\"\n        }\n      }, {\n        border: \"#4AD63A\",\n        background: \"#C2FABC\",\n        highlight: {\n          border: \"#4AD63A\",\n          background: \"#E6FFE3\"\n        },\n        hover: {\n          border: \"#4AD63A\",\n          background: \"#E6FFE3\"\n        }\n      }, {\n        border: \"#990000\",\n        background: \"#EE0000\",\n        highlight: {\n          border: \"#BB0000\",\n          background: \"#FF3333\"\n        },\n        hover: {\n          border: \"#BB0000\",\n          background: \"#FF3333\"\n        }\n      }, {\n        border: \"#FF6000\",\n        background: \"#FF6000\",\n        highlight: {\n          border: \"#FF6000\",\n          background: \"#FF6000\"\n        },\n        hover: {\n          border: \"#FF6000\",\n          background: \"#FF6000\"\n        }\n      }, {\n        border: \"#97C2FC\",\n        background: \"#2B7CE9\",\n        highlight: {\n          border: \"#D2E5FF\",\n          background: \"#2B7CE9\"\n        },\n        hover: {\n          border: \"#D2E5FF\",\n          background: \"#2B7CE9\"\n        }\n      }, {\n        border: \"#399605\",\n        background: \"#255C03\",\n        highlight: {\n          border: \"#399605\",\n          background: \"#255C03\"\n        },\n        hover: {\n          border: \"#399605\",\n          background: \"#255C03\"\n        }\n      }, {\n        border: \"#B70054\",\n        background: \"#FF007E\",\n        highlight: {\n          border: \"#B70054\",\n          background: \"#FF007E\"\n        },\n        hover: {\n          border: \"#B70054\",\n          background: \"#FF007E\"\n        }\n      }, {\n        border: \"#AD85E4\",\n        background: \"#7C29F0\",\n        highlight: {\n          border: \"#D3BDF0\",\n          background: \"#7C29F0\"\n        },\n        hover: {\n          border: \"#D3BDF0\",\n          background: \"#7C29F0\"\n        }\n      }, {\n        border: \"#4557FA\",\n        background: \"#000EA1\",\n        highlight: {\n          border: \"#6E6EFD\",\n          background: \"#000EA1\"\n        },\n        hover: {\n          border: \"#6E6EFD\",\n          background: \"#000EA1\"\n        }\n      }, {\n        border: \"#FFC0CB\",\n        background: \"#FD5A77\",\n        highlight: {\n          border: \"#FFD1D9\",\n          background: \"#FD5A77\"\n        },\n        hover: {\n          border: \"#FFD1D9\",\n          background: \"#FD5A77\"\n        }\n      }, {\n        border: \"#C2FABC\",\n        background: \"#74D66A\",\n        highlight: {\n          border: \"#E6FFE3\",\n          background: \"#74D66A\"\n        },\n        hover: {\n          border: \"#E6FFE3\",\n          background: \"#74D66A\"\n        }\n      }, {\n        border: \"#EE0000\",\n        background: \"#990000\",\n        highlight: {\n          border: \"#FF3333\",\n          background: \"#BB0000\"\n        },\n        hover: {\n          border: \"#FF3333\",\n          background: \"#BB0000\"\n        }\n      }], this.options = {}, this.defaultOptions = {\n        useDefaultGroups: !0\n      }, wo(this.options, this.defaultOptions);\n    }\n    setOptions(t) {\n      const e = [\"useDefaultGroups\"];\n      if (void 0 !== t) for (const i in t) if (Object.prototype.hasOwnProperty.call(t, i) && -1 === Mp(e).call(e, i)) {\n        const e = t[i];\n        this.add(i, e);\n      }\n    }\n    clear() {\n      this._groups = new Rv(), this._groupNames = [];\n    }\n    get(t) {\n      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],\n        i = this._groups.get(t);\n      if (void 0 === i && e) if (!1 === this.options.useDefaultGroups && this._groupNames.length > 0) {\n        const e = this._groupIndex % this._groupNames.length;\n        ++this._groupIndex, i = {}, i.color = this._groups.get(this._groupNames[e]), this._groups.set(t, i);\n      } else {\n        const e = this._defaultIndex % this._defaultGroups.length;\n        this._defaultIndex++, i = {}, i.color = this._defaultGroups[e], this._groups.set(t, i);\n      }\n      return i;\n    }\n    add(t, e) {\n      return this._groups.has(t) || this._groupNames.push(t), this._groups.set(t, e), e;\n    }\n  }\n  Mi({\n    target: \"Number\",\n    stat: !0\n  }, {\n    isNaN: function (t) {\n      return t != t;\n    }\n  });\n  var Lv = o(it.Number.isNaN),\n    Hv = n.isFinite,\n    Wv = Number.isFinite || function (t) {\n      return \"number\" == typeof t && Hv(t);\n    };\n  Mi({\n    target: \"Number\",\n    stat: !0\n  }, {\n    isFinite: Wv\n  });\n  var Vv = o(it.Number.isFinite),\n    qv = Ur.some;\n  Mi({\n    target: \"Array\",\n    proto: !0,\n    forced: !nc(\"some\")\n  }, {\n    some: function (t) {\n      return qv(this, t, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n  var Uv = zo(\"Array\").some,\n    Yv = ht,\n    Xv = Uv,\n    Kv = Array.prototype,\n    Gv = function (t) {\n      var e = t.some;\n      return t === Kv || Yv(Kv, t) && e === Kv.some ? Xv : e;\n    },\n    Zv = o(Gv),\n    Qv = {\n      exports: {}\n    },\n    $v = Mi,\n    Jv = D,\n    tw = $e.f;\n  $v({\n    target: \"Object\",\n    stat: !0,\n    forced: Object.defineProperty !== tw,\n    sham: !Jv\n  }, {\n    defineProperty: tw\n  });\n  var ew = it.Object,\n    iw = Qv.exports = function (t, e, i) {\n      return ew.defineProperty(t, e, i);\n    };\n  ew.defineProperty.sham && (iw.sham = !0);\n  var ow = Qv.exports,\n    sw = o(ow),\n    nw = pe,\n    rw = $e.f,\n    aw = nw(\"metadata\"),\n    hw = Function.prototype;\n  void 0 === hw[aw] && rw(hw, aw, {\n    value: null\n  }), rr(\"asyncDispose\"), rr(\"dispose\"), rr(\"metadata\");\n  var dw = fl,\n    lw = y,\n    cw = at(\"Symbol\"),\n    uw = cw.keyFor,\n    pw = lw(cw.prototype.valueOf),\n    gw = cw.isRegisteredSymbol || function (t) {\n      try {\n        return void 0 !== uw(pw(t));\n      } catch (t) {\n        return !1;\n      }\n    };\n  Mi({\n    target: \"Symbol\",\n    stat: !0\n  }, {\n    isRegisteredSymbol: gw\n  });\n  for (var fw = Xt, mw = at, yw = y, bw = kt, vw = pe, ww = mw(\"Symbol\"), _w = ww.isWellKnownSymbol, xw = mw(\"Object\", \"getOwnPropertyNames\"), Ew = yw(ww.prototype.valueOf), Ow = fw(\"wks\"), Cw = 0, kw = xw(ww), Sw = kw.length; Cw < Sw; Cw++) try {\n    var Tw = kw[Cw];\n    bw(ww[Tw]) && vw(Tw);\n  } catch (t) {}\n  var Mw = function (t) {\n    if (_w && _w(t)) return !0;\n    try {\n      for (var e = Ew(t), i = 0, o = xw(Ow), s = o.length; i < s; i++) if (Ow[o[i]] == e) return !0;\n    } catch (t) {}\n    return !1;\n  };\n  Mi({\n    target: \"Symbol\",\n    stat: !0,\n    forced: !0\n  }, {\n    isWellKnownSymbol: Mw\n  }), rr(\"matcher\"), rr(\"observable\"), Mi({\n    target: \"Symbol\",\n    stat: !0,\n    name: \"isRegisteredSymbol\"\n  }, {\n    isRegistered: gw\n  }), Mi({\n    target: \"Symbol\",\n    stat: !0,\n    name: \"isWellKnownSymbol\",\n    forced: !0\n  }, {\n    isWellKnown: Mw\n  }), rr(\"metadataKey\"), rr(\"patternMatch\"), rr(\"replaceAll\");\n  var Dw = o(dw),\n    Iw = o(Qn.f(\"iterator\"));\n  function Pw(t) {\n    return Pw = \"function\" == typeof Dw && \"symbol\" == typeof Iw ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Dw && t.constructor === Dw && t !== Dw.prototype ? \"symbol\" : typeof t;\n    }, Pw(t);\n  }\n  var Bw = o(Qn.f(\"toPrimitive\"));\n  function Fw(t) {\n    var e = function (t, e) {\n      if (\"object\" !== Pw(t) || null === t) return t;\n      var i = t[Bw];\n      if (void 0 !== i) {\n        var o = i.call(t, e || \"default\");\n        if (\"object\" !== Pw(o)) return o;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n      }\n      return (\"string\" === e ? String : Number)(t);\n    }(t, \"string\");\n    return \"symbol\" === Pw(e) ? e : String(e);\n  }\n  function zw(t, e, i) {\n    return (e = Fw(e)) in t ? sw(t, e, {\n      value: i,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = i, t;\n  }\n  var Nw = n,\n    Aw = r,\n    Rw = nn,\n    jw = np.trim,\n    Lw = Qu,\n    Hw = y(\"\".charAt),\n    Ww = Nw.parseFloat,\n    Vw = Nw.Symbol,\n    qw = Vw && Vw.iterator,\n    Uw = 1 / Ww(Lw + \"-0\") != -1 / 0 || qw && !Aw(function () {\n      Ww(Object(qw));\n    }) ? function (t) {\n      var e = jw(Rw(t)),\n        i = Ww(e);\n      return 0 === i && \"-\" === Hw(e, 0) ? -0 : i;\n    } : Ww;\n  Mi({\n    global: !0,\n    forced: parseFloat !== Uw\n  }, {\n    parseFloat: Uw\n  });\n  var Yw = o(it.parseFloat),\n    Xw = Mi,\n    Kw = r,\n    Gw = zn.f;\n  Xw({\n    target: \"Object\",\n    stat: !0,\n    forced: Kw(function () {\n      return !Object.getOwnPropertyNames(1);\n    })\n  }, {\n    getOwnPropertyNames: Gw\n  });\n  var Zw = it.Object,\n    Qw = function (t) {\n      return Zw.getOwnPropertyNames(t);\n    },\n    $w = o(Qw),\n    Jw = o(it.Object.getOwnPropertySymbols),\n    t_ = {\n      exports: {}\n    },\n    e_ = Mi,\n    i_ = r,\n    o_ = $,\n    s_ = M.f,\n    n_ = D;\n  e_({\n    target: \"Object\",\n    stat: !0,\n    forced: !n_ || i_(function () {\n      s_(1);\n    }),\n    sham: !n_\n  }, {\n    getOwnPropertyDescriptor: function (t, e) {\n      return s_(o_(t), e);\n    }\n  });\n  var r_ = it.Object,\n    a_ = t_.exports = function (t, e) {\n      return r_.getOwnPropertyDescriptor(t, e);\n    };\n  r_.getOwnPropertyDescriptor.sham && (a_.sham = !0);\n  var h_ = o(t_.exports),\n    d_ = Wl,\n    l_ = $,\n    c_ = M,\n    u_ = os;\n  Mi({\n    target: \"Object\",\n    stat: !0,\n    sham: !D\n  }, {\n    getOwnPropertyDescriptors: function (t) {\n      for (var e, i, o = l_(t), s = c_.f, n = d_(o), r = {}, a = 0; n.length > a;) void 0 !== (i = s(o, e = n[a++])) && u_(r, e, i);\n      return r;\n    }\n  });\n  var p_ = o(it.Object.getOwnPropertyDescriptors),\n    g_ = {\n      exports: {}\n    },\n    f_ = Mi,\n    m_ = D,\n    y_ = rn.f;\n  f_({\n    target: \"Object\",\n    stat: !0,\n    forced: Object.defineProperties !== y_,\n    sham: !m_\n  }, {\n    defineProperties: y_\n  });\n  var b_ = it.Object,\n    v_ = g_.exports = function (t, e) {\n      return b_.defineProperties(t, e);\n    };\n  b_.defineProperties.sham && (v_.sham = !0);\n  var w_ = o(g_.exports),\n    __ = o(ow);\n  function x_(t, e) {\n    const i = [\"node\", \"edge\", \"label\"];\n    let o = !0;\n    const s = Rm(e, \"chosen\");\n    if (\"boolean\" == typeof s) o = s;else if (\"object\" == typeof s) {\n      if (-1 === Mp(i).call(i, t)) throw new Error(\"choosify: subOption '\" + t + \"' should be one of '\" + i.join(\"', '\") + \"'\");\n      const s = Rm(e, [\"chosen\", t]);\n      \"boolean\" != typeof s && \"function\" != typeof s || (o = s);\n    }\n    return o;\n  }\n  function E_(t, e, i) {\n    if (t.width <= 0 || t.height <= 0) return !1;\n    if (void 0 !== i) {\n      const t = {\n        x: e.x - i.x,\n        y: e.y - i.y\n      };\n      if (0 !== i.angle) {\n        const o = -i.angle;\n        e = {\n          x: Math.cos(o) * t.x - Math.sin(o) * t.y,\n          y: Math.sin(o) * t.x + Math.cos(o) * t.y\n        };\n      } else e = t;\n    }\n    const o = t.x + t.width,\n      s = t.y + t.width;\n    return t.left < e.x && o > e.x && t.top < e.y && s > e.y;\n  }\n  function O_(t) {\n    return \"string\" == typeof t && \"\" !== t;\n  }\n  function C_(t, e, i, o) {\n    let s = o.x,\n      n = o.y;\n    if (\"function\" == typeof o.distanceToBorder) {\n      const i = o.distanceToBorder(t, e),\n        r = Math.sin(e) * i,\n        a = Math.cos(e) * i;\n      a === i ? (s += i, n = o.y) : r === i ? (s = o.x, n -= i) : (s += a, n -= r);\n    } else o.shape.width > o.shape.height ? (s = o.x + .5 * o.shape.width, n = o.y - i) : (s = o.x + i, n = o.y - .5 * o.shape.height);\n    return {\n      x: s,\n      y: n\n    };\n  }\n  var k_ = zo(\"Array\").values,\n    S_ = us,\n    T_ = Jt,\n    M_ = ht,\n    D_ = k_,\n    I_ = Array.prototype,\n    P_ = {\n      DOMTokenList: !0,\n      NodeList: !0\n    },\n    B_ = function (t) {\n      var e = t.values;\n      return t === I_ || M_(I_, t) && e === I_.values || T_(P_, S_(t)) ? D_ : e;\n    },\n    F_ = o(B_);\n  class z_ {\n    constructor(t) {\n      this.measureText = t, this.current = 0, this.width = 0, this.height = 0, this.lines = [];\n    }\n    _add(t, e) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : \"normal\";\n      void 0 === this.lines[t] && (this.lines[t] = {\n        width: 0,\n        height: 0,\n        blocks: []\n      });\n      let o = e;\n      void 0 !== e && \"\" !== e || (o = \" \");\n      const s = this.measureText(o, i),\n        n = wo({}, F_(s));\n      n.text = e, n.width = s.width, n.mod = i, void 0 !== e && \"\" !== e || (n.width = 0), this.lines[t].blocks.push(n), this.lines[t].width += n.width;\n    }\n    curWidth() {\n      const t = this.lines[this.current];\n      return void 0 === t ? 0 : t.width;\n    }\n    append(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"normal\";\n      this._add(this.current, t, e);\n    }\n    newLine(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"normal\";\n      this._add(this.current, t, e), this.current++;\n    }\n    determineLineHeights() {\n      for (let t = 0; t < this.lines.length; t++) {\n        const e = this.lines[t];\n        let i = 0;\n        if (void 0 !== e.blocks) for (let t = 0; t < e.blocks.length; t++) {\n          const o = e.blocks[t];\n          i < o.height && (i = o.height);\n        }\n        e.height = i;\n      }\n    }\n    determineLabelSize() {\n      let t = 0,\n        e = 0;\n      for (let i = 0; i < this.lines.length; i++) {\n        const o = this.lines[i];\n        o.width > t && (t = o.width), e += o.height;\n      }\n      this.width = t, this.height = e;\n    }\n    removeEmptyBlocks() {\n      const t = [];\n      for (let e = 0; e < this.lines.length; e++) {\n        const i = this.lines[e];\n        if (0 === i.blocks.length) continue;\n        if (e === this.lines.length - 1 && 0 === i.width) continue;\n        const o = {};\n        let s;\n        wo(o, i), o.blocks = [];\n        const n = [];\n        for (let t = 0; t < i.blocks.length; t++) {\n          const e = i.blocks[t];\n          0 !== e.width ? n.push(e) : void 0 === s && (s = e);\n        }\n        0 === n.length && void 0 !== s && n.push(s), o.blocks = n, t.push(o);\n      }\n      return t;\n    }\n    finalize() {\n      this.determineLineHeights(), this.determineLabelSize();\n      const t = this.removeEmptyBlocks();\n      return {\n        width: this.width,\n        height: this.height,\n        lines: t\n      };\n    }\n  }\n  const N_ = {\n    \"<b>\": /<b>/,\n    \"<i>\": /<i>/,\n    \"<code>\": /<code>/,\n    \"</b>\": /<\\/b>/,\n    \"</i>\": /<\\/i>/,\n    \"</code>\": /<\\/code>/,\n    \"*\": /\\*/,\n    _: /_/,\n    \"`\": /`/,\n    afterBold: /[^*]/,\n    afterItal: /[^_]/,\n    afterMono: /[^`]/\n  };\n  class A_ {\n    constructor(t) {\n      this.text = t, this.bold = !1, this.ital = !1, this.mono = !1, this.spacing = !1, this.position = 0, this.buffer = \"\", this.modStack = [], this.blocks = [];\n    }\n    mod() {\n      return 0 === this.modStack.length ? \"normal\" : this.modStack[0];\n    }\n    modName() {\n      return 0 === this.modStack.length ? \"normal\" : \"mono\" === this.modStack[0] ? \"mono\" : this.bold && this.ital ? \"boldital\" : this.bold ? \"bold\" : this.ital ? \"ital\" : void 0;\n    }\n    emitBlock() {\n      this.spacing && (this.add(\" \"), this.spacing = !1), this.buffer.length > 0 && (this.blocks.push({\n        text: this.buffer,\n        mod: this.modName()\n      }), this.buffer = \"\");\n    }\n    add(t) {\n      \" \" === t && (this.spacing = !0), this.spacing && (this.buffer += \" \", this.spacing = !1), \" \" != t && (this.buffer += t);\n    }\n    parseWS(t) {\n      return !!/[ \\t]/.test(t) && (this.mono ? this.add(t) : this.spacing = !0, !0);\n    }\n    setTag(t) {\n      this.emitBlock(), this[t] = !0, this.modStack.unshift(t);\n    }\n    unsetTag(t) {\n      this.emitBlock(), this[t] = !1, this.modStack.shift();\n    }\n    parseStartTag(t, e) {\n      return !(this.mono || this[t] || !this.match(e)) && (this.setTag(t), !0);\n    }\n    match(t) {\n      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      const [i, o] = this.prepareRegExp(t),\n        s = i.test(this.text.substr(this.position, o));\n      return s && e && (this.position += o - 1), s;\n    }\n    parseEndTag(t, e, i) {\n      let o = this.mod() === t;\n      return o = \"mono\" === t ? o && this.mono : o && !this.mono, !(!o || !this.match(e)) && (void 0 !== i ? (this.position === this.text.length - 1 || this.match(i, !1)) && this.unsetTag(t) : this.unsetTag(t), !0);\n    }\n    replace(t, e) {\n      return !!this.match(t) && (this.add(e), this.position += length - 1, !0);\n    }\n    prepareRegExp(t) {\n      let e, i;\n      if (t instanceof RegExp) i = t, e = 1;else {\n        const o = N_[t];\n        i = void 0 !== o ? o : new RegExp(t), e = t.length;\n      }\n      return [i, e];\n    }\n  }\n  class R_ {\n    constructor(t, e, i, o) {\n      this.ctx = t, this.parent = e, this.selected = i, this.hover = o;\n      this.lines = new z_((e, s) => {\n        if (void 0 === e) return 0;\n        const n = this.parent.getFormattingValues(t, i, o, s);\n        let r = 0;\n        if (\"\" !== e) {\n          r = this.ctx.measureText(e).width;\n        }\n        return {\n          width: r,\n          values: n\n        };\n      });\n    }\n    process(t) {\n      if (!O_(t)) return this.lines.finalize();\n      const e = this.parent.fontOptions;\n      t = (t = t.replace(/\\r\\n/g, \"\\n\")).replace(/\\r/g, \"\\n\");\n      const i = String(t).split(\"\\n\"),\n        o = i.length;\n      if (e.multi) for (let t = 0; t < o; t++) {\n        const o = this.splitBlocks(i[t], e.multi);\n        if (void 0 !== o) if (0 !== o.length) {\n          if (e.maxWdt > 0) for (let t = 0; t < o.length; t++) {\n            const e = o[t].mod,\n              i = o[t].text;\n            this.splitStringIntoLines(i, e, !0);\n          } else for (let t = 0; t < o.length; t++) {\n            const e = o[t].mod,\n              i = o[t].text;\n            this.lines.append(i, e);\n          }\n          this.lines.newLine();\n        } else this.lines.newLine(\"\");\n      } else if (e.maxWdt > 0) for (let t = 0; t < o; t++) this.splitStringIntoLines(i[t]);else for (let t = 0; t < o; t++) this.lines.newLine(i[t]);\n      return this.lines.finalize();\n    }\n    decodeMarkupSystem(t) {\n      let e = \"none\";\n      return \"markdown\" === t || \"md\" === t ? e = \"markdown\" : !0 !== t && \"html\" !== t || (e = \"html\"), e;\n    }\n    splitHtmlBlocks(t) {\n      const e = new A_(t),\n        i = t => {\n          if (/&/.test(t)) {\n            return e.replace(e.text, \"&lt;\", \"<\") || e.replace(e.text, \"&amp;\", \"&\") || e.add(\"&\"), !0;\n          }\n          return !1;\n        };\n      for (; e.position < e.text.length;) {\n        const t = e.text.charAt(e.position);\n        e.parseWS(t) || /</.test(t) && (e.parseStartTag(\"bold\", \"<b>\") || e.parseStartTag(\"ital\", \"<i>\") || e.parseStartTag(\"mono\", \"<code>\") || e.parseEndTag(\"bold\", \"</b>\") || e.parseEndTag(\"ital\", \"</i>\") || e.parseEndTag(\"mono\", \"</code>\")) || i(t) || e.add(t), e.position++;\n      }\n      return e.emitBlock(), e.blocks;\n    }\n    splitMarkdownBlocks(t) {\n      const e = new A_(t);\n      let i = !0;\n      const o = t => !!/\\\\/.test(t) && (e.position < this.text.length + 1 && (e.position++, t = this.text.charAt(e.position), / \\t/.test(t) ? e.spacing = !0 : (e.add(t), i = !1)), !0);\n      for (; e.position < e.text.length;) {\n        const t = e.text.charAt(e.position);\n        e.parseWS(t) || o(t) || (i || e.spacing) && (e.parseStartTag(\"bold\", \"*\") || e.parseStartTag(\"ital\", \"_\") || e.parseStartTag(\"mono\", \"`\")) || e.parseEndTag(\"bold\", \"*\", \"afterBold\") || e.parseEndTag(\"ital\", \"_\", \"afterItal\") || e.parseEndTag(\"mono\", \"`\", \"afterMono\") || (e.add(t), i = !1), e.position++;\n      }\n      return e.emitBlock(), e.blocks;\n    }\n    splitBlocks(t, e) {\n      const i = this.decodeMarkupSystem(e);\n      return \"none\" === i ? [{\n        text: t,\n        mod: \"normal\"\n      }] : \"markdown\" === i ? this.splitMarkdownBlocks(t) : \"html\" === i ? this.splitHtmlBlocks(t) : void 0;\n    }\n    overMaxWidth(t) {\n      const e = this.ctx.measureText(t).width;\n      return this.lines.curWidth() + e > this.parent.fontOptions.maxWdt;\n    }\n    getLongestFit(t) {\n      let e = \"\",\n        i = 0;\n      for (; i < t.length;) {\n        const o = e + (\"\" === e ? \"\" : \" \") + t[i];\n        if (this.overMaxWidth(o)) break;\n        e = o, i++;\n      }\n      return i;\n    }\n    getLongestFitWord(t) {\n      let e = 0;\n      for (; e < t.length && !this.overMaxWidth(Nl(t).call(t, 0, e));) e++;\n      return e;\n    }\n    splitStringIntoLines(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"normal\",\n        i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n      this.parent.getFormattingValues(this.ctx, this.selected, this.hover, e);\n      let o = (t = (t = t.replace(/^( +)/g, \"$1\\r\")).replace(/([^\\r][^ ]*)( +)/g, \"$1\\r$2\\r\")).split(\"\\r\");\n      for (; o.length > 0;) {\n        let t = this.getLongestFit(o);\n        if (0 === t) {\n          const t = o[0],\n            i = this.getLongestFitWord(t);\n          this.lines.newLine(Nl(t).call(t, 0, i), e), o[0] = Nl(t).call(t, i);\n        } else {\n          let s = t;\n          \" \" === o[t - 1] ? t-- : \" \" === o[s] && s++;\n          const n = Nl(o).call(o, 0, t).join(\"\");\n          t == o.length && i ? this.lines.append(n, e) : this.lines.newLine(n, e), o = Nl(o).call(o, s);\n        }\n      }\n    }\n  }\n  const j_ = [\"bold\", \"ital\", \"boldital\", \"mono\"];\n  class L_ {\n    constructor(t, e) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n      this.body = t, this.pointToSelf = !1, this.baseSize = void 0, this.fontOptions = {}, this.setOptions(e), this.size = {\n        top: 0,\n        left: 0,\n        width: 0,\n        height: 0,\n        yLine: 0\n      }, this.isEdgeLabel = i;\n    }\n    setOptions(t) {\n      if (this.elementOptions = t, this.initFontOptions(t.font), O_(t.label) ? this.labelDirty = !0 : t.label = void 0, void 0 !== t.font && null !== t.font) if (\"string\" == typeof t.font) this.baseSize = this.fontOptions.size;else if (\"object\" == typeof t.font) {\n        const e = t.font.size;\n        void 0 !== e && (this.baseSize = e);\n      }\n    }\n    initFontOptions(t) {\n      Cm(j_, t => {\n        this.fontOptions[t] = {};\n      }), L_.parseFontString(this.fontOptions, t) ? this.fontOptions.vadjust = 0 : Cm(t, (t, e) => {\n        null != t && \"object\" != typeof t && (this.fontOptions[e] = t);\n      });\n    }\n    static parseFontString(t, e) {\n      if (!e || \"string\" != typeof e) return !1;\n      const i = e.split(\" \");\n      return t.size = +i[0].replace(\"px\", \"\"), t.face = i[1], t.color = i[2], !0;\n    }\n    constrain(t) {\n      const e = {\n          constrainWidth: !1,\n          maxWdt: -1,\n          minWdt: -1,\n          constrainHeight: !1,\n          minHgt: -1,\n          valign: \"middle\"\n        },\n        i = Rm(t, \"widthConstraint\");\n      if (\"number\" == typeof i) e.maxWdt = Number(i), e.minWdt = Number(i);else if (\"object\" == typeof i) {\n        const i = Rm(t, [\"widthConstraint\", \"maximum\"]);\n        \"number\" == typeof i && (e.maxWdt = Number(i));\n        const o = Rm(t, [\"widthConstraint\", \"minimum\"]);\n        \"number\" == typeof o && (e.minWdt = Number(o));\n      }\n      const o = Rm(t, \"heightConstraint\");\n      if (\"number\" == typeof o) e.minHgt = Number(o);else if (\"object\" == typeof o) {\n        const i = Rm(t, [\"heightConstraint\", \"minimum\"]);\n        \"number\" == typeof i && (e.minHgt = Number(i));\n        const o = Rm(t, [\"heightConstraint\", \"valign\"]);\n        \"string\" == typeof o && (\"top\" !== o && \"bottom\" !== o || (e.valign = o));\n      }\n      return e;\n    }\n    update(t, e) {\n      this.setOptions(t, !0), this.propagateFonts(e), xm(this.fontOptions, this.constrain(e)), this.fontOptions.chooser = x_(\"label\", e);\n    }\n    adjustSizes(t) {\n      const e = t ? t.right + t.left : 0;\n      this.fontOptions.constrainWidth && (this.fontOptions.maxWdt -= e, this.fontOptions.minWdt -= e);\n      const i = t ? t.top + t.bottom : 0;\n      this.fontOptions.constrainHeight && (this.fontOptions.minHgt -= i);\n    }\n    addFontOptionsToPile(t, e) {\n      for (let i = 0; i < e.length; ++i) this.addFontToPile(t, e[i]);\n    }\n    addFontToPile(t, e) {\n      if (void 0 === e) return;\n      if (void 0 === e.font || null === e.font) return;\n      const i = e.font;\n      t.push(i);\n    }\n    getBasicOptions(t) {\n      const e = {};\n      for (let i = 0; i < t.length; ++i) {\n        let o = t[i];\n        const s = {};\n        L_.parseFontString(s, o) && (o = s), Cm(o, (t, i) => {\n          void 0 !== t && (Object.prototype.hasOwnProperty.call(e, i) || (-1 !== Mp(j_).call(j_, i) ? e[i] = {} : e[i] = t));\n        });\n      }\n      return e;\n    }\n    getFontOption(t, e, i) {\n      let o;\n      for (let s = 0; s < t.length; ++s) {\n        const n = t[s];\n        if (Object.prototype.hasOwnProperty.call(n, e)) {\n          if (o = n[e], null == o) continue;\n          const t = {};\n          if (L_.parseFontString(t, o) && (o = t), Object.prototype.hasOwnProperty.call(o, i)) return o[i];\n        }\n      }\n      if (Object.prototype.hasOwnProperty.call(this.fontOptions, i)) return this.fontOptions[i];\n      throw new Error(\"Did not find value for multi-font for property: '\" + i + \"'\");\n    }\n    getFontOptions(t, e) {\n      const i = {},\n        o = [\"color\", \"size\", \"face\", \"mod\", \"vadjust\"];\n      for (let s = 0; s < o.length; ++s) {\n        const n = o[s];\n        i[n] = this.getFontOption(t, e, n);\n      }\n      return i;\n    }\n    propagateFonts(t) {\n      const e = [];\n      this.addFontOptionsToPile(e, t), this.fontOptions = this.getBasicOptions(e);\n      for (let t = 0; t < j_.length; ++t) {\n        const i = j_[t],\n          o = this.fontOptions[i];\n        Cm(this.getFontOptions(e, i), (t, e) => {\n          o[e] = t;\n        }), o.size = Number(o.size), o.vadjust = Number(o.vadjust);\n      }\n    }\n    draw(t, e, i, o, s) {\n      let n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : \"middle\";\n      if (void 0 === this.elementOptions.label) return;\n      let r = this.fontOptions.size * this.body.view.scale;\n      this.elementOptions.label && r < this.elementOptions.scaling.label.drawThreshold - 1 || (r >= this.elementOptions.scaling.label.maxVisible && (r = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale), this.calculateLabelSize(t, o, s, e, i, n), this._drawBackground(t), this._drawText(t, e, this.size.yLine, n, r));\n    }\n    _drawBackground(t) {\n      if (void 0 !== this.fontOptions.background && \"none\" !== this.fontOptions.background) {\n        t.fillStyle = this.fontOptions.background;\n        const e = this.getSize();\n        t.fillRect(e.left, e.top, e.width, e.height);\n      }\n    }\n    _drawText(t, e, i) {\n      let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : \"middle\",\n        s = arguments.length > 4 ? arguments[4] : void 0;\n      [e, i] = this._setAlignment(t, e, i, o), t.textAlign = \"left\", e -= this.size.width / 2, this.fontOptions.valign && this.size.height > this.size.labelHeight && (\"top\" === this.fontOptions.valign && (i -= (this.size.height - this.size.labelHeight) / 2), \"bottom\" === this.fontOptions.valign && (i += (this.size.height - this.size.labelHeight) / 2));\n      for (let o = 0; o < this.lineCount; o++) {\n        const n = this.lines[o];\n        if (n && n.blocks) {\n          let o = 0;\n          this.isEdgeLabel || \"center\" === this.fontOptions.align ? o += (this.size.width - n.width) / 2 : \"right\" === this.fontOptions.align && (o += this.size.width - n.width);\n          for (let r = 0; r < n.blocks.length; r++) {\n            const a = n.blocks[r];\n            t.font = a.font;\n            const [h, d] = this._getColor(a.color, s, a.strokeColor);\n            a.strokeWidth > 0 && (t.lineWidth = a.strokeWidth, t.strokeStyle = d, t.lineJoin = \"round\"), t.fillStyle = h, a.strokeWidth > 0 && t.strokeText(a.text, e + o, i + a.vadjust), t.fillText(a.text, e + o, i + a.vadjust), o += a.width;\n          }\n          i += n.height;\n        }\n      }\n    }\n    _setAlignment(t, e, i, o) {\n      if (this.isEdgeLabel && \"horizontal\" !== this.fontOptions.align && !1 === this.pointToSelf) {\n        e = 0, i = 0;\n        const o = 2;\n        \"top\" === this.fontOptions.align ? (t.textBaseline = \"alphabetic\", i -= 2 * o) : \"bottom\" === this.fontOptions.align ? (t.textBaseline = \"hanging\", i += 2 * o) : t.textBaseline = \"middle\";\n      } else t.textBaseline = o;\n      return [e, i];\n    }\n    _getColor(t, e, i) {\n      let o = t || \"#000000\",\n        s = i || \"#ffffff\";\n      if (e <= this.elementOptions.scaling.label.drawThreshold) {\n        const t = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - e)));\n        o = Sm(o, t), s = Sm(s, t);\n      }\n      return [o, s];\n    }\n    getTextSize(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n        i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n      return this._processLabel(t, e, i), {\n        width: this.size.width,\n        height: this.size.height,\n        lineCount: this.lineCount\n      };\n    }\n    getSize() {\n      let t = this.size.left,\n        e = this.size.top - 1;\n      if (this.isEdgeLabel) {\n        const i = .5 * -this.size.width;\n        switch (this.fontOptions.align) {\n          case \"middle\":\n            t = i, e = .5 * -this.size.height;\n            break;\n          case \"top\":\n            t = i, e = -(this.size.height + 2);\n            break;\n          case \"bottom\":\n            t = i, e = 2;\n        }\n      }\n      return {\n        left: t,\n        top: e,\n        width: this.size.width,\n        height: this.size.height\n      };\n    }\n    calculateLabelSize(t, e, i) {\n      let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,\n        s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,\n        n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : \"middle\";\n      this._processLabel(t, e, i), this.size.left = o - .5 * this.size.width, this.size.top = s - .5 * this.size.height, this.size.yLine = s + .5 * (1 - this.lineCount) * this.fontOptions.size, \"hanging\" === n && (this.size.top += .5 * this.fontOptions.size, this.size.top += 4, this.size.yLine += 4);\n    }\n    getFormattingValues(t, e, i, o) {\n      const s = function (t, e, i) {\n          return \"normal\" === e ? \"mod\" === i ? \"\" : t[i] : void 0 !== t[e][i] ? t[e][i] : t[i];\n        },\n        n = {\n          color: s(this.fontOptions, o, \"color\"),\n          size: s(this.fontOptions, o, \"size\"),\n          face: s(this.fontOptions, o, \"face\"),\n          mod: s(this.fontOptions, o, \"mod\"),\n          vadjust: s(this.fontOptions, o, \"vadjust\"),\n          strokeWidth: this.fontOptions.strokeWidth,\n          strokeColor: this.fontOptions.strokeColor\n        };\n      (e || i) && (\"normal\" === o && !0 === this.fontOptions.chooser && this.elementOptions.labelHighlightBold ? n.mod = \"bold\" : \"function\" == typeof this.fontOptions.chooser && this.fontOptions.chooser(n, this.elementOptions.id, e, i));\n      let r = \"\";\n      return void 0 !== n.mod && \"\" !== n.mod && (r += n.mod + \" \"), r += n.size + \"px \" + n.face, t.font = r.replace(/\"/g, \"\"), n.font = t.font, n.height = n.size, n;\n    }\n    differentState(t, e) {\n      return t !== this.selectedState || e !== this.hoverState;\n    }\n    _processLabelText(t, e, i, o) {\n      return new R_(t, this, e, i).process(o);\n    }\n    _processLabel(t, e, i) {\n      if (!1 === this.labelDirty && !this.differentState(e, i)) return;\n      const o = this._processLabelText(t, e, i, this.elementOptions.label);\n      this.fontOptions.minWdt > 0 && o.width < this.fontOptions.minWdt && (o.width = this.fontOptions.minWdt), this.size.labelHeight = o.height, this.fontOptions.minHgt > 0 && o.height < this.fontOptions.minHgt && (o.height = this.fontOptions.minHgt), this.lines = o.lines, this.lineCount = o.lines.length, this.size.width = o.width, this.size.height = o.height, this.selectedState = e, this.hoverState = i, this.labelDirty = !1;\n    }\n    visible() {\n      if (0 === this.size.width || 0 === this.size.height || void 0 === this.elementOptions.label) return !1;\n      return !(this.fontOptions.size * this.body.view.scale < this.elementOptions.scaling.label.drawThreshold - 1);\n    }\n  }\n  class H_ {\n    constructor(t, e, i) {\n      this.body = e, this.labelModule = i, this.setOptions(t), this.top = void 0, this.left = void 0, this.height = void 0, this.width = void 0, this.radius = void 0, this.margin = void 0, this.refreshNeeded = !0, this.boundingBox = {\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      };\n    }\n    setOptions(t) {\n      this.options = t;\n    }\n    _setMargins(t) {\n      this.margin = {}, this.options.margin && (\"object\" == typeof this.options.margin ? (this.margin.top = this.options.margin.top, this.margin.right = this.options.margin.right, this.margin.bottom = this.options.margin.bottom, this.margin.left = this.options.margin.left) : (this.margin.top = this.options.margin, this.margin.right = this.options.margin, this.margin.bottom = this.options.margin, this.margin.left = this.options.margin)), t.adjustSizes(this.margin);\n    }\n    _distanceToBorder(t, e) {\n      const i = this.options.borderWidth;\n      return t && this.resize(t), Math.min(Math.abs(this.width / 2 / Math.cos(e)), Math.abs(this.height / 2 / Math.sin(e))) + i;\n    }\n    enableShadow(t, e) {\n      e.shadow && (t.shadowColor = e.shadowColor, t.shadowBlur = e.shadowSize, t.shadowOffsetX = e.shadowX, t.shadowOffsetY = e.shadowY);\n    }\n    disableShadow(t, e) {\n      e.shadow && (t.shadowColor = \"rgba(0,0,0,0)\", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0);\n    }\n    enableBorderDashes(t, e) {\n      if (!1 !== e.borderDashes) if (void 0 !== t.setLineDash) {\n        let i = e.borderDashes;\n        !0 === i && (i = [5, 15]), t.setLineDash(i);\n      } else console.warn(\"setLineDash is not supported in this browser. The dashed borders cannot be used.\"), this.options.shapeProperties.borderDashes = !1, e.borderDashes = !1;\n    }\n    disableBorderDashes(t, e) {\n      !1 !== e.borderDashes && (void 0 !== t.setLineDash ? t.setLineDash([0]) : (console.warn(\"setLineDash is not supported in this browser. The dashed borders cannot be used.\"), this.options.shapeProperties.borderDashes = !1, e.borderDashes = !1));\n    }\n    needsRefresh(t, e) {\n      return !0 === this.refreshNeeded ? (this.refreshNeeded = !1, !0) : void 0 === this.width || this.labelModule.differentState(t, e);\n    }\n    initContextForDraw(t, e) {\n      const i = e.borderWidth / this.body.view.scale;\n      t.lineWidth = Math.min(this.width, i), t.strokeStyle = e.borderColor, t.fillStyle = e.color;\n    }\n    performStroke(t, e) {\n      const i = e.borderWidth / this.body.view.scale;\n      t.save(), i > 0 && (this.enableBorderDashes(t, e), t.stroke(), this.disableBorderDashes(t, e)), t.restore();\n    }\n    performFill(t, e) {\n      t.save(), t.fillStyle = e.color, this.enableShadow(t, e), cg(t).call(t), this.disableShadow(t, e), t.restore(), this.performStroke(t, e);\n    }\n    _addBoundingBoxMargin(t) {\n      this.boundingBox.left -= t, this.boundingBox.top -= t, this.boundingBox.bottom += t, this.boundingBox.right += t;\n    }\n    _updateBoundingBox(t, e, i, o, s) {\n      void 0 !== i && this.resize(i, o, s), this.left = t - this.width / 2, this.top = e - this.height / 2, this.boundingBox.left = this.left, this.boundingBox.top = this.top, this.boundingBox.bottom = this.top + this.height, this.boundingBox.right = this.left + this.width;\n    }\n    updateBoundingBox(t, e, i, o, s) {\n      this._updateBoundingBox(t, e, i, o, s);\n    }\n    getDimensionsFromLabel(t, e, i) {\n      this.textSize = this.labelModule.getTextSize(t, e, i);\n      let o = this.textSize.width,\n        s = this.textSize.height;\n      return 0 === o && (o = 14, s = 14), {\n        width: o,\n        height: s\n      };\n    }\n  }\n  let W_ = class extends H_ {\n    constructor(t, e, i) {\n      super(t, e, i), this._setMargins(i);\n    }\n    resize(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,\n        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;\n      if (this.needsRefresh(e, i)) {\n        const o = this.getDimensionsFromLabel(t, e, i);\n        this.width = o.width + this.margin.right + this.margin.left, this.height = o.height + this.margin.top + this.margin.bottom, this.radius = this.width / 2;\n      }\n    }\n    draw(t, e, i, o, s, n) {\n      this.resize(t, o, s), this.left = e - this.width / 2, this.top = i - this.height / 2, this.initContextForDraw(t, n), Vo(t, this.left, this.top, this.width, this.height, n.borderRadius), this.performFill(t, n), this.updateBoundingBox(e, i, t, o, s), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, o, s);\n    }\n    updateBoundingBox(t, e, i, o, s) {\n      this._updateBoundingBox(t, e, i, o, s);\n      const n = this.options.shapeProperties.borderRadius;\n      this._addBoundingBoxMargin(n);\n    }\n    distanceToBorder(t, e) {\n      t && this.resize(t);\n      const i = this.options.borderWidth;\n      return Math.min(Math.abs(this.width / 2 / Math.cos(e)), Math.abs(this.height / 2 / Math.sin(e))) + i;\n    }\n  };\n  class V_ extends H_ {\n    constructor(t, e, i) {\n      super(t, e, i), this.labelOffset = 0, this.selected = !1;\n    }\n    setOptions(t, e, i) {\n      this.options = t, void 0 === e && void 0 === i || this.setImages(e, i);\n    }\n    setImages(t, e) {\n      e && this.selected ? (this.imageObj = e, this.imageObjAlt = t) : (this.imageObj = t, this.imageObjAlt = e);\n    }\n    switchImages(t) {\n      const e = t && !this.selected || !t && this.selected;\n      if (this.selected = t, void 0 !== this.imageObjAlt && e) {\n        const t = this.imageObj;\n        this.imageObj = this.imageObjAlt, this.imageObjAlt = t;\n      }\n    }\n    _getImagePadding() {\n      const t = {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n      if (this.options.imagePadding) {\n        const e = this.options.imagePadding;\n        \"object\" == typeof e ? (t.top = e.top, t.right = e.right, t.bottom = e.bottom, t.left = e.left) : (t.top = e, t.right = e, t.bottom = e, t.left = e);\n      }\n      return t;\n    }\n    _resizeImage() {\n      let t, e;\n      if (!1 === this.options.shapeProperties.useImageSize) {\n        let i = 1,\n          o = 1;\n        this.imageObj.width && this.imageObj.height && (this.imageObj.width > this.imageObj.height ? i = this.imageObj.width / this.imageObj.height : o = this.imageObj.height / this.imageObj.width), t = 2 * this.options.size * i, e = 2 * this.options.size * o;\n      } else {\n        const i = this._getImagePadding();\n        t = this.imageObj.width + i.left + i.right, e = this.imageObj.height + i.top + i.bottom;\n      }\n      this.width = t, this.height = e, this.radius = .5 * this.width;\n    }\n    _drawRawCircle(t, e, i, o) {\n      this.initContextForDraw(t, o), Wo(t, e, i, o.size), this.performFill(t, o);\n    }\n    _drawImageAtPosition(t, e) {\n      if (0 != this.imageObj.width) {\n        t.globalAlpha = void 0 !== e.opacity ? e.opacity : 1, this.enableShadow(t, e);\n        let i = 1;\n        !0 === this.options.shapeProperties.interpolation && (i = this.imageObj.width / this.width / this.body.view.scale);\n        const o = this._getImagePadding(),\n          s = this.left + o.left,\n          n = this.top + o.top,\n          r = this.width - o.left - o.right,\n          a = this.height - o.top - o.bottom;\n        this.imageObj.drawImageAtPosition(t, i, s, n, r, a), this.disableShadow(t, e);\n      }\n    }\n    _drawImageLabel(t, e, i, o, s) {\n      let n = 0;\n      if (void 0 !== this.height) {\n        n = .5 * this.height;\n        const e = this.labelModule.getTextSize(t, o, s);\n        e.lineCount >= 1 && (n += e.height / 2);\n      }\n      const r = i + n;\n      this.options.label && (this.labelOffset = n), this.labelModule.draw(t, e, r, o, s, \"hanging\");\n    }\n  }\n  let q_ = class extends V_ {\n    constructor(t, e, i) {\n      super(t, e, i), this._setMargins(i);\n    }\n    resize(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,\n        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;\n      if (this.needsRefresh(e, i)) {\n        const o = this.getDimensionsFromLabel(t, e, i),\n          s = Math.max(o.width + this.margin.right + this.margin.left, o.height + this.margin.top + this.margin.bottom);\n        this.options.size = s / 2, this.width = s, this.height = s, this.radius = this.width / 2;\n      }\n    }\n    draw(t, e, i, o, s, n) {\n      this.resize(t, o, s), this.left = e - this.width / 2, this.top = i - this.height / 2, this._drawRawCircle(t, e, i, n), this.updateBoundingBox(e, i), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, i, o, s);\n    }\n    updateBoundingBox(t, e) {\n      this.boundingBox.top = e - this.options.size, this.boundingBox.left = t - this.options.size, this.boundingBox.right = t + this.options.size, this.boundingBox.bottom = e + this.options.size;\n    }\n    distanceToBorder(t) {\n      return t && this.resize(t), .5 * this.width;\n    }\n  };\n  class U_ extends V_ {\n    constructor(t, e, i, o, s) {\n      super(t, e, i), this.setImages(o, s);\n    }\n    resize(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,\n        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;\n      if (void 0 === this.imageObj.src || void 0 === this.imageObj.width || void 0 === this.imageObj.height) {\n        const t = 2 * this.options.size;\n        return this.width = t, this.height = t, void (this.radius = .5 * this.width);\n      }\n      this.needsRefresh(e, i) && this._resizeImage();\n    }\n    draw(t, e, i, o, s, n) {\n      this.switchImages(o), this.resize();\n      let r = e,\n        a = i;\n      \"top-left\" === this.options.shapeProperties.coordinateOrigin ? (this.left = e, this.top = i, r += this.width / 2, a += this.height / 2) : (this.left = e - this.width / 2, this.top = i - this.height / 2), this._drawRawCircle(t, r, a, n), t.save(), t.clip(), this._drawImageAtPosition(t, n), t.restore(), this._drawImageLabel(t, r, a, o, s), this.updateBoundingBox(e, i);\n    }\n    updateBoundingBox(t, e) {\n      \"top-left\" === this.options.shapeProperties.coordinateOrigin ? (this.boundingBox.top = e, this.boundingBox.left = t, this.boundingBox.right = t + 2 * this.options.size, this.boundingBox.bottom = e + 2 * this.options.size) : (this.boundingBox.top = e - this.options.size, this.boundingBox.left = t - this.options.size, this.boundingBox.right = t + this.options.size, this.boundingBox.bottom = e + this.options.size), this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);\n    }\n    distanceToBorder(t) {\n      return t && this.resize(t), .5 * this.width;\n    }\n  }\n  class Y_ extends H_ {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    resize(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,\n        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover,\n        o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {\n          size: this.options.size\n        };\n      if (this.needsRefresh(e, i)) {\n        var s, n;\n        this.labelModule.getTextSize(t, e, i);\n        const r = 2 * o.size;\n        this.width = null !== (s = this.customSizeWidth) && void 0 !== s ? s : r, this.height = null !== (n = this.customSizeHeight) && void 0 !== n ? n : r, this.radius = .5 * this.width;\n      }\n    }\n    _drawShape(t, e, i, o, s, n, r, a) {\n      var h;\n      return this.resize(t, n, r, a), this.left = o - this.width / 2, this.top = s - this.height / 2, this.initContextForDraw(t, a), (h = e, Object.prototype.hasOwnProperty.call(Xo, h) ? Xo[h] : function (t) {\n        for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), o = 1; o < e; o++) i[o - 1] = arguments[o];\n        CanvasRenderingContext2D.prototype[h].call(t, i);\n      })(t, o, s, a.size), this.performFill(t, a), void 0 !== this.options.icon && void 0 !== this.options.icon.code && (t.font = (n ? \"bold \" : \"\") + this.height / 2 + \"px \" + (this.options.icon.face || \"FontAwesome\"), t.fillStyle = this.options.icon.color || \"black\", t.textAlign = \"center\", t.textBaseline = \"middle\", t.fillText(this.options.icon.code, o, s)), {\n        drawExternalLabel: () => {\n          if (void 0 !== this.options.label) {\n            this.labelModule.calculateLabelSize(t, n, r, o, s, \"hanging\");\n            const e = s + .5 * this.height + .5 * this.labelModule.size.height;\n            this.labelModule.draw(t, o, e, n, r, \"hanging\");\n          }\n          this.updateBoundingBox(o, s);\n        }\n      };\n    }\n    updateBoundingBox(t, e) {\n      this.boundingBox.top = e - this.options.size, this.boundingBox.left = t - this.options.size, this.boundingBox.right = t + this.options.size, this.boundingBox.bottom = e + this.options.size, void 0 !== this.options.label && this.labelModule.size.width > 0 && (this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height));\n    }\n  }\n  function X_(t, e) {\n    var i = Jl(t);\n    if (Jw) {\n      var o = Jw(t);\n      e && (o = Ru(o).call(o, function (e) {\n        return h_(t, e).enumerable;\n      })), i.push.apply(i, o);\n    }\n    return i;\n  }\n  function K_(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i,\n        o,\n        s = null != arguments[e] ? arguments[e] : {};\n      e % 2 ? mc(i = X_(Object(s), !0)).call(i, function (e) {\n        zw(t, e, s[e]);\n      }) : p_ ? w_(t, p_(s)) : mc(o = X_(Object(s))).call(o, function (e) {\n        __(t, e, h_(s, e));\n      });\n    }\n    return t;\n  }\n  class G_ extends Y_ {\n    constructor(t, e, i, o) {\n      super(t, e, i, o), this.ctxRenderer = o;\n    }\n    draw(t, e, i, o, s, n) {\n      this.resize(t, o, s, n), this.left = e - this.width / 2, this.top = i - this.height / 2, t.save();\n      const r = this.ctxRenderer({\n        ctx: t,\n        id: this.options.id,\n        x: e,\n        y: i,\n        state: {\n          selected: o,\n          hover: s\n        },\n        style: K_({}, n),\n        label: this.options.label\n      });\n      if (null != r.drawNode && r.drawNode(), t.restore(), r.drawExternalLabel) {\n        const e = r.drawExternalLabel;\n        r.drawExternalLabel = () => {\n          t.save(), e(), t.restore();\n        };\n      }\n      return r.nodeDimensions && (this.customSizeWidth = r.nodeDimensions.width, this.customSizeHeight = r.nodeDimensions.height), r;\n    }\n    distanceToBorder(t, e) {\n      return this._distanceToBorder(t, e);\n    }\n  }\n  class Z_ extends H_ {\n    constructor(t, e, i) {\n      super(t, e, i), this._setMargins(i);\n    }\n    resize(t, e, i) {\n      if (this.needsRefresh(e, i)) {\n        const o = this.getDimensionsFromLabel(t, e, i).width + this.margin.right + this.margin.left;\n        this.width = o, this.height = o, this.radius = this.width / 2;\n      }\n    }\n    draw(t, e, i, o, s, n) {\n      this.resize(t, o, s), this.left = e - this.width / 2, this.top = i - this.height / 2, this.initContextForDraw(t, n), Uo(t, e - this.width / 2, i - this.height / 2, this.width, this.height), this.performFill(t, n), this.updateBoundingBox(e, i, t, o, s), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, o, s);\n    }\n    distanceToBorder(t, e) {\n      return this._distanceToBorder(t, e);\n    }\n  }\n  let Q_ = class extends Y_ {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    draw(t, e, i, o, s, n) {\n      return this._drawShape(t, \"diamond\", 4, e, i, o, s, n);\n    }\n    distanceToBorder(t, e) {\n      return this._distanceToBorder(t, e);\n    }\n  };\n  class $_ extends Y_ {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    draw(t, e, i, o, s, n) {\n      return this._drawShape(t, \"circle\", 2, e, i, o, s, n);\n    }\n    distanceToBorder(t) {\n      return t && this.resize(t), this.options.size;\n    }\n  }\n  class J_ extends H_ {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    resize(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,\n        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;\n      if (this.needsRefresh(e, i)) {\n        const o = this.getDimensionsFromLabel(t, e, i);\n        this.height = 2 * o.height, this.width = o.width + o.height, this.radius = .5 * this.width;\n      }\n    }\n    draw(t, e, i, o, s, n) {\n      this.resize(t, o, s), this.left = e - .5 * this.width, this.top = i - .5 * this.height, this.initContextForDraw(t, n), qo(t, this.left, this.top, this.width, this.height), this.performFill(t, n), this.updateBoundingBox(e, i, t, o, s), this.labelModule.draw(t, e, i, o, s);\n    }\n    distanceToBorder(t, e) {\n      t && this.resize(t);\n      const i = .5 * this.width,\n        o = .5 * this.height,\n        s = Math.sin(e) * i,\n        n = Math.cos(e) * o;\n      return i * o / Math.sqrt(s * s + n * n);\n    }\n  }\n  class tx extends H_ {\n    constructor(t, e, i) {\n      super(t, e, i), this._setMargins(i);\n    }\n    resize(t, e, i) {\n      this.needsRefresh(e, i) && (this.iconSize = {\n        width: Number(this.options.icon.size),\n        height: Number(this.options.icon.size)\n      }, this.width = this.iconSize.width + this.margin.right + this.margin.left, this.height = this.iconSize.height + this.margin.top + this.margin.bottom, this.radius = .5 * this.width);\n    }\n    draw(t, e, i, o, s, n) {\n      return this.resize(t, o, s), this.options.icon.size = this.options.icon.size || 50, this.left = e - this.width / 2, this.top = i - this.height / 2, this._icon(t, e, i, o, s, n), {\n        drawExternalLabel: () => {\n          if (void 0 !== this.options.label) {\n            const e = 5;\n            this.labelModule.draw(t, this.left + this.iconSize.width / 2 + this.margin.left, i + this.height / 2 + e, o);\n          }\n          this.updateBoundingBox(e, i);\n        }\n      };\n    }\n    updateBoundingBox(t, e) {\n      if (this.boundingBox.top = e - .5 * this.options.icon.size, this.boundingBox.left = t - .5 * this.options.icon.size, this.boundingBox.right = t + .5 * this.options.icon.size, this.boundingBox.bottom = e + .5 * this.options.icon.size, void 0 !== this.options.label && this.labelModule.size.width > 0) {\n        const t = 5;\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + t);\n      }\n    }\n    _icon(t, e, i, o, s, n) {\n      const r = Number(this.options.icon.size);\n      void 0 !== this.options.icon.code ? (t.font = [null != this.options.icon.weight ? this.options.icon.weight : o ? \"bold\" : \"\", (null != this.options.icon.weight && o ? 5 : 0) + r + \"px\", this.options.icon.face].join(\" \"), t.fillStyle = this.options.icon.color || \"black\", t.textAlign = \"center\", t.textBaseline = \"middle\", this.enableShadow(t, n), t.fillText(this.options.icon.code, e, i), this.disableShadow(t, n)) : console.error(\"When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.\");\n    }\n    distanceToBorder(t, e) {\n      return this._distanceToBorder(t, e);\n    }\n  }\n  let ex = class extends V_ {\n    constructor(t, e, i, o, s) {\n      super(t, e, i), this.setImages(o, s);\n    }\n    resize(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,\n        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;\n      if (void 0 === this.imageObj.src || void 0 === this.imageObj.width || void 0 === this.imageObj.height) {\n        const t = 2 * this.options.size;\n        return this.width = t, void (this.height = t);\n      }\n      this.needsRefresh(e, i) && this._resizeImage();\n    }\n    draw(t, e, i, o, s, n) {\n      t.save(), this.switchImages(o), this.resize();\n      let r = e,\n        a = i;\n      if (\"top-left\" === this.options.shapeProperties.coordinateOrigin ? (this.left = e, this.top = i, r += this.width / 2, a += this.height / 2) : (this.left = e - this.width / 2, this.top = i - this.height / 2), !0 === this.options.shapeProperties.useBorderWithImage) {\n        const e = this.options.borderWidth,\n          i = this.options.borderWidthSelected || 2 * this.options.borderWidth,\n          r = (o ? i : e) / this.body.view.scale;\n        t.lineWidth = Math.min(this.width, r), t.beginPath();\n        let a = o ? this.options.color.highlight.border : s ? this.options.color.hover.border : this.options.color.border,\n          h = o ? this.options.color.highlight.background : s ? this.options.color.hover.background : this.options.color.background;\n        void 0 !== n.opacity && (a = Sm(a, n.opacity), h = Sm(h, n.opacity)), t.strokeStyle = a, t.fillStyle = h, t.rect(this.left - .5 * t.lineWidth, this.top - .5 * t.lineWidth, this.width + t.lineWidth, this.height + t.lineWidth), cg(t).call(t), this.performStroke(t, n), t.closePath();\n      }\n      this._drawImageAtPosition(t, n), this._drawImageLabel(t, r, a, o, s), this.updateBoundingBox(e, i), t.restore();\n    }\n    updateBoundingBox(t, e) {\n      this.resize(), \"top-left\" === this.options.shapeProperties.coordinateOrigin ? (this.left = t, this.top = e) : (this.left = t - this.width / 2, this.top = e - this.height / 2), this.boundingBox.left = this.left, this.boundingBox.top = this.top, this.boundingBox.bottom = this.top + this.height, this.boundingBox.right = this.left + this.width, void 0 !== this.options.label && this.labelModule.size.width > 0 && (this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset));\n    }\n    distanceToBorder(t, e) {\n      return this._distanceToBorder(t, e);\n    }\n  };\n  class ix extends Y_ {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    draw(t, e, i, o, s, n) {\n      return this._drawShape(t, \"square\", 2, e, i, o, s, n);\n    }\n    distanceToBorder(t, e) {\n      return this._distanceToBorder(t, e);\n    }\n  }\n  class ox extends Y_ {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    draw(t, e, i, o, s, n) {\n      return this._drawShape(t, \"hexagon\", 4, e, i, o, s, n);\n    }\n    distanceToBorder(t, e) {\n      return this._distanceToBorder(t, e);\n    }\n  }\n  class sx extends Y_ {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    draw(t, e, i, o, s, n) {\n      return this._drawShape(t, \"star\", 4, e, i, o, s, n);\n    }\n    distanceToBorder(t, e) {\n      return this._distanceToBorder(t, e);\n    }\n  }\n  class nx extends H_ {\n    constructor(t, e, i) {\n      super(t, e, i), this._setMargins(i);\n    }\n    resize(t, e, i) {\n      this.needsRefresh(e, i) && (this.textSize = this.labelModule.getTextSize(t, e, i), this.width = this.textSize.width + this.margin.right + this.margin.left, this.height = this.textSize.height + this.margin.top + this.margin.bottom, this.radius = .5 * this.width);\n    }\n    draw(t, e, i, o, s, n) {\n      this.resize(t, o, s), this.left = e - this.width / 2, this.top = i - this.height / 2, this.enableShadow(t, n), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, o, s), this.disableShadow(t, n), this.updateBoundingBox(e, i, t, o, s);\n    }\n    distanceToBorder(t, e) {\n      return this._distanceToBorder(t, e);\n    }\n  }\n  let rx = class extends Y_ {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    draw(t, e, i, o, s, n) {\n      return this._drawShape(t, \"triangle\", 3, e, i, o, s, n);\n    }\n    distanceToBorder(t, e) {\n      return this._distanceToBorder(t, e);\n    }\n  };\n  class ax extends Y_ {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    draw(t, e, i, o, s, n) {\n      return this._drawShape(t, \"triangleDown\", 3, e, i, o, s, n);\n    }\n    distanceToBorder(t, e) {\n      return this._distanceToBorder(t, e);\n    }\n  }\n  function hx(t, e) {\n    var i = Jl(t);\n    if (Jw) {\n      var o = Jw(t);\n      e && (o = Ru(o).call(o, function (e) {\n        return h_(t, e).enumerable;\n      })), i.push.apply(i, o);\n    }\n    return i;\n  }\n  function dx(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i,\n        o,\n        s = null != arguments[e] ? arguments[e] : {};\n      e % 2 ? mc(i = hx(Object(s), !0)).call(i, function (e) {\n        zw(t, e, s[e]);\n      }) : p_ ? w_(t, p_(s)) : mc(o = hx(Object(s))).call(o, function (e) {\n        __(t, e, h_(s, e));\n      });\n    }\n    return t;\n  }\n  class lx {\n    constructor(t, e, i, o, s, n) {\n      this.options = zm(s), this.globalOptions = s, this.defaultOptions = n, this.body = e, this.edges = [], this.id = void 0, this.imagelist = i, this.grouplist = o, this.x = void 0, this.y = void 0, this.baseSize = this.options.size, this.baseFontSize = this.options.font.size, this.predefinedPosition = !1, this.selected = !1, this.hover = !1, this.labelModule = new L_(this.body, this.options, !1), this.setOptions(t);\n    }\n    attachEdge(t) {\n      var e;\n      -1 === Mp(e = this.edges).call(e, t) && this.edges.push(t);\n    }\n    detachEdge(t) {\n      var e;\n      const i = Mp(e = this.edges).call(e, t);\n      var o;\n      -1 != i && Jc(o = this.edges).call(o, i, 1);\n    }\n    setOptions(t) {\n      const e = this.options.shape;\n      if (!t) return;\n      if (void 0 !== t.color && (this._localColor = t.color), void 0 !== t.id && (this.id = t.id), void 0 === this.id) throw new Error(\"Node must have an id\");\n      lx.checkMass(t, this.id), void 0 !== t.x && (null === t.x ? (this.x = void 0, this.predefinedPosition = !1) : (this.x = bp(t.x), this.predefinedPosition = !0)), void 0 !== t.y && (null === t.y ? (this.y = void 0, this.predefinedPosition = !1) : (this.y = bp(t.y), this.predefinedPosition = !0)), void 0 !== t.size && (this.baseSize = t.size), void 0 !== t.value && (t.value = Yw(t.value)), lx.parseOptions(this.options, t, !0, this.globalOptions, this.grouplist);\n      const i = [t, this.options, this.defaultOptions];\n      return this.chooser = x_(\"node\", i), this._load_images(), this.updateLabelModule(t), void 0 !== t.opacity && lx.checkOpacity(t.opacity) && (this.options.opacity = t.opacity), this.updateShape(e), void 0 !== t.hidden || void 0 !== t.physics;\n    }\n    _load_images() {\n      if ((\"circularImage\" === this.options.shape || \"image\" === this.options.shape) && void 0 === this.options.image) throw new Error(\"Option image must be defined for node type '\" + this.options.shape + \"'\");\n      if (void 0 !== this.options.image) {\n        if (void 0 === this.imagelist) throw new Error(\"Internal Error: No images provided\");\n        if (\"string\" == typeof this.options.image) this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);else {\n          if (void 0 === this.options.image.unselected) throw new Error(\"No unselected image provided\");\n          this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id), void 0 !== this.options.image.selected ? this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id) : this.imageObjAlt = void 0;\n        }\n      }\n    }\n    static checkOpacity(t) {\n      return 0 <= t && t <= 1;\n    }\n    static checkCoordinateOrigin(t) {\n      return void 0 === t || \"center\" === t || \"top-left\" === t;\n    }\n    static updateGroupOptions(t, e, i) {\n      var o;\n      if (void 0 === i) return;\n      const s = t.group;\n      if (void 0 !== e && void 0 !== e.group && s !== e.group) throw new Error(\"updateGroupOptions: group values in options don't match.\");\n      if (!(\"number\" == typeof s || \"string\" == typeof s && \"\" != s)) return;\n      const n = i.get(s);\n      void 0 !== n.opacity && void 0 === e.opacity && (lx.checkOpacity(n.opacity) || (console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + n.opacity), n.opacity = void 0));\n      const r = Ru(o = $w(e)).call(o, t => null != e[t]);\n      r.push(\"font\"), _m(r, t, n), t.color = Mm(t.color);\n    }\n    static parseOptions(t, e) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n        o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},\n        s = arguments.length > 4 ? arguments[4] : void 0;\n      if (_m([\"color\", \"fixed\", \"shadow\"], t, e, i), lx.checkMass(e), void 0 !== t.opacity && (lx.checkOpacity(t.opacity) || (console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + t.opacity), t.opacity = void 0)), void 0 !== e.opacity && (lx.checkOpacity(e.opacity) || (console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + e.opacity), e.opacity = void 0)), e.shapeProperties && !lx.checkCoordinateOrigin(e.shapeProperties.coordinateOrigin) && console.error(\"Invalid option for node coordinateOrigin, found: \" + e.shapeProperties.coordinateOrigin), Nm(t, e, \"shadow\", o), void 0 !== e.color && null !== e.color) {\n        const i = Mm(e.color);\n        vm(t.color, i);\n      } else !0 === i && null === e.color && (t.color = zm(o.color));\n      void 0 !== e.fixed && null !== e.fixed && (\"boolean\" == typeof e.fixed ? (t.fixed.x = e.fixed, t.fixed.y = e.fixed) : (void 0 !== e.fixed.x && \"boolean\" == typeof e.fixed.x && (t.fixed.x = e.fixed.x), void 0 !== e.fixed.y && \"boolean\" == typeof e.fixed.y && (t.fixed.y = e.fixed.y))), !0 === i && null === e.font && (t.font = zm(o.font)), lx.updateGroupOptions(t, e, s), void 0 !== e.scaling && Nm(t.scaling, e.scaling, \"label\", o.scaling);\n    }\n    getFormattingValues() {\n      const t = {\n        color: this.options.color.background,\n        opacity: this.options.opacity,\n        borderWidth: this.options.borderWidth,\n        borderColor: this.options.color.border,\n        size: this.options.size,\n        borderDashes: this.options.shapeProperties.borderDashes,\n        borderRadius: this.options.shapeProperties.borderRadius,\n        shadow: this.options.shadow.enabled,\n        shadowColor: this.options.shadow.color,\n        shadowSize: this.options.shadow.size,\n        shadowX: this.options.shadow.x,\n        shadowY: this.options.shadow.y\n      };\n      if (this.selected || this.hover ? !0 === this.chooser ? this.selected ? (null != this.options.borderWidthSelected ? t.borderWidth = this.options.borderWidthSelected : t.borderWidth *= 2, t.color = this.options.color.highlight.background, t.borderColor = this.options.color.highlight.border, t.shadow = this.options.shadow.enabled) : this.hover && (t.color = this.options.color.hover.background, t.borderColor = this.options.color.hover.border, t.shadow = this.options.shadow.enabled) : \"function\" == typeof this.chooser && (this.chooser(t, this.options.id, this.selected, this.hover), !1 === t.shadow && (t.shadowColor === this.options.shadow.color && t.shadowSize === this.options.shadow.size && t.shadowX === this.options.shadow.x && t.shadowY === this.options.shadow.y || (t.shadow = !0))) : t.shadow = this.options.shadow.enabled, void 0 !== this.options.opacity) {\n        const e = this.options.opacity;\n        t.borderColor = Sm(t.borderColor, e), t.color = Sm(t.color, e), t.shadowColor = Sm(t.shadowColor, e);\n      }\n      return t;\n    }\n    updateLabelModule(t) {\n      void 0 !== this.options.label && null !== this.options.label || (this.options.label = \"\"), lx.updateGroupOptions(this.options, dx(dx({}, t), {}, {\n        color: t && t.color || this._localColor || void 0\n      }), this.grouplist);\n      const e = this.grouplist.get(this.options.group, !1),\n        i = [t, this.options, e, this.globalOptions, this.defaultOptions];\n      this.labelModule.update(this.options, i), void 0 !== this.labelModule.baseSize && (this.baseFontSize = this.labelModule.baseSize);\n    }\n    updateShape(t) {\n      if (t === this.options.shape && this.shape) this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);else switch (this.options.shape) {\n        case \"box\":\n          this.shape = new W_(this.options, this.body, this.labelModule);\n          break;\n        case \"circle\":\n          this.shape = new q_(this.options, this.body, this.labelModule);\n          break;\n        case \"circularImage\":\n          this.shape = new U_(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n          break;\n        case \"custom\":\n          this.shape = new G_(this.options, this.body, this.labelModule, this.options.ctxRenderer);\n          break;\n        case \"database\":\n          this.shape = new Z_(this.options, this.body, this.labelModule);\n          break;\n        case \"diamond\":\n          this.shape = new Q_(this.options, this.body, this.labelModule);\n          break;\n        case \"dot\":\n          this.shape = new $_(this.options, this.body, this.labelModule);\n          break;\n        case \"ellipse\":\n        default:\n          this.shape = new J_(this.options, this.body, this.labelModule);\n          break;\n        case \"icon\":\n          this.shape = new tx(this.options, this.body, this.labelModule);\n          break;\n        case \"image\":\n          this.shape = new ex(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n          break;\n        case \"square\":\n          this.shape = new ix(this.options, this.body, this.labelModule);\n          break;\n        case \"hexagon\":\n          this.shape = new ox(this.options, this.body, this.labelModule);\n          break;\n        case \"star\":\n          this.shape = new sx(this.options, this.body, this.labelModule);\n          break;\n        case \"text\":\n          this.shape = new nx(this.options, this.body, this.labelModule);\n          break;\n        case \"triangle\":\n          this.shape = new rx(this.options, this.body, this.labelModule);\n          break;\n        case \"triangleDown\":\n          this.shape = new ax(this.options, this.body, this.labelModule);\n      }\n      this.needsRefresh();\n    }\n    select() {\n      this.selected = !0, this.needsRefresh();\n    }\n    unselect() {\n      this.selected = !1, this.needsRefresh();\n    }\n    needsRefresh() {\n      this.shape.refreshNeeded = !0;\n    }\n    getTitle() {\n      return this.options.title;\n    }\n    distanceToBorder(t, e) {\n      return this.shape.distanceToBorder(t, e);\n    }\n    isFixed() {\n      return this.options.fixed.x && this.options.fixed.y;\n    }\n    isSelected() {\n      return this.selected;\n    }\n    getValue() {\n      return this.options.value;\n    }\n    getLabelSize() {\n      return this.labelModule.size();\n    }\n    setValueRange(t, e, i) {\n      if (void 0 !== this.options.value) {\n        const o = this.options.scaling.customScalingFunction(t, e, i, this.options.value),\n          s = this.options.scaling.max - this.options.scaling.min;\n        if (!0 === this.options.scaling.label.enabled) {\n          const t = this.options.scaling.label.max - this.options.scaling.label.min;\n          this.options.font.size = this.options.scaling.label.min + o * t;\n        }\n        this.options.size = this.options.scaling.min + o * s;\n      } else this.options.size = this.baseSize, this.options.font.size = this.baseFontSize;\n      this.updateLabelModule();\n    }\n    draw(t) {\n      const e = this.getFormattingValues();\n      return this.shape.draw(t, this.x, this.y, this.selected, this.hover, e) || {};\n    }\n    updateBoundingBox(t) {\n      this.shape.updateBoundingBox(this.x, this.y, t);\n    }\n    resize(t) {\n      const e = this.getFormattingValues();\n      this.shape.resize(t, this.selected, this.hover, e);\n    }\n    getItemsOnPoint(t) {\n      const e = [];\n      return this.labelModule.visible() && E_(this.labelModule.getSize(), t) && e.push({\n        nodeId: this.id,\n        labelId: 0\n      }), E_(this.shape.boundingBox, t) && e.push({\n        nodeId: this.id\n      }), e;\n    }\n    isOverlappingWith(t) {\n      return this.shape.left < t.right && this.shape.left + this.shape.width > t.left && this.shape.top < t.bottom && this.shape.top + this.shape.height > t.top;\n    }\n    isBoundingBoxOverlappingWith(t) {\n      return this.shape.boundingBox.left < t.right && this.shape.boundingBox.right > t.left && this.shape.boundingBox.top < t.bottom && this.shape.boundingBox.bottom > t.top;\n    }\n    static checkMass(t, e) {\n      if (void 0 !== t.mass && t.mass <= 0) {\n        let i = \"\";\n        void 0 !== e && (i = \" in node id: \" + e), console.error(\"%cNegative or zero mass disallowed\" + i + \", setting mass to 1.\", Gm), t.mass = 1;\n      }\n    }\n  }\n  class cx {\n    constructor(t, e, i, o) {\n      var s;\n      if (this.body = t, this.images = e, this.groups = i, this.layoutEngine = o, this.body.functions.createNode = Ho(s = this.create).call(s, this), this.nodesListeners = {\n        add: (t, e) => {\n          this.add(e.items);\n        },\n        update: (t, e) => {\n          this.update(e.items, e.data, e.oldData);\n        },\n        remove: (t, e) => {\n          this.remove(e.items);\n        }\n      }, this.defaultOptions = {\n        borderWidth: 1,\n        borderWidthSelected: void 0,\n        brokenImage: void 0,\n        color: {\n          border: \"#2B7CE9\",\n          background: \"#97C2FC\",\n          highlight: {\n            border: \"#2B7CE9\",\n            background: \"#D2E5FF\"\n          },\n          hover: {\n            border: \"#2B7CE9\",\n            background: \"#D2E5FF\"\n          }\n        },\n        opacity: void 0,\n        fixed: {\n          x: !1,\n          y: !1\n        },\n        font: {\n          color: \"#343434\",\n          size: 14,\n          face: \"arial\",\n          background: \"none\",\n          strokeWidth: 0,\n          strokeColor: \"#ffffff\",\n          align: \"center\",\n          vadjust: 0,\n          multi: !1,\n          bold: {\n            mod: \"bold\"\n          },\n          boldital: {\n            mod: \"bold italic\"\n          },\n          ital: {\n            mod: \"italic\"\n          },\n          mono: {\n            mod: \"\",\n            size: 15,\n            face: \"monospace\",\n            vadjust: 2\n          }\n        },\n        group: void 0,\n        hidden: !1,\n        icon: {\n          face: \"FontAwesome\",\n          code: void 0,\n          size: 50,\n          color: \"#2B7CE9\"\n        },\n        image: void 0,\n        imagePadding: {\n          top: 0,\n          right: 0,\n          bottom: 0,\n          left: 0\n        },\n        label: void 0,\n        labelHighlightBold: !0,\n        level: void 0,\n        margin: {\n          top: 5,\n          right: 5,\n          bottom: 5,\n          left: 5\n        },\n        mass: 1,\n        physics: !0,\n        scaling: {\n          min: 10,\n          max: 30,\n          label: {\n            enabled: !1,\n            min: 14,\n            max: 30,\n            maxVisible: 30,\n            drawThreshold: 5\n          },\n          customScalingFunction: function (t, e, i, o) {\n            if (e === t) return .5;\n            {\n              const i = 1 / (e - t);\n              return Math.max(0, (o - t) * i);\n            }\n          }\n        },\n        shadow: {\n          enabled: !1,\n          color: \"rgba(0,0,0,0.5)\",\n          size: 10,\n          x: 5,\n          y: 5\n        },\n        shape: \"ellipse\",\n        shapeProperties: {\n          borderDashes: !1,\n          borderRadius: 6,\n          interpolation: !0,\n          useImageSize: !1,\n          useBorderWithImage: !1,\n          coordinateOrigin: \"center\"\n        },\n        size: 25,\n        title: void 0,\n        value: void 0,\n        x: void 0,\n        y: void 0\n      }, this.defaultOptions.mass <= 0) throw \"Internal error: mass in defaultOptions of NodesHandler may not be zero or negative\";\n      this.options = zm(this.defaultOptions), this.bindEventListeners();\n    }\n    bindEventListeners() {\n      var t, e;\n      this.body.emitter.on(\"refreshNodes\", Ho(t = this.refresh).call(t, this)), this.body.emitter.on(\"refresh\", Ho(e = this.refresh).call(e, this)), this.body.emitter.on(\"destroy\", () => {\n        Cm(this.nodesListeners, (t, e) => {\n          this.body.data.nodes && this.body.data.nodes.off(e, t);\n        }), delete this.body.functions.createNode, delete this.nodesListeners.add, delete this.nodesListeners.update, delete this.nodesListeners.remove, delete this.nodesListeners;\n      });\n    }\n    setOptions(t) {\n      if (void 0 !== t) {\n        if (lx.parseOptions(this.options, t), void 0 !== t.opacity && (Lv(t.opacity) || !Vv(t.opacity) || t.opacity < 0 || t.opacity > 1 ? console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + t.opacity) : this.options.opacity = t.opacity), void 0 !== t.shape) for (const t in this.body.nodes) Object.prototype.hasOwnProperty.call(this.body.nodes, t) && this.body.nodes[t].updateShape();\n        if (void 0 !== t.font || void 0 !== t.widthConstraint || void 0 !== t.heightConstraint) for (const t of Jl(this.body.nodes)) this.body.nodes[t].updateLabelModule(), this.body.nodes[t].needsRefresh();\n        if (void 0 !== t.size) for (const t in this.body.nodes) Object.prototype.hasOwnProperty.call(this.body.nodes, t) && this.body.nodes[t].needsRefresh();\n        void 0 === t.hidden && void 0 === t.physics || this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n    setData(t) {\n      let i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      const o = this.body.data.nodes;\n      if (e.isDataViewLike(\"id\", t)) this.body.data.nodes = t;else if (Vl(t)) this.body.data.nodes = new e.DataSet(), this.body.data.nodes.add(t);else {\n        if (t) throw new TypeError(\"Array or DataSet expected\");\n        this.body.data.nodes = new e.DataSet();\n      }\n      if (o && Cm(this.nodesListeners, function (t, e) {\n        o.off(e, t);\n      }), this.body.nodes = {}, this.body.data.nodes) {\n        const t = this;\n        Cm(this.nodesListeners, function (e, i) {\n          t.body.data.nodes.on(i, e);\n        });\n        const e = this.body.data.nodes.getIds();\n        this.add(e, !0);\n      }\n      !1 === i && this.body.emitter.emit(\"_dataChanged\");\n    }\n    add(t) {\n      let e,\n        i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      const o = [];\n      for (let i = 0; i < t.length; i++) {\n        e = t[i];\n        const s = this.body.data.nodes.get(e),\n          n = this.create(s);\n        o.push(n), this.body.nodes[e] = n;\n      }\n      this.layoutEngine.positionInitially(o), !1 === i && this.body.emitter.emit(\"_dataChanged\");\n    }\n    update(t, e, i) {\n      const o = this.body.nodes;\n      let s = !1;\n      for (let i = 0; i < t.length; i++) {\n        const n = t[i];\n        let r = o[n];\n        const a = e[i];\n        void 0 !== r ? r.setOptions(a) && (s = !0) : (s = !0, r = this.create(a), o[n] = r);\n      }\n      s || void 0 === i || (s = Zv(e).call(e, function (t, e) {\n        const o = i[e];\n        return o && o.level !== t.level;\n      })), !0 === s ? this.body.emitter.emit(\"_dataChanged\") : this.body.emitter.emit(\"_dataUpdated\");\n    }\n    remove(t) {\n      const e = this.body.nodes;\n      for (let i = 0; i < t.length; i++) {\n        delete e[t[i]];\n      }\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n    create(t) {\n      return new (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : lx)(t, this.body, this.images, this.groups, this.options, this.defaultOptions);\n    }\n    refresh() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      Cm(this.body.nodes, (e, i) => {\n        const o = this.body.data.nodes.get(i);\n        void 0 !== o && (!0 === t && e.setOptions({\n          x: null,\n          y: null\n        }), e.setOptions({\n          fixed: !1\n        }), e.setOptions(o));\n      });\n    }\n    getPositions(t) {\n      const e = {};\n      if (void 0 !== t) {\n        if (!0 === Vl(t)) {\n          for (let i = 0; i < t.length; i++) if (void 0 !== this.body.nodes[t[i]]) {\n            const o = this.body.nodes[t[i]];\n            e[t[i]] = {\n              x: Math.round(o.x),\n              y: Math.round(o.y)\n            };\n          }\n        } else if (void 0 !== this.body.nodes[t]) {\n          const i = this.body.nodes[t];\n          e[t] = {\n            x: Math.round(i.x),\n            y: Math.round(i.y)\n          };\n        }\n      } else for (let t = 0; t < this.body.nodeIndices.length; t++) {\n        const i = this.body.nodes[this.body.nodeIndices[t]];\n        e[this.body.nodeIndices[t]] = {\n          x: Math.round(i.x),\n          y: Math.round(i.y)\n        };\n      }\n      return e;\n    }\n    getPosition(t) {\n      if (null == t) throw new TypeError(\"No id was specified for getPosition method.\");\n      if (null == this.body.nodes[t]) throw new ReferenceError(\"NodeId provided for getPosition does not exist. Provided: \".concat(t));\n      return {\n        x: Math.round(this.body.nodes[t].x),\n        y: Math.round(this.body.nodes[t].y)\n      };\n    }\n    storePositions() {\n      const t = [],\n        e = this.body.data.nodes.getDataSet();\n      for (const i of e.get()) {\n        const e = i.id,\n          o = this.body.nodes[e],\n          s = Math.round(o.x),\n          n = Math.round(o.y);\n        i.x === s && i.y === n || t.push({\n          id: e,\n          x: s,\n          y: n\n        });\n      }\n      e.update(t);\n    }\n    getBoundingBox(t) {\n      if (void 0 !== this.body.nodes[t]) return this.body.nodes[t].shape.boundingBox;\n    }\n    getConnectedNodes(t, e) {\n      const i = [];\n      if (void 0 !== this.body.nodes[t]) {\n        const o = this.body.nodes[t],\n          s = {};\n        for (let t = 0; t < o.edges.length; t++) {\n          const n = o.edges[t];\n          \"to\" !== e && n.toId == o.id ? void 0 === s[n.fromId] && (i.push(n.fromId), s[n.fromId] = !0) : \"from\" !== e && n.fromId == o.id && void 0 === s[n.toId] && (i.push(n.toId), s[n.toId] = !0);\n        }\n      }\n      return i;\n    }\n    getConnectedEdges(t) {\n      const e = [];\n      if (void 0 !== this.body.nodes[t]) {\n        const i = this.body.nodes[t];\n        for (let t = 0; t < i.edges.length; t++) e.push(i.edges[t].id);\n      } else console.error(\"NodeId provided for getConnectedEdges does not exist. Provided: \", t);\n      return e;\n    }\n    moveNode(t, e, i) {\n      void 0 !== this.body.nodes[t] ? (this.body.nodes[t].x = Number(e), this.body.nodes[t].y = Number(i), tg(() => {\n        this.body.emitter.emit(\"startSimulation\");\n      }, 0)) : console.error(\"Node id supplied to moveNode does not exist. Provided: \", t);\n    }\n  }\n  var ux = Mi,\n    px = Math.hypot,\n    gx = Math.abs,\n    fx = Math.sqrt;\n  ux({\n    target: \"Math\",\n    stat: !0,\n    arity: 2,\n    forced: !!px && px(1 / 0, NaN) !== 1 / 0\n  }, {\n    hypot: function (t, e) {\n      for (var i, o, s = 0, n = 0, r = arguments.length, a = 0; n < r;) a < (i = gx(arguments[n++])) ? (s = s * (o = a / i) * o + 1, a = i) : s += i > 0 ? (o = i / a) * o : i;\n      return a === 1 / 0 ? 1 / 0 : a * fx(s);\n    }\n  });\n  var mx = o(it.Math.hypot);\n  class yx {\n    static transform(t, e) {\n      Vl(t) || (t = [t]);\n      const i = e.point.x,\n        o = e.point.y,\n        s = e.angle,\n        n = e.length;\n      for (let e = 0; e < t.length; ++e) {\n        const r = t[e],\n          a = r.x * Math.cos(s) - r.y * Math.sin(s),\n          h = r.x * Math.sin(s) + r.y * Math.cos(s);\n        r.x = i + n * a, r.y = o + n * h;\n      }\n    }\n    static drawPath(t, e) {\n      t.beginPath(), t.moveTo(e[0].x, e[0].y);\n      for (let i = 1; i < e.length; ++i) t.lineTo(e[i].x, e[i].y);\n      t.closePath();\n    }\n  }\n  let bx,\n    vx = class extends yx {\n      static draw(t, e) {\n        if (e.image) {\n          t.save(), t.translate(e.point.x, e.point.y), t.rotate(Math.PI / 2 + e.angle);\n          const i = null != e.imageWidth ? e.imageWidth : e.image.width,\n            o = null != e.imageHeight ? e.imageHeight : e.image.height;\n          e.image.drawImageAtPosition(t, 1, -i / 2, 0, i, o), t.restore();\n        }\n        return !1;\n      }\n    };\n  class wx extends yx {\n    static draw(t, e) {\n      const i = [{\n        x: 0,\n        y: 0\n      }, {\n        x: -1,\n        y: .3\n      }, {\n        x: -.9,\n        y: 0\n      }, {\n        x: -1,\n        y: -.3\n      }];\n      return yx.transform(i, e), yx.drawPath(t, i), !0;\n    }\n  }\n  class _x {\n    static draw(t, e) {\n      const i = [{\n        x: -1,\n        y: 0\n      }, {\n        x: 0,\n        y: .3\n      }, {\n        x: -.4,\n        y: 0\n      }, {\n        x: 0,\n        y: -.3\n      }];\n      return yx.transform(i, e), yx.drawPath(t, i), !0;\n    }\n  }\n  class xx {\n    static draw(t, e) {\n      const i = {\n        x: -.4,\n        y: 0\n      };\n      yx.transform(i, e), t.strokeStyle = t.fillStyle, t.fillStyle = \"rgba(0, 0, 0, 0)\";\n      const o = Math.PI,\n        s = e.angle - o / 2,\n        n = e.angle + o / 2;\n      return t.beginPath(), t.arc(i.x, i.y, .4 * e.length, s, n, !1), t.stroke(), !0;\n    }\n  }\n  class Ex {\n    static draw(t, e) {\n      const i = {\n        x: -.3,\n        y: 0\n      };\n      yx.transform(i, e), t.strokeStyle = t.fillStyle, t.fillStyle = \"rgba(0, 0, 0, 0)\";\n      const o = Math.PI,\n        s = e.angle + o / 2,\n        n = e.angle + 3 * o / 2;\n      return t.beginPath(), t.arc(i.x, i.y, .4 * e.length, s, n, !1), t.stroke(), !0;\n    }\n  }\n  class Ox {\n    static draw(t, e) {\n      const i = [{\n        x: .02,\n        y: 0\n      }, {\n        x: -1,\n        y: .3\n      }, {\n        x: -1,\n        y: -.3\n      }];\n      return yx.transform(i, e), yx.drawPath(t, i), !0;\n    }\n  }\n  class Cx {\n    static draw(t, e) {\n      const i = [{\n        x: 0,\n        y: .3\n      }, {\n        x: 0,\n        y: -.3\n      }, {\n        x: -1,\n        y: 0\n      }];\n      return yx.transform(i, e), yx.drawPath(t, i), !0;\n    }\n  }\n  class kx {\n    static draw(t, e) {\n      const i = {\n        x: -.4,\n        y: 0\n      };\n      return yx.transform(i, e), Wo(t, i.x, i.y, .4 * e.length), !0;\n    }\n  }\n  class Sx {\n    static draw(t, e) {\n      const i = [{\n        x: 0,\n        y: .5\n      }, {\n        x: 0,\n        y: -.5\n      }, {\n        x: -.15,\n        y: -.5\n      }, {\n        x: -.15,\n        y: .5\n      }];\n      return yx.transform(i, e), yx.drawPath(t, i), !0;\n    }\n  }\n  class Tx {\n    static draw(t, e) {\n      const i = [{\n        x: 0,\n        y: .3\n      }, {\n        x: 0,\n        y: -.3\n      }, {\n        x: -.6,\n        y: -.3\n      }, {\n        x: -.6,\n        y: .3\n      }];\n      return yx.transform(i, e), yx.drawPath(t, i), !0;\n    }\n  }\n  class Mx {\n    static draw(t, e) {\n      const i = [{\n        x: 0,\n        y: 0\n      }, {\n        x: -.5,\n        y: -.3\n      }, {\n        x: -1,\n        y: 0\n      }, {\n        x: -.5,\n        y: .3\n      }];\n      return yx.transform(i, e), yx.drawPath(t, i), !0;\n    }\n  }\n  class Dx {\n    static draw(t, e) {\n      const i = [{\n        x: -1,\n        y: .3\n      }, {\n        x: -.5,\n        y: 0\n      }, {\n        x: -1,\n        y: -.3\n      }, {\n        x: 0,\n        y: 0\n      }];\n      return yx.transform(i, e), yx.drawPath(t, i), !0;\n    }\n  }\n  class Ix {\n    static draw(t, e) {\n      let i;\n      switch (e.type && (i = e.type.toLowerCase()), i) {\n        case \"image\":\n          return vx.draw(t, e);\n        case \"circle\":\n          return kx.draw(t, e);\n        case \"box\":\n          return Tx.draw(t, e);\n        case \"crow\":\n          return _x.draw(t, e);\n        case \"curve\":\n          return xx.draw(t, e);\n        case \"diamond\":\n          return Mx.draw(t, e);\n        case \"inv_curve\":\n          return Ex.draw(t, e);\n        case \"triangle\":\n          return Ox.draw(t, e);\n        case \"inv_triangle\":\n          return Cx.draw(t, e);\n        case \"bar\":\n          return Sx.draw(t, e);\n        case \"vee\":\n          return Dx.draw(t, e);\n        default:\n          return wx.draw(t, e);\n      }\n    }\n  }\n  function Px(t, e) {\n    var i = Jl(t);\n    if (Jw) {\n      var o = Jw(t);\n      e && (o = Ru(o).call(o, function (e) {\n        return h_(t, e).enumerable;\n      })), i.push.apply(i, o);\n    }\n    return i;\n  }\n  function Bx(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i,\n        o,\n        s = null != arguments[e] ? arguments[e] : {};\n      e % 2 ? mc(i = Px(Object(s), !0)).call(i, function (e) {\n        zw(t, e, s[e]);\n      }) : p_ ? w_(t, p_(s)) : mc(o = Px(Object(s))).call(o, function (e) {\n        __(t, e, h_(s, e));\n      });\n    }\n    return t;\n  }\n  class Fx {\n    constructor(t, e, i) {\n      this._body = e, this._labelModule = i, this.color = {}, this.colorDirty = !0, this.hoverWidth = 1.5, this.selectionWidth = 2, this.setOptions(t), this.fromPoint = this.from, this.toPoint = this.to;\n    }\n    connect() {\n      this.from = this._body.nodes[this.options.from], this.to = this._body.nodes[this.options.to];\n    }\n    cleanup() {\n      return !1;\n    }\n    setOptions(t) {\n      this.options = t, this.from = this._body.nodes[this.options.from], this.to = this._body.nodes[this.options.to], this.id = this.options.id;\n    }\n    drawLine(t, e, i, o) {\n      let s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.getViaNode();\n      t.strokeStyle = this.getColor(t, e), t.lineWidth = e.width, !1 !== e.dashes ? this._drawDashedLine(t, e, s) : this._drawLine(t, e, s);\n    }\n    _drawLine(t, e, i, o, s) {\n      if (this.from != this.to) this._line(t, e, i, o, s);else {\n        const [i, o, s] = this._getCircleData(t);\n        this._circle(t, e, i, o, s);\n      }\n    }\n    _drawDashedLine(t, e, i, o, s) {\n      t.lineCap = \"round\";\n      const n = Vl(e.dashes) ? e.dashes : [5, 5];\n      if (void 0 !== t.setLineDash) {\n        if (t.save(), t.setLineDash(n), t.lineDashOffset = 0, this.from != this.to) this._line(t, e, i);else {\n          const [i, o, s] = this._getCircleData(t);\n          this._circle(t, e, i, o, s);\n        }\n        t.setLineDash([0]), t.lineDashOffset = 0, t.restore();\n      } else {\n        if (this.from != this.to) Yo(t, this.from.x, this.from.y, this.to.x, this.to.y, n);else {\n          const [i, o, s] = this._getCircleData(t);\n          this._circle(t, e, i, o, s);\n        }\n        this.enableShadow(t, e), t.stroke(), this.disableShadow(t, e);\n      }\n    }\n    findBorderPosition(t, e, i) {\n      return this.from != this.to ? this._findBorderPosition(t, e, i) : this._findBorderPositionCircle(t, e, i);\n    }\n    findBorderPositions(t) {\n      if (this.from != this.to) return {\n        from: this._findBorderPosition(this.from, t),\n        to: this._findBorderPosition(this.to, t)\n      };\n      {\n        var e;\n        const [i, o] = Nl(e = this._getCircleData(t)).call(e, 0, 2);\n        return {\n          from: this._findBorderPositionCircle(this.from, t, {\n            x: i,\n            y: o,\n            low: .25,\n            high: .6,\n            direction: -1\n          }),\n          to: this._findBorderPositionCircle(this.from, t, {\n            x: i,\n            y: o,\n            low: .6,\n            high: .8,\n            direction: 1\n          })\n        };\n      }\n    }\n    _getCircleData(t) {\n      const e = this.options.selfReference.size;\n      void 0 !== t && void 0 === this.from.shape.width && this.from.shape.resize(t);\n      const i = C_(t, this.options.selfReference.angle, e, this.from);\n      return [i.x, i.y, e];\n    }\n    _pointOnCircle(t, e, i, o) {\n      const s = 2 * o * Math.PI;\n      return {\n        x: t + i * Math.cos(s),\n        y: e - i * Math.sin(s)\n      };\n    }\n    _findBorderPositionCircle(t, e, i) {\n      const o = i.x,\n        s = i.y;\n      let n = i.low,\n        r = i.high;\n      const a = i.direction,\n        h = this.options.selfReference.size;\n      let d,\n        l = .5 * (n + r),\n        c = 0;\n      !0 === this.options.arrowStrikethrough && (-1 === a ? c = this.options.endPointOffset.from : 1 === a && (c = this.options.endPointOffset.to));\n      let u = 0;\n      do {\n        l = .5 * (n + r), d = this._pointOnCircle(o, s, h, l);\n        const i = Math.atan2(t.y - d.y, t.x - d.x),\n          p = t.distanceToBorder(e, i) + c - Math.sqrt(Math.pow(d.x - t.x, 2) + Math.pow(d.y - t.y, 2));\n        if (Math.abs(p) < .05) break;\n        p > 0 ? a > 0 ? n = l : r = l : a > 0 ? r = l : n = l, ++u;\n      } while (n <= r && u < 10);\n      return Bx(Bx({}, d), {}, {\n        t: l\n      });\n    }\n    getLineWidth(t, e) {\n      return !0 === t ? Math.max(this.selectionWidth, .3 / this._body.view.scale) : !0 === e ? Math.max(this.hoverWidth, .3 / this._body.view.scale) : Math.max(this.options.width, .3 / this._body.view.scale);\n    }\n    getColor(t, e) {\n      if (!1 !== e.inheritsColor) {\n        if (\"both\" === e.inheritsColor && this.from.id !== this.to.id) {\n          const i = t.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);\n          let o = this.from.options.color.highlight.border,\n            s = this.to.options.color.highlight.border;\n          return !1 === this.from.selected && !1 === this.to.selected ? (o = Sm(this.from.options.color.border, e.opacity), s = Sm(this.to.options.color.border, e.opacity)) : !0 === this.from.selected && !1 === this.to.selected ? s = this.to.options.color.border : !1 === this.from.selected && !0 === this.to.selected && (o = this.from.options.color.border), i.addColorStop(0, o), i.addColorStop(1, s), i;\n        }\n        return \"to\" === e.inheritsColor ? Sm(this.to.options.color.border, e.opacity) : Sm(this.from.options.color.border, e.opacity);\n      }\n      return Sm(e.color, e.opacity);\n    }\n    _circle(t, e, i, o, s) {\n      this.enableShadow(t, e);\n      let n = 0,\n        r = 2 * Math.PI;\n      if (!this.options.selfReference.renderBehindTheNode) {\n        const e = this.options.selfReference.angle,\n          s = this.options.selfReference.angle + Math.PI,\n          a = this._findBorderPositionCircle(this.from, t, {\n            x: i,\n            y: o,\n            low: e,\n            high: s,\n            direction: -1\n          }),\n          h = this._findBorderPositionCircle(this.from, t, {\n            x: i,\n            y: o,\n            low: e,\n            high: s,\n            direction: 1\n          });\n        n = Math.atan2(a.y - o, a.x - i), r = Math.atan2(h.y - o, h.x - i);\n      }\n      t.beginPath(), t.arc(i, o, s, n, r, !1), t.stroke(), this.disableShadow(t, e);\n    }\n    getDistanceToEdge(t, e, i, o, s, n) {\n      if (this.from != this.to) return this._getDistanceToEdge(t, e, i, o, s, n);\n      {\n        const [t, e, i] = this._getCircleData(void 0),\n          o = t - s,\n          r = e - n;\n        return Math.abs(Math.sqrt(o * o + r * r) - i);\n      }\n    }\n    _getDistanceToLine(t, e, i, o, s, n) {\n      const r = i - t,\n        a = o - e;\n      let h = ((s - t) * r + (n - e) * a) / (r * r + a * a);\n      h > 1 ? h = 1 : h < 0 && (h = 0);\n      const d = t + h * r - s,\n        l = e + h * a - n;\n      return Math.sqrt(d * d + l * l);\n    }\n    getArrowData(t, e, i, o, s, n) {\n      let r, a, h, d, l, c, u;\n      const p = n.width;\n      \"from\" === e ? (h = this.from, d = this.to, l = n.fromArrowScale < 0, c = Math.abs(n.fromArrowScale), u = n.fromArrowType) : \"to\" === e ? (h = this.to, d = this.from, l = n.toArrowScale < 0, c = Math.abs(n.toArrowScale), u = n.toArrowType) : (h = this.to, d = this.from, l = n.middleArrowScale < 0, c = Math.abs(n.middleArrowScale), u = n.middleArrowType);\n      const g = 15 * c + 3 * p;\n      if (h != d) {\n        const o = g / mx(h.x - d.x, h.y - d.y);\n        if (\"middle\" !== e) {\n          if (!0 === this.options.smooth.enabled) {\n            const s = this._findBorderPosition(h, t, {\n                via: i\n              }),\n              n = this.getPoint(s.t + o * (\"from\" === e ? 1 : -1), i);\n            r = Math.atan2(s.y - n.y, s.x - n.x), a = s;\n          } else r = Math.atan2(h.y - d.y, h.x - d.x), a = this._findBorderPosition(h, t);\n        } else {\n          const t = (l ? -o : o) / 2,\n            e = this.getPoint(.5 + t, i),\n            s = this.getPoint(.5 - t, i);\n          r = Math.atan2(e.y - s.y, e.x - s.x), a = this.getPoint(.5, i);\n        }\n      } else {\n        const [i, o, s] = this._getCircleData(t);\n        if (\"from\" === e) {\n          const e = this.options.selfReference.angle,\n            s = this.options.selfReference.angle + Math.PI,\n            n = this._findBorderPositionCircle(this.from, t, {\n              x: i,\n              y: o,\n              low: e,\n              high: s,\n              direction: -1\n            });\n          r = -2 * n.t * Math.PI + 1.5 * Math.PI + .1 * Math.PI, a = n;\n        } else if (\"to\" === e) {\n          const e = this.options.selfReference.angle,\n            s = this.options.selfReference.angle + Math.PI,\n            n = this._findBorderPositionCircle(this.from, t, {\n              x: i,\n              y: o,\n              low: e,\n              high: s,\n              direction: 1\n            });\n          r = -2 * n.t * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI, a = n;\n        } else {\n          const t = this.options.selfReference.angle / (2 * Math.PI);\n          a = this._pointOnCircle(i, o, s, t), r = -2 * t * Math.PI + 1.5 * Math.PI + .1 * Math.PI;\n        }\n      }\n      return {\n        point: a,\n        core: {\n          x: a.x - .9 * g * Math.cos(r),\n          y: a.y - .9 * g * Math.sin(r)\n        },\n        angle: r,\n        length: g,\n        type: u\n      };\n    }\n    drawArrowHead(t, e, i, o, s) {\n      t.strokeStyle = this.getColor(t, e), t.fillStyle = t.strokeStyle, t.lineWidth = e.width;\n      Ix.draw(t, s) && (this.enableShadow(t, e), cg(t).call(t), this.disableShadow(t, e));\n    }\n    enableShadow(t, e) {\n      !0 === e.shadow && (t.shadowColor = e.shadowColor, t.shadowBlur = e.shadowSize, t.shadowOffsetX = e.shadowX, t.shadowOffsetY = e.shadowY);\n    }\n    disableShadow(t, e) {\n      !0 === e.shadow && (t.shadowColor = \"rgba(0,0,0,0)\", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0);\n    }\n    drawBackground(t, e) {\n      if (!1 !== e.background) {\n        const i = {\n          strokeStyle: t.strokeStyle,\n          lineWidth: t.lineWidth,\n          dashes: t.dashes\n        };\n        t.strokeStyle = e.backgroundColor, t.lineWidth = e.backgroundSize, this.setStrokeDashed(t, e.backgroundDashes), t.stroke(), t.strokeStyle = i.strokeStyle, t.lineWidth = i.lineWidth, t.dashes = i.dashes, this.setStrokeDashed(t, e.dashes);\n      }\n    }\n    setStrokeDashed(t, e) {\n      if (!1 !== e) {\n        if (void 0 !== t.setLineDash) {\n          const i = Vl(e) ? e : [5, 5];\n          t.setLineDash(i);\n        } else console.warn(\"setLineDash is not supported in this browser. The dashed stroke cannot be used.\");\n      } else void 0 !== t.setLineDash ? t.setLineDash([]) : console.warn(\"setLineDash is not supported in this browser. The dashed stroke cannot be used.\");\n    }\n  }\n  function zx(t, e) {\n    var i = Jl(t);\n    if (Jw) {\n      var o = Jw(t);\n      e && (o = Ru(o).call(o, function (e) {\n        return h_(t, e).enumerable;\n      })), i.push.apply(i, o);\n    }\n    return i;\n  }\n  function Nx(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i,\n        o,\n        s = null != arguments[e] ? arguments[e] : {};\n      e % 2 ? mc(i = zx(Object(s), !0)).call(i, function (e) {\n        zw(t, e, s[e]);\n      }) : p_ ? w_(t, p_(s)) : mc(o = zx(Object(s))).call(o, function (e) {\n        __(t, e, h_(s, e));\n      });\n    }\n    return t;\n  }\n  class Ax extends Fx {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    _findBorderPositionBezier(t, e) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this._getViaCoordinates();\n      let o,\n        s,\n        n = !1,\n        r = 1,\n        a = 0,\n        h = this.to,\n        d = this.options.endPointOffset ? this.options.endPointOffset.to : 0;\n      t.id === this.from.id && (h = this.from, n = !0, d = this.options.endPointOffset ? this.options.endPointOffset.from : 0), !1 === this.options.arrowStrikethrough && (d = 0);\n      let l = 0;\n      do {\n        s = .5 * (a + r), o = this.getPoint(s, i);\n        const t = Math.atan2(h.y - o.y, h.x - o.x),\n          c = h.distanceToBorder(e, t) + d - Math.sqrt(Math.pow(o.x - h.x, 2) + Math.pow(o.y - h.y, 2));\n        if (Math.abs(c) < .2) break;\n        c < 0 ? !1 === n ? a = s : r = s : !1 === n ? r = s : a = s, ++l;\n      } while (a <= r && l < 10);\n      return Nx(Nx({}, o), {}, {\n        t: s\n      });\n    }\n    _getDistanceToBezierEdge(t, e, i, o, s, n, r) {\n      let a,\n        h,\n        d,\n        l,\n        c,\n        u = 1e9,\n        p = t,\n        g = e;\n      for (h = 1; h < 10; h++) d = .1 * h, l = Math.pow(1 - d, 2) * t + 2 * d * (1 - d) * r.x + Math.pow(d, 2) * i, c = Math.pow(1 - d, 2) * e + 2 * d * (1 - d) * r.y + Math.pow(d, 2) * o, h > 0 && (a = this._getDistanceToLine(p, g, l, c, s, n), u = a < u ? a : u), p = l, g = c;\n      return u;\n    }\n    _bezierCurve(t, e, i, o) {\n      t.beginPath(), t.moveTo(this.fromPoint.x, this.fromPoint.y), null != i && null != i.x ? null != o && null != o.x ? t.bezierCurveTo(i.x, i.y, o.x, o.y, this.toPoint.x, this.toPoint.y) : t.quadraticCurveTo(i.x, i.y, this.toPoint.x, this.toPoint.y) : t.lineTo(this.toPoint.x, this.toPoint.y), this.drawBackground(t, e), this.enableShadow(t, e), t.stroke(), this.disableShadow(t, e);\n    }\n    getViaNode() {\n      return this._getViaCoordinates();\n    }\n  }\n  class Rx extends Ax {\n    constructor(t, e, i) {\n      super(t, e, i), this.via = this.via, this._boundFunction = () => {\n        this.positionBezierNode();\n      }, this._body.emitter.on(\"_repositionBezierNodes\", this._boundFunction);\n    }\n    setOptions(t) {\n      super.setOptions(t);\n      let e = !1;\n      this.options.physics !== t.physics && (e = !0), this.options = t, this.id = this.options.id, this.from = this._body.nodes[this.options.from], this.to = this._body.nodes[this.options.to], this.setupSupportNode(), this.connect(), !0 === e && (this.via.setOptions({\n        physics: this.options.physics\n      }), this.positionBezierNode());\n    }\n    connect() {\n      this.from = this._body.nodes[this.options.from], this.to = this._body.nodes[this.options.to], void 0 === this.from || void 0 === this.to || !1 === this.options.physics || this.from.id === this.to.id ? this.via.setOptions({\n        physics: !1\n      }) : this.via.setOptions({\n        physics: !0\n      });\n    }\n    cleanup() {\n      return this._body.emitter.off(\"_repositionBezierNodes\", this._boundFunction), void 0 !== this.via && (delete this._body.nodes[this.via.id], this.via = void 0, !0);\n    }\n    setupSupportNode() {\n      if (void 0 === this.via) {\n        const t = \"edgeId:\" + this.id,\n          e = this._body.functions.createNode({\n            id: t,\n            shape: \"circle\",\n            physics: !0,\n            hidden: !0\n          });\n        this._body.nodes[t] = e, this.via = e, this.via.parentEdgeId = this.id, this.positionBezierNode();\n      }\n    }\n    positionBezierNode() {\n      void 0 !== this.via && void 0 !== this.from && void 0 !== this.to ? (this.via.x = .5 * (this.from.x + this.to.x), this.via.y = .5 * (this.from.y + this.to.y)) : void 0 !== this.via && (this.via.x = 0, this.via.y = 0);\n    }\n    _line(t, e, i) {\n      this._bezierCurve(t, e, i);\n    }\n    _getViaCoordinates() {\n      return this.via;\n    }\n    getViaNode() {\n      return this.via;\n    }\n    getPoint(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.via;\n      if (this.from === this.to) {\n        const [e, i, o] = this._getCircleData(),\n          s = 2 * Math.PI * (1 - t);\n        return {\n          x: e + o * Math.sin(s),\n          y: i + o - o * (1 - Math.cos(s))\n        };\n      }\n      return {\n        x: Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * e.x + Math.pow(t, 2) * this.toPoint.x,\n        y: Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * e.y + Math.pow(t, 2) * this.toPoint.y\n      };\n    }\n    _findBorderPosition(t, e) {\n      return this._findBorderPositionBezier(t, e, this.via);\n    }\n    _getDistanceToEdge(t, e, i, o, s, n) {\n      return this._getDistanceToBezierEdge(t, e, i, o, s, n, this.via);\n    }\n  }\n  class jx extends Ax {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    _line(t, e, i) {\n      this._bezierCurve(t, e, i);\n    }\n    getViaNode() {\n      return this._getViaCoordinates();\n    }\n    _getViaCoordinates() {\n      const t = this.options.smooth.roundness,\n        e = this.options.smooth.type;\n      let i = Math.abs(this.from.x - this.to.x),\n        o = Math.abs(this.from.y - this.to.y);\n      if (\"discrete\" === e || \"diagonalCross\" === e) {\n        let s, n;\n        s = n = i <= o ? t * o : t * i, this.from.x > this.to.x && (s = -s), this.from.y >= this.to.y && (n = -n);\n        let r = this.from.x + s,\n          a = this.from.y + n;\n        return \"discrete\" === e && (i <= o ? r = i < t * o ? this.from.x : r : a = o < t * i ? this.from.y : a), {\n          x: r,\n          y: a\n        };\n      }\n      if (\"straightCross\" === e) {\n        let e = (1 - t) * i,\n          s = (1 - t) * o;\n        return i <= o ? (e = 0, this.from.y < this.to.y && (s = -s)) : (this.from.x < this.to.x && (e = -e), s = 0), {\n          x: this.to.x + e,\n          y: this.to.y + s\n        };\n      }\n      if (\"horizontal\" === e) {\n        let e = (1 - t) * i;\n        return this.from.x < this.to.x && (e = -e), {\n          x: this.to.x + e,\n          y: this.from.y\n        };\n      }\n      if (\"vertical\" === e) {\n        let e = (1 - t) * o;\n        return this.from.y < this.to.y && (e = -e), {\n          x: this.from.x,\n          y: this.to.y + e\n        };\n      }\n      if (\"curvedCW\" === e) {\n        i = this.to.x - this.from.x, o = this.from.y - this.to.y;\n        const e = Math.sqrt(i * i + o * o),\n          s = Math.PI,\n          n = (Math.atan2(o, i) + (.5 * t + .5) * s) % (2 * s);\n        return {\n          x: this.from.x + (.5 * t + .5) * e * Math.sin(n),\n          y: this.from.y + (.5 * t + .5) * e * Math.cos(n)\n        };\n      }\n      if (\"curvedCCW\" === e) {\n        i = this.to.x - this.from.x, o = this.from.y - this.to.y;\n        const e = Math.sqrt(i * i + o * o),\n          s = Math.PI,\n          n = (Math.atan2(o, i) + (.5 * -t + .5) * s) % (2 * s);\n        return {\n          x: this.from.x + (.5 * t + .5) * e * Math.sin(n),\n          y: this.from.y + (.5 * t + .5) * e * Math.cos(n)\n        };\n      }\n      {\n        let e, s;\n        e = s = i <= o ? t * o : t * i, this.from.x > this.to.x && (e = -e), this.from.y >= this.to.y && (s = -s);\n        let n = this.from.x + e,\n          r = this.from.y + s;\n        return i <= o ? n = this.from.x <= this.to.x ? this.to.x < n ? this.to.x : n : this.to.x > n ? this.to.x : n : r = this.from.y >= this.to.y ? this.to.y > r ? this.to.y : r : this.to.y < r ? this.to.y : r, {\n          x: n,\n          y: r\n        };\n      }\n    }\n    _findBorderPosition(t, e) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n      return this._findBorderPositionBezier(t, e, i.via);\n    }\n    _getDistanceToEdge(t, e, i, o, s, n) {\n      let r = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : this._getViaCoordinates();\n      return this._getDistanceToBezierEdge(t, e, i, o, s, n, r);\n    }\n    getPoint(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._getViaCoordinates();\n      const i = t;\n      return {\n        x: Math.pow(1 - i, 2) * this.fromPoint.x + 2 * i * (1 - i) * e.x + Math.pow(i, 2) * this.toPoint.x,\n        y: Math.pow(1 - i, 2) * this.fromPoint.y + 2 * i * (1 - i) * e.y + Math.pow(i, 2) * this.toPoint.y\n      };\n    }\n  }\n  class Lx extends Ax {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    _getDistanceToBezierEdge2(t, e, i, o, s, n, r, a) {\n      let h = 1e9,\n        d = t,\n        l = e;\n      const c = [0, 0, 0, 0];\n      for (let u = 1; u < 10; u++) {\n        const p = .1 * u;\n        c[0] = Math.pow(1 - p, 3), c[1] = 3 * p * Math.pow(1 - p, 2), c[2] = 3 * Math.pow(p, 2) * (1 - p), c[3] = Math.pow(p, 3);\n        const g = c[0] * t + c[1] * r.x + c[2] * a.x + c[3] * i,\n          f = c[0] * e + c[1] * r.y + c[2] * a.y + c[3] * o;\n        if (u > 0) {\n          const t = this._getDistanceToLine(d, l, g, f, s, n);\n          h = t < h ? t : h;\n        }\n        d = g, l = f;\n      }\n      return h;\n    }\n  }\n  class Hx extends Lx {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    _line(t, e, i) {\n      const o = i[0],\n        s = i[1];\n      this._bezierCurve(t, e, o, s);\n    }\n    _getViaCoordinates() {\n      const t = this.from.x - this.to.x,\n        e = this.from.y - this.to.y;\n      let i, o, s, n;\n      const r = this.options.smooth.roundness;\n      return (Math.abs(t) > Math.abs(e) || !0 === this.options.smooth.forceDirection || \"horizontal\" === this.options.smooth.forceDirection) && \"vertical\" !== this.options.smooth.forceDirection ? (o = this.from.y, n = this.to.y, i = this.from.x - r * t, s = this.to.x + r * t) : (o = this.from.y - r * e, n = this.to.y + r * e, i = this.from.x, s = this.to.x), [{\n        x: i,\n        y: o\n      }, {\n        x: s,\n        y: n\n      }];\n    }\n    getViaNode() {\n      return this._getViaCoordinates();\n    }\n    _findBorderPosition(t, e) {\n      return this._findBorderPositionBezier(t, e);\n    }\n    _getDistanceToEdge(t, e, i, o, s, n) {\n      let [r, a] = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : this._getViaCoordinates();\n      return this._getDistanceToBezierEdge2(t, e, i, o, s, n, r, a);\n    }\n    getPoint(t) {\n      let [e, i] = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._getViaCoordinates();\n      const o = t,\n        s = [Math.pow(1 - o, 3), 3 * o * Math.pow(1 - o, 2), 3 * Math.pow(o, 2) * (1 - o), Math.pow(o, 3)];\n      return {\n        x: s[0] * this.fromPoint.x + s[1] * e.x + s[2] * i.x + s[3] * this.toPoint.x,\n        y: s[0] * this.fromPoint.y + s[1] * e.y + s[2] * i.y + s[3] * this.toPoint.y\n      };\n    }\n  }\n  class Wx extends Fx {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    _line(t, e) {\n      t.beginPath(), t.moveTo(this.fromPoint.x, this.fromPoint.y), t.lineTo(this.toPoint.x, this.toPoint.y), this.enableShadow(t, e), t.stroke(), this.disableShadow(t, e);\n    }\n    getViaNode() {}\n    getPoint(t) {\n      return {\n        x: (1 - t) * this.fromPoint.x + t * this.toPoint.x,\n        y: (1 - t) * this.fromPoint.y + t * this.toPoint.y\n      };\n    }\n    _findBorderPosition(t, e) {\n      let i = this.to,\n        o = this.from;\n      t.id === this.from.id && (i = this.from, o = this.to);\n      const s = Math.atan2(i.y - o.y, i.x - o.x),\n        n = i.x - o.x,\n        r = i.y - o.y,\n        a = Math.sqrt(n * n + r * r),\n        h = (a - t.distanceToBorder(e, s)) / a;\n      return {\n        x: (1 - h) * o.x + h * i.x,\n        y: (1 - h) * o.y + h * i.y,\n        t: 0\n      };\n    }\n    _getDistanceToEdge(t, e, i, o, s, n) {\n      return this._getDistanceToLine(t, e, i, o, s, n);\n    }\n  }\n  class Vx {\n    constructor(t, e, i, o, s) {\n      if (void 0 === e) throw new Error(\"No body provided\");\n      this.options = zm(o), this.globalOptions = o, this.defaultOptions = s, this.body = e, this.imagelist = i, this.id = void 0, this.fromId = void 0, this.toId = void 0, this.selected = !1, this.hover = !1, this.labelDirty = !0, this.baseWidth = this.options.width, this.baseFontSize = this.options.font.size, this.from = void 0, this.to = void 0, this.edgeType = void 0, this.connected = !1, this.labelModule = new L_(this.body, this.options, !0), this.setOptions(t);\n    }\n    setOptions(t) {\n      if (!t) return;\n      let e = void 0 !== t.physics && this.options.physics !== t.physics || void 0 !== t.hidden && (this.options.hidden || !1) !== (t.hidden || !1) || void 0 !== t.from && this.options.from !== t.from || void 0 !== t.to && this.options.to !== t.to;\n      Vx.parseOptions(this.options, t, !0, this.globalOptions), void 0 !== t.id && (this.id = t.id), void 0 !== t.from && (this.fromId = t.from), void 0 !== t.to && (this.toId = t.to), void 0 !== t.title && (this.title = t.title), void 0 !== t.value && (t.value = Yw(t.value));\n      const i = [t, this.options, this.defaultOptions];\n      return this.chooser = x_(\"edge\", i), this.updateLabelModule(t), e = this.updateEdgeType() || e, this._setInteractionWidths(), this.connect(), e;\n    }\n    static parseOptions(t, e) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n        o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},\n        s = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];\n      if (wm([\"endPointOffset\", \"arrowStrikethrough\", \"id\", \"from\", \"hidden\", \"hoverWidth\", \"labelHighlightBold\", \"length\", \"line\", \"opacity\", \"physics\", \"scaling\", \"selectionWidth\", \"selfReferenceSize\", \"selfReference\", \"to\", \"title\", \"value\", \"width\", \"font\", \"chosen\", \"widthConstraint\"], t, e, i), void 0 !== e.endPointOffset && void 0 !== e.endPointOffset.from && (Vv(e.endPointOffset.from) ? t.endPointOffset.from = e.endPointOffset.from : (t.endPointOffset.from = void 0 !== o.endPointOffset.from ? o.endPointOffset.from : 0, console.error(\"endPointOffset.from is not a valid number\"))), void 0 !== e.endPointOffset && void 0 !== e.endPointOffset.to && (Vv(e.endPointOffset.to) ? t.endPointOffset.to = e.endPointOffset.to : (t.endPointOffset.to = void 0 !== o.endPointOffset.to ? o.endPointOffset.to : 0, console.error(\"endPointOffset.to is not a valid number\"))), O_(e.label) ? t.label = e.label : O_(t.label) || (t.label = void 0), Nm(t, e, \"smooth\", o), Nm(t, e, \"shadow\", o), Nm(t, e, \"background\", o), void 0 !== e.dashes && null !== e.dashes ? t.dashes = e.dashes : !0 === i && null === e.dashes && (t.dashes = Ip(o.dashes)), void 0 !== e.scaling && null !== e.scaling ? (void 0 !== e.scaling.min && (t.scaling.min = e.scaling.min), void 0 !== e.scaling.max && (t.scaling.max = e.scaling.max), Nm(t.scaling, e.scaling, \"label\", o.scaling)) : !0 === i && null === e.scaling && (t.scaling = Ip(o.scaling)), void 0 !== e.arrows && null !== e.arrows) {\n        if (\"string\" == typeof e.arrows) {\n          const i = e.arrows.toLowerCase();\n          t.arrows.to.enabled = -1 != Mp(i).call(i, \"to\"), t.arrows.middle.enabled = -1 != Mp(i).call(i, \"middle\"), t.arrows.from.enabled = -1 != Mp(i).call(i, \"from\");\n        } else {\n          if (\"object\" != typeof e.arrows) throw new Error(\"The arrow newOptions can only be an object or a string. Refer to the documentation. You used:\" + zp(e.arrows));\n          Nm(t.arrows, e.arrows, \"to\", o.arrows), Nm(t.arrows, e.arrows, \"middle\", o.arrows), Nm(t.arrows, e.arrows, \"from\", o.arrows);\n        }\n      } else !0 === i && null === e.arrows && (t.arrows = Ip(o.arrows));\n      if (void 0 !== e.color && null !== e.color) {\n        const n = mm(e.color) ? {\n            color: e.color,\n            highlight: e.color,\n            hover: e.color,\n            inherit: !1,\n            opacity: 1\n          } : e.color,\n          r = t.color;\n        if (s) xm(r, o.color, !1, i);else for (const t in r) Object.prototype.hasOwnProperty.call(r, t) && delete r[t];\n        if (mm(r)) r.color = r, r.highlight = r, r.hover = r, r.inherit = !1, void 0 === n.opacity && (r.opacity = 1);else {\n          let t = !1;\n          void 0 !== n.color && (r.color = n.color, t = !0), void 0 !== n.highlight && (r.highlight = n.highlight, t = !0), void 0 !== n.hover && (r.hover = n.hover, t = !0), void 0 !== n.inherit && (r.inherit = n.inherit), void 0 !== n.opacity && (r.opacity = Math.min(1, Math.max(0, n.opacity))), !0 === t ? r.inherit = !1 : void 0 === r.inherit && (r.inherit = \"from\");\n        }\n      } else !0 === i && null === e.color && (t.color = zm(o.color));\n      !0 === i && null === e.font && (t.font = zm(o.font)), Object.prototype.hasOwnProperty.call(e, \"selfReferenceSize\") && (console.warn(\"The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}\"), t.selfReference.size = e.selfReferenceSize);\n    }\n    getFormattingValues() {\n      const t = !0 === this.options.arrows.to || !0 === this.options.arrows.to.enabled,\n        e = !0 === this.options.arrows.from || !0 === this.options.arrows.from.enabled,\n        i = !0 === this.options.arrows.middle || !0 === this.options.arrows.middle.enabled,\n        o = this.options.color.inherit,\n        s = {\n          toArrow: t,\n          toArrowScale: this.options.arrows.to.scaleFactor,\n          toArrowType: this.options.arrows.to.type,\n          toArrowSrc: this.options.arrows.to.src,\n          toArrowImageWidth: this.options.arrows.to.imageWidth,\n          toArrowImageHeight: this.options.arrows.to.imageHeight,\n          middleArrow: i,\n          middleArrowScale: this.options.arrows.middle.scaleFactor,\n          middleArrowType: this.options.arrows.middle.type,\n          middleArrowSrc: this.options.arrows.middle.src,\n          middleArrowImageWidth: this.options.arrows.middle.imageWidth,\n          middleArrowImageHeight: this.options.arrows.middle.imageHeight,\n          fromArrow: e,\n          fromArrowScale: this.options.arrows.from.scaleFactor,\n          fromArrowType: this.options.arrows.from.type,\n          fromArrowSrc: this.options.arrows.from.src,\n          fromArrowImageWidth: this.options.arrows.from.imageWidth,\n          fromArrowImageHeight: this.options.arrows.from.imageHeight,\n          arrowStrikethrough: this.options.arrowStrikethrough,\n          color: o ? void 0 : this.options.color.color,\n          inheritsColor: o,\n          opacity: this.options.color.opacity,\n          hidden: this.options.hidden,\n          length: this.options.length,\n          shadow: this.options.shadow.enabled,\n          shadowColor: this.options.shadow.color,\n          shadowSize: this.options.shadow.size,\n          shadowX: this.options.shadow.x,\n          shadowY: this.options.shadow.y,\n          dashes: this.options.dashes,\n          width: this.options.width,\n          background: this.options.background.enabled,\n          backgroundColor: this.options.background.color,\n          backgroundSize: this.options.background.size,\n          backgroundDashes: this.options.background.dashes\n        };\n      if (this.selected || this.hover) {\n        if (!0 === this.chooser) {\n          if (this.selected) {\n            const t = this.options.selectionWidth;\n            \"function\" == typeof t ? s.width = t(s.width) : \"number\" == typeof t && (s.width += t), s.width = Math.max(s.width, .3 / this.body.view.scale), s.color = this.options.color.highlight, s.shadow = this.options.shadow.enabled;\n          } else if (this.hover) {\n            const t = this.options.hoverWidth;\n            \"function\" == typeof t ? s.width = t(s.width) : \"number\" == typeof t && (s.width += t), s.width = Math.max(s.width, .3 / this.body.view.scale), s.color = this.options.color.hover, s.shadow = this.options.shadow.enabled;\n          }\n        } else \"function\" == typeof this.chooser && (this.chooser(s, this.options.id, this.selected, this.hover), void 0 !== s.color && (s.inheritsColor = !1), !1 === s.shadow && (s.shadowColor === this.options.shadow.color && s.shadowSize === this.options.shadow.size && s.shadowX === this.options.shadow.x && s.shadowY === this.options.shadow.y || (s.shadow = !0)));\n      } else s.shadow = this.options.shadow.enabled, s.width = Math.max(s.width, .3 / this.body.view.scale);\n      return s;\n    }\n    updateLabelModule(t) {\n      const e = [t, this.options, this.globalOptions, this.defaultOptions];\n      this.labelModule.update(this.options, e), void 0 !== this.labelModule.baseSize && (this.baseFontSize = this.labelModule.baseSize);\n    }\n    updateEdgeType() {\n      const t = this.options.smooth;\n      let e = !1,\n        i = !0;\n      return void 0 !== this.edgeType && ((this.edgeType instanceof Rx && !0 === t.enabled && \"dynamic\" === t.type || this.edgeType instanceof Hx && !0 === t.enabled && \"cubicBezier\" === t.type || this.edgeType instanceof jx && !0 === t.enabled && \"dynamic\" !== t.type && \"cubicBezier\" !== t.type || this.edgeType instanceof Wx && !1 === t.type.enabled) && (i = !1), !0 === i && (e = this.cleanup())), !0 === i ? !0 === t.enabled ? \"dynamic\" === t.type ? (e = !0, this.edgeType = new Rx(this.options, this.body, this.labelModule)) : \"cubicBezier\" === t.type ? this.edgeType = new Hx(this.options, this.body, this.labelModule) : this.edgeType = new jx(this.options, this.body, this.labelModule) : this.edgeType = new Wx(this.options, this.body, this.labelModule) : this.edgeType.setOptions(this.options), e;\n    }\n    connect() {\n      this.disconnect(), this.from = this.body.nodes[this.fromId] || void 0, this.to = this.body.nodes[this.toId] || void 0, this.connected = void 0 !== this.from && void 0 !== this.to, !0 === this.connected ? (this.from.attachEdge(this), this.to.attachEdge(this)) : (this.from && this.from.detachEdge(this), this.to && this.to.detachEdge(this)), this.edgeType.connect();\n    }\n    disconnect() {\n      this.from && (this.from.detachEdge(this), this.from = void 0), this.to && (this.to.detachEdge(this), this.to = void 0), this.connected = !1;\n    }\n    getTitle() {\n      return this.title;\n    }\n    isSelected() {\n      return this.selected;\n    }\n    getValue() {\n      return this.options.value;\n    }\n    setValueRange(t, e, i) {\n      if (void 0 !== this.options.value) {\n        const o = this.options.scaling.customScalingFunction(t, e, i, this.options.value),\n          s = this.options.scaling.max - this.options.scaling.min;\n        if (!0 === this.options.scaling.label.enabled) {\n          const t = this.options.scaling.label.max - this.options.scaling.label.min;\n          this.options.font.size = this.options.scaling.label.min + o * t;\n        }\n        this.options.width = this.options.scaling.min + o * s;\n      } else this.options.width = this.baseWidth, this.options.font.size = this.baseFontSize;\n      this._setInteractionWidths(), this.updateLabelModule();\n    }\n    _setInteractionWidths() {\n      \"function\" == typeof this.options.hoverWidth ? this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width) : this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width, \"function\" == typeof this.options.selectionWidth ? this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width) : this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;\n    }\n    draw(t) {\n      const e = this.getFormattingValues();\n      if (e.hidden) return;\n      const i = this.edgeType.getViaNode();\n      this.edgeType.drawLine(t, e, this.selected, this.hover, i), this.drawLabel(t, i);\n    }\n    drawArrows(t) {\n      const e = this.getFormattingValues();\n      if (e.hidden) return;\n      const i = this.edgeType.getViaNode(),\n        o = {};\n      this.edgeType.fromPoint = this.edgeType.from, this.edgeType.toPoint = this.edgeType.to, e.fromArrow && (o.from = this.edgeType.getArrowData(t, \"from\", i, this.selected, this.hover, e), !1 === e.arrowStrikethrough && (this.edgeType.fromPoint = o.from.core), e.fromArrowSrc && (o.from.image = this.imagelist.load(e.fromArrowSrc)), e.fromArrowImageWidth && (o.from.imageWidth = e.fromArrowImageWidth), e.fromArrowImageHeight && (o.from.imageHeight = e.fromArrowImageHeight)), e.toArrow && (o.to = this.edgeType.getArrowData(t, \"to\", i, this.selected, this.hover, e), !1 === e.arrowStrikethrough && (this.edgeType.toPoint = o.to.core), e.toArrowSrc && (o.to.image = this.imagelist.load(e.toArrowSrc)), e.toArrowImageWidth && (o.to.imageWidth = e.toArrowImageWidth), e.toArrowImageHeight && (o.to.imageHeight = e.toArrowImageHeight)), e.middleArrow && (o.middle = this.edgeType.getArrowData(t, \"middle\", i, this.selected, this.hover, e), e.middleArrowSrc && (o.middle.image = this.imagelist.load(e.middleArrowSrc)), e.middleArrowImageWidth && (o.middle.imageWidth = e.middleArrowImageWidth), e.middleArrowImageHeight && (o.middle.imageHeight = e.middleArrowImageHeight)), e.fromArrow && this.edgeType.drawArrowHead(t, e, this.selected, this.hover, o.from), e.middleArrow && this.edgeType.drawArrowHead(t, e, this.selected, this.hover, o.middle), e.toArrow && this.edgeType.drawArrowHead(t, e, this.selected, this.hover, o.to);\n    }\n    drawLabel(t, e) {\n      if (void 0 !== this.options.label) {\n        const i = this.from,\n          o = this.to;\n        let s;\n        if (this.labelModule.differentState(this.selected, this.hover) && this.labelModule.getTextSize(t, this.selected, this.hover), i.id != o.id) {\n          this.labelModule.pointToSelf = !1, s = this.edgeType.getPoint(.5, e), t.save();\n          const i = this._getRotation(t);\n          0 != i.angle && (t.translate(i.x, i.y), t.rotate(i.angle)), this.labelModule.draw(t, s.x, s.y, this.selected, this.hover), t.restore();\n        } else {\n          this.labelModule.pointToSelf = !0;\n          const e = C_(t, this.options.selfReference.angle, this.options.selfReference.size, i);\n          s = this._pointOnCircle(e.x, e.y, this.options.selfReference.size, this.options.selfReference.angle), this.labelModule.draw(t, s.x, s.y, this.selected, this.hover);\n        }\n      }\n    }\n    getItemsOnPoint(t) {\n      const e = [];\n      if (this.labelModule.visible()) {\n        const i = this._getRotation();\n        E_(this.labelModule.getSize(), t, i) && e.push({\n          edgeId: this.id,\n          labelId: 0\n        });\n      }\n      const i = {\n        left: t.x,\n        top: t.y\n      };\n      return this.isOverlappingWith(i) && e.push({\n        edgeId: this.id\n      }), e;\n    }\n    isOverlappingWith(t) {\n      if (this.connected) {\n        const e = 10,\n          i = this.from.x,\n          o = this.from.y,\n          s = this.to.x,\n          n = this.to.y,\n          r = t.left,\n          a = t.top;\n        return this.edgeType.getDistanceToEdge(i, o, s, n, r, a) < e;\n      }\n      return !1;\n    }\n    _getRotation(t) {\n      const e = this.edgeType.getViaNode(),\n        i = this.edgeType.getPoint(.5, e);\n      void 0 !== t && this.labelModule.calculateLabelSize(t, this.selected, this.hover, i.x, i.y);\n      const o = {\n        x: i.x,\n        y: this.labelModule.size.yLine,\n        angle: 0\n      };\n      if (!this.labelModule.visible()) return o;\n      if (\"horizontal\" === this.options.font.align) return o;\n      const s = this.from.y - this.to.y,\n        n = this.from.x - this.to.x;\n      let r = Math.atan2(s, n);\n      return (r < -1 && n < 0 || r > 0 && n < 0) && (r += Math.PI), o.angle = r, o;\n    }\n    _pointOnCircle(t, e, i, o) {\n      return {\n        x: t + i * Math.cos(o),\n        y: e - i * Math.sin(o)\n      };\n    }\n    select() {\n      this.selected = !0;\n    }\n    unselect() {\n      this.selected = !1;\n    }\n    cleanup() {\n      return this.edgeType.cleanup();\n    }\n    remove() {\n      this.cleanup(), this.disconnect(), delete this.body.edges[this.id];\n    }\n    endPointsValid() {\n      return void 0 !== this.body.nodes[this.fromId] && void 0 !== this.body.nodes[this.toId];\n    }\n  }\n  class qx {\n    constructor(t, e, i) {\n      var o;\n      this.body = t, this.images = e, this.groups = i, this.body.functions.createEdge = Ho(o = this.create).call(o, this), this.edgesListeners = {\n        add: (t, e) => {\n          this.add(e.items);\n        },\n        update: (t, e) => {\n          this.update(e.items);\n        },\n        remove: (t, e) => {\n          this.remove(e.items);\n        }\n      }, this.options = {}, this.defaultOptions = {\n        arrows: {\n          to: {\n            enabled: !1,\n            scaleFactor: 1,\n            type: \"arrow\"\n          },\n          middle: {\n            enabled: !1,\n            scaleFactor: 1,\n            type: \"arrow\"\n          },\n          from: {\n            enabled: !1,\n            scaleFactor: 1,\n            type: \"arrow\"\n          }\n        },\n        endPointOffset: {\n          from: 0,\n          to: 0\n        },\n        arrowStrikethrough: !0,\n        color: {\n          color: \"#848484\",\n          highlight: \"#848484\",\n          hover: \"#848484\",\n          inherit: \"from\",\n          opacity: 1\n        },\n        dashes: !1,\n        font: {\n          color: \"#343434\",\n          size: 14,\n          face: \"arial\",\n          background: \"none\",\n          strokeWidth: 2,\n          strokeColor: \"#ffffff\",\n          align: \"horizontal\",\n          multi: !1,\n          vadjust: 0,\n          bold: {\n            mod: \"bold\"\n          },\n          boldital: {\n            mod: \"bold italic\"\n          },\n          ital: {\n            mod: \"italic\"\n          },\n          mono: {\n            mod: \"\",\n            size: 15,\n            face: \"courier new\",\n            vadjust: 2\n          }\n        },\n        hidden: !1,\n        hoverWidth: 1.5,\n        label: void 0,\n        labelHighlightBold: !0,\n        length: void 0,\n        physics: !0,\n        scaling: {\n          min: 1,\n          max: 15,\n          label: {\n            enabled: !0,\n            min: 14,\n            max: 30,\n            maxVisible: 30,\n            drawThreshold: 5\n          },\n          customScalingFunction: function (t, e, i, o) {\n            if (e === t) return .5;\n            {\n              const i = 1 / (e - t);\n              return Math.max(0, (o - t) * i);\n            }\n          }\n        },\n        selectionWidth: 1.5,\n        selfReference: {\n          size: 20,\n          angle: Math.PI / 4,\n          renderBehindTheNode: !0\n        },\n        shadow: {\n          enabled: !1,\n          color: \"rgba(0,0,0,0.5)\",\n          size: 10,\n          x: 5,\n          y: 5\n        },\n        background: {\n          enabled: !1,\n          color: \"rgba(111,111,111,1)\",\n          size: 10,\n          dashes: !1\n        },\n        smooth: {\n          enabled: !0,\n          type: \"dynamic\",\n          forceDirection: \"none\",\n          roundness: .5\n        },\n        title: void 0,\n        width: 1,\n        value: void 0\n      }, xm(this.options, this.defaultOptions), this.bindEventListeners();\n    }\n    bindEventListeners() {\n      var t,\n        e,\n        i = this;\n      this.body.emitter.on(\"_forceDisableDynamicCurves\", function (t) {\n        let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n        \"dynamic\" === t && (t = \"continuous\");\n        let o = !1;\n        for (const e in i.body.edges) if (Object.prototype.hasOwnProperty.call(i.body.edges, e)) {\n          const s = i.body.edges[e],\n            n = i.body.data.edges.get(e);\n          if (null != n) {\n            const e = n.smooth;\n            void 0 !== e && !0 === e.enabled && \"dynamic\" === e.type && (void 0 === t ? s.setOptions({\n              smooth: !1\n            }) : s.setOptions({\n              smooth: {\n                type: t\n              }\n            }), o = !0);\n          }\n        }\n        !0 === e && !0 === o && i.body.emitter.emit(\"_dataChanged\");\n      }), this.body.emitter.on(\"_dataUpdated\", () => {\n        this.reconnectEdges();\n      }), this.body.emitter.on(\"refreshEdges\", Ho(t = this.refresh).call(t, this)), this.body.emitter.on(\"refresh\", Ho(e = this.refresh).call(e, this)), this.body.emitter.on(\"destroy\", () => {\n        Cm(this.edgesListeners, (t, e) => {\n          this.body.data.edges && this.body.data.edges.off(e, t);\n        }), delete this.body.functions.createEdge, delete this.edgesListeners.add, delete this.edgesListeners.update, delete this.edgesListeners.remove, delete this.edgesListeners;\n      });\n    }\n    setOptions(t) {\n      if (void 0 !== t) {\n        Vx.parseOptions(this.options, t, !0, this.defaultOptions, !0);\n        let e = !1;\n        if (void 0 !== t.smooth) for (const t in this.body.edges) Object.prototype.hasOwnProperty.call(this.body.edges, t) && (e = this.body.edges[t].updateEdgeType() || e);\n        if (void 0 !== t.font) for (const t in this.body.edges) Object.prototype.hasOwnProperty.call(this.body.edges, t) && this.body.edges[t].updateLabelModule();\n        void 0 === t.hidden && void 0 === t.physics && !0 !== e || this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n    setData(t) {\n      let i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      const o = this.body.data.edges;\n      if (e.isDataViewLike(\"id\", t)) this.body.data.edges = t;else if (Vl(t)) this.body.data.edges = new e.DataSet(), this.body.data.edges.add(t);else {\n        if (t) throw new TypeError(\"Array or DataSet expected\");\n        this.body.data.edges = new e.DataSet();\n      }\n      if (o && Cm(this.edgesListeners, (t, e) => {\n        o.off(e, t);\n      }), this.body.edges = {}, this.body.data.edges) {\n        Cm(this.edgesListeners, (t, e) => {\n          this.body.data.edges.on(e, t);\n        });\n        const t = this.body.data.edges.getIds();\n        this.add(t, !0);\n      }\n      this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\"), !1 === i && this.body.emitter.emit(\"_dataChanged\");\n    }\n    add(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      const i = this.body.edges,\n        o = this.body.data.edges;\n      for (let e = 0; e < t.length; e++) {\n        const s = t[e],\n          n = i[s];\n        n && n.disconnect();\n        const r = o.get(s, {\n          showInternalIds: !0\n        });\n        i[s] = this.create(r);\n      }\n      this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\"), !1 === e && this.body.emitter.emit(\"_dataChanged\");\n    }\n    update(t) {\n      const e = this.body.edges,\n        i = this.body.data.edges;\n      let o = !1;\n      for (let s = 0; s < t.length; s++) {\n        const n = t[s],\n          r = i.get(n),\n          a = e[n];\n        void 0 !== a ? (a.disconnect(), o = a.setOptions(r) || o, a.connect()) : (this.body.edges[n] = this.create(r), o = !0);\n      }\n      !0 === o ? (this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\"), this.body.emitter.emit(\"_dataChanged\")) : this.body.emitter.emit(\"_dataUpdated\");\n    }\n    remove(t) {\n      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      if (0 === t.length) return;\n      const i = this.body.edges;\n      Cm(t, t => {\n        const e = i[t];\n        void 0 !== e && e.remove();\n      }), e && this.body.emitter.emit(\"_dataChanged\");\n    }\n    refresh() {\n      Cm(this.body.edges, (t, e) => {\n        const i = this.body.data.edges.get(e);\n        void 0 !== i && t.setOptions(i);\n      });\n    }\n    create(t) {\n      return new Vx(t, this.body, this.images, this.options, this.defaultOptions);\n    }\n    reconnectEdges() {\n      let t;\n      const e = this.body.nodes,\n        i = this.body.edges;\n      for (t in e) Object.prototype.hasOwnProperty.call(e, t) && (e[t].edges = []);\n      for (t in i) if (Object.prototype.hasOwnProperty.call(i, t)) {\n        const e = i[t];\n        e.from = null, e.to = null, e.connect();\n      }\n    }\n    getConnectedNodes(t) {\n      const e = [];\n      if (void 0 !== this.body.edges[t]) {\n        const i = this.body.edges[t];\n        void 0 !== i.fromId && e.push(i.fromId), void 0 !== i.toId && e.push(i.toId);\n      }\n      return e;\n    }\n    _updateState() {\n      this._addMissingEdges(), this._removeInvalidEdges();\n    }\n    _removeInvalidEdges() {\n      const t = [];\n      Cm(this.body.edges, (e, i) => {\n        const o = this.body.nodes[e.toId],\n          s = this.body.nodes[e.fromId];\n        void 0 !== o && !0 === o.isCluster || void 0 !== s && !0 === s.isCluster || void 0 !== o && void 0 !== s || t.push(i);\n      }), this.remove(t, !1);\n    }\n    _addMissingEdges() {\n      const t = this.body.data.edges;\n      if (null == t) return;\n      const e = this.body.edges,\n        i = [];\n      mc(t).call(t, (t, o) => {\n        void 0 === e[o] && i.push(o);\n      }), this.add(i, !0);\n    }\n  }\n  class Ux {\n    constructor(t, e, i) {\n      this.body = t, this.physicsBody = e, this.barnesHutTree, this.setOptions(i), this._rng = hm(\"BARNES HUT SOLVER\");\n    }\n    setOptions(t) {\n      this.options = t, this.thetaInversed = 1 / this.options.theta, this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));\n    }\n    solve() {\n      if (0 !== this.options.gravitationalConstant && this.physicsBody.physicsNodeIndices.length > 0) {\n        let t;\n        const e = this.body.nodes,\n          i = this.physicsBody.physicsNodeIndices,\n          o = i.length,\n          s = this._formBarnesHutTree(e, i);\n        this.barnesHutTree = s;\n        for (let n = 0; n < o; n++) t = e[i[n]], t.options.mass > 0 && this._getForceContributions(s.root, t);\n      }\n    }\n    _getForceContributions(t, e) {\n      this._getForceContribution(t.children.NW, e), this._getForceContribution(t.children.NE, e), this._getForceContribution(t.children.SW, e), this._getForceContribution(t.children.SE, e);\n    }\n    _getForceContribution(t, e) {\n      if (t.childrenCount > 0) {\n        const i = t.centerOfMass.x - e.x,\n          o = t.centerOfMass.y - e.y,\n          s = Math.sqrt(i * i + o * o);\n        s * t.calcSize > this.thetaInversed ? this._calculateForces(s, i, o, e, t) : 4 === t.childrenCount ? this._getForceContributions(t, e) : t.children.data.id != e.id && this._calculateForces(s, i, o, e, t);\n      }\n    }\n    _calculateForces(t, e, i, o, s) {\n      0 === t && (e = t = .1), this.overlapAvoidanceFactor < 1 && o.shape.radius && (t = Math.max(.1 + this.overlapAvoidanceFactor * o.shape.radius, t - o.shape.radius));\n      const n = this.options.gravitationalConstant * s.mass * o.options.mass / Math.pow(t, 3),\n        r = e * n,\n        a = i * n;\n      this.physicsBody.forces[o.id].x += r, this.physicsBody.forces[o.id].y += a;\n    }\n    _formBarnesHutTree(t, e) {\n      let i;\n      const o = e.length;\n      let s = t[e[0]].x,\n        n = t[e[0]].y,\n        r = t[e[0]].x,\n        a = t[e[0]].y;\n      for (let i = 1; i < o; i++) {\n        const o = t[e[i]],\n          h = o.x,\n          d = o.y;\n        o.options.mass > 0 && (h < s && (s = h), h > r && (r = h), d < n && (n = d), d > a && (a = d));\n      }\n      const h = Math.abs(r - s) - Math.abs(a - n);\n      h > 0 ? (n -= .5 * h, a += .5 * h) : (s += .5 * h, r -= .5 * h);\n      const d = Math.max(1e-5, Math.abs(r - s)),\n        l = .5 * d,\n        c = .5 * (s + r),\n        u = .5 * (n + a),\n        p = {\n          root: {\n            centerOfMass: {\n              x: 0,\n              y: 0\n            },\n            mass: 0,\n            range: {\n              minX: c - l,\n              maxX: c + l,\n              minY: u - l,\n              maxY: u + l\n            },\n            size: d,\n            calcSize: 1 / d,\n            children: {\n              data: null\n            },\n            maxWidth: 0,\n            level: 0,\n            childrenCount: 4\n          }\n        };\n      this._splitBranch(p.root);\n      for (let s = 0; s < o; s++) i = t[e[s]], i.options.mass > 0 && this._placeInTree(p.root, i);\n      return p;\n    }\n    _updateBranchMass(t, e) {\n      const i = t.centerOfMass,\n        o = t.mass + e.options.mass,\n        s = 1 / o;\n      i.x = i.x * t.mass + e.x * e.options.mass, i.x *= s, i.y = i.y * t.mass + e.y * e.options.mass, i.y *= s, t.mass = o;\n      const n = Math.max(Math.max(e.height, e.radius), e.width);\n      t.maxWidth = t.maxWidth < n ? n : t.maxWidth;\n    }\n    _placeInTree(t, e, i) {\n      1 == i && void 0 !== i || this._updateBranchMass(t, e);\n      const o = t.children.NW.range;\n      let s;\n      s = o.maxX > e.x ? o.maxY > e.y ? \"NW\" : \"SW\" : o.maxY > e.y ? \"NE\" : \"SE\", this._placeInRegion(t, e, s);\n    }\n    _placeInRegion(t, e, i) {\n      const o = t.children[i];\n      switch (o.childrenCount) {\n        case 0:\n          o.children.data = e, o.childrenCount = 1, this._updateBranchMass(o, e);\n          break;\n        case 1:\n          o.children.data.x === e.x && o.children.data.y === e.y ? (e.x += this._rng(), e.y += this._rng()) : (this._splitBranch(o), this._placeInTree(o, e));\n          break;\n        case 4:\n          this._placeInTree(o, e);\n      }\n    }\n    _splitBranch(t) {\n      let e = null;\n      1 === t.childrenCount && (e = t.children.data, t.mass = 0, t.centerOfMass.x = 0, t.centerOfMass.y = 0), t.childrenCount = 4, t.children.data = null, this._insertRegion(t, \"NW\"), this._insertRegion(t, \"NE\"), this._insertRegion(t, \"SW\"), this._insertRegion(t, \"SE\"), null != e && this._placeInTree(t, e);\n    }\n    _insertRegion(t, e) {\n      let i, o, s, n;\n      const r = .5 * t.size;\n      switch (e) {\n        case \"NW\":\n          i = t.range.minX, o = t.range.minX + r, s = t.range.minY, n = t.range.minY + r;\n          break;\n        case \"NE\":\n          i = t.range.minX + r, o = t.range.maxX, s = t.range.minY, n = t.range.minY + r;\n          break;\n        case \"SW\":\n          i = t.range.minX, o = t.range.minX + r, s = t.range.minY + r, n = t.range.maxY;\n          break;\n        case \"SE\":\n          i = t.range.minX + r, o = t.range.maxX, s = t.range.minY + r, n = t.range.maxY;\n      }\n      t.children[e] = {\n        centerOfMass: {\n          x: 0,\n          y: 0\n        },\n        mass: 0,\n        range: {\n          minX: i,\n          maxX: o,\n          minY: s,\n          maxY: n\n        },\n        size: .5 * t.size,\n        calcSize: 2 * t.calcSize,\n        children: {\n          data: null\n        },\n        maxWidth: 0,\n        level: t.level + 1,\n        childrenCount: 0\n      };\n    }\n    _debug(t, e) {\n      void 0 !== this.barnesHutTree && (t.lineWidth = 1, this._drawBranch(this.barnesHutTree.root, t, e));\n    }\n    _drawBranch(t, e, i) {\n      void 0 === i && (i = \"#FF0000\"), 4 === t.childrenCount && (this._drawBranch(t.children.NW, e), this._drawBranch(t.children.NE, e), this._drawBranch(t.children.SE, e), this._drawBranch(t.children.SW, e)), e.strokeStyle = i, e.beginPath(), e.moveTo(t.range.minX, t.range.minY), e.lineTo(t.range.maxX, t.range.minY), e.stroke(), e.beginPath(), e.moveTo(t.range.maxX, t.range.minY), e.lineTo(t.range.maxX, t.range.maxY), e.stroke(), e.beginPath(), e.moveTo(t.range.maxX, t.range.maxY), e.lineTo(t.range.minX, t.range.maxY), e.stroke(), e.beginPath(), e.moveTo(t.range.minX, t.range.maxY), e.lineTo(t.range.minX, t.range.minY), e.stroke();\n    }\n  }\n  class Yx {\n    constructor(t, e, i) {\n      this._rng = hm(\"REPULSION SOLVER\"), this.body = t, this.physicsBody = e, this.setOptions(i);\n    }\n    setOptions(t) {\n      this.options = t;\n    }\n    solve() {\n      let t, e, i, o, s, n, r, a;\n      const h = this.body.nodes,\n        d = this.physicsBody.physicsNodeIndices,\n        l = this.physicsBody.forces,\n        c = this.options.nodeDistance,\n        u = -2 / 3 / c;\n      for (let p = 0; p < d.length - 1; p++) {\n        r = h[d[p]];\n        for (let g = p + 1; g < d.length; g++) a = h[d[g]], t = a.x - r.x, e = a.y - r.y, i = Math.sqrt(t * t + e * e), 0 === i && (i = .1 * this._rng(), t = i), i < 2 * c && (n = i < .5 * c ? 1 : u * i + 1.3333333333333333, n /= i, o = t * n, s = e * n, l[r.id].x -= o, l[r.id].y -= s, l[a.id].x += o, l[a.id].y += s);\n      }\n    }\n  }\n  class Xx {\n    constructor(t, e, i) {\n      this.body = t, this.physicsBody = e, this.setOptions(i);\n    }\n    setOptions(t) {\n      this.options = t, this.overlapAvoidanceFactor = Math.max(0, Math.min(1, this.options.avoidOverlap || 0));\n    }\n    solve() {\n      const t = this.body.nodes,\n        e = this.physicsBody.physicsNodeIndices,\n        i = this.physicsBody.forces,\n        o = this.options.nodeDistance;\n      for (let s = 0; s < e.length - 1; s++) {\n        const n = t[e[s]];\n        for (let r = s + 1; r < e.length; r++) {\n          const s = t[e[r]];\n          if (n.level === s.level) {\n            const t = o + this.overlapAvoidanceFactor * ((n.shape.radius || 0) / 2 + (s.shape.radius || 0) / 2),\n              e = s.x - n.x,\n              r = s.y - n.y,\n              a = Math.sqrt(e * e + r * r),\n              h = .05;\n            let d;\n            d = a < t ? -Math.pow(h * a, 2) + Math.pow(h * t, 2) : 0, 0 !== a && (d /= a);\n            const l = e * d,\n              c = r * d;\n            i[n.id].x -= l, i[n.id].y -= c, i[s.id].x += l, i[s.id].y += c;\n          }\n        }\n      }\n    }\n  }\n  class Kx {\n    constructor(t, e, i) {\n      this.body = t, this.physicsBody = e, this.setOptions(i);\n    }\n    setOptions(t) {\n      this.options = t;\n    }\n    solve() {\n      let t, e;\n      const i = this.physicsBody.physicsEdgeIndices,\n        o = this.body.edges;\n      let s, n, r;\n      for (let a = 0; a < i.length; a++) e = o[i[a]], !0 === e.connected && e.toId !== e.fromId && void 0 !== this.body.nodes[e.toId] && void 0 !== this.body.nodes[e.fromId] && (void 0 !== e.edgeType.via ? (t = void 0 === e.options.length ? this.options.springLength : e.options.length, s = e.to, n = e.edgeType.via, r = e.from, this._calculateSpringForce(s, n, .5 * t), this._calculateSpringForce(n, r, .5 * t)) : (t = void 0 === e.options.length ? 1.5 * this.options.springLength : e.options.length, this._calculateSpringForce(e.from, e.to, t)));\n    }\n    _calculateSpringForce(t, e, i) {\n      const o = t.x - e.x,\n        s = t.y - e.y,\n        n = Math.max(Math.sqrt(o * o + s * s), .01),\n        r = this.options.springConstant * (i - n) / n,\n        a = o * r,\n        h = s * r;\n      void 0 !== this.physicsBody.forces[t.id] && (this.physicsBody.forces[t.id].x += a, this.physicsBody.forces[t.id].y += h), void 0 !== this.physicsBody.forces[e.id] && (this.physicsBody.forces[e.id].x -= a, this.physicsBody.forces[e.id].y -= h);\n    }\n  }\n  class Gx {\n    constructor(t, e, i) {\n      this.body = t, this.physicsBody = e, this.setOptions(i);\n    }\n    setOptions(t) {\n      this.options = t;\n    }\n    solve() {\n      let t, e, i, o, s, n, r, a;\n      const h = this.body.edges,\n        d = .5,\n        l = this.physicsBody.physicsEdgeIndices,\n        c = this.physicsBody.physicsNodeIndices,\n        u = this.physicsBody.forces;\n      for (let t = 0; t < c.length; t++) {\n        const e = c[t];\n        u[e].springFx = 0, u[e].springFy = 0;\n      }\n      for (let c = 0; c < l.length; c++) e = h[l[c]], !0 === e.connected && (t = void 0 === e.options.length ? this.options.springLength : e.options.length, i = e.from.x - e.to.x, o = e.from.y - e.to.y, a = Math.sqrt(i * i + o * o), a = 0 === a ? .01 : a, r = this.options.springConstant * (t - a) / a, s = i * r, n = o * r, e.to.level != e.from.level ? (void 0 !== u[e.toId] && (u[e.toId].springFx -= s, u[e.toId].springFy -= n), void 0 !== u[e.fromId] && (u[e.fromId].springFx += s, u[e.fromId].springFy += n)) : (void 0 !== u[e.toId] && (u[e.toId].x -= d * s, u[e.toId].y -= d * n), void 0 !== u[e.fromId] && (u[e.fromId].x += d * s, u[e.fromId].y += d * n)));\n      let p, g;\n      r = 1;\n      for (let t = 0; t < c.length; t++) {\n        const e = c[t];\n        p = Math.min(r, Math.max(-r, u[e].springFx)), g = Math.min(r, Math.max(-r, u[e].springFy)), u[e].x += p, u[e].y += g;\n      }\n      let f = 0,\n        m = 0;\n      for (let t = 0; t < c.length; t++) {\n        const e = c[t];\n        f += u[e].x, m += u[e].y;\n      }\n      const y = f / c.length,\n        b = m / c.length;\n      for (let t = 0; t < c.length; t++) {\n        const e = c[t];\n        u[e].x -= y, u[e].y -= b;\n      }\n    }\n  }\n  class Zx {\n    constructor(t, e, i) {\n      this.body = t, this.physicsBody = e, this.setOptions(i);\n    }\n    setOptions(t) {\n      this.options = t;\n    }\n    solve() {\n      let t, e, i, o;\n      const s = this.body.nodes,\n        n = this.physicsBody.physicsNodeIndices,\n        r = this.physicsBody.forces;\n      for (let a = 0; a < n.length; a++) {\n        o = s[n[a]], t = -o.x, e = -o.y, i = Math.sqrt(t * t + e * e), this._calculateForces(i, t, e, r, o);\n      }\n    }\n    _calculateForces(t, e, i, o, s) {\n      const n = 0 === t ? 0 : this.options.centralGravity / t;\n      o[s.id].x = e * n, o[s.id].y = i * n;\n    }\n  }\n  class Qx extends Ux {\n    constructor(t, e, i) {\n      super(t, e, i), this._rng = hm(\"FORCE ATLAS 2 BASED REPULSION SOLVER\");\n    }\n    _calculateForces(t, e, i, o, s) {\n      0 === t && (e = t = .1 * this._rng()), this.overlapAvoidanceFactor < 1 && o.shape.radius && (t = Math.max(.1 + this.overlapAvoidanceFactor * o.shape.radius, t - o.shape.radius));\n      const n = o.edges.length + 1,\n        r = this.options.gravitationalConstant * s.mass * o.options.mass * n / Math.pow(t, 2),\n        a = e * r,\n        h = i * r;\n      this.physicsBody.forces[o.id].x += a, this.physicsBody.forces[o.id].y += h;\n    }\n  }\n  class $x extends Zx {\n    constructor(t, e, i) {\n      super(t, e, i);\n    }\n    _calculateForces(t, e, i, o, s) {\n      if (t > 0) {\n        const t = s.edges.length + 1,\n          n = this.options.centralGravity * t * s.options.mass;\n        o[s.id].x = e * n, o[s.id].y = i * n;\n      }\n    }\n  }\n  class Jx {\n    constructor(t) {\n      this.body = t, this.physicsBody = {\n        physicsNodeIndices: [],\n        physicsEdgeIndices: [],\n        forces: {},\n        velocities: {}\n      }, this.physicsEnabled = !0, this.simulationInterval = 1e3 / 60, this.requiresTimeout = !0, this.previousStates = {}, this.referenceState = {}, this.freezeCache = {}, this.renderTimer = void 0, this.adaptiveTimestep = !1, this.adaptiveTimestepEnabled = !1, this.adaptiveCounter = 0, this.adaptiveInterval = 3, this.stabilized = !1, this.startedStabilization = !1, this.stabilizationIterations = 0, this.ready = !1, this.options = {}, this.defaultOptions = {\n        enabled: !0,\n        barnesHut: {\n          theta: .5,\n          gravitationalConstant: -2e3,\n          centralGravity: .3,\n          springLength: 95,\n          springConstant: .04,\n          damping: .09,\n          avoidOverlap: 0\n        },\n        forceAtlas2Based: {\n          theta: .5,\n          gravitationalConstant: -50,\n          centralGravity: .01,\n          springConstant: .08,\n          springLength: 100,\n          damping: .4,\n          avoidOverlap: 0\n        },\n        repulsion: {\n          centralGravity: .2,\n          springLength: 200,\n          springConstant: .05,\n          nodeDistance: 100,\n          damping: .09,\n          avoidOverlap: 0\n        },\n        hierarchicalRepulsion: {\n          centralGravity: 0,\n          springLength: 100,\n          springConstant: .01,\n          nodeDistance: 120,\n          damping: .09\n        },\n        maxVelocity: 50,\n        minVelocity: .75,\n        solver: \"barnesHut\",\n        stabilization: {\n          enabled: !0,\n          iterations: 1e3,\n          updateInterval: 50,\n          onlyDynamicEdges: !1,\n          fit: !0\n        },\n        timestep: .5,\n        adaptiveTimestep: !0,\n        wind: {\n          x: 0,\n          y: 0\n        }\n      }, wo(this.options, this.defaultOptions), this.timestep = .5, this.layoutFailed = !1, this.bindEventListeners();\n    }\n    bindEventListeners() {\n      this.body.emitter.on(\"initPhysics\", () => {\n        this.initPhysics();\n      }), this.body.emitter.on(\"_layoutFailed\", () => {\n        this.layoutFailed = !0;\n      }), this.body.emitter.on(\"resetPhysics\", () => {\n        this.stopSimulation(), this.ready = !1;\n      }), this.body.emitter.on(\"disablePhysics\", () => {\n        this.physicsEnabled = !1, this.stopSimulation();\n      }), this.body.emitter.on(\"restorePhysics\", () => {\n        this.setOptions(this.options), !0 === this.ready && this.startSimulation();\n      }), this.body.emitter.on(\"startSimulation\", () => {\n        !0 === this.ready && this.startSimulation();\n      }), this.body.emitter.on(\"stopSimulation\", () => {\n        this.stopSimulation();\n      }), this.body.emitter.on(\"destroy\", () => {\n        this.stopSimulation(!1), this.body.emitter.off();\n      }), this.body.emitter.on(\"_dataChanged\", () => {\n        this.updatePhysicsData();\n      });\n    }\n    setOptions(t) {\n      if (void 0 !== t) if (!1 === t) this.options.enabled = !1, this.physicsEnabled = !1, this.stopSimulation();else if (!0 === t) this.options.enabled = !0, this.physicsEnabled = !0, this.startSimulation();else {\n        this.physicsEnabled = !0, _m([\"stabilization\"], this.options, t), Nm(this.options, t, \"stabilization\"), void 0 === t.enabled && (this.options.enabled = !0), !1 === this.options.enabled && (this.physicsEnabled = !1, this.stopSimulation());\n        const e = this.options.wind;\n        e && ((\"number\" != typeof e.x || Lv(e.x)) && (e.x = 0), (\"number\" != typeof e.y || Lv(e.y)) && (e.y = 0)), this.timestep = this.options.timestep;\n      }\n      this.init();\n    }\n    init() {\n      let t;\n      \"forceAtlas2Based\" === this.options.solver ? (t = this.options.forceAtlas2Based, this.nodesSolver = new Qx(this.body, this.physicsBody, t), this.edgesSolver = new Kx(this.body, this.physicsBody, t), this.gravitySolver = new $x(this.body, this.physicsBody, t)) : \"repulsion\" === this.options.solver ? (t = this.options.repulsion, this.nodesSolver = new Yx(this.body, this.physicsBody, t), this.edgesSolver = new Kx(this.body, this.physicsBody, t), this.gravitySolver = new Zx(this.body, this.physicsBody, t)) : \"hierarchicalRepulsion\" === this.options.solver ? (t = this.options.hierarchicalRepulsion, this.nodesSolver = new Xx(this.body, this.physicsBody, t), this.edgesSolver = new Gx(this.body, this.physicsBody, t), this.gravitySolver = new Zx(this.body, this.physicsBody, t)) : (t = this.options.barnesHut, this.nodesSolver = new Ux(this.body, this.physicsBody, t), this.edgesSolver = new Kx(this.body, this.physicsBody, t), this.gravitySolver = new Zx(this.body, this.physicsBody, t)), this.modelOptions = t;\n    }\n    initPhysics() {\n      !0 === this.physicsEnabled && !0 === this.options.enabled ? !0 === this.options.stabilization.enabled ? this.stabilize() : (this.stabilized = !1, this.ready = !0, this.body.emitter.emit(\"fit\", {}, this.layoutFailed), this.startSimulation()) : (this.ready = !0, this.body.emitter.emit(\"fit\"));\n    }\n    startSimulation() {\n      var t;\n      !0 === this.physicsEnabled && !0 === this.options.enabled ? (this.stabilized = !1, this.adaptiveTimestep = !1, this.body.emitter.emit(\"_resizeNodes\"), void 0 === this.viewFunction && (this.viewFunction = Ho(t = this.simulationStep).call(t, this), this.body.emitter.on(\"initRedraw\", this.viewFunction), this.body.emitter.emit(\"_startRendering\"))) : this.body.emitter.emit(\"_redraw\");\n    }\n    stopSimulation() {\n      let t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n      this.stabilized = !0, !0 === t && this._emitStabilized(), void 0 !== this.viewFunction && (this.body.emitter.off(\"initRedraw\", this.viewFunction), this.viewFunction = void 0, !0 === t && this.body.emitter.emit(\"_stopRendering\"));\n    }\n    simulationStep() {\n      const t = oc();\n      this.physicsTick();\n      (oc() - t < .4 * this.simulationInterval || !0 === this.runDoubleSpeed) && !1 === this.stabilized && (this.physicsTick(), this.runDoubleSpeed = !0), !0 === this.stabilized && this.stopSimulation();\n    }\n    _emitStabilized() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.stabilizationIterations;\n      (this.stabilizationIterations > 1 || !0 === this.startedStabilization) && tg(() => {\n        this.body.emitter.emit(\"stabilized\", {\n          iterations: t\n        }), this.startedStabilization = !1, this.stabilizationIterations = 0;\n      }, 0);\n    }\n    physicsStep() {\n      this.gravitySolver.solve(), this.nodesSolver.solve(), this.edgesSolver.solve(), this.moveNodes();\n    }\n    adjustTimeStep() {\n      !0 === this._evaluateStepQuality() ? this.timestep = 1.2 * this.timestep : this.timestep / 1.2 < this.options.timestep ? this.timestep = this.options.timestep : (this.adaptiveCounter = -1, this.timestep = Math.max(this.options.timestep, this.timestep / 1.2));\n    }\n    physicsTick() {\n      if (this._startStabilizing(), !0 !== this.stabilized) {\n        if (!0 === this.adaptiveTimestep && !0 === this.adaptiveTimestepEnabled) {\n          this.adaptiveCounter % this.adaptiveInterval == 0 ? (this.timestep = 2 * this.timestep, this.physicsStep(), this.revert(), this.timestep = .5 * this.timestep, this.physicsStep(), this.physicsStep(), this.adjustTimeStep()) : this.physicsStep(), this.adaptiveCounter += 1;\n        } else this.timestep = this.options.timestep, this.physicsStep();\n        !0 === this.stabilized && this.revert(), this.stabilizationIterations++;\n      }\n    }\n    updatePhysicsData() {\n      this.physicsBody.forces = {}, this.physicsBody.physicsNodeIndices = [], this.physicsBody.physicsEdgeIndices = [];\n      const t = this.body.nodes,\n        e = this.body.edges;\n      for (const e in t) Object.prototype.hasOwnProperty.call(t, e) && !0 === t[e].options.physics && this.physicsBody.physicsNodeIndices.push(t[e].id);\n      for (const t in e) Object.prototype.hasOwnProperty.call(e, t) && !0 === e[t].options.physics && this.physicsBody.physicsEdgeIndices.push(e[t].id);\n      for (let t = 0; t < this.physicsBody.physicsNodeIndices.length; t++) {\n        const e = this.physicsBody.physicsNodeIndices[t];\n        this.physicsBody.forces[e] = {\n          x: 0,\n          y: 0\n        }, void 0 === this.physicsBody.velocities[e] && (this.physicsBody.velocities[e] = {\n          x: 0,\n          y: 0\n        });\n      }\n      for (const e in this.physicsBody.velocities) void 0 === t[e] && delete this.physicsBody.velocities[e];\n    }\n    revert() {\n      const t = Jl(this.previousStates),\n        e = this.body.nodes,\n        i = this.physicsBody.velocities;\n      this.referenceState = {};\n      for (let o = 0; o < t.length; o++) {\n        const s = t[o];\n        void 0 !== e[s] ? !0 === e[s].options.physics && (this.referenceState[s] = {\n          positions: {\n            x: e[s].x,\n            y: e[s].y\n          }\n        }, i[s].x = this.previousStates[s].vx, i[s].y = this.previousStates[s].vy, e[s].x = this.previousStates[s].x, e[s].y = this.previousStates[s].y) : delete this.previousStates[s];\n      }\n    }\n    _evaluateStepQuality() {\n      let t, e, i;\n      const o = this.body.nodes,\n        s = this.referenceState;\n      for (const n in this.referenceState) if (Object.prototype.hasOwnProperty.call(this.referenceState, n) && void 0 !== o[n] && (t = o[n].x - s[n].positions.x, e = o[n].y - s[n].positions.y, i = Math.sqrt(Math.pow(t, 2) + Math.pow(e, 2)), i > .3)) return !1;\n      return !0;\n    }\n    moveNodes() {\n      const t = this.physicsBody.physicsNodeIndices;\n      let e = 0,\n        i = 0;\n      for (let o = 0; o < t.length; o++) {\n        const s = t[o],\n          n = this._performStep(s);\n        e = Math.max(e, n), i += n;\n      }\n      this.adaptiveTimestepEnabled = i / t.length < 5, this.stabilized = e < this.options.minVelocity;\n    }\n    calculateComponentVelocity(t, e, i) {\n      t += (e - this.modelOptions.damping * t) / i * this.timestep;\n      const o = this.options.maxVelocity || 1e9;\n      return Math.abs(t) > o && (t = t > 0 ? o : -o), t;\n    }\n    _performStep(t) {\n      const e = this.body.nodes[t],\n        i = this.physicsBody.forces[t];\n      this.options.wind && (i.x += this.options.wind.x, i.y += this.options.wind.y);\n      const o = this.physicsBody.velocities[t];\n      this.previousStates[t] = {\n        x: e.x,\n        y: e.y,\n        vx: o.x,\n        vy: o.y\n      }, !1 === e.options.fixed.x ? (o.x = this.calculateComponentVelocity(o.x, i.x, e.options.mass), e.x += o.x * this.timestep) : (i.x = 0, o.x = 0), !1 === e.options.fixed.y ? (o.y = this.calculateComponentVelocity(o.y, i.y, e.options.mass), e.y += o.y * this.timestep) : (i.y = 0, o.y = 0);\n      return Math.sqrt(Math.pow(o.x, 2) + Math.pow(o.y, 2));\n    }\n    _freezeNodes() {\n      const t = this.body.nodes;\n      for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e) && t[e].x && t[e].y) {\n        const i = t[e].options.fixed;\n        this.freezeCache[e] = {\n          x: i.x,\n          y: i.y\n        }, i.x = !0, i.y = !0;\n      }\n    }\n    _restoreFrozenNodes() {\n      const t = this.body.nodes;\n      for (const e in t) Object.prototype.hasOwnProperty.call(t, e) && void 0 !== this.freezeCache[e] && (t[e].options.fixed.x = this.freezeCache[e].x, t[e].options.fixed.y = this.freezeCache[e].y);\n      this.freezeCache = {};\n    }\n    stabilize() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options.stabilization.iterations;\n      \"number\" != typeof t && (t = this.options.stabilization.iterations, console.error(\"The stabilize method needs a numeric amount of iterations. Switching to default: \", t)), 0 !== this.physicsBody.physicsNodeIndices.length ? (this.adaptiveTimestep = this.options.adaptiveTimestep, this.body.emitter.emit(\"_resizeNodes\"), this.stopSimulation(), this.stabilized = !1, this.body.emitter.emit(\"_blockRedraw\"), this.targetIterations = t, !0 === this.options.stabilization.onlyDynamicEdges && this._freezeNodes(), this.stabilizationIterations = 0, tg(() => this._stabilizationBatch(), 0)) : this.ready = !0;\n    }\n    _startStabilizing() {\n      return !0 !== this.startedStabilization && (this.body.emitter.emit(\"startStabilizing\"), this.startedStabilization = !0, !0);\n    }\n    _stabilizationBatch() {\n      const t = () => !1 === this.stabilized && this.stabilizationIterations < this.targetIterations,\n        e = () => {\n          this.body.emitter.emit(\"stabilizationProgress\", {\n            iterations: this.stabilizationIterations,\n            total: this.targetIterations\n          });\n        };\n      this._startStabilizing() && e();\n      let i = 0;\n      for (; t() && i < this.options.stabilization.updateInterval;) this.physicsTick(), i++;\n      var o;\n      (e(), t()) ? tg(Ho(o = this._stabilizationBatch).call(o, this), 0) : this._finalizeStabilization();\n    }\n    _finalizeStabilization() {\n      this.body.emitter.emit(\"_allowRedraw\"), !0 === this.options.stabilization.fit && this.body.emitter.emit(\"fit\"), !0 === this.options.stabilization.onlyDynamicEdges && this._restoreFrozenNodes(), this.body.emitter.emit(\"stabilizationIterationsDone\"), this.body.emitter.emit(\"_requestRedraw\"), !0 === this.stabilized ? this._emitStabilized() : this.startSimulation(), this.ready = !0;\n    }\n    _drawForces(t) {\n      for (let e = 0; e < this.physicsBody.physicsNodeIndices.length; e++) {\n        const i = this.physicsBody.physicsNodeIndices[e],\n          o = this.body.nodes[i],\n          s = this.physicsBody.forces[i],\n          n = 20,\n          r = .03,\n          a = Math.sqrt(Math.pow(s.x, 2) + Math.pow(s.x, 2)),\n          h = Math.min(Math.max(5, a), 15),\n          d = 3 * h,\n          l = Pm((180 - 180 * Math.min(1, Math.max(0, r * a))) / 360, 1, 1),\n          c = {\n            x: o.x + n * s.x,\n            y: o.y + n * s.y\n          };\n        t.lineWidth = h, t.strokeStyle = l, t.beginPath(), t.moveTo(o.x, o.y), t.lineTo(c.x, c.y), t.stroke();\n        const u = Math.atan2(s.y, s.x);\n        t.fillStyle = l, Ix.draw(t, {\n          type: \"arrow\",\n          point: c,\n          angle: u,\n          length: d\n        }), cg(t).call(t);\n      }\n    }\n  }\n  const tE = new Uint8Array(16);\n  function eE() {\n    if (!bx && (bx = \"undefined\" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !bx)) throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n    return bx(tE);\n  }\n  const iE = [];\n  for (let t = 0; t < 256; ++t) iE.push((t + 256).toString(16).slice(1));\n  var oE = {\n    randomUUID: \"undefined\" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto)\n  };\n  function sE(t, e, i) {\n    if (oE.randomUUID && !e && !t) return oE.randomUUID();\n    const o = (t = t || {}).random || (t.rng || eE)();\n    if (o[6] = 15 & o[6] | 64, o[8] = 63 & o[8] | 128, e) {\n      i = i || 0;\n      for (let t = 0; t < 16; ++t) e[i + t] = o[t];\n      return e;\n    }\n    return function (t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return iE[t[e + 0]] + iE[t[e + 1]] + iE[t[e + 2]] + iE[t[e + 3]] + \"-\" + iE[t[e + 4]] + iE[t[e + 5]] + \"-\" + iE[t[e + 6]] + iE[t[e + 7]] + \"-\" + iE[t[e + 8]] + iE[t[e + 9]] + \"-\" + iE[t[e + 10]] + iE[t[e + 11]] + iE[t[e + 12]] + iE[t[e + 13]] + iE[t[e + 14]] + iE[t[e + 15]];\n    }(o);\n  }\n  class nE {\n    constructor() {}\n    static getRange(t) {\n      let e,\n        i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],\n        o = 1e9,\n        s = -1e9,\n        n = 1e9,\n        r = -1e9;\n      if (i.length > 0) for (let a = 0; a < i.length; a++) e = t[i[a]], n > e.shape.boundingBox.left && (n = e.shape.boundingBox.left), r < e.shape.boundingBox.right && (r = e.shape.boundingBox.right), o > e.shape.boundingBox.top && (o = e.shape.boundingBox.top), s < e.shape.boundingBox.bottom && (s = e.shape.boundingBox.bottom);\n      return 1e9 === n && -1e9 === r && 1e9 === o && -1e9 === s && (o = 0, s = 0, n = 0, r = 0), {\n        minX: n,\n        maxX: r,\n        minY: o,\n        maxY: s\n      };\n    }\n    static getRangeCore(t) {\n      let e,\n        i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],\n        o = 1e9,\n        s = -1e9,\n        n = 1e9,\n        r = -1e9;\n      if (i.length > 0) for (let a = 0; a < i.length; a++) e = t[i[a]], n > e.x && (n = e.x), r < e.x && (r = e.x), o > e.y && (o = e.y), s < e.y && (s = e.y);\n      return 1e9 === n && -1e9 === r && 1e9 === o && -1e9 === s && (o = 0, s = 0, n = 0, r = 0), {\n        minX: n,\n        maxX: r,\n        minY: o,\n        maxY: s\n      };\n    }\n    static findCenter(t) {\n      return {\n        x: .5 * (t.maxX + t.minX),\n        y: .5 * (t.maxY + t.minY)\n      };\n    }\n    static cloneOptions(t, e) {\n      const i = {};\n      return void 0 === e || \"node\" === e ? (xm(i, t.options, !0), i.x = t.x, i.y = t.y, i.amountOfConnections = t.edges.length) : xm(i, t.options, !0), i;\n    }\n  }\n  class rE extends lx {\n    constructor(t, e, i, o, s, n) {\n      super(t, e, i, o, s, n), this.isCluster = !0, this.containedNodes = {}, this.containedEdges = {};\n    }\n    _openChildCluster(t) {\n      const e = this.body.nodes[t];\n      if (void 0 === this.containedNodes[t]) throw new Error(\"node with id: \" + t + \" not in current cluster\");\n      if (!e.isCluster) throw new Error(\"node with id: \" + t + \" is not a cluster\");\n      delete this.containedNodes[t], Cm(e.edges, t => {\n        delete this.containedEdges[t.id];\n      }), Cm(e.containedNodes, (t, e) => {\n        this.containedNodes[e] = t;\n      }), e.containedNodes = {}, Cm(e.containedEdges, (t, e) => {\n        this.containedEdges[e] = t;\n      }), e.containedEdges = {}, Cm(e.edges, t => {\n        Cm(this.edges, e => {\n          var i, o;\n          const s = Mp(i = e.clusteringEdgeReplacingIds).call(i, t.id);\n          -1 !== s && (Cm(t.clusteringEdgeReplacingIds, t => {\n            e.clusteringEdgeReplacingIds.push(t), this.body.edges[t].edgeReplacedById = e.id;\n          }), Jc(o = e.clusteringEdgeReplacingIds).call(o, s, 1));\n        });\n      }), e.edges = [];\n    }\n  }\n  class aE {\n    constructor(t) {\n      this.body = t, this.clusteredNodes = {}, this.clusteredEdges = {}, this.options = {}, this.defaultOptions = {}, wo(this.options, this.defaultOptions), this.body.emitter.on(\"_resetData\", () => {\n        this.clusteredNodes = {}, this.clusteredEdges = {};\n      });\n    }\n    clusterByHubsize(t, e) {\n      void 0 === t ? t = this._getHubSize() : \"object\" == typeof t && (e = this._checkOptions(t), t = this._getHubSize());\n      const i = [];\n      for (let e = 0; e < this.body.nodeIndices.length; e++) {\n        const o = this.body.nodes[this.body.nodeIndices[e]];\n        o.edges.length >= t && i.push(o.id);\n      }\n      for (let t = 0; t < i.length; t++) this.clusterByConnection(i[t], e, !0);\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n    cluster() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n        e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      if (void 0 === t.joinCondition) throw new Error(\"Cannot call clusterByNodeData without a joinCondition function in the options.\");\n      t = this._checkOptions(t);\n      const i = {},\n        o = {};\n      Cm(this.body.nodes, (e, s) => {\n        e.options && !0 === t.joinCondition(e.options) && (i[s] = e, Cm(e.edges, t => {\n          void 0 === this.clusteredEdges[t.id] && (o[t.id] = t);\n        }));\n      }), this._cluster(i, o, t, e);\n    }\n    clusterByEdgeCount(t, e) {\n      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];\n      e = this._checkOptions(e);\n      const o = [],\n        s = {};\n      let n, r, a;\n      for (let i = 0; i < this.body.nodeIndices.length; i++) {\n        const h = {},\n          d = {},\n          l = this.body.nodeIndices[i],\n          c = this.body.nodes[l];\n        if (void 0 === s[l]) {\n          a = 0, r = [];\n          for (let t = 0; t < c.edges.length; t++) n = c.edges[t], void 0 === this.clusteredEdges[n.id] && (n.toId !== n.fromId && a++, r.push(n));\n          if (a === t) {\n            const t = function (t) {\n              if (void 0 === e.joinCondition || null === e.joinCondition) return !0;\n              const i = nE.cloneOptions(t);\n              return e.joinCondition(i);\n            };\n            let i = !0;\n            for (let e = 0; e < r.length; e++) {\n              n = r[e];\n              const o = this._getConnectedId(n, l);\n              if (!t(c)) {\n                i = !1;\n                break;\n              }\n              d[n.id] = n, h[l] = c, h[o] = this.body.nodes[o], s[l] = !0;\n            }\n            if (Jl(h).length > 0 && Jl(d).length > 0 && !0 === i) {\n              const t = function () {\n                for (let t = 0; t < o.length; ++t) for (const e in h) if (void 0 !== o[t].nodes[e]) return o[t];\n              }();\n              if (void 0 !== t) {\n                for (const e in h) void 0 === t.nodes[e] && (t.nodes[e] = h[e]);\n                for (const e in d) void 0 === t.edges[e] && (t.edges[e] = d[e]);\n              } else o.push({\n                nodes: h,\n                edges: d\n              });\n            }\n          }\n        }\n      }\n      for (let t = 0; t < o.length; t++) this._cluster(o[t].nodes, o[t].edges, e, !1);\n      !0 === i && this.body.emitter.emit(\"_dataChanged\");\n    }\n    clusterOutliers(t) {\n      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      this.clusterByEdgeCount(1, t, e);\n    }\n    clusterBridges(t) {\n      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      this.clusterByEdgeCount(2, t, e);\n    }\n    clusterByConnection(t, e) {\n      var i;\n      let o = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];\n      if (void 0 === t) throw new Error(\"No nodeId supplied to clusterByConnection!\");\n      if (void 0 === this.body.nodes[t]) throw new Error(\"The nodeId given to clusterByConnection does not exist!\");\n      const s = this.body.nodes[t];\n      void 0 === (e = this._checkOptions(e, s)).clusterNodeProperties.x && (e.clusterNodeProperties.x = s.x), void 0 === e.clusterNodeProperties.y && (e.clusterNodeProperties.y = s.y), void 0 === e.clusterNodeProperties.fixed && (e.clusterNodeProperties.fixed = {}, e.clusterNodeProperties.fixed.x = s.options.fixed.x, e.clusterNodeProperties.fixed.y = s.options.fixed.y);\n      const n = {},\n        r = {},\n        a = s.id,\n        h = nE.cloneOptions(s);\n      n[a] = s;\n      for (let t = 0; t < s.edges.length; t++) {\n        const i = s.edges[t];\n        if (void 0 === this.clusteredEdges[i.id]) {\n          const t = this._getConnectedId(i, a);\n          if (void 0 === this.clusteredNodes[t]) if (t !== a) {\n            if (void 0 === e.joinCondition) r[i.id] = i, n[t] = this.body.nodes[t];else {\n              const o = nE.cloneOptions(this.body.nodes[t]);\n              !0 === e.joinCondition(h, o) && (r[i.id] = i, n[t] = this.body.nodes[t]);\n            }\n          } else r[i.id] = i;\n        }\n      }\n      const d = Zl(i = Jl(n)).call(i, function (t) {\n        return n[t].id;\n      });\n      for (const t in n) {\n        if (!Object.prototype.hasOwnProperty.call(n, t)) continue;\n        const e = n[t];\n        for (let t = 0; t < e.edges.length; t++) {\n          const i = e.edges[t];\n          Mp(d).call(d, this._getConnectedId(i, e.id)) > -1 && (r[i.id] = i);\n        }\n      }\n      this._cluster(n, r, e, o);\n    }\n    _createClusterEdges(t, e, i, o) {\n      let s, n, r, a, h, d;\n      const l = Jl(t),\n        c = [];\n      for (let o = 0; o < l.length; o++) {\n        n = l[o], r = t[n];\n        for (let o = 0; o < r.edges.length; o++) s = r.edges[o], void 0 === this.clusteredEdges[s.id] && (s.toId == s.fromId ? e[s.id] = s : s.toId == n ? (a = i.id, h = s.fromId, d = h) : (a = s.toId, h = i.id, d = a), void 0 === t[d] && c.push({\n          edge: s,\n          fromId: h,\n          toId: a\n        }));\n      }\n      const u = [],\n        p = function (t) {\n          for (let e = 0; e < u.length; e++) {\n            const i = u[e],\n              o = t.fromId === i.fromId && t.toId === i.toId,\n              s = t.fromId === i.toId && t.toId === i.fromId;\n            if (o || s) return i;\n          }\n          return null;\n        };\n      for (let t = 0; t < c.length; t++) {\n        const e = c[t],\n          i = e.edge;\n        let s = p(e);\n        null === s ? (s = this._createClusteredEdge(e.fromId, e.toId, i, o), u.push(s)) : s.clusteringEdgeReplacingIds.push(i.id), this.body.edges[i.id].edgeReplacedById = s.id, this._backupEdgeOptions(i), i.setOptions({\n          physics: !1\n        });\n      }\n    }\n    _checkOptions() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n      return void 0 === t.clusterEdgeProperties && (t.clusterEdgeProperties = {}), void 0 === t.clusterNodeProperties && (t.clusterNodeProperties = {}), t;\n    }\n    _cluster(t, e, i) {\n      let o = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];\n      const s = [];\n      for (const e in t) Object.prototype.hasOwnProperty.call(t, e) && void 0 !== this.clusteredNodes[e] && s.push(e);\n      for (let e = 0; e < s.length; ++e) delete t[s[e]];\n      if (0 == Jl(t).length) return;\n      if (1 == Jl(t).length && 1 != i.clusterNodeProperties.allowSingleNodeCluster) return;\n      let n = xm({}, i.clusterNodeProperties);\n      if (void 0 !== i.processProperties) {\n        const o = [];\n        for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) {\n          const i = nE.cloneOptions(t[e]);\n          o.push(i);\n        }\n        const s = [];\n        for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t) && \"clusterEdge:\" !== t.substr(0, 12)) {\n          const i = nE.cloneOptions(e[t], \"edge\");\n          s.push(i);\n        }\n        if (n = i.processProperties(n, o, s), !n) throw new Error(\"The processProperties function does not return properties!\");\n      }\n      void 0 === n.id && (n.id = \"cluster:\" + sE());\n      const r = n.id;\n      let a;\n      void 0 === n.label && (n.label = \"cluster\"), void 0 === n.x && (a = this._getClusterPosition(t), n.x = a.x), void 0 === n.y && (void 0 === a && (a = this._getClusterPosition(t)), n.y = a.y), n.id = r;\n      const h = this.body.functions.createNode(n, rE);\n      h.containedNodes = t, h.containedEdges = e, h.clusterEdgeProperties = i.clusterEdgeProperties, this.body.nodes[n.id] = h, this._clusterEdges(t, e, n, i.clusterEdgeProperties), n.id = void 0, !0 === o && this.body.emitter.emit(\"_dataChanged\");\n    }\n    _backupEdgeOptions(t) {\n      void 0 === this.clusteredEdges[t.id] && (this.clusteredEdges[t.id] = {\n        physics: t.options.physics\n      });\n    }\n    _restoreEdge(t) {\n      const e = this.clusteredEdges[t.id];\n      void 0 !== e && (t.setOptions({\n        physics: e.physics\n      }), delete this.clusteredEdges[t.id]);\n    }\n    isCluster(t) {\n      return void 0 !== this.body.nodes[t] ? !0 === this.body.nodes[t].isCluster : (console.error(\"Node does not exist.\"), !1);\n    }\n    _getClusterPosition(t) {\n      const e = Jl(t);\n      let i,\n        o = t[e[0]].x,\n        s = t[e[0]].x,\n        n = t[e[0]].y,\n        r = t[e[0]].y;\n      for (let a = 1; a < e.length; a++) i = t[e[a]], o = i.x < o ? i.x : o, s = i.x > s ? i.x : s, n = i.y < n ? i.y : n, r = i.y > r ? i.y : r;\n      return {\n        x: .5 * (o + s),\n        y: .5 * (n + r)\n      };\n    }\n    openCluster(t, e) {\n      let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];\n      if (void 0 === t) throw new Error(\"No clusterNodeId supplied to openCluster.\");\n      const o = this.body.nodes[t];\n      if (void 0 === o) throw new Error(\"The clusterNodeId supplied to openCluster does not exist.\");\n      if (!0 !== o.isCluster || void 0 === o.containedNodes || void 0 === o.containedEdges) throw new Error(\"The node:\" + t + \" is not a valid cluster.\");\n      const s = this.findNode(t),\n        n = Mp(s).call(s, t) - 1;\n      if (n >= 0) {\n        const e = s[n];\n        return this.body.nodes[e]._openChildCluster(t), delete this.body.nodes[t], void (!0 === i && this.body.emitter.emit(\"_dataChanged\"));\n      }\n      const r = o.containedNodes,\n        a = o.containedEdges;\n      if (void 0 !== e && void 0 !== e.releaseFunction && \"function\" == typeof e.releaseFunction) {\n        const t = {},\n          i = {\n            x: o.x,\n            y: o.y\n          };\n        for (const e in r) if (Object.prototype.hasOwnProperty.call(r, e)) {\n          const i = this.body.nodes[e];\n          t[e] = {\n            x: i.x,\n            y: i.y\n          };\n        }\n        const s = e.releaseFunction(i, t);\n        for (const t in r) if (Object.prototype.hasOwnProperty.call(r, t)) {\n          const e = this.body.nodes[t];\n          void 0 !== s[t] && (e.x = void 0 === s[t].x ? o.x : s[t].x, e.y = void 0 === s[t].y ? o.y : s[t].y);\n        }\n      } else Cm(r, function (t) {\n        !1 === t.options.fixed.x && (t.x = o.x), !1 === t.options.fixed.y && (t.y = o.y);\n      });\n      for (const t in r) if (Object.prototype.hasOwnProperty.call(r, t)) {\n        const e = this.body.nodes[t];\n        e.vx = o.vx, e.vy = o.vy, e.setOptions({\n          physics: !0\n        }), delete this.clusteredNodes[t];\n      }\n      const h = [];\n      for (let t = 0; t < o.edges.length; t++) h.push(o.edges[t]);\n      for (let e = 0; e < h.length; e++) {\n        const i = h[e],\n          o = this._getConnectedId(i, t),\n          s = this.clusteredNodes[o];\n        for (let t = 0; t < i.clusteringEdgeReplacingIds.length; t++) {\n          const e = i.clusteringEdgeReplacingIds[t],\n            n = this.body.edges[e];\n          if (void 0 !== n) if (void 0 !== s) {\n            const t = this.body.nodes[s.clusterId];\n            t.containedEdges[n.id] = n, delete a[n.id];\n            let e = n.fromId,\n              i = n.toId;\n            n.toId == o ? i = s.clusterId : e = s.clusterId, this._createClusteredEdge(e, i, n, t.clusterEdgeProperties, {\n              hidden: !1,\n              physics: !0\n            });\n          } else this._restoreEdge(n);\n        }\n        i.remove();\n      }\n      for (const t in a) Object.prototype.hasOwnProperty.call(a, t) && this._restoreEdge(a[t]);\n      delete this.body.nodes[t], !0 === i && this.body.emitter.emit(\"_dataChanged\");\n    }\n    getNodesInCluster(t) {\n      const e = [];\n      if (!0 === this.isCluster(t)) {\n        const i = this.body.nodes[t].containedNodes;\n        for (const t in i) Object.prototype.hasOwnProperty.call(i, t) && e.push(this.body.nodes[t].id);\n      }\n      return e;\n    }\n    findNode(t) {\n      const e = [];\n      let i,\n        o = 0;\n      for (; void 0 !== this.clusteredNodes[t] && o < 100;) {\n        if (i = this.body.nodes[t], void 0 === i) return [];\n        e.push(i.id), t = this.clusteredNodes[t].clusterId, o++;\n      }\n      return i = this.body.nodes[t], void 0 === i ? [] : (e.push(i.id), kc(e).call(e), e);\n    }\n    updateClusteredNode(t, e) {\n      if (void 0 === t) throw new Error(\"No clusteredNodeId supplied to updateClusteredNode.\");\n      if (void 0 === e) throw new Error(\"No newOptions supplied to updateClusteredNode.\");\n      if (void 0 === this.body.nodes[t]) throw new Error(\"The clusteredNodeId supplied to updateClusteredNode does not exist.\");\n      this.body.nodes[t].setOptions(e), this.body.emitter.emit(\"_dataChanged\");\n    }\n    updateEdge(t, e) {\n      if (void 0 === t) throw new Error(\"No startEdgeId supplied to updateEdge.\");\n      if (void 0 === e) throw new Error(\"No newOptions supplied to updateEdge.\");\n      if (void 0 === this.body.edges[t]) throw new Error(\"The startEdgeId supplied to updateEdge does not exist.\");\n      const i = this.getClusteredEdges(t);\n      for (let t = 0; t < i.length; t++) {\n        this.body.edges[i[t]].setOptions(e);\n      }\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n    getClusteredEdges(t) {\n      const e = [];\n      let i = 0;\n      for (; void 0 !== t && void 0 !== this.body.edges[t] && i < 100;) e.push(this.body.edges[t].id), t = this.body.edges[t].edgeReplacedById, i++;\n      return kc(e).call(e), e;\n    }\n    getBaseEdge(t) {\n      return this.getBaseEdges(t)[0];\n    }\n    getBaseEdges(t) {\n      const e = [t],\n        i = [],\n        o = [];\n      let s = 0;\n      for (; e.length > 0 && s < 100;) {\n        const t = e.pop();\n        if (void 0 === t) continue;\n        const n = this.body.edges[t];\n        if (void 0 === n) continue;\n        s++;\n        const r = n.clusteringEdgeReplacingIds;\n        if (void 0 === r) o.push(t);else for (let t = 0; t < r.length; ++t) {\n          const o = r[t];\n          -1 === Mp(e).call(e, r) && -1 === Mp(i).call(i, r) && e.push(o);\n        }\n        i.push(t);\n      }\n      return o;\n    }\n    _getConnectedId(t, e) {\n      return t.toId != e ? t.toId : (t.fromId, t.fromId);\n    }\n    _getHubSize() {\n      let t = 0,\n        e = 0,\n        i = 0,\n        o = 0;\n      for (let s = 0; s < this.body.nodeIndices.length; s++) {\n        const n = this.body.nodes[this.body.nodeIndices[s]];\n        n.edges.length > o && (o = n.edges.length), t += n.edges.length, e += Math.pow(n.edges.length, 2), i += 1;\n      }\n      t /= i, e /= i;\n      const s = e - Math.pow(t, 2),\n        n = Math.sqrt(s);\n      let r = Math.floor(t + 2 * n);\n      return r > o && (r = o), r;\n    }\n    _createClusteredEdge(t, e, i, o, s) {\n      const n = nE.cloneOptions(i, \"edge\");\n      xm(n, o), n.from = t, n.to = e, n.id = \"clusterEdge:\" + sE(), void 0 !== s && xm(n, s);\n      const r = this.body.functions.createEdge(n);\n      return r.clusteringEdgeReplacingIds = [i.id], r.connect(), this.body.edges[r.id] = r, r;\n    }\n    _clusterEdges(t, e, i, o) {\n      if (e instanceof Vx) {\n        const t = e,\n          i = {};\n        i[t.id] = t, e = i;\n      }\n      if (t instanceof lx) {\n        const e = t,\n          i = {};\n        i[e.id] = e, t = i;\n      }\n      if (null == i) throw new Error(\"_clusterEdges: parameter clusterNode required\");\n      void 0 === o && (o = i.clusterEdgeProperties), this._createClusterEdges(t, e, i, o);\n      for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t) && void 0 !== this.body.edges[t]) {\n        const e = this.body.edges[t];\n        this._backupEdgeOptions(e), e.setOptions({\n          physics: !1\n        });\n      }\n      for (const e in t) Object.prototype.hasOwnProperty.call(t, e) && (this.clusteredNodes[e] = {\n        clusterId: i.id,\n        node: this.body.nodes[e]\n      }, this.body.nodes[e].setOptions({\n        physics: !1\n      }));\n    }\n    _getClusterNodeForNode(t) {\n      if (void 0 === t) return;\n      const e = this.clusteredNodes[t];\n      if (void 0 === e) return;\n      const i = e.clusterId;\n      return void 0 !== i ? this.body.nodes[i] : void 0;\n    }\n    _filter(t, e) {\n      const i = [];\n      return Cm(t, t => {\n        e(t) && i.push(t);\n      }), i;\n    }\n    _updateState() {\n      let t;\n      const e = [],\n        i = {},\n        o = t => {\n          Cm(this.body.nodes, e => {\n            !0 === e.isCluster && t(e);\n          });\n        };\n      for (t in this.clusteredNodes) {\n        if (!Object.prototype.hasOwnProperty.call(this.clusteredNodes, t)) continue;\n        void 0 === this.body.nodes[t] && e.push(t);\n      }\n      o(function (t) {\n        for (let i = 0; i < e.length; i++) delete t.containedNodes[e[i]];\n      });\n      for (let t = 0; t < e.length; t++) delete this.clusteredNodes[e[t]];\n      Cm(this.clusteredEdges, t => {\n        const e = this.body.edges[t];\n        void 0 !== e && e.endPointsValid() || (i[t] = t);\n      }), o(function (t) {\n        Cm(t.containedEdges, (t, e) => {\n          t.endPointsValid() || i[e] || (i[e] = e);\n        });\n      }), Cm(this.body.edges, (t, e) => {\n        let o = !0;\n        const s = t.clusteringEdgeReplacingIds;\n        if (void 0 !== s) {\n          let t = 0;\n          Cm(s, e => {\n            const i = this.body.edges[e];\n            void 0 !== i && i.endPointsValid() && (t += 1);\n          }), o = t > 0;\n        }\n        t.endPointsValid() && o || (i[e] = e);\n      }), o(t => {\n        Cm(i, e => {\n          delete t.containedEdges[e], Cm(t.edges, (o, s) => {\n            o.id !== e ? o.clusteringEdgeReplacingIds = this._filter(o.clusteringEdgeReplacingIds, function (t) {\n              return !i[t];\n            }) : t.edges[s] = null;\n          }), t.edges = this._filter(t.edges, function (t) {\n            return null !== t;\n          });\n        });\n      }), Cm(i, t => {\n        delete this.clusteredEdges[t];\n      }), Cm(i, t => {\n        delete this.body.edges[t];\n      });\n      Cm(Jl(this.body.edges), t => {\n        const e = this.body.edges[t],\n          i = this._isClusteredNode(e.fromId) || this._isClusteredNode(e.toId);\n        if (i !== this._isClusteredEdge(e.id)) if (i) {\n          const t = this._getClusterNodeForNode(e.fromId);\n          void 0 !== t && this._clusterEdges(this.body.nodes[e.fromId], e, t);\n          const i = this._getClusterNodeForNode(e.toId);\n          void 0 !== i && this._clusterEdges(this.body.nodes[e.toId], e, i);\n        } else delete this._clusterEdges[t], this._restoreEdge(e);\n      });\n      let s = !1,\n        n = !0;\n      for (; n;) {\n        const t = [];\n        o(function (e) {\n          const i = Jl(e.containedNodes).length,\n            o = !0 === e.options.allowSingleNodeCluster;\n          (o && i < 1 || !o && i < 2) && t.push(e.id);\n        });\n        for (let e = 0; e < t.length; ++e) this.openCluster(t[e], {}, !1);\n        n = t.length > 0, s = s || n;\n      }\n      s && this._updateState();\n    }\n    _isClusteredNode(t) {\n      return void 0 !== this.clusteredNodes[t];\n    }\n    _isClusteredEdge(t) {\n      return void 0 !== this.clusteredEdges[t];\n    }\n  }\n  class hE {\n    constructor(t, e) {\n      this.body = t, this.canvas = e, this.redrawRequested = !1, this.requestAnimationFrameRequestId = void 0, this.renderingActive = !1, this.renderRequests = 0, this.allowRedraw = !0, this.dragging = !1, this.zooming = !1, this.options = {}, this.defaultOptions = {\n        hideEdgesOnDrag: !1,\n        hideEdgesOnZoom: !1,\n        hideNodesOnDrag: !1\n      }, wo(this.options, this.defaultOptions), this.bindEventListeners();\n    }\n    bindEventListeners() {\n      var t;\n      this.body.emitter.on(\"dragStart\", () => {\n        this.dragging = !0;\n      }), this.body.emitter.on(\"dragEnd\", () => {\n        this.dragging = !1;\n      }), this.body.emitter.on(\"zoom\", () => {\n        this.zooming = !0, window.clearTimeout(this.zoomTimeoutId), this.zoomTimeoutId = tg(() => {\n          var t;\n          this.zooming = !1, Ho(t = this._requestRedraw).call(t, this)();\n        }, 250);\n      }), this.body.emitter.on(\"_resizeNodes\", () => {\n        this._resizeNodes();\n      }), this.body.emitter.on(\"_redraw\", () => {\n        !1 === this.renderingActive && this._redraw();\n      }), this.body.emitter.on(\"_blockRedraw\", () => {\n        this.allowRedraw = !1;\n      }), this.body.emitter.on(\"_allowRedraw\", () => {\n        this.allowRedraw = !0, this.redrawRequested = !1;\n      }), this.body.emitter.on(\"_requestRedraw\", Ho(t = this._requestRedraw).call(t, this)), this.body.emitter.on(\"_startRendering\", () => {\n        this.renderRequests += 1, this.renderingActive = !0, this._startRendering();\n      }), this.body.emitter.on(\"_stopRendering\", () => {\n        this.renderRequests -= 1, this.renderingActive = this.renderRequests > 0, this.requestAnimationFrameRequestId = void 0;\n      }), this.body.emitter.on(\"destroy\", () => {\n        this.renderRequests = 0, this.allowRedraw = !1, this.renderingActive = !1, window.cancelAnimationFrame(this.requestAnimationFrameRequestId), this.body.emitter.off();\n      });\n    }\n    setOptions(t) {\n      if (void 0 !== t) {\n        wm([\"hideEdgesOnDrag\", \"hideEdgesOnZoom\", \"hideNodesOnDrag\"], this.options, t);\n      }\n    }\n    _startRendering() {\n      var t;\n      !0 === this.renderingActive && void 0 === this.requestAnimationFrameRequestId && (this.requestAnimationFrameRequestId = window.requestAnimationFrame(Ho(t = this._renderStep).call(t, this), this.simulationInterval));\n    }\n    _renderStep() {\n      !0 === this.renderingActive && (this.requestAnimationFrameRequestId = void 0, this._startRendering(), this._redraw());\n    }\n    redraw() {\n      this.body.emitter.emit(\"setSize\"), this._redraw();\n    }\n    _requestRedraw() {\n      !0 !== this.redrawRequested && !1 === this.renderingActive && !0 === this.allowRedraw && (this.redrawRequested = !0, window.requestAnimationFrame(() => {\n        this._redraw(!1);\n      }));\n    }\n    _redraw() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      if (!0 === this.allowRedraw) {\n        this.body.emitter.emit(\"initRedraw\"), this.redrawRequested = !1;\n        const e = {\n          drawExternalLabels: null\n        };\n        0 !== this.canvas.frame.canvas.width && 0 !== this.canvas.frame.canvas.height || this.canvas.setSize(), this.canvas.setTransform();\n        const i = this.canvas.getContext(),\n          o = this.canvas.frame.canvas.clientWidth,\n          s = this.canvas.frame.canvas.clientHeight;\n        if (i.clearRect(0, 0, o, s), 0 === this.canvas.frame.clientWidth) return;\n        if (i.save(), i.translate(this.body.view.translation.x, this.body.view.translation.y), i.scale(this.body.view.scale, this.body.view.scale), i.beginPath(), this.body.emitter.emit(\"beforeDrawing\", i), i.closePath(), !1 === t && (!1 === this.dragging || !0 === this.dragging && !1 === this.options.hideEdgesOnDrag) && (!1 === this.zooming || !0 === this.zooming && !1 === this.options.hideEdgesOnZoom) && this._drawEdges(i), !1 === this.dragging || !0 === this.dragging && !1 === this.options.hideNodesOnDrag) {\n          const {\n            drawExternalLabels: o\n          } = this._drawNodes(i, t);\n          e.drawExternalLabels = o;\n        }\n        !1 === t && (!1 === this.dragging || !0 === this.dragging && !1 === this.options.hideEdgesOnDrag) && (!1 === this.zooming || !0 === this.zooming && !1 === this.options.hideEdgesOnZoom) && this._drawArrows(i), null != e.drawExternalLabels && e.drawExternalLabels(), !1 === t && this._drawSelectionBox(i), i.beginPath(), this.body.emitter.emit(\"afterDrawing\", i), i.closePath(), i.restore(), !0 === t && i.clearRect(0, 0, o, s);\n      }\n    }\n    _resizeNodes() {\n      this.canvas.setTransform();\n      const t = this.canvas.getContext();\n      t.save(), t.translate(this.body.view.translation.x, this.body.view.translation.y), t.scale(this.body.view.scale, this.body.view.scale);\n      const e = this.body.nodes;\n      let i;\n      for (const o in e) Object.prototype.hasOwnProperty.call(e, o) && (i = e[o], i.resize(t), i.updateBoundingBox(t, i.selected));\n      t.restore();\n    }\n    _drawNodes(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      const i = this.body.nodes,\n        o = this.body.nodeIndices;\n      let s;\n      const n = [],\n        r = [],\n        a = this.canvas.DOMtoCanvas({\n          x: -20,\n          y: -20\n        }),\n        h = this.canvas.DOMtoCanvas({\n          x: this.canvas.frame.canvas.clientWidth + 20,\n          y: this.canvas.frame.canvas.clientHeight + 20\n        }),\n        d = {\n          top: a.y,\n          left: a.x,\n          bottom: h.y,\n          right: h.x\n        },\n        l = [];\n      for (let a = 0; a < o.length; a++) if (s = i[o[a]], s.hover) r.push(o[a]);else if (s.isSelected()) n.push(o[a]);else if (!0 === e) {\n        const e = s.draw(t);\n        null != e.drawExternalLabel && l.push(e.drawExternalLabel);\n      } else if (!0 === s.isBoundingBoxOverlappingWith(d)) {\n        const e = s.draw(t);\n        null != e.drawExternalLabel && l.push(e.drawExternalLabel);\n      } else s.updateBoundingBox(t, s.selected);\n      let c;\n      const u = n.length,\n        p = r.length;\n      for (c = 0; c < u; c++) {\n        s = i[n[c]];\n        const e = s.draw(t);\n        null != e.drawExternalLabel && l.push(e.drawExternalLabel);\n      }\n      for (c = 0; c < p; c++) {\n        s = i[r[c]];\n        const e = s.draw(t);\n        null != e.drawExternalLabel && l.push(e.drawExternalLabel);\n      }\n      return {\n        drawExternalLabels: () => {\n          for (const t of l) t();\n        }\n      };\n    }\n    _drawEdges(t) {\n      const e = this.body.edges,\n        i = this.body.edgeIndices;\n      for (let o = 0; o < i.length; o++) {\n        const s = e[i[o]];\n        !0 === s.connected && s.draw(t);\n      }\n    }\n    _drawArrows(t) {\n      const e = this.body.edges,\n        i = this.body.edgeIndices;\n      for (let o = 0; o < i.length; o++) {\n        const s = e[i[o]];\n        !0 === s.connected && s.drawArrows(t);\n      }\n    }\n    _drawSelectionBox(t) {\n      if (this.body.selectionBox.show) {\n        t.beginPath();\n        const e = this.body.selectionBox.position.end.x - this.body.selectionBox.position.start.x,\n          i = this.body.selectionBox.position.end.y - this.body.selectionBox.position.start.y;\n        t.rect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, e, i), t.fillStyle = \"rgba(151, 194, 252, 0.2)\", t.fillRect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, e, i), t.strokeStyle = \"rgba(151, 194, 252, 1)\", t.stroke();\n      } else t.closePath();\n    }\n  }\n  var dE = o(it.setInterval);\n  function lE(t, e) {\n    e.inputHandler = function (t) {\n      t.isFirst && e(t);\n    }, t.on(\"hammer.input\", e.inputHandler);\n  }\n  function cE(t, e) {\n    return e.inputHandler = function (t) {\n      t.isFinal && e(t);\n    }, t.on(\"hammer.input\", e.inputHandler);\n  }\n  class uE {\n    constructor(t) {\n      this.body = t, this.pixelRatio = 1, this.cameraState = {}, this.initialized = !1, this.canvasViewCenter = {}, this._cleanupCallbacks = [], this.options = {}, this.defaultOptions = {\n        autoResize: !0,\n        height: \"100%\",\n        width: \"100%\"\n      }, wo(this.options, this.defaultOptions), this.bindEventListeners();\n    }\n    bindEventListeners() {\n      var t;\n      this.body.emitter.once(\"resize\", t => {\n        0 !== t.width && (this.body.view.translation.x = .5 * t.width), 0 !== t.height && (this.body.view.translation.y = .5 * t.height);\n      }), this.body.emitter.on(\"setSize\", Ho(t = this.setSize).call(t, this)), this.body.emitter.on(\"destroy\", () => {\n        this.hammerFrame.destroy(), this.hammer.destroy(), this._cleanUp();\n      });\n    }\n    setOptions(t) {\n      if (void 0 !== t) {\n        wm([\"width\", \"height\", \"autoResize\"], this.options, t);\n      }\n      if (this._cleanUp(), !0 === this.options.autoResize) {\n        var e;\n        if (window.ResizeObserver) {\n          const t = new ResizeObserver(() => {\n              !0 === this.setSize() && this.body.emitter.emit(\"_requestRedraw\");\n            }),\n            {\n              frame: e\n            } = this;\n          t.observe(e), this._cleanupCallbacks.push(() => {\n            t.unobserve(e);\n          });\n        } else {\n          const t = dE(() => {\n            !0 === this.setSize() && this.body.emitter.emit(\"_requestRedraw\");\n          }, 1e3);\n          this._cleanupCallbacks.push(() => {\n            clearInterval(t);\n          });\n        }\n        const t = Ho(e = this._onResize).call(e, this);\n        window.addEventListener(\"resize\", t), this._cleanupCallbacks.push(() => {\n          window.removeEventListener(\"resize\", t);\n        });\n      }\n    }\n    _cleanUp() {\n      var t, e, i;\n      mc(t = kc(e = Jc(i = this._cleanupCallbacks).call(i, 0)).call(e)).call(t, t => {\n        try {\n          t();\n        } catch (t) {\n          console.error(t);\n        }\n      });\n    }\n    _onResize() {\n      this.setSize(), this.body.emitter.emit(\"_redraw\");\n    }\n    _getCameraState() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.pixelRatio;\n      !0 === this.initialized && (this.cameraState.previousWidth = this.frame.canvas.width / t, this.cameraState.previousHeight = this.frame.canvas.height / t, this.cameraState.scale = this.body.view.scale, this.cameraState.position = this.DOMtoCanvas({\n        x: .5 * this.frame.canvas.width / t,\n        y: .5 * this.frame.canvas.height / t\n      }));\n    }\n    _setCameraState() {\n      if (void 0 !== this.cameraState.scale && 0 !== this.frame.canvas.clientWidth && 0 !== this.frame.canvas.clientHeight && 0 !== this.pixelRatio && this.cameraState.previousWidth > 0 && this.cameraState.previousHeight > 0) {\n        const t = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth,\n          e = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;\n        let i = this.cameraState.scale;\n        1 != t && 1 != e ? i = .5 * this.cameraState.scale * (t + e) : 1 != t ? i = this.cameraState.scale * t : 1 != e && (i = this.cameraState.scale * e), this.body.view.scale = i;\n        const o = this.DOMtoCanvas({\n            x: .5 * this.frame.canvas.clientWidth,\n            y: .5 * this.frame.canvas.clientHeight\n          }),\n          s = {\n            x: o.x - this.cameraState.position.x,\n            y: o.y - this.cameraState.position.y\n          };\n        this.body.view.translation.x += s.x * this.body.view.scale, this.body.view.translation.y += s.y * this.body.view.scale;\n      }\n    }\n    _prepareValue(t) {\n      if (\"number\" == typeof t) return t + \"px\";\n      if (\"string\" == typeof t) {\n        if (-1 !== Mp(t).call(t, \"%\") || -1 !== Mp(t).call(t, \"px\")) return t;\n        if (-1 === Mp(t).call(t, \"%\")) return t + \"px\";\n      }\n      throw new Error(\"Could not use the value supplied for width or height:\" + t);\n    }\n    _create() {\n      for (; this.body.container.hasChildNodes();) this.body.container.removeChild(this.body.container.firstChild);\n      if (this.frame = document.createElement(\"div\"), this.frame.className = \"vis-network\", this.frame.style.position = \"relative\", this.frame.style.overflow = \"hidden\", this.frame.tabIndex = 0, this.frame.canvas = document.createElement(\"canvas\"), this.frame.canvas.style.position = \"relative\", this.frame.appendChild(this.frame.canvas), this.frame.canvas.getContext) this._setPixelRatio(), this.setTransform();else {\n        const t = document.createElement(\"DIV\");\n        t.style.color = \"red\", t.style.fontWeight = \"bold\", t.style.padding = \"10px\", t.innerText = \"Error: your browser does not support HTML canvas\", this.frame.canvas.appendChild(t);\n      }\n      this.body.container.appendChild(this.frame), this.body.view.scale = 1, this.body.view.translation = {\n        x: .5 * this.frame.canvas.clientWidth,\n        y: .5 * this.frame.canvas.clientHeight\n      }, this._bindHammer();\n    }\n    _bindHammer() {\n      void 0 !== this.hammer && this.hammer.destroy(), this.drag = {}, this.pinch = {}, this.hammer = new Xm(this.frame.canvas), this.hammer.get(\"pinch\").set({\n        enable: !0\n      }), this.hammer.get(\"pan\").set({\n        threshold: 5,\n        direction: Xm.DIRECTION_ALL\n      }), lE(this.hammer, t => {\n        this.body.eventListeners.onTouch(t);\n      }), this.hammer.on(\"tap\", t => {\n        this.body.eventListeners.onTap(t);\n      }), this.hammer.on(\"doubletap\", t => {\n        this.body.eventListeners.onDoubleTap(t);\n      }), this.hammer.on(\"press\", t => {\n        this.body.eventListeners.onHold(t);\n      }), this.hammer.on(\"panstart\", t => {\n        this.body.eventListeners.onDragStart(t);\n      }), this.hammer.on(\"panmove\", t => {\n        this.body.eventListeners.onDrag(t);\n      }), this.hammer.on(\"panend\", t => {\n        this.body.eventListeners.onDragEnd(t);\n      }), this.hammer.on(\"pinch\", t => {\n        this.body.eventListeners.onPinch(t);\n      }), this.frame.canvas.addEventListener(\"wheel\", t => {\n        this.body.eventListeners.onMouseWheel(t);\n      }), this.frame.canvas.addEventListener(\"mousemove\", t => {\n        this.body.eventListeners.onMouseMove(t);\n      }), this.frame.canvas.addEventListener(\"contextmenu\", t => {\n        this.body.eventListeners.onContext(t);\n      }), this.hammerFrame = new Xm(this.frame), cE(this.hammerFrame, t => {\n        this.body.eventListeners.onRelease(t);\n      });\n    }\n    setSize() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options.width,\n        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.options.height;\n      t = this._prepareValue(t), e = this._prepareValue(e);\n      let i = !1;\n      const o = this.frame.canvas.width,\n        s = this.frame.canvas.height,\n        n = this.pixelRatio;\n      if (this._setPixelRatio(), t != this.options.width || e != this.options.height || this.frame.style.width != t || this.frame.style.height != e) this._getCameraState(n), this.frame.style.width = t, this.frame.style.height = e, this.frame.canvas.style.width = \"100%\", this.frame.canvas.style.height = \"100%\", this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio), this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio), this.options.width = t, this.options.height = e, this.canvasViewCenter = {\n        x: .5 * this.frame.clientWidth,\n        y: .5 * this.frame.clientHeight\n      }, i = !0;else {\n        const t = Math.round(this.frame.canvas.clientWidth * this.pixelRatio),\n          e = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);\n        this.frame.canvas.width === t && this.frame.canvas.height === e || this._getCameraState(n), this.frame.canvas.width !== t && (this.frame.canvas.width = t, i = !0), this.frame.canvas.height !== e && (this.frame.canvas.height = e, i = !0);\n      }\n      return !0 === i && (this.body.emitter.emit(\"resize\", {\n        width: Math.round(this.frame.canvas.width / this.pixelRatio),\n        height: Math.round(this.frame.canvas.height / this.pixelRatio),\n        oldWidth: Math.round(o / this.pixelRatio),\n        oldHeight: Math.round(s / this.pixelRatio)\n      }), this._setCameraState()), this.initialized = !0, i;\n    }\n    getContext() {\n      return this.frame.canvas.getContext(\"2d\");\n    }\n    _determinePixelRatio() {\n      const t = this.getContext();\n      if (void 0 === t) throw new Error(\"Could not get canvax context\");\n      let e = 1;\n      \"undefined\" != typeof window && (e = window.devicePixelRatio || 1);\n      return e / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1);\n    }\n    _setPixelRatio() {\n      this.pixelRatio = this._determinePixelRatio();\n    }\n    setTransform() {\n      const t = this.getContext();\n      if (void 0 === t) throw new Error(\"Could not get canvax context\");\n      t.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n    }\n    _XconvertDOMtoCanvas(t) {\n      return (t - this.body.view.translation.x) / this.body.view.scale;\n    }\n    _XconvertCanvasToDOM(t) {\n      return t * this.body.view.scale + this.body.view.translation.x;\n    }\n    _YconvertDOMtoCanvas(t) {\n      return (t - this.body.view.translation.y) / this.body.view.scale;\n    }\n    _YconvertCanvasToDOM(t) {\n      return t * this.body.view.scale + this.body.view.translation.y;\n    }\n    canvasToDOM(t) {\n      return {\n        x: this._XconvertCanvasToDOM(t.x),\n        y: this._YconvertCanvasToDOM(t.y)\n      };\n    }\n    DOMtoCanvas(t) {\n      return {\n        x: this._XconvertDOMtoCanvas(t.x),\n        y: this._YconvertDOMtoCanvas(t.y)\n      };\n    }\n  }\n  class pE {\n    constructor(t, e) {\n      var i, o;\n      this.body = t, this.canvas = e, this.animationSpeed = 1 / this.renderRefreshRate, this.animationEasingFunction = \"easeInOutQuint\", this.easingTime = 0, this.sourceScale = 0, this.targetScale = 0, this.sourceTranslation = 0, this.targetTranslation = 0, this.lockedOnNodeId = void 0, this.lockedOnNodeOffset = void 0, this.touchTime = 0, this.viewFunction = void 0, this.body.emitter.on(\"fit\", Ho(i = this.fit).call(i, this)), this.body.emitter.on(\"animationFinished\", () => {\n        this.body.emitter.emit(\"_stopRendering\");\n      }), this.body.emitter.on(\"unlockNode\", Ho(o = this.releaseNode).call(o, this));\n    }\n    setOptions() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n      this.options = t;\n    }\n    fit(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      t = function (t, e) {\n        const i = wo({\n          nodes: e,\n          minZoomLevel: Number.MIN_VALUE,\n          maxZoomLevel: 1\n        }, null != t ? t : {});\n        if (!Vl(i.nodes)) throw new TypeError(\"Nodes has to be an array of ids.\");\n        if (0 === i.nodes.length && (i.nodes = e), !(\"number\" == typeof i.minZoomLevel && i.minZoomLevel > 0)) throw new TypeError(\"Min zoom level has to be a number higher than zero.\");\n        if (!(\"number\" == typeof i.maxZoomLevel && i.minZoomLevel <= i.maxZoomLevel)) throw new TypeError(\"Max zoom level has to be a number higher than min zoom level.\");\n        return i;\n      }(t, this.body.nodeIndices);\n      const i = this.canvas.frame.canvas.clientWidth,\n        o = this.canvas.frame.canvas.clientHeight;\n      let s, n;\n      if (0 === i || 0 === o) n = 1, s = nE.getRange(this.body.nodes, t.nodes);else if (!0 === e) {\n        let e = 0;\n        for (const t in this.body.nodes) if (Object.prototype.hasOwnProperty.call(this.body.nodes, t)) {\n          !0 === this.body.nodes[t].predefinedPosition && (e += 1);\n        }\n        if (e > .5 * this.body.nodeIndices.length) return void this.fit(t, !1);\n        s = nE.getRange(this.body.nodes, t.nodes);\n        n = 12.662 / (this.body.nodeIndices.length + 7.4147) + .0964822;\n        n *= Math.min(i / 600, o / 600);\n      } else {\n        this.body.emitter.emit(\"_resizeNodes\"), s = nE.getRange(this.body.nodes, t.nodes);\n        const e = i / (1.1 * Math.abs(s.maxX - s.minX)),\n          r = o / (1.1 * Math.abs(s.maxY - s.minY));\n        n = e <= r ? e : r;\n      }\n      n > t.maxZoomLevel ? n = t.maxZoomLevel : n < t.minZoomLevel && (n = t.minZoomLevel);\n      const r = {\n        position: nE.findCenter(s),\n        scale: n,\n        animation: t.animation\n      };\n      this.moveTo(r);\n    }\n    focus(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      if (void 0 !== this.body.nodes[t]) {\n        const i = {\n          x: this.body.nodes[t].x,\n          y: this.body.nodes[t].y\n        };\n        e.position = i, e.lockedOnNode = t, this.moveTo(e);\n      } else console.error(\"Node: \" + t + \" cannot be found.\");\n    }\n    moveTo(t) {\n      if (void 0 !== t) {\n        if (null != t.offset) {\n          if (null != t.offset.x) {\n            if (t.offset.x = +t.offset.x, !Vv(t.offset.x)) throw new TypeError('The option \"offset.x\" has to be a finite number.');\n          } else t.offset.x = 0;\n          if (null != t.offset.y) {\n            if (t.offset.y = +t.offset.y, !Vv(t.offset.y)) throw new TypeError('The option \"offset.y\" has to be a finite number.');\n          } else t.offset.x = 0;\n        } else t.offset = {\n          x: 0,\n          y: 0\n        };\n        if (null != t.position) {\n          if (null != t.position.x) {\n            if (t.position.x = +t.position.x, !Vv(t.position.x)) throw new TypeError('The option \"position.x\" has to be a finite number.');\n          } else t.position.x = 0;\n          if (null != t.position.y) {\n            if (t.position.y = +t.position.y, !Vv(t.position.y)) throw new TypeError('The option \"position.y\" has to be a finite number.');\n          } else t.position.x = 0;\n        } else t.position = this.getViewPosition();\n        if (null != t.scale) {\n          if (t.scale = +t.scale, !(t.scale > 0)) throw new TypeError('The option \"scale\" has to be a number greater than zero.');\n        } else t.scale = this.body.view.scale;\n        void 0 === t.animation && (t.animation = {\n          duration: 0\n        }), !1 === t.animation && (t.animation = {\n          duration: 0\n        }), !0 === t.animation && (t.animation = {}), void 0 === t.animation.duration && (t.animation.duration = 1e3), void 0 === t.animation.easingFunction && (t.animation.easingFunction = \"easeInOutQuad\"), this.animateView(t);\n      } else t = {};\n    }\n    animateView(t) {\n      if (void 0 === t) return;\n      this.animationEasingFunction = t.animation.easingFunction, this.releaseNode(), !0 === t.locked && (this.lockedOnNodeId = t.lockedOnNode, this.lockedOnNodeOffset = t.offset), 0 != this.easingTime && this._transitionRedraw(!0), this.sourceScale = this.body.view.scale, this.sourceTranslation = this.body.view.translation, this.targetScale = t.scale, this.body.view.scale = this.targetScale;\n      const e = this.canvas.DOMtoCanvas({\n          x: .5 * this.canvas.frame.canvas.clientWidth,\n          y: .5 * this.canvas.frame.canvas.clientHeight\n        }),\n        i = e.x - t.position.x,\n        o = e.y - t.position.y;\n      var s, n;\n      (this.targetTranslation = {\n        x: this.sourceTranslation.x + i * this.targetScale + t.offset.x,\n        y: this.sourceTranslation.y + o * this.targetScale + t.offset.y\n      }, 0 === t.animation.duration) ? null != this.lockedOnNodeId ? (this.viewFunction = Ho(s = this._lockedRedraw).call(s, this), this.body.emitter.on(\"initRedraw\", this.viewFunction)) : (this.body.view.scale = this.targetScale, this.body.view.translation = this.targetTranslation, this.body.emitter.emit(\"_requestRedraw\")) : (this.animationSpeed = 1 / (60 * t.animation.duration * .001) || 1 / 60, this.animationEasingFunction = t.animation.easingFunction, this.viewFunction = Ho(n = this._transitionRedraw).call(n, this), this.body.emitter.on(\"initRedraw\", this.viewFunction), this.body.emitter.emit(\"_startRendering\"));\n    }\n    _lockedRedraw() {\n      const t = this.body.nodes[this.lockedOnNodeId].x,\n        e = this.body.nodes[this.lockedOnNodeId].y,\n        i = this.canvas.DOMtoCanvas({\n          x: .5 * this.canvas.frame.canvas.clientWidth,\n          y: .5 * this.canvas.frame.canvas.clientHeight\n        }),\n        o = i.x - t,\n        s = i.y - e,\n        n = this.body.view.translation,\n        r = {\n          x: n.x + o * this.body.view.scale + this.lockedOnNodeOffset.x,\n          y: n.y + s * this.body.view.scale + this.lockedOnNodeOffset.y\n        };\n      this.body.view.translation = r;\n    }\n    releaseNode() {\n      void 0 !== this.lockedOnNodeId && void 0 !== this.viewFunction && (this.body.emitter.off(\"initRedraw\", this.viewFunction), this.lockedOnNodeId = void 0, this.lockedOnNodeOffset = void 0);\n    }\n    _transitionRedraw() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      this.easingTime += this.animationSpeed, this.easingTime = !0 === t ? 1 : this.easingTime;\n      const e = Am[this.animationEasingFunction](this.easingTime);\n      if (this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * e, this.body.view.translation = {\n        x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * e,\n        y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * e\n      }, this.easingTime >= 1) {\n        var i;\n        if (this.body.emitter.off(\"initRedraw\", this.viewFunction), this.easingTime = 0, null != this.lockedOnNodeId) this.viewFunction = Ho(i = this._lockedRedraw).call(i, this), this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        this.body.emitter.emit(\"animationFinished\");\n      }\n    }\n    getScale() {\n      return this.body.view.scale;\n    }\n    getViewPosition() {\n      return this.canvas.DOMtoCanvas({\n        x: .5 * this.canvas.frame.canvas.clientWidth,\n        y: .5 * this.canvas.frame.canvas.clientHeight\n      });\n    }\n  }\n  function gE(t) {\n    var e,\n      i = t && t.preventDefault || !1,\n      o = t && t.container || window,\n      s = {},\n      n = {\n        keydown: {},\n        keyup: {}\n      },\n      r = {};\n    for (e = 97; e <= 122; e++) r[String.fromCharCode(e)] = {\n      code: e - 97 + 65,\n      shift: !1\n    };\n    for (e = 65; e <= 90; e++) r[String.fromCharCode(e)] = {\n      code: e,\n      shift: !0\n    };\n    for (e = 0; e <= 9; e++) r[\"\" + e] = {\n      code: 48 + e,\n      shift: !1\n    };\n    for (e = 1; e <= 12; e++) r[\"F\" + e] = {\n      code: 111 + e,\n      shift: !1\n    };\n    for (e = 0; e <= 9; e++) r[\"num\" + e] = {\n      code: 96 + e,\n      shift: !1\n    };\n    r[\"num*\"] = {\n      code: 106,\n      shift: !1\n    }, r[\"num+\"] = {\n      code: 107,\n      shift: !1\n    }, r[\"num-\"] = {\n      code: 109,\n      shift: !1\n    }, r[\"num/\"] = {\n      code: 111,\n      shift: !1\n    }, r[\"num.\"] = {\n      code: 110,\n      shift: !1\n    }, r.left = {\n      code: 37,\n      shift: !1\n    }, r.up = {\n      code: 38,\n      shift: !1\n    }, r.right = {\n      code: 39,\n      shift: !1\n    }, r.down = {\n      code: 40,\n      shift: !1\n    }, r.space = {\n      code: 32,\n      shift: !1\n    }, r.enter = {\n      code: 13,\n      shift: !1\n    }, r.shift = {\n      code: 16,\n      shift: void 0\n    }, r.esc = {\n      code: 27,\n      shift: !1\n    }, r.backspace = {\n      code: 8,\n      shift: !1\n    }, r.tab = {\n      code: 9,\n      shift: !1\n    }, r.ctrl = {\n      code: 17,\n      shift: !1\n    }, r.alt = {\n      code: 18,\n      shift: !1\n    }, r.delete = {\n      code: 46,\n      shift: !1\n    }, r.pageup = {\n      code: 33,\n      shift: !1\n    }, r.pagedown = {\n      code: 34,\n      shift: !1\n    }, r[\"=\"] = {\n      code: 187,\n      shift: !1\n    }, r[\"-\"] = {\n      code: 189,\n      shift: !1\n    }, r[\"]\"] = {\n      code: 221,\n      shift: !1\n    }, r[\"[\"] = {\n      code: 219,\n      shift: !1\n    };\n    var a = function (t) {\n        d(t, \"keydown\");\n      },\n      h = function (t) {\n        d(t, \"keyup\");\n      },\n      d = function (t, e) {\n        if (void 0 !== n[e][t.keyCode]) {\n          for (var o = n[e][t.keyCode], s = 0; s < o.length; s++) (void 0 === o[s].shift || 1 == o[s].shift && 1 == t.shiftKey || 0 == o[s].shift && 0 == t.shiftKey) && o[s].fn(t);\n          1 == i && t.preventDefault();\n        }\n      };\n    return s.bind = function (t, e, i) {\n      if (void 0 === i && (i = \"keydown\"), void 0 === r[t]) throw new Error(\"unsupported key: \" + t);\n      void 0 === n[i][r[t].code] && (n[i][r[t].code] = []), n[i][r[t].code].push({\n        fn: e,\n        shift: r[t].shift\n      });\n    }, s.bindAll = function (t, e) {\n      for (var i in void 0 === e && (e = \"keydown\"), r) r.hasOwnProperty(i) && s.bind(i, t, e);\n    }, s.getKey = function (t) {\n      for (var e in r) if (r.hasOwnProperty(e)) {\n        if (1 == t.shiftKey && 1 == r[e].shift && t.keyCode == r[e].code) return e;\n        if (0 == t.shiftKey && 0 == r[e].shift && t.keyCode == r[e].code) return e;\n        if (t.keyCode == r[e].code && \"shift\" == e) return e;\n      }\n      return \"unknown key, currently not supported\";\n    }, s.unbind = function (t, e, i) {\n      if (void 0 === i && (i = \"keydown\"), void 0 === r[t]) throw new Error(\"unsupported key: \" + t);\n      if (void 0 !== e) {\n        var o = [],\n          s = n[i][r[t].code];\n        if (void 0 !== s) for (var a = 0; a < s.length; a++) s[a].fn == e && s[a].shift == r[t].shift || o.push(n[i][r[t].code][a]);\n        n[i][r[t].code] = o;\n      } else n[i][r[t].code] = [];\n    }, s.reset = function () {\n      n = {\n        keydown: {},\n        keyup: {}\n      };\n    }, s.destroy = function () {\n      n = {\n        keydown: {},\n        keyup: {}\n      }, o.removeEventListener(\"keydown\", a, !0), o.removeEventListener(\"keyup\", h, !0);\n    }, o.addEventListener(\"keydown\", a, !0), o.addEventListener(\"keyup\", h, !0), s;\n  }\n  class fE {\n    constructor(t, e) {\n      this.body = t, this.canvas = e, this.iconsCreated = !1, this.navigationHammers = [], this.boundFunctions = {}, this.touchTime = 0, this.activated = !1, this.body.emitter.on(\"activate\", () => {\n        this.activated = !0, this.configureKeyboardBindings();\n      }), this.body.emitter.on(\"deactivate\", () => {\n        this.activated = !1, this.configureKeyboardBindings();\n      }), this.body.emitter.on(\"destroy\", () => {\n        void 0 !== this.keycharm && this.keycharm.destroy();\n      }), this.options = {};\n    }\n    setOptions(t) {\n      void 0 !== t && (this.options = t, this.create());\n    }\n    create() {\n      !0 === this.options.navigationButtons ? !1 === this.iconsCreated && this.loadNavigationElements() : !0 === this.iconsCreated && this.cleanNavigation(), this.configureKeyboardBindings();\n    }\n    cleanNavigation() {\n      if (0 != this.navigationHammers.length) {\n        for (let t = 0; t < this.navigationHammers.length; t++) this.navigationHammers[t].destroy();\n        this.navigationHammers = [];\n      }\n      this.navigationDOM && this.navigationDOM.wrapper && this.navigationDOM.wrapper.parentNode && this.navigationDOM.wrapper.parentNode.removeChild(this.navigationDOM.wrapper), this.iconsCreated = !1;\n    }\n    loadNavigationElements() {\n      this.cleanNavigation(), this.navigationDOM = {};\n      const t = [\"up\", \"down\", \"left\", \"right\", \"zoomIn\", \"zoomOut\", \"zoomExtends\"],\n        e = [\"_moveUp\", \"_moveDown\", \"_moveLeft\", \"_moveRight\", \"_zoomIn\", \"_zoomOut\", \"_fit\"];\n      this.navigationDOM.wrapper = document.createElement(\"div\"), this.navigationDOM.wrapper.className = \"vis-navigation\", this.canvas.frame.appendChild(this.navigationDOM.wrapper);\n      for (let s = 0; s < t.length; s++) {\n        this.navigationDOM[t[s]] = document.createElement(\"div\"), this.navigationDOM[t[s]].className = \"vis-button vis-\" + t[s], this.navigationDOM.wrapper.appendChild(this.navigationDOM[t[s]]);\n        const n = new Xm(this.navigationDOM[t[s]]);\n        var i, o;\n        if (\"_fit\" === e[s]) lE(n, Ho(i = this._fit).call(i, this));else lE(n, Ho(o = this.bindToRedraw).call(o, this, e[s]));\n        this.navigationHammers.push(n);\n      }\n      const s = new Xm(this.canvas.frame);\n      cE(s, () => {\n        this._stopMovement();\n      }), this.navigationHammers.push(s), this.iconsCreated = !0;\n    }\n    bindToRedraw(t) {\n      var e;\n      void 0 === this.boundFunctions[t] && (this.boundFunctions[t] = Ho(e = this[t]).call(e, this), this.body.emitter.on(\"initRedraw\", this.boundFunctions[t]), this.body.emitter.emit(\"_startRendering\"));\n    }\n    unbindFromRedraw(t) {\n      void 0 !== this.boundFunctions[t] && (this.body.emitter.off(\"initRedraw\", this.boundFunctions[t]), this.body.emitter.emit(\"_stopRendering\"), delete this.boundFunctions[t]);\n    }\n    _fit() {\n      new Date().valueOf() - this.touchTime > 700 && (this.body.emitter.emit(\"fit\", {\n        duration: 700\n      }), this.touchTime = new Date().valueOf());\n    }\n    _stopMovement() {\n      for (const t in this.boundFunctions) Object.prototype.hasOwnProperty.call(this.boundFunctions, t) && (this.body.emitter.off(\"initRedraw\", this.boundFunctions[t]), this.body.emitter.emit(\"_stopRendering\"));\n      this.boundFunctions = {};\n    }\n    _moveUp() {\n      this.body.view.translation.y += this.options.keyboard.speed.y;\n    }\n    _moveDown() {\n      this.body.view.translation.y -= this.options.keyboard.speed.y;\n    }\n    _moveLeft() {\n      this.body.view.translation.x += this.options.keyboard.speed.x;\n    }\n    _moveRight() {\n      this.body.view.translation.x -= this.options.keyboard.speed.x;\n    }\n    _zoomIn() {\n      const t = this.body.view.scale,\n        e = this.body.view.scale * (1 + this.options.keyboard.speed.zoom),\n        i = this.body.view.translation,\n        o = e / t,\n        s = (1 - o) * this.canvas.canvasViewCenter.x + i.x * o,\n        n = (1 - o) * this.canvas.canvasViewCenter.y + i.y * o;\n      this.body.view.scale = e, this.body.view.translation = {\n        x: s,\n        y: n\n      }, this.body.emitter.emit(\"zoom\", {\n        direction: \"+\",\n        scale: this.body.view.scale,\n        pointer: null\n      });\n    }\n    _zoomOut() {\n      const t = this.body.view.scale,\n        e = this.body.view.scale / (1 + this.options.keyboard.speed.zoom),\n        i = this.body.view.translation,\n        o = e / t,\n        s = (1 - o) * this.canvas.canvasViewCenter.x + i.x * o,\n        n = (1 - o) * this.canvas.canvasViewCenter.y + i.y * o;\n      this.body.view.scale = e, this.body.view.translation = {\n        x: s,\n        y: n\n      }, this.body.emitter.emit(\"zoom\", {\n        direction: \"-\",\n        scale: this.body.view.scale,\n        pointer: null\n      });\n    }\n    configureKeyboardBindings() {\n      var t, e, i, o, s, n, r, a, h, d, l, c, u, p, g, f, m, y, b, v, w, _, x, E;\n      (void 0 !== this.keycharm && this.keycharm.destroy(), !0 === this.options.keyboard.enabled) && (!0 === this.options.keyboard.bindToWindow ? this.keycharm = gE({\n        container: window,\n        preventDefault: !0\n      }) : this.keycharm = gE({\n        container: this.canvas.frame,\n        preventDefault: !0\n      }), this.keycharm.reset(), !0 === this.activated && (Ho(t = this.keycharm).call(t, \"up\", () => {\n        this.bindToRedraw(\"_moveUp\");\n      }, \"keydown\"), Ho(e = this.keycharm).call(e, \"down\", () => {\n        this.bindToRedraw(\"_moveDown\");\n      }, \"keydown\"), Ho(i = this.keycharm).call(i, \"left\", () => {\n        this.bindToRedraw(\"_moveLeft\");\n      }, \"keydown\"), Ho(o = this.keycharm).call(o, \"right\", () => {\n        this.bindToRedraw(\"_moveRight\");\n      }, \"keydown\"), Ho(s = this.keycharm).call(s, \"=\", () => {\n        this.bindToRedraw(\"_zoomIn\");\n      }, \"keydown\"), Ho(n = this.keycharm).call(n, \"num+\", () => {\n        this.bindToRedraw(\"_zoomIn\");\n      }, \"keydown\"), Ho(r = this.keycharm).call(r, \"num-\", () => {\n        this.bindToRedraw(\"_zoomOut\");\n      }, \"keydown\"), Ho(a = this.keycharm).call(a, \"-\", () => {\n        this.bindToRedraw(\"_zoomOut\");\n      }, \"keydown\"), Ho(h = this.keycharm).call(h, \"[\", () => {\n        this.bindToRedraw(\"_zoomOut\");\n      }, \"keydown\"), Ho(d = this.keycharm).call(d, \"]\", () => {\n        this.bindToRedraw(\"_zoomIn\");\n      }, \"keydown\"), Ho(l = this.keycharm).call(l, \"pageup\", () => {\n        this.bindToRedraw(\"_zoomIn\");\n      }, \"keydown\"), Ho(c = this.keycharm).call(c, \"pagedown\", () => {\n        this.bindToRedraw(\"_zoomOut\");\n      }, \"keydown\"), Ho(u = this.keycharm).call(u, \"up\", () => {\n        this.unbindFromRedraw(\"_moveUp\");\n      }, \"keyup\"), Ho(p = this.keycharm).call(p, \"down\", () => {\n        this.unbindFromRedraw(\"_moveDown\");\n      }, \"keyup\"), Ho(g = this.keycharm).call(g, \"left\", () => {\n        this.unbindFromRedraw(\"_moveLeft\");\n      }, \"keyup\"), Ho(f = this.keycharm).call(f, \"right\", () => {\n        this.unbindFromRedraw(\"_moveRight\");\n      }, \"keyup\"), Ho(m = this.keycharm).call(m, \"=\", () => {\n        this.unbindFromRedraw(\"_zoomIn\");\n      }, \"keyup\"), Ho(y = this.keycharm).call(y, \"num+\", () => {\n        this.unbindFromRedraw(\"_zoomIn\");\n      }, \"keyup\"), Ho(b = this.keycharm).call(b, \"num-\", () => {\n        this.unbindFromRedraw(\"_zoomOut\");\n      }, \"keyup\"), Ho(v = this.keycharm).call(v, \"-\", () => {\n        this.unbindFromRedraw(\"_zoomOut\");\n      }, \"keyup\"), Ho(w = this.keycharm).call(w, \"[\", () => {\n        this.unbindFromRedraw(\"_zoomOut\");\n      }, \"keyup\"), Ho(_ = this.keycharm).call(_, \"]\", () => {\n        this.unbindFromRedraw(\"_zoomIn\");\n      }, \"keyup\"), Ho(x = this.keycharm).call(x, \"pageup\", () => {\n        this.unbindFromRedraw(\"_zoomIn\");\n      }, \"keyup\"), Ho(E = this.keycharm).call(E, \"pagedown\", () => {\n        this.unbindFromRedraw(\"_zoomOut\");\n      }, \"keyup\")));\n    }\n  }\n  class mE {\n    constructor(t, e, i) {\n      var o, s, n, r, a, h, d, l, c, u, p, g, f;\n      this.body = t, this.canvas = e, this.selectionHandler = i, this.navigationHandler = new fE(t, e), this.body.eventListeners.onTap = Ho(o = this.onTap).call(o, this), this.body.eventListeners.onTouch = Ho(s = this.onTouch).call(s, this), this.body.eventListeners.onDoubleTap = Ho(n = this.onDoubleTap).call(n, this), this.body.eventListeners.onHold = Ho(r = this.onHold).call(r, this), this.body.eventListeners.onDragStart = Ho(a = this.onDragStart).call(a, this), this.body.eventListeners.onDrag = Ho(h = this.onDrag).call(h, this), this.body.eventListeners.onDragEnd = Ho(d = this.onDragEnd).call(d, this), this.body.eventListeners.onMouseWheel = Ho(l = this.onMouseWheel).call(l, this), this.body.eventListeners.onPinch = Ho(c = this.onPinch).call(c, this), this.body.eventListeners.onMouseMove = Ho(u = this.onMouseMove).call(u, this), this.body.eventListeners.onRelease = Ho(p = this.onRelease).call(p, this), this.body.eventListeners.onContext = Ho(g = this.onContext).call(g, this), this.touchTime = 0, this.drag = {}, this.pinch = {}, this.popup = void 0, this.popupObj = void 0, this.popupTimer = void 0, this.body.functions.getPointer = Ho(f = this.getPointer).call(f, this), this.options = {}, this.defaultOptions = {\n        dragNodes: !0,\n        dragView: !0,\n        hover: !1,\n        keyboard: {\n          enabled: !1,\n          speed: {\n            x: 10,\n            y: 10,\n            zoom: .02\n          },\n          bindToWindow: !0,\n          autoFocus: !0\n        },\n        navigationButtons: !1,\n        tooltipDelay: 300,\n        zoomView: !0,\n        zoomSpeed: 1\n      }, wo(this.options, this.defaultOptions), this.bindEventListeners();\n    }\n    bindEventListeners() {\n      this.body.emitter.on(\"destroy\", () => {\n        clearTimeout(this.popupTimer), delete this.body.functions.getPointer;\n      });\n    }\n    setOptions(t) {\n      if (void 0 !== t) {\n        _m([\"hideEdgesOnDrag\", \"hideEdgesOnZoom\", \"hideNodesOnDrag\", \"keyboard\", \"multiselect\", \"selectable\", \"selectConnectedEdges\"], this.options, t), Nm(this.options, t, \"keyboard\"), t.tooltip && (wo(this.options.tooltip, t.tooltip), t.tooltip.color && (this.options.tooltip.color = Mm(t.tooltip.color)));\n      }\n      this.navigationHandler.setOptions(this.options);\n    }\n    getPointer(t) {\n      return {\n        x: t.x - (e = this.canvas.frame.canvas, e.getBoundingClientRect().left),\n        y: t.y - Om(this.canvas.frame.canvas)\n      };\n      var e;\n    }\n    onTouch(t) {\n      new Date().valueOf() - this.touchTime > 50 && (this.drag.pointer = this.getPointer(t.center), this.drag.pinched = !1, this.pinch.scale = this.body.view.scale, this.touchTime = new Date().valueOf());\n    }\n    onTap(t) {\n      const e = this.getPointer(t.center),\n        i = this.selectionHandler.options.multiselect && (t.changedPointers[0].ctrlKey || t.changedPointers[0].metaKey);\n      this.checkSelectionChanges(e, i), this.selectionHandler.commitAndEmit(e, t), this.selectionHandler.generateClickEvent(\"click\", t, e);\n    }\n    onDoubleTap(t) {\n      const e = this.getPointer(t.center);\n      this.selectionHandler.generateClickEvent(\"doubleClick\", t, e);\n    }\n    onHold(t) {\n      const e = this.getPointer(t.center),\n        i = this.selectionHandler.options.multiselect;\n      this.checkSelectionChanges(e, i), this.selectionHandler.commitAndEmit(e, t), this.selectionHandler.generateClickEvent(\"click\", t, e), this.selectionHandler.generateClickEvent(\"hold\", t, e);\n    }\n    onRelease(t) {\n      if (new Date().valueOf() - this.touchTime > 10) {\n        const e = this.getPointer(t.center);\n        this.selectionHandler.generateClickEvent(\"release\", t, e), this.touchTime = new Date().valueOf();\n      }\n    }\n    onContext(t) {\n      const e = this.getPointer({\n        x: t.clientX,\n        y: t.clientY\n      });\n      this.selectionHandler.generateClickEvent(\"oncontext\", t, e);\n    }\n    checkSelectionChanges(t) {\n      !0 === (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) ? this.selectionHandler.selectAdditionalOnPoint(t) : this.selectionHandler.selectOnPoint(t);\n    }\n    _determineDifference(t, e) {\n      const i = function (t, e) {\n        const i = [];\n        for (let o = 0; o < t.length; o++) {\n          const s = t[o];\n          -1 === Mp(e).call(e, s) && i.push(s);\n        }\n        return i;\n      };\n      return {\n        nodes: i(t.nodes, e.nodes),\n        edges: i(t.edges, e.edges)\n      };\n    }\n    onDragStart(t) {\n      if (this.drag.dragging) return;\n      void 0 === this.drag.pointer && this.onTouch(t);\n      const e = this.selectionHandler.getNodeAt(this.drag.pointer);\n      if (this.drag.dragging = !0, this.drag.selection = [], this.drag.translation = wo({}, this.body.view.translation), this.drag.nodeId = void 0, t.srcEvent.shiftKey) {\n        this.body.selectionBox.show = !0;\n        const e = this.getPointer(t.center);\n        this.body.selectionBox.position.start = {\n          x: this.canvas._XconvertDOMtoCanvas(e.x),\n          y: this.canvas._YconvertDOMtoCanvas(e.y)\n        }, this.body.selectionBox.position.end = {\n          x: this.canvas._XconvertDOMtoCanvas(e.x),\n          y: this.canvas._YconvertDOMtoCanvas(e.y)\n        };\n      } else if (void 0 !== e && !0 === this.options.dragNodes) {\n        this.drag.nodeId = e.id, !1 === e.isSelected() && this.selectionHandler.setSelection({\n          nodes: [e.id]\n        }), this.selectionHandler.generateClickEvent(\"dragStart\", t, this.drag.pointer);\n        for (const t of this.selectionHandler.getSelectedNodes()) {\n          const e = {\n            id: t.id,\n            node: t,\n            x: t.x,\n            y: t.y,\n            xFixed: t.options.fixed.x,\n            yFixed: t.options.fixed.y\n          };\n          t.options.fixed.x = !0, t.options.fixed.y = !0, this.drag.selection.push(e);\n        }\n      } else this.selectionHandler.generateClickEvent(\"dragStart\", t, this.drag.pointer, void 0, !0);\n    }\n    onDrag(t) {\n      if (!0 === this.drag.pinched) return;\n      this.body.emitter.emit(\"unlockNode\");\n      const e = this.getPointer(t.center),\n        i = this.drag.selection;\n      if (i && i.length && !0 === this.options.dragNodes) {\n        this.selectionHandler.generateClickEvent(\"dragging\", t, e);\n        const o = e.x - this.drag.pointer.x,\n          s = e.y - this.drag.pointer.y;\n        mc(i).call(i, t => {\n          const e = t.node;\n          !1 === t.xFixed && (e.x = this.canvas._XconvertDOMtoCanvas(this.canvas._XconvertCanvasToDOM(t.x) + o)), !1 === t.yFixed && (e.y = this.canvas._YconvertDOMtoCanvas(this.canvas._YconvertCanvasToDOM(t.y) + s));\n        }), this.body.emitter.emit(\"startSimulation\");\n      } else {\n        if (t.srcEvent.shiftKey) {\n          if (this.selectionHandler.generateClickEvent(\"dragging\", t, e, void 0, !0), void 0 === this.drag.pointer) return void this.onDragStart(t);\n          this.body.selectionBox.position.end = {\n            x: this.canvas._XconvertDOMtoCanvas(e.x),\n            y: this.canvas._YconvertDOMtoCanvas(e.y)\n          }, this.body.emitter.emit(\"_requestRedraw\");\n        }\n        if (!0 === this.options.dragView && !t.srcEvent.shiftKey) {\n          if (this.selectionHandler.generateClickEvent(\"dragging\", t, e, void 0, !0), void 0 === this.drag.pointer) return void this.onDragStart(t);\n          const i = e.x - this.drag.pointer.x,\n            o = e.y - this.drag.pointer.y;\n          this.body.view.translation = {\n            x: this.drag.translation.x + i,\n            y: this.drag.translation.y + o\n          }, this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n    }\n    onDragEnd(t) {\n      if (this.drag.dragging = !1, this.body.selectionBox.show) {\n        var e;\n        this.body.selectionBox.show = !1;\n        const i = this.body.selectionBox.position,\n          o = {\n            minX: Math.min(i.start.x, i.end.x),\n            minY: Math.min(i.start.y, i.end.y),\n            maxX: Math.max(i.start.x, i.end.x),\n            maxY: Math.max(i.start.y, i.end.y)\n          },\n          s = Ru(e = this.body.nodeIndices).call(e, t => {\n            const e = this.body.nodes[t];\n            return e.x >= o.minX && e.x <= o.maxX && e.y >= o.minY && e.y <= o.maxY;\n          });\n        mc(s).call(s, t => this.selectionHandler.selectObject(this.body.nodes[t]));\n        const n = this.getPointer(t.center);\n        this.selectionHandler.commitAndEmit(n, t), this.selectionHandler.generateClickEvent(\"dragEnd\", t, this.getPointer(t.center), void 0, !0), this.body.emitter.emit(\"_requestRedraw\");\n      } else {\n        const e = this.drag.selection;\n        e && e.length ? (mc(e).call(e, function (t) {\n          t.node.options.fixed.x = t.xFixed, t.node.options.fixed.y = t.yFixed;\n        }), this.selectionHandler.generateClickEvent(\"dragEnd\", t, this.getPointer(t.center)), this.body.emitter.emit(\"startSimulation\")) : (this.selectionHandler.generateClickEvent(\"dragEnd\", t, this.getPointer(t.center), void 0, !0), this.body.emitter.emit(\"_requestRedraw\"));\n      }\n    }\n    onPinch(t) {\n      const e = this.getPointer(t.center);\n      this.drag.pinched = !0, void 0 === this.pinch.scale && (this.pinch.scale = 1);\n      const i = this.pinch.scale * t.scale;\n      this.zoom(i, e);\n    }\n    zoom(t, e) {\n      if (!0 === this.options.zoomView) {\n        const i = this.body.view.scale;\n        let o;\n        t < 1e-5 && (t = 1e-5), t > 10 && (t = 10), void 0 !== this.drag && !0 === this.drag.dragging && (o = this.canvas.DOMtoCanvas(this.drag.pointer));\n        const s = this.body.view.translation,\n          n = t / i,\n          r = (1 - n) * e.x + s.x * n,\n          a = (1 - n) * e.y + s.y * n;\n        if (this.body.view.scale = t, this.body.view.translation = {\n          x: r,\n          y: a\n        }, null != o) {\n          const t = this.canvas.canvasToDOM(o);\n          this.drag.pointer.x = t.x, this.drag.pointer.y = t.y;\n        }\n        this.body.emitter.emit(\"_requestRedraw\"), i < t ? this.body.emitter.emit(\"zoom\", {\n          direction: \"+\",\n          scale: this.body.view.scale,\n          pointer: e\n        }) : this.body.emitter.emit(\"zoom\", {\n          direction: \"-\",\n          scale: this.body.view.scale,\n          pointer: e\n        });\n      }\n    }\n    onMouseWheel(t) {\n      if (!0 === this.options.zoomView) {\n        if (0 !== t.deltaY) {\n          let e = this.body.view.scale;\n          e *= 1 + (t.deltaY < 0 ? 1 : -1) * (.1 * this.options.zoomSpeed);\n          const i = this.getPointer({\n            x: t.clientX,\n            y: t.clientY\n          });\n          this.zoom(e, i);\n        }\n        t.preventDefault();\n      }\n    }\n    onMouseMove(t) {\n      const e = this.getPointer({\n        x: t.clientX,\n        y: t.clientY\n      });\n      let i = !1;\n      void 0 !== this.popup && (!1 === this.popup.hidden && this._checkHidePopup(e), !1 === this.popup.hidden && (i = !0, this.popup.setPosition(e.x + 3, e.y - 5), this.popup.show())), this.options.keyboard.autoFocus && !1 === this.options.keyboard.bindToWindow && !0 === this.options.keyboard.enabled && this.canvas.frame.focus(), !1 === i && (void 0 !== this.popupTimer && (clearInterval(this.popupTimer), this.popupTimer = void 0), this.drag.dragging || (this.popupTimer = tg(() => this._checkShowPopup(e), this.options.tooltipDelay))), !0 === this.options.hover && this.selectionHandler.hoverObject(t, e);\n    }\n    _checkShowPopup(t) {\n      const e = this.canvas._XconvertDOMtoCanvas(t.x),\n        i = this.canvas._YconvertDOMtoCanvas(t.y),\n        o = {\n          left: e,\n          top: i,\n          right: e,\n          bottom: i\n        },\n        s = void 0 === this.popupObj ? void 0 : this.popupObj.id;\n      let n = !1,\n        r = \"node\";\n      if (void 0 === this.popupObj) {\n        const t = this.body.nodeIndices,\n          e = this.body.nodes;\n        let i;\n        const s = [];\n        for (let r = 0; r < t.length; r++) i = e[t[r]], !0 === i.isOverlappingWith(o) && (n = !0, void 0 !== i.getTitle() && s.push(t[r]));\n        s.length > 0 && (this.popupObj = e[s[s.length - 1]], n = !0);\n      }\n      if (void 0 === this.popupObj && !1 === n) {\n        const t = this.body.edgeIndices,\n          e = this.body.edges;\n        let i;\n        const s = [];\n        for (let n = 0; n < t.length; n++) i = e[t[n]], !0 === i.isOverlappingWith(o) && !0 === i.connected && void 0 !== i.getTitle() && s.push(t[n]);\n        s.length > 0 && (this.popupObj = e[s[s.length - 1]], r = \"edge\");\n      }\n      void 0 !== this.popupObj ? this.popupObj.id !== s && (void 0 === this.popup && (this.popup = new Km(this.canvas.frame)), this.popup.popupTargetType = r, this.popup.popupTargetId = this.popupObj.id, this.popup.setPosition(t.x + 3, t.y - 5), this.popup.setText(this.popupObj.getTitle()), this.popup.show(), this.body.emitter.emit(\"showPopup\", this.popupObj.id)) : void 0 !== this.popup && (this.popup.hide(), this.body.emitter.emit(\"hidePopup\"));\n    }\n    _checkHidePopup(t) {\n      const e = this.selectionHandler._pointerToPositionObject(t);\n      let i = !1;\n      if (\"node\" === this.popup.popupTargetType) {\n        if (void 0 !== this.body.nodes[this.popup.popupTargetId] && (i = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(e), !0 === i)) {\n          const e = this.selectionHandler.getNodeAt(t);\n          i = void 0 !== e && e.id === this.popup.popupTargetId;\n        }\n      } else void 0 === this.selectionHandler.getNodeAt(t) && void 0 !== this.body.edges[this.popup.popupTargetId] && (i = this.body.edges[this.popup.popupTargetId].isOverlappingWith(e));\n      !1 === i && (this.popupObj = void 0, this.popup.hide(), this.body.emitter.emit(\"hidePopup\"));\n    }\n  }\n  tv(\"Set\", function (t) {\n    return function () {\n      return t(this, arguments.length ? arguments[0] : void 0);\n    };\n  }, _v);\n  var yE = o(it.Set),\n    bE = y,\n    vE = iv,\n    wE = ib.getWeakData,\n    _E = Ab,\n    xE = oi,\n    EE = Y,\n    OE = et,\n    CE = Fb,\n    kE = Jt,\n    SE = Ar.set,\n    TE = Ar.getterFor,\n    ME = Ur.find,\n    DE = Ur.findIndex,\n    IE = bE([].splice),\n    PE = 0,\n    BE = function (t) {\n      return t.frozen || (t.frozen = new FE());\n    },\n    FE = function () {\n      this.entries = [];\n    },\n    zE = function (t, e) {\n      return ME(t.entries, function (t) {\n        return t[0] === e;\n      });\n    };\n  FE.prototype = {\n    get: function (t) {\n      var e = zE(this, t);\n      if (e) return e[1];\n    },\n    has: function (t) {\n      return !!zE(this, t);\n    },\n    set: function (t, e) {\n      var i = zE(this, t);\n      i ? i[1] = e : this.entries.push([t, e]);\n    },\n    delete: function (t) {\n      var e = DE(this.entries, function (e) {\n        return e[0] === t;\n      });\n      return ~e && IE(this.entries, e, 1), !!~e;\n    }\n  };\n  var NE,\n    AE = {\n      getConstructor: function (t, e, i, o) {\n        var s = t(function (t, s) {\n            _E(t, n), SE(t, {\n              type: e,\n              id: PE++,\n              frozen: void 0\n            }), EE(s) || CE(s, t[o], {\n              that: t,\n              AS_ENTRIES: i\n            });\n          }),\n          n = s.prototype,\n          r = TE(e),\n          a = function (t, e, i) {\n            var o = r(t),\n              s = wE(xE(e), !0);\n            return !0 === s ? BE(o).set(e, i) : s[o.id] = i, t;\n          };\n        return vE(n, {\n          delete: function (t) {\n            var e = r(this);\n            if (!OE(t)) return !1;\n            var i = wE(t);\n            return !0 === i ? BE(e).delete(t) : i && kE(i, e.id) && delete i[e.id];\n          },\n          has: function (t) {\n            var e = r(this);\n            if (!OE(t)) return !1;\n            var i = wE(t);\n            return !0 === i ? BE(e).has(t) : i && kE(i, e.id);\n          }\n        }), vE(n, i ? {\n          get: function (t) {\n            var e = r(this);\n            if (OE(t)) {\n              var i = wE(t);\n              return !0 === i ? BE(e).get(t) : i ? i[e.id] : void 0;\n            }\n          },\n          set: function (t, e) {\n            return a(this, t, e);\n          }\n        } : {\n          add: function (t) {\n            return a(this, t, !0);\n          }\n        }), s;\n      }\n    },\n    RE = Ly,\n    jE = n,\n    LE = y,\n    HE = iv,\n    WE = ib,\n    VE = tv,\n    qE = AE,\n    UE = et,\n    YE = Ar.enforce,\n    XE = r,\n    KE = Er,\n    GE = Object,\n    ZE = Array.isArray,\n    QE = GE.isExtensible,\n    $E = GE.isFrozen,\n    JE = GE.isSealed,\n    tO = GE.freeze,\n    eO = GE.seal,\n    iO = {},\n    oO = {},\n    sO = !jE.ActiveXObject && \"ActiveXObject\" in jE,\n    nO = function (t) {\n      return function () {\n        return t(this, arguments.length ? arguments[0] : void 0);\n      };\n    },\n    rO = VE(\"WeakMap\", nO, qE),\n    aO = rO.prototype,\n    hO = LE(aO.set);\n  if (KE) if (sO) {\n    NE = qE.getConstructor(nO, \"WeakMap\", !0), WE.enable();\n    var dO = LE(aO.delete),\n      lO = LE(aO.has),\n      cO = LE(aO.get);\n    HE(aO, {\n      delete: function (t) {\n        if (UE(t) && !QE(t)) {\n          var e = YE(this);\n          return e.frozen || (e.frozen = new NE()), dO(this, t) || e.frozen.delete(t);\n        }\n        return dO(this, t);\n      },\n      has: function (t) {\n        if (UE(t) && !QE(t)) {\n          var e = YE(this);\n          return e.frozen || (e.frozen = new NE()), lO(this, t) || e.frozen.has(t);\n        }\n        return lO(this, t);\n      },\n      get: function (t) {\n        if (UE(t) && !QE(t)) {\n          var e = YE(this);\n          return e.frozen || (e.frozen = new NE()), lO(this, t) ? cO(this, t) : e.frozen.get(t);\n        }\n        return cO(this, t);\n      },\n      set: function (t, e) {\n        if (UE(t) && !QE(t)) {\n          var i = YE(this);\n          i.frozen || (i.frozen = new NE()), lO(this, t) ? hO(this, t, e) : i.frozen.set(t, e);\n        } else hO(this, t, e);\n        return this;\n      }\n    });\n  } else RE && XE(function () {\n    var t = tO([]);\n    return hO(new rO(), t, 1), !$E(t);\n  }) && HE(aO, {\n    set: function (t, e) {\n      var i;\n      return ZE(t) && ($E(t) ? i = iO : JE(t) && (i = oO)), hO(this, t, e), i === iO && tO(t), i === oO && eO(t), this;\n    }\n  });\n  var uO,\n    pO,\n    gO,\n    fO,\n    mO,\n    yO = o(it.WeakMap);\n  function bO(t, e, i, o) {\n    if (\"a\" === i && !o) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (\"function\" == typeof e ? t !== e || !o : !e.has(t)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return \"m\" === i ? o : \"a\" === i ? o.call(t) : o ? o.value : e.get(t);\n  }\n  function vO(t, e, i, o, s) {\n    if (\"m\" === o) throw new TypeError(\"Private method is not writable\");\n    if (\"a\" === o && !s) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (\"function\" == typeof e ? t !== e || !s : !e.has(t)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return \"a\" === o ? s.call(t, i) : s ? s.value = i : e.set(t, i), i;\n  }\n  function wO(t, e) {\n    const i = new yE();\n    for (const o of e) t.has(o) || i.add(o);\n    return i;\n  }\n  \"function\" == typeof SuppressedError && SuppressedError;\n  class _O {\n    constructor() {\n      uO.set(this, new yE()), pO.set(this, new yE());\n    }\n    get size() {\n      return bO(this, pO, \"f\").size;\n    }\n    add() {\n      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];\n      for (const t of e) bO(this, pO, \"f\").add(t);\n    }\n    delete() {\n      for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];\n      for (const t of e) bO(this, pO, \"f\").delete(t);\n    }\n    clear() {\n      bO(this, pO, \"f\").clear();\n    }\n    getSelection() {\n      return [...bO(this, pO, \"f\")];\n    }\n    getChanges() {\n      return {\n        added: [...wO(bO(this, uO, \"f\"), bO(this, pO, \"f\"))],\n        deleted: [...wO(bO(this, pO, \"f\"), bO(this, uO, \"f\"))],\n        previous: [...new yE(bO(this, uO, \"f\"))],\n        current: [...new yE(bO(this, pO, \"f\"))]\n      };\n    }\n    commit() {\n      const t = this.getChanges();\n      vO(this, uO, bO(this, pO, \"f\"), \"f\"), vO(this, pO, new yE(bO(this, uO, \"f\")), \"f\");\n      for (const e of t.added) e.select();\n      for (const e of t.deleted) e.unselect();\n      return t;\n    }\n  }\n  uO = new yO(), pO = new yO();\n  class xO {\n    constructor() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : () => {};\n      gO.set(this, new _O()), fO.set(this, new _O()), mO.set(this, void 0), vO(this, mO, t, \"f\");\n    }\n    get sizeNodes() {\n      return bO(this, gO, \"f\").size;\n    }\n    get sizeEdges() {\n      return bO(this, fO, \"f\").size;\n    }\n    getNodes() {\n      return bO(this, gO, \"f\").getSelection();\n    }\n    getEdges() {\n      return bO(this, fO, \"f\").getSelection();\n    }\n    addNodes() {\n      bO(this, gO, \"f\").add(...arguments);\n    }\n    addEdges() {\n      bO(this, fO, \"f\").add(...arguments);\n    }\n    deleteNodes(t) {\n      bO(this, gO, \"f\").delete(t);\n    }\n    deleteEdges(t) {\n      bO(this, fO, \"f\").delete(t);\n    }\n    clear() {\n      bO(this, gO, \"f\").clear(), bO(this, fO, \"f\").clear();\n    }\n    commit() {\n      const t = {\n        nodes: bO(this, gO, \"f\").commit(),\n        edges: bO(this, fO, \"f\").commit()\n      };\n      for (var e = arguments.length, i = new Array(e), o = 0; o < e; o++) i[o] = arguments[o];\n      return bO(this, mO, \"f\").call(this, t, ...i), t;\n    }\n  }\n  gO = new yO(), fO = new yO(), mO = new yO();\n  class EO {\n    constructor(t, e) {\n      this.body = t, this.canvas = e, this._selectionAccumulator = new xO(), this.hoverObj = {\n        nodes: {},\n        edges: {}\n      }, this.options = {}, this.defaultOptions = {\n        multiselect: !1,\n        selectable: !0,\n        selectConnectedEdges: !0,\n        hoverConnectedEdges: !0\n      }, wo(this.options, this.defaultOptions), this.body.emitter.on(\"_dataChanged\", () => {\n        this.updateSelection();\n      });\n    }\n    setOptions(t) {\n      if (void 0 !== t) {\n        wm([\"multiselect\", \"hoverConnectedEdges\", \"selectable\", \"selectConnectedEdges\"], this.options, t);\n      }\n    }\n    selectOnPoint(t) {\n      let e = !1;\n      if (!0 === this.options.selectable) {\n        const i = this.getNodeAt(t) || this.getEdgeAt(t);\n        this.unselectAll(), void 0 !== i && (e = this.selectObject(i)), this.body.emitter.emit(\"_requestRedraw\");\n      }\n      return e;\n    }\n    selectAdditionalOnPoint(t) {\n      let e = !1;\n      if (!0 === this.options.selectable) {\n        const i = this.getNodeAt(t) || this.getEdgeAt(t);\n        void 0 !== i && (e = !0, !0 === i.isSelected() ? this.deselectObject(i) : this.selectObject(i), this.body.emitter.emit(\"_requestRedraw\"));\n      }\n      return e;\n    }\n    _initBaseEvent(t, e) {\n      const i = {};\n      return i.pointer = {\n        DOM: {\n          x: e.x,\n          y: e.y\n        },\n        canvas: this.canvas.DOMtoCanvas(e)\n      }, i.event = t, i;\n    }\n    generateClickEvent(t, e, i, o) {\n      let s = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];\n      const n = this._initBaseEvent(e, i);\n      if (!0 === s) n.nodes = [], n.edges = [];else {\n        const t = this.getSelection();\n        n.nodes = t.nodes, n.edges = t.edges;\n      }\n      void 0 !== o && (n.previousSelection = o), \"click\" == t && (n.items = this.getClickedItems(i)), void 0 !== e.controlEdge && (n.controlEdge = e.controlEdge), this.body.emitter.emit(t, n);\n    }\n    selectObject(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.options.selectConnectedEdges;\n      return void 0 !== t && (t instanceof lx ? (!0 === e && this._selectionAccumulator.addEdges(...t.edges), this._selectionAccumulator.addNodes(t)) : this._selectionAccumulator.addEdges(t), !0);\n    }\n    deselectObject(t) {\n      !0 === t.isSelected() && (t.selected = !1, this._removeFromSelection(t));\n    }\n    _getAllNodesOverlappingWith(t) {\n      const e = [],\n        i = this.body.nodes;\n      for (let o = 0; o < this.body.nodeIndices.length; o++) {\n        const s = this.body.nodeIndices[o];\n        i[s].isOverlappingWith(t) && e.push(s);\n      }\n      return e;\n    }\n    _pointerToPositionObject(t) {\n      const e = this.canvas.DOMtoCanvas(t);\n      return {\n        left: e.x - 1,\n        top: e.y + 1,\n        right: e.x + 1,\n        bottom: e.y - 1\n      };\n    }\n    getNodeAt(t) {\n      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      const i = this._pointerToPositionObject(t),\n        o = this._getAllNodesOverlappingWith(i);\n      return o.length > 0 ? !0 === e ? this.body.nodes[o[o.length - 1]] : o[o.length - 1] : void 0;\n    }\n    _getEdgesOverlappingWith(t, e) {\n      const i = this.body.edges;\n      for (let o = 0; o < this.body.edgeIndices.length; o++) {\n        const s = this.body.edgeIndices[o];\n        i[s].isOverlappingWith(t) && e.push(s);\n      }\n    }\n    _getAllEdgesOverlappingWith(t) {\n      const e = [];\n      return this._getEdgesOverlappingWith(t, e), e;\n    }\n    getEdgeAt(t) {\n      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      const i = this.canvas.DOMtoCanvas(t);\n      let o = 10,\n        s = null;\n      const n = this.body.edges;\n      for (let t = 0; t < this.body.edgeIndices.length; t++) {\n        const e = this.body.edgeIndices[t],\n          r = n[e];\n        if (r.connected) {\n          const t = r.from.x,\n            n = r.from.y,\n            a = r.to.x,\n            h = r.to.y,\n            d = r.edgeType.getDistanceToEdge(t, n, a, h, i.x, i.y);\n          d < o && (s = e, o = d);\n        }\n      }\n      return null !== s ? !0 === e ? this.body.edges[s] : s : void 0;\n    }\n    _addToHover(t) {\n      t instanceof lx ? this.hoverObj.nodes[t.id] = t : this.hoverObj.edges[t.id] = t;\n    }\n    _removeFromSelection(t) {\n      t instanceof lx ? (this._selectionAccumulator.deleteNodes(t), this._selectionAccumulator.deleteEdges(...t.edges)) : this._selectionAccumulator.deleteEdges(t);\n    }\n    unselectAll() {\n      this._selectionAccumulator.clear();\n    }\n    getSelectedNodeCount() {\n      return this._selectionAccumulator.sizeNodes;\n    }\n    getSelectedEdgeCount() {\n      return this._selectionAccumulator.sizeEdges;\n    }\n    _hoverConnectedEdges(t) {\n      for (let e = 0; e < t.edges.length; e++) {\n        const i = t.edges[e];\n        i.hover = !0, this._addToHover(i);\n      }\n    }\n    emitBlurEvent(t, e, i) {\n      const o = this._initBaseEvent(t, e);\n      !0 === i.hover && (i.hover = !1, i instanceof lx ? (o.node = i.id, this.body.emitter.emit(\"blurNode\", o)) : (o.edge = i.id, this.body.emitter.emit(\"blurEdge\", o)));\n    }\n    emitHoverEvent(t, e, i) {\n      const o = this._initBaseEvent(t, e);\n      let s = !1;\n      return !1 === i.hover && (i.hover = !0, this._addToHover(i), s = !0, i instanceof lx ? (o.node = i.id, this.body.emitter.emit(\"hoverNode\", o)) : (o.edge = i.id, this.body.emitter.emit(\"hoverEdge\", o))), s;\n    }\n    hoverObject(t, e) {\n      let i = this.getNodeAt(e);\n      void 0 === i && (i = this.getEdgeAt(e));\n      let o = !1;\n      for (const s in this.hoverObj.nodes) Object.prototype.hasOwnProperty.call(this.hoverObj.nodes, s) && (void 0 === i || i instanceof lx && i.id != s || i instanceof Vx) && (this.emitBlurEvent(t, e, this.hoverObj.nodes[s]), delete this.hoverObj.nodes[s], o = !0);\n      for (const s in this.hoverObj.edges) Object.prototype.hasOwnProperty.call(this.hoverObj.edges, s) && (!0 === o ? (this.hoverObj.edges[s].hover = !1, delete this.hoverObj.edges[s]) : (void 0 === i || i instanceof Vx && i.id != s || i instanceof lx && !i.hover) && (this.emitBlurEvent(t, e, this.hoverObj.edges[s]), delete this.hoverObj.edges[s], o = !0));\n      if (void 0 !== i) {\n        const s = Jl(this.hoverObj.edges).length,\n          n = Jl(this.hoverObj.nodes).length;\n        (o || i instanceof Vx && 0 === s && 0 === n || i instanceof lx && 0 === s && 0 === n) && (o = this.emitHoverEvent(t, e, i)), i instanceof lx && !0 === this.options.hoverConnectedEdges && this._hoverConnectedEdges(i);\n      }\n      !0 === o && this.body.emitter.emit(\"_requestRedraw\");\n    }\n    commitWithoutEmitting() {\n      this._selectionAccumulator.commit();\n    }\n    commitAndEmit(t, e) {\n      let i = !1;\n      const o = this._selectionAccumulator.commit(),\n        s = {\n          nodes: o.nodes.previous,\n          edges: o.edges.previous\n        };\n      o.edges.deleted.length > 0 && (this.generateClickEvent(\"deselectEdge\", e, t, s), i = !0), o.nodes.deleted.length > 0 && (this.generateClickEvent(\"deselectNode\", e, t, s), i = !0), o.nodes.added.length > 0 && (this.generateClickEvent(\"selectNode\", e, t), i = !0), o.edges.added.length > 0 && (this.generateClickEvent(\"selectEdge\", e, t), i = !0), !0 === i && this.generateClickEvent(\"select\", e, t);\n    }\n    getSelection() {\n      return {\n        nodes: this.getSelectedNodeIds(),\n        edges: this.getSelectedEdgeIds()\n      };\n    }\n    getSelectedNodes() {\n      return this._selectionAccumulator.getNodes();\n    }\n    getSelectedEdges() {\n      return this._selectionAccumulator.getEdges();\n    }\n    getSelectedNodeIds() {\n      var t;\n      return Zl(t = this._selectionAccumulator.getNodes()).call(t, t => t.id);\n    }\n    getSelectedEdgeIds() {\n      var t;\n      return Zl(t = this._selectionAccumulator.getEdges()).call(t, t => t.id);\n    }\n    setSelection(t) {\n      let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      if (!t || !t.nodes && !t.edges) throw new TypeError(\"Selection must be an object with nodes and/or edges properties\");\n      if ((e.unselectAll || void 0 === e.unselectAll) && this.unselectAll(), t.nodes) for (const i of t.nodes) {\n        const t = this.body.nodes[i];\n        if (!t) throw new RangeError('Node with id \"' + i + '\" not found');\n        this.selectObject(t, e.highlightEdges);\n      }\n      if (t.edges) for (const e of t.edges) {\n        const t = this.body.edges[e];\n        if (!t) throw new RangeError('Edge with id \"' + e + '\" not found');\n        this.selectObject(t);\n      }\n      this.body.emitter.emit(\"_requestRedraw\"), this._selectionAccumulator.commit();\n    }\n    selectNodes(t) {\n      let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      if (!t || void 0 === t.length) throw \"Selection must be an array with ids\";\n      this.setSelection({\n        nodes: t\n      }, {\n        highlightEdges: e\n      });\n    }\n    selectEdges(t) {\n      if (!t || void 0 === t.length) throw \"Selection must be an array with ids\";\n      this.setSelection({\n        edges: t\n      });\n    }\n    updateSelection() {\n      for (const t in this._selectionAccumulator.getNodes()) Object.prototype.hasOwnProperty.call(this.body.nodes, t.id) || this._selectionAccumulator.deleteNodes(t);\n      for (const t in this._selectionAccumulator.getEdges()) Object.prototype.hasOwnProperty.call(this.body.edges, t.id) || this._selectionAccumulator.deleteEdges(t);\n    }\n    getClickedItems(t) {\n      const e = this.canvas.DOMtoCanvas(t),\n        i = [],\n        o = this.body.nodeIndices,\n        s = this.body.nodes;\n      for (let t = o.length - 1; t >= 0; t--) {\n        const n = s[o[t]].getItemsOnPoint(e);\n        i.push.apply(i, n);\n      }\n      const n = this.body.edgeIndices,\n        r = this.body.edges;\n      for (let t = n.length - 1; t >= 0; t--) {\n        const o = r[n[t]].getItemsOnPoint(e);\n        i.push.apply(i, o);\n      }\n      return i;\n    }\n  }\n  var OO = Hn,\n    CO = Math.floor,\n    kO = function (t, e) {\n      var i = t.length,\n        o = CO(i / 2);\n      return i < 8 ? SO(t, e) : TO(t, kO(OO(t, 0, o), e), kO(OO(t, o), e), e);\n    },\n    SO = function (t, e) {\n      for (var i, o, s = t.length, n = 1; n < s;) {\n        for (o = n, i = t[n]; o && e(t[o - 1], i) > 0;) t[o] = t[--o];\n        o !== n++ && (t[o] = i);\n      }\n      return t;\n    },\n    TO = function (t, e, i, o) {\n      for (var s = e.length, n = i.length, r = 0, a = 0; r < s || a < n;) t[r + a] = r < s && a < n ? o(e[r], i[a]) <= 0 ? e[r++] : i[a++] : r < s ? e[r++] : i[a++];\n      return t;\n    },\n    MO = kO,\n    DO = dt.match(/firefox\\/(\\d+)/i),\n    IO = !!DO && +DO[1],\n    PO = /MSIE|Trident/.test(dt),\n    BO = dt.match(/AppleWebKit\\/(\\d+)\\./),\n    FO = !!BO && +BO[1],\n    zO = Mi,\n    NO = y,\n    AO = Pt,\n    RO = Zt,\n    jO = Hi,\n    LO = Fc,\n    HO = nn,\n    WO = r,\n    VO = MO,\n    qO = nc,\n    UO = IO,\n    YO = PO,\n    XO = mt,\n    KO = FO,\n    GO = [],\n    ZO = NO(GO.sort),\n    QO = NO(GO.push),\n    $O = WO(function () {\n      GO.sort(void 0);\n    }),\n    JO = WO(function () {\n      GO.sort(null);\n    }),\n    tC = qO(\"sort\"),\n    eC = !WO(function () {\n      if (XO) return XO < 70;\n      if (!(UO && UO > 3)) {\n        if (YO) return !0;\n        if (KO) return KO < 603;\n        var t,\n          e,\n          i,\n          o,\n          s = \"\";\n        for (t = 65; t < 76; t++) {\n          switch (e = String.fromCharCode(t), t) {\n            case 66:\n            case 69:\n            case 70:\n            case 72:\n              i = 3;\n              break;\n            case 68:\n            case 71:\n              i = 4;\n              break;\n            default:\n              i = 2;\n          }\n          for (o = 0; o < 47; o++) GO.push({\n            k: e + o,\n            v: i\n          });\n        }\n        for (GO.sort(function (t, e) {\n          return e.v - t.v;\n        }), o = 0; o < GO.length; o++) e = GO[o].k.charAt(0), s.charAt(s.length - 1) !== e && (s += e);\n        return \"DGBEFHACIJK\" !== s;\n      }\n    });\n  zO({\n    target: \"Array\",\n    proto: !0,\n    forced: $O || !JO || !tC || !eC\n  }, {\n    sort: function (t) {\n      void 0 !== t && AO(t);\n      var e = RO(this);\n      if (eC) return void 0 === t ? ZO(e) : ZO(e, t);\n      var i,\n        o,\n        s = [],\n        n = jO(e);\n      for (o = 0; o < n; o++) o in e && QO(s, e[o]);\n      for (VO(s, function (t) {\n        return function (e, i) {\n          return void 0 === i ? -1 : void 0 === e ? 1 : void 0 !== t ? +t(e, i) || 0 : HO(e) > HO(i) ? 1 : -1;\n        };\n      }(t)), i = jO(s), o = 0; o < i;) e[o] = s[o++];\n      for (; o < n;) LO(e, o++);\n      return e;\n    }\n  });\n  var iC = zo(\"Array\").sort,\n    oC = ht,\n    sC = iC,\n    nC = Array.prototype,\n    rC = function (t) {\n      var e = t.sort;\n      return t === nC || oC(nC, t) && e === nC.sort ? sC : e;\n    },\n    aC = o(rC),\n    hC = Pt,\n    dC = Zt,\n    lC = U,\n    cC = Hi,\n    uC = TypeError,\n    pC = function (t) {\n      return function (e, i, o, s) {\n        hC(i);\n        var n = dC(e),\n          r = lC(n),\n          a = cC(n),\n          h = t ? a - 1 : 0,\n          d = t ? -1 : 1;\n        if (o < 2) for (;;) {\n          if (h in r) {\n            s = r[h], h += d;\n            break;\n          }\n          if (h += d, t ? h < 0 : a <= h) throw new uC(\"Reduce of empty array with no initial value\");\n        }\n        for (; t ? h >= 0 : a > h; h += d) h in r && (s = i(s, r[h], h, n));\n        return s;\n      };\n    },\n    gC = {\n      left: pC(!1),\n      right: pC(!0)\n    },\n    fC = \"process\" === _(n.process),\n    mC = gC.left;\n  Mi({\n    target: \"Array\",\n    proto: !0,\n    forced: !fC && mt > 79 && mt < 83 || !nc(\"reduce\")\n  }, {\n    reduce: function (t) {\n      var e = arguments.length;\n      return mC(this, t, e, e > 1 ? arguments[1] : void 0);\n    }\n  });\n  var yC = zo(\"Array\").reduce,\n    bC = ht,\n    vC = yC,\n    wC = Array.prototype,\n    _C = function (t) {\n      var e = t.reduce;\n      return t === wC || bC(wC, t) && e === wC.reduce ? vC : e;\n    },\n    xC = o(_C);\n  class EC {\n    abstract() {\n      throw new Error(\"Can't instantiate abstract class!\");\n    }\n    fake_use() {}\n    curveType() {\n      return this.abstract();\n    }\n    getPosition(t) {\n      return this.fake_use(t), this.abstract();\n    }\n    setPosition(t, e) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;\n      this.fake_use(t, e, i), this.abstract();\n    }\n    getTreeSize(t) {\n      return this.fake_use(t), this.abstract();\n    }\n    sort(t) {\n      this.fake_use(t), this.abstract();\n    }\n    fix(t, e) {\n      this.fake_use(t, e), this.abstract();\n    }\n    shift(t, e) {\n      this.fake_use(t, e), this.abstract();\n    }\n  }\n  class OC extends EC {\n    constructor(t) {\n      super(), this.layout = t;\n    }\n    curveType() {\n      return \"horizontal\";\n    }\n    getPosition(t) {\n      return t.x;\n    }\n    setPosition(t, e) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;\n      void 0 !== i && this.layout.hierarchical.addToOrdering(t, i), t.x = e;\n    }\n    getTreeSize(t) {\n      const e = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, t);\n      return {\n        min: e.min_x,\n        max: e.max_x\n      };\n    }\n    sort(t) {\n      aC(t).call(t, function (t, e) {\n        return t.x - e.x;\n      });\n    }\n    fix(t, e) {\n      t.y = this.layout.options.hierarchical.levelSeparation * e, t.options.fixed.y = !0;\n    }\n    shift(t, e) {\n      this.layout.body.nodes[t].x += e;\n    }\n  }\n  class CC extends EC {\n    constructor(t) {\n      super(), this.layout = t;\n    }\n    curveType() {\n      return \"vertical\";\n    }\n    getPosition(t) {\n      return t.y;\n    }\n    setPosition(t, e) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;\n      void 0 !== i && this.layout.hierarchical.addToOrdering(t, i), t.y = e;\n    }\n    getTreeSize(t) {\n      const e = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, t);\n      return {\n        min: e.min_y,\n        max: e.max_y\n      };\n    }\n    sort(t) {\n      aC(t).call(t, function (t, e) {\n        return t.y - e.y;\n      });\n    }\n    fix(t, e) {\n      t.x = this.layout.options.hierarchical.levelSeparation * e, t.options.fixed.x = !0;\n    }\n    shift(t, e) {\n      this.layout.body.nodes[t].y += e;\n    }\n  }\n  var kC = Ur.every;\n  Mi({\n    target: \"Array\",\n    proto: !0,\n    forced: !nc(\"every\")\n  }, {\n    every: function (t) {\n      return kC(this, t, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n  var SC = zo(\"Array\").every,\n    TC = ht,\n    MC = SC,\n    DC = Array.prototype,\n    IC = function (t) {\n      var e = t.every;\n      return t === DC || TC(DC, t) && e === DC.every ? MC : e;\n    },\n    PC = o(IC);\n  function BC(t, e) {\n    const i = new yE();\n    return mc(t).call(t, t => {\n      var e;\n      mc(e = t.edges).call(e, t => {\n        t.connected && i.add(t);\n      });\n    }), mc(i).call(i, t => {\n      const i = t.from.id,\n        o = t.to.id;\n      null == e[i] && (e[i] = 0), (null == e[o] || e[i] >= e[o]) && (e[o] = e[i] + 1);\n    }), e;\n  }\n  function FC(t, e, i, o) {\n    var s;\n    const n = Ip(null),\n      r = xC(s = [...F_(o).call(o)]).call(s, (t, e) => t + 1 + e.edges.length, 0),\n      a = i + \"Id\",\n      h = \"to\" === i ? 1 : -1;\n    for (const [s, c] of o) {\n      if (!o.has(s) || !t(c)) continue;\n      n[s] = 0;\n      const u = [c];\n      let p,\n        g = 0;\n      for (; p = u.pop();) {\n        var d, l;\n        if (!o.has(s)) continue;\n        const t = n[p.id] + h;\n        if (mc(d = Ru(l = p.edges).call(l, t => t.connected && t.to !== t.from && t[i] !== p && o.has(t.toId) && o.has(t.fromId))).call(d, o => {\n          const s = o[a],\n            r = n[s];\n          (null == r || e(t, r)) && (n[s] = t, u.push(o[i]));\n        }), g > r) return BC(o, n);\n        ++g;\n      }\n    }\n    return n;\n  }\n  class zC {\n    constructor() {\n      this.childrenReference = {}, this.parentReference = {}, this.trees = {}, this.distributionOrdering = {}, this.levels = {}, this.distributionIndex = {}, this.isTree = !1, this.treeIndex = -1;\n    }\n    addRelation(t, e) {\n      void 0 === this.childrenReference[t] && (this.childrenReference[t] = []), this.childrenReference[t].push(e), void 0 === this.parentReference[e] && (this.parentReference[e] = []), this.parentReference[e].push(t);\n    }\n    checkIfTree() {\n      for (const t in this.parentReference) if (this.parentReference[t].length > 1) return void (this.isTree = !1);\n      this.isTree = !0;\n    }\n    numTrees() {\n      return this.treeIndex + 1;\n    }\n    setTreeIndex(t, e) {\n      void 0 !== e && void 0 === this.trees[t.id] && (this.trees[t.id] = e, this.treeIndex = Math.max(e, this.treeIndex));\n    }\n    ensureLevel(t) {\n      void 0 === this.levels[t] && (this.levels[t] = 0);\n    }\n    getMaxLevel(t) {\n      const e = {},\n        i = t => {\n          if (void 0 !== e[t]) return e[t];\n          let o = this.levels[t];\n          if (this.childrenReference[t]) {\n            const e = this.childrenReference[t];\n            if (e.length > 0) for (let t = 0; t < e.length; t++) o = Math.max(o, i(e[t]));\n          }\n          return e[t] = o, o;\n        };\n      return i(t);\n    }\n    levelDownstream(t, e) {\n      void 0 === this.levels[e.id] && (void 0 === this.levels[t.id] && (this.levels[t.id] = 0), this.levels[e.id] = this.levels[t.id] + 1);\n    }\n    setMinLevelToZero() {\n      var t;\n      const e = new Rv();\n      let i = 0;\n      const o = aC(t = [...new yE(Zu(this.levels))]).call(t, (t, e) => t - e);\n      for (const t of o) e.set(t, i++);\n      for (const t in this.levels) Object.prototype.hasOwnProperty.call(this.levels, t) && (this.levels[t] = e.get(this.levels[t]));\n    }\n    getTreeSize(t, e) {\n      let i = 1e9,\n        o = -1e9,\n        s = 1e9,\n        n = -1e9;\n      for (const r in this.trees) if (Object.prototype.hasOwnProperty.call(this.trees, r) && this.trees[r] === e) {\n        const e = t[r];\n        i = Math.min(e.x, i), o = Math.max(e.x, o), s = Math.min(e.y, s), n = Math.max(e.y, n);\n      }\n      return {\n        min_x: i,\n        max_x: o,\n        min_y: s,\n        max_y: n\n      };\n    }\n    hasSameParent(t, e) {\n      const i = this.parentReference[t.id],\n        o = this.parentReference[e.id];\n      if (void 0 === i || void 0 === o) return !1;\n      for (let t = 0; t < i.length; t++) for (let e = 0; e < o.length; e++) if (i[t] == o[e]) return !0;\n      return !1;\n    }\n    inSameSubNetwork(t, e) {\n      return this.trees[t.id] === this.trees[e.id];\n    }\n    getLevels() {\n      return Jl(this.distributionOrdering);\n    }\n    addToOrdering(t, e) {\n      void 0 === this.distributionOrdering[e] && (this.distributionOrdering[e] = []);\n      let i = !1;\n      const o = this.distributionOrdering[e];\n      for (const e in o) if (o[e] === t) {\n        i = !0;\n        break;\n      }\n      i || (this.distributionOrdering[e].push(t), this.distributionIndex[t.id] = this.distributionOrdering[e].length - 1);\n    }\n  }\n  class NC {\n    constructor(t) {\n      this.body = t, this._resetRNG(Math.random() + \":\" + oc()), this.setPhysics = !1, this.options = {}, this.optionsBackup = {\n        physics: {}\n      }, this.defaultOptions = {\n        randomSeed: void 0,\n        improvedLayout: !0,\n        clusterThreshold: 150,\n        hierarchical: {\n          enabled: !1,\n          levelSeparation: 150,\n          nodeSpacing: 100,\n          treeSpacing: 200,\n          blockShifting: !0,\n          edgeMinimization: !0,\n          parentCentralization: !0,\n          direction: \"UD\",\n          sortMethod: \"hubsize\"\n        }\n      }, wo(this.options, this.defaultOptions), this.bindEventListeners();\n    }\n    bindEventListeners() {\n      this.body.emitter.on(\"_dataChanged\", () => {\n        this.setupHierarchicalLayout();\n      }), this.body.emitter.on(\"_dataLoaded\", () => {\n        this.layoutNetwork();\n      }), this.body.emitter.on(\"_resetHierarchicalLayout\", () => {\n        this.setupHierarchicalLayout();\n      }), this.body.emitter.on(\"_adjustEdgesForHierarchicalLayout\", () => {\n        if (!0 !== this.options.hierarchical.enabled) return;\n        const t = this.direction.curveType();\n        this.body.emitter.emit(\"_forceDisableDynamicCurves\", t, !1);\n      });\n    }\n    setOptions(t, e) {\n      if (void 0 !== t) {\n        const i = this.options.hierarchical,\n          o = i.enabled;\n        if (wm([\"randomSeed\", \"improvedLayout\", \"clusterThreshold\"], this.options, t), Nm(this.options, t, \"hierarchical\"), void 0 !== t.randomSeed && this._resetRNG(t.randomSeed), !0 === i.enabled) return !0 === o && this.body.emitter.emit(\"refresh\", !0), \"RL\" === i.direction || \"DU\" === i.direction ? i.levelSeparation > 0 && (i.levelSeparation *= -1) : i.levelSeparation < 0 && (i.levelSeparation *= -1), this.setDirectionStrategy(), this.body.emitter.emit(\"_resetHierarchicalLayout\"), this.adaptAllOptionsForHierarchicalLayout(e);\n        if (!0 === o) return this.body.emitter.emit(\"refresh\"), xm(e, this.optionsBackup);\n      }\n      return e;\n    }\n    _resetRNG(t) {\n      this.initialRandomSeed = t, this._rng = hm(this.initialRandomSeed);\n    }\n    adaptAllOptionsForHierarchicalLayout(t) {\n      if (!0 === this.options.hierarchical.enabled) {\n        const e = this.optionsBackup.physics;\n        void 0 === t.physics || !0 === t.physics ? (t.physics = {\n          enabled: void 0 === e.enabled || e.enabled,\n          solver: \"hierarchicalRepulsion\"\n        }, e.enabled = void 0 === e.enabled || e.enabled, e.solver = e.solver || \"barnesHut\") : \"object\" == typeof t.physics ? (e.enabled = void 0 === t.physics.enabled || t.physics.enabled, e.solver = t.physics.solver || \"barnesHut\", t.physics.solver = \"hierarchicalRepulsion\") : !1 !== t.physics && (e.solver = \"barnesHut\", t.physics = {\n          solver: \"hierarchicalRepulsion\"\n        });\n        let i = this.direction.curveType();\n        if (void 0 === t.edges) this.optionsBackup.edges = {\n          smooth: {\n            enabled: !0,\n            type: \"dynamic\"\n          }\n        }, t.edges = {\n          smooth: !1\n        };else if (void 0 === t.edges.smooth) this.optionsBackup.edges = {\n          smooth: {\n            enabled: !0,\n            type: \"dynamic\"\n          }\n        }, t.edges.smooth = !1;else if (\"boolean\" == typeof t.edges.smooth) this.optionsBackup.edges = {\n          smooth: t.edges.smooth\n        }, t.edges.smooth = {\n          enabled: t.edges.smooth,\n          type: i\n        };else {\n          const e = t.edges.smooth;\n          void 0 !== e.type && \"dynamic\" !== e.type && (i = e.type), this.optionsBackup.edges = {\n            smooth: {\n              enabled: void 0 === e.enabled || e.enabled,\n              type: void 0 === e.type ? \"dynamic\" : e.type,\n              roundness: void 0 === e.roundness ? .5 : e.roundness,\n              forceDirection: void 0 !== e.forceDirection && e.forceDirection\n            }\n          }, t.edges.smooth = {\n            enabled: void 0 === e.enabled || e.enabled,\n            type: i,\n            roundness: void 0 === e.roundness ? .5 : e.roundness,\n            forceDirection: void 0 !== e.forceDirection && e.forceDirection\n          };\n        }\n        this.body.emitter.emit(\"_forceDisableDynamicCurves\", i);\n      }\n      return t;\n    }\n    positionInitially(t) {\n      if (!0 !== this.options.hierarchical.enabled) {\n        this._resetRNG(this.initialRandomSeed);\n        const e = t.length + 50;\n        for (let i = 0; i < t.length; i++) {\n          const o = t[i],\n            s = 2 * Math.PI * this._rng();\n          void 0 === o.x && (o.x = e * Math.cos(s)), void 0 === o.y && (o.y = e * Math.sin(s));\n        }\n      }\n    }\n    layoutNetwork() {\n      if (!0 !== this.options.hierarchical.enabled && !0 === this.options.improvedLayout) {\n        const t = this.body.nodeIndices;\n        let e = 0;\n        for (let i = 0; i < t.length; i++) {\n          !0 === this.body.nodes[t[i]].predefinedPosition && (e += 1);\n        }\n        if (e < .5 * t.length) {\n          const e = 10;\n          let i = 0;\n          const o = this.options.clusterThreshold,\n            s = {\n              clusterNodeProperties: {\n                shape: \"ellipse\",\n                label: \"\",\n                group: \"\",\n                font: {\n                  multi: !1\n                }\n              },\n              clusterEdgeProperties: {\n                label: \"\",\n                font: {\n                  multi: !1\n                },\n                smooth: {\n                  enabled: !1\n                }\n              }\n            };\n          if (t.length > o) {\n            const n = t.length;\n            for (; t.length > o && i <= e;) {\n              i += 1;\n              const e = t.length;\n              i % 3 == 0 ? this.body.modules.clustering.clusterBridges(s) : this.body.modules.clustering.clusterOutliers(s);\n              if (e == t.length && i % 3 != 0) return this._declusterAll(), this.body.emitter.emit(\"_layoutFailed\"), void console.info(\"This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.\");\n            }\n            this.body.modules.kamadaKawai.setOptions({\n              springLength: Math.max(150, 2 * n)\n            });\n          }\n          i > e && console.info(\"The clustering didn't succeed within the amount of interations allowed, progressing with partial result.\"), this.body.modules.kamadaKawai.solve(t, this.body.edgeIndices, !0), this._shiftToCenter();\n          const n = 70;\n          for (let e = 0; e < t.length; e++) {\n            const i = this.body.nodes[t[e]];\n            !1 === i.predefinedPosition && (i.x += (.5 - this._rng()) * n, i.y += (.5 - this._rng()) * n);\n          }\n          this._declusterAll(), this.body.emitter.emit(\"_repositionBezierNodes\");\n        }\n      }\n    }\n    _shiftToCenter() {\n      const t = nE.getRangeCore(this.body.nodes, this.body.nodeIndices),\n        e = nE.findCenter(t);\n      for (let t = 0; t < this.body.nodeIndices.length; t++) {\n        const i = this.body.nodes[this.body.nodeIndices[t]];\n        i.x -= e.x, i.y -= e.y;\n      }\n    }\n    _declusterAll() {\n      let t = !0;\n      for (; !0 === t;) {\n        t = !1;\n        for (let e = 0; e < this.body.nodeIndices.length; e++) !0 === this.body.nodes[this.body.nodeIndices[e]].isCluster && (t = !0, this.body.modules.clustering.openCluster(this.body.nodeIndices[e], {}, !1));\n        !0 === t && this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n    getSeed() {\n      return this.initialRandomSeed;\n    }\n    setupHierarchicalLayout() {\n      if (!0 === this.options.hierarchical.enabled && this.body.nodeIndices.length > 0) {\n        let t,\n          e,\n          i = !1,\n          o = !1;\n        for (e in this.lastNodeOnLevel = {}, this.hierarchical = new zC(), this.body.nodes) Object.prototype.hasOwnProperty.call(this.body.nodes, e) && (t = this.body.nodes[e], void 0 !== t.options.level ? (i = !0, this.hierarchical.levels[e] = t.options.level) : o = !0);\n        if (!0 === o && !0 === i) throw new Error(\"To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.\");\n        {\n          if (!0 === o) {\n            const t = this.options.hierarchical.sortMethod;\n            \"hubsize\" === t ? this._determineLevelsByHubsize() : \"directed\" === t ? this._determineLevelsDirected() : \"custom\" === t && this._determineLevelsCustomCallback();\n          }\n          for (const t in this.body.nodes) Object.prototype.hasOwnProperty.call(this.body.nodes, t) && this.hierarchical.ensureLevel(t);\n          const t = this._getDistribution();\n          this._generateMap(), this._placeNodesByHierarchy(t), this._condenseHierarchy(), this._shiftToCenter();\n        }\n      }\n    }\n    _condenseHierarchy() {\n      var t = this;\n      let e = !1;\n      const i = {},\n        o = (t, e) => {\n          const i = this.hierarchical.trees;\n          for (const o in i) Object.prototype.hasOwnProperty.call(i, o) && i[o] === t && this.direction.shift(o, e);\n        },\n        s = () => {\n          const t = [];\n          for (let e = 0; e < this.hierarchical.numTrees(); e++) t.push(this.direction.getTreeSize(e));\n          return t;\n        },\n        n = (t, e) => {\n          if (!e[t.id] && (e[t.id] = !0, this.hierarchical.childrenReference[t.id])) {\n            const i = this.hierarchical.childrenReference[t.id];\n            if (i.length > 0) for (let t = 0; t < i.length; t++) n(this.body.nodes[i[t]], e);\n          }\n        },\n        r = function (e) {\n          let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e9,\n            o = 1e9,\n            s = 1e9,\n            n = 1e9,\n            r = -1e9;\n          for (const a in e) if (Object.prototype.hasOwnProperty.call(e, a)) {\n            const h = t.body.nodes[a],\n              d = t.hierarchical.levels[h.id],\n              l = t.direction.getPosition(h),\n              [c, u] = t._getSpaceAroundNode(h, e);\n            o = Math.min(c, o), s = Math.min(u, s), d <= i && (n = Math.min(l, n), r = Math.max(l, r));\n          }\n          return [n, r, o, s];\n        },\n        a = (t, e) => {\n          const i = this.hierarchical.getMaxLevel(t.id),\n            o = this.hierarchical.getMaxLevel(e.id);\n          return Math.min(i, o);\n        },\n        h = (t, e, i) => {\n          const o = this.hierarchical;\n          for (let s = 0; s < e.length; s++) {\n            const n = e[s],\n              r = o.distributionOrdering[n];\n            if (r.length > 1) for (let e = 0; e < r.length - 1; e++) {\n              const s = r[e],\n                n = r[e + 1];\n              o.hasSameParent(s, n) && o.inSameSubNetwork(s, n) && t(s, n, i);\n            }\n          }\n        },\n        d = function (i, o) {\n          let s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n          const h = t.direction.getPosition(i),\n            d = t.direction.getPosition(o),\n            l = Math.abs(d - h),\n            c = t.options.hierarchical.nodeSpacing;\n          if (l > c) {\n            const h = {},\n              d = {};\n            n(i, h), n(o, d);\n            const l = a(i, o),\n              u = r(h, l),\n              p = r(d, l),\n              g = u[1],\n              f = p[0],\n              m = p[2];\n            if (Math.abs(g - f) > c) {\n              let i = g - f + c;\n              i < -m + c && (i = -m + c), i < 0 && (t._shiftBlock(o.id, i), e = !0, !0 === s && t._centerParent(o));\n            }\n          }\n        },\n        l = (t, o) => {\n          const s = o.id,\n            a = o.edges,\n            h = this.hierarchical.levels[o.id],\n            d = this.options.hierarchical.levelSeparation * this.options.hierarchical.levelSeparation,\n            l = {},\n            c = [];\n          for (let t = 0; t < a.length; t++) {\n            const e = a[t];\n            if (e.toId != e.fromId) {\n              const i = e.toId == s ? e.from : e.to;\n              l[a[t].id] = i, this.hierarchical.levels[i.id] < h && c.push(e);\n            }\n          }\n          const u = (t, e) => {\n              let i = 0;\n              for (let o = 0; o < e.length; o++) if (void 0 !== l[e[o].id]) {\n                const s = this.direction.getPosition(l[e[o].id]) - t;\n                i += s / Math.sqrt(s * s + d);\n              }\n              return i;\n            },\n            p = (t, e) => {\n              let i = 0;\n              for (let o = 0; o < e.length; o++) if (void 0 !== l[e[o].id]) {\n                const s = this.direction.getPosition(l[e[o].id]) - t;\n                i -= d * Math.pow(s * s + d, -1.5);\n              }\n              return i;\n            },\n            g = (t, e) => {\n              let i = this.direction.getPosition(o);\n              const s = {};\n              for (let o = 0; o < t; o++) {\n                const t = u(i, e),\n                  n = p(i, e),\n                  r = 40;\n                if (i -= Math.max(-r, Math.min(r, Math.round(t / n))), void 0 !== s[i]) break;\n                s[i] = o;\n              }\n              return i;\n            };\n          let f = g(t, c);\n          (t => {\n            const s = this.direction.getPosition(o);\n            if (void 0 === i[o.id]) {\n              const t = {};\n              n(o, t), i[o.id] = t;\n            }\n            const a = r(i[o.id]),\n              h = a[2],\n              d = a[3],\n              l = t - s;\n            let c = 0;\n            l > 0 ? c = Math.min(l, d - this.options.hierarchical.nodeSpacing) : l < 0 && (c = -Math.min(-l, h - this.options.hierarchical.nodeSpacing)), 0 != c && (this._shiftBlock(o.id, c), e = !0);\n          })(f), f = g(t, a), (t => {\n            const i = this.direction.getPosition(o),\n              [s, n] = this._getSpaceAroundNode(o),\n              r = t - i;\n            let a = i;\n            r > 0 ? a = Math.min(i + (n - this.options.hierarchical.nodeSpacing), t) : r < 0 && (a = Math.max(i - (s - this.options.hierarchical.nodeSpacing), t)), a !== i && (this.direction.setPosition(o, a), e = !0);\n          })(f);\n        },\n        c = t => {\n          let i = this.hierarchical.getLevels();\n          i = kc(i).call(i);\n          for (let o = 0; o < t; o++) {\n            e = !1;\n            for (let t = 0; t < i.length; t++) {\n              const e = i[t],\n                o = this.hierarchical.distributionOrdering[e];\n              for (let t = 0; t < o.length; t++) l(1e3, o[t]);\n            }\n            if (!0 !== e) break;\n          }\n        },\n        u = t => {\n          let i = this.hierarchical.getLevels();\n          i = kc(i).call(i);\n          for (let o = 0; o < t && (e = !1, h(d, i, !0), !0 === e); o++);\n        },\n        p = () => {\n          for (const t in this.body.nodes) Object.prototype.hasOwnProperty.call(this.body.nodes, t) && this._centerParent(this.body.nodes[t]);\n        },\n        g = () => {\n          let t = this.hierarchical.getLevels();\n          t = kc(t).call(t);\n          for (let e = 0; e < t.length; e++) {\n            const i = t[e],\n              o = this.hierarchical.distributionOrdering[i];\n            for (let t = 0; t < o.length; t++) this._centerParent(o[t]);\n          }\n        };\n      !0 === this.options.hierarchical.blockShifting && (u(5), p()), !0 === this.options.hierarchical.edgeMinimization && c(20), !0 === this.options.hierarchical.parentCentralization && g(), (() => {\n        const t = s();\n        let e = 0;\n        for (let i = 0; i < t.length - 1; i++) {\n          e += t[i].max - t[i + 1].min + this.options.hierarchical.treeSpacing, o(i + 1, e);\n        }\n      })();\n    }\n    _getSpaceAroundNode(t, e) {\n      let i = !0;\n      void 0 === e && (i = !1);\n      const o = this.hierarchical.levels[t.id];\n      if (void 0 !== o) {\n        const s = this.hierarchical.distributionIndex[t.id],\n          n = this.direction.getPosition(t),\n          r = this.hierarchical.distributionOrdering[o];\n        let a = 1e9,\n          h = 1e9;\n        if (0 !== s) {\n          const t = r[s - 1];\n          if (!0 === i && void 0 === e[t.id] || !1 === i) {\n            a = n - this.direction.getPosition(t);\n          }\n        }\n        if (s != r.length - 1) {\n          const t = r[s + 1];\n          if (!0 === i && void 0 === e[t.id] || !1 === i) {\n            const e = this.direction.getPosition(t);\n            h = Math.min(h, e - n);\n          }\n        }\n        return [a, h];\n      }\n      return [0, 0];\n    }\n    _centerParent(t) {\n      if (this.hierarchical.parentReference[t.id]) {\n        const e = this.hierarchical.parentReference[t.id];\n        for (let t = 0; t < e.length; t++) {\n          const i = e[t],\n            o = this.body.nodes[i],\n            s = this.hierarchical.childrenReference[i];\n          if (void 0 !== s) {\n            const t = this._getCenterPosition(s),\n              e = this.direction.getPosition(o),\n              [i, n] = this._getSpaceAroundNode(o),\n              r = e - t;\n            (r < 0 && Math.abs(r) < n - this.options.hierarchical.nodeSpacing || r > 0 && Math.abs(r) < i - this.options.hierarchical.nodeSpacing) && this.direction.setPosition(o, t);\n          }\n        }\n      }\n    }\n    _placeNodesByHierarchy(t) {\n      this.positionedNodes = {};\n      for (const i in t) if (Object.prototype.hasOwnProperty.call(t, i)) {\n        var e;\n        let o = Jl(t[i]);\n        o = this._indexArrayToNodes(o), aC(e = this.direction).call(e, o);\n        let s = 0;\n        for (let t = 0; t < o.length; t++) {\n          const e = o[t];\n          if (void 0 === this.positionedNodes[e.id]) {\n            const n = this.options.hierarchical.nodeSpacing;\n            let r = n * s;\n            s > 0 && (r = this.direction.getPosition(o[t - 1]) + n), this.direction.setPosition(e, r, i), this._validatePositionAndContinue(e, i, r), s++;\n          }\n        }\n      }\n    }\n    _placeBranchNodes(t, e) {\n      var i;\n      const o = this.hierarchical.childrenReference[t];\n      if (void 0 === o) return;\n      const s = [];\n      for (let t = 0; t < o.length; t++) s.push(this.body.nodes[o[t]]);\n      aC(i = this.direction).call(i, s);\n      for (let i = 0; i < s.length; i++) {\n        const o = s[i],\n          n = this.hierarchical.levels[o.id];\n        if (!(n > e && void 0 === this.positionedNodes[o.id])) return;\n        {\n          const e = this.options.hierarchical.nodeSpacing;\n          let r;\n          r = 0 === i ? this.direction.getPosition(this.body.nodes[t]) : this.direction.getPosition(s[i - 1]) + e, this.direction.setPosition(o, r, n), this._validatePositionAndContinue(o, n, r);\n        }\n      }\n      const n = this._getCenterPosition(s);\n      this.direction.setPosition(this.body.nodes[t], n, e);\n    }\n    _validatePositionAndContinue(t, e, i) {\n      if (this.hierarchical.isTree) {\n        if (void 0 !== this.lastNodeOnLevel[e]) {\n          const o = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[e]]);\n          if (i - o < this.options.hierarchical.nodeSpacing) {\n            const s = o + this.options.hierarchical.nodeSpacing - i,\n              n = this._findCommonParent(this.lastNodeOnLevel[e], t.id);\n            this._shiftBlock(n.withChild, s);\n          }\n        }\n        this.lastNodeOnLevel[e] = t.id, this.positionedNodes[t.id] = !0, this._placeBranchNodes(t.id, e);\n      }\n    }\n    _indexArrayToNodes(t) {\n      const e = [];\n      for (let i = 0; i < t.length; i++) e.push(this.body.nodes[t[i]]);\n      return e;\n    }\n    _getDistribution() {\n      const t = {};\n      let e, i;\n      for (e in this.body.nodes) if (Object.prototype.hasOwnProperty.call(this.body.nodes, e)) {\n        i = this.body.nodes[e];\n        const o = void 0 === this.hierarchical.levels[e] ? 0 : this.hierarchical.levels[e];\n        this.direction.fix(i, o), void 0 === t[o] && (t[o] = {}), t[o][e] = i;\n      }\n      return t;\n    }\n    _getActiveEdges(t) {\n      const e = [];\n      return Cm(t.edges, t => {\n        var i;\n        -1 !== Mp(i = this.body.edgeIndices).call(i, t.id) && e.push(t);\n      }), e;\n    }\n    _getHubSizes() {\n      const t = {};\n      Cm(this.body.nodeIndices, e => {\n        const i = this.body.nodes[e],\n          o = this._getActiveEdges(i).length;\n        t[o] = !0;\n      });\n      const e = [];\n      return Cm(t, t => {\n        e.push(Number(t));\n      }), aC(e).call(e, function (t, e) {\n        return e - t;\n      }), e;\n    }\n    _determineLevelsByHubsize() {\n      const t = (t, e) => {\n          this.hierarchical.levelDownstream(t, e);\n        },\n        e = this._getHubSizes();\n      for (let i = 0; i < e.length; ++i) {\n        const o = e[i];\n        if (0 === o) break;\n        Cm(this.body.nodeIndices, e => {\n          const i = this.body.nodes[e];\n          o === this._getActiveEdges(i).length && this._crawlNetwork(t, e);\n        });\n      }\n    }\n    _determineLevelsCustomCallback() {\n      this._crawlNetwork((t, e, i) => {\n        let o = this.hierarchical.levels[t.id];\n        void 0 === o && (o = this.hierarchical.levels[t.id] = 1e5);\n        const s = (nE.cloneOptions(t, \"node\"), nE.cloneOptions(e, \"node\"), void nE.cloneOptions(i, \"edge\"));\n        this.hierarchical.levels[e.id] = o + s;\n      }), this.hierarchical.setMinLevelToZero();\n    }\n    _determineLevelsDirected() {\n      var t;\n      const e = xC(t = this.body.nodeIndices).call(t, (t, e) => (t.set(e, this.body.nodes[e]), t), new Rv());\n      \"roots\" === this.options.hierarchical.shakeTowards ? this.hierarchical.levels = function (t) {\n        return FC(e => {\n          var i, o;\n          return PC(i = Ru(o = e.edges).call(o, e => t.has(e.toId))).call(i, t => t.from === e);\n        }, (t, e) => e < t, \"to\", t);\n      }(e) : this.hierarchical.levels = function (t) {\n        return FC(e => {\n          var i, o;\n          return PC(i = Ru(o = e.edges).call(o, e => t.has(e.toId))).call(i, t => t.to === e);\n        }, (t, e) => e > t, \"from\", t);\n      }(e), this.hierarchical.setMinLevelToZero();\n    }\n    _generateMap() {\n      this._crawlNetwork((t, e) => {\n        this.hierarchical.levels[e.id] > this.hierarchical.levels[t.id] && this.hierarchical.addRelation(t.id, e.id);\n      }), this.hierarchical.checkIfTree();\n    }\n    _crawlNetwork() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {},\n        e = arguments.length > 1 ? arguments[1] : void 0;\n      const i = {},\n        o = (e, s) => {\n          if (void 0 === i[e.id]) {\n            let n;\n            this.hierarchical.setTreeIndex(e, s), i[e.id] = !0;\n            const r = this._getActiveEdges(e);\n            for (let i = 0; i < r.length; i++) {\n              const a = r[i];\n              !0 === a.connected && (n = a.toId == e.id ? a.from : a.to, e.id != n.id && (t(e, n, a), o(n, s)));\n            }\n          }\n        };\n      if (void 0 === e) {\n        let t = 0;\n        for (let e = 0; e < this.body.nodeIndices.length; e++) {\n          const s = this.body.nodeIndices[e];\n          if (void 0 === i[s]) {\n            const e = this.body.nodes[s];\n            o(e, t), t += 1;\n          }\n        }\n      } else {\n        const t = this.body.nodes[e];\n        if (void 0 === t) return void console.error(\"Node not found:\", e);\n        o(t);\n      }\n    }\n    _shiftBlock(t, e) {\n      const i = {},\n        o = t => {\n          if (i[t]) return;\n          i[t] = !0, this.direction.shift(t, e);\n          const s = this.hierarchical.childrenReference[t];\n          if (void 0 !== s) for (let t = 0; t < s.length; t++) o(s[t]);\n        };\n      o(t);\n    }\n    _findCommonParent(t, e) {\n      const i = {},\n        o = (t, e) => {\n          const i = this.hierarchical.parentReference[e];\n          if (void 0 !== i) for (let e = 0; e < i.length; e++) {\n            const s = i[e];\n            t[s] = !0, o(t, s);\n          }\n        },\n        s = (t, e) => {\n          const i = this.hierarchical.parentReference[e];\n          if (void 0 !== i) for (let o = 0; o < i.length; o++) {\n            const n = i[o];\n            if (void 0 !== t[n]) return {\n              foundParent: n,\n              withChild: e\n            };\n            const r = s(t, n);\n            if (null !== r.foundParent) return r;\n          }\n          return {\n            foundParent: null,\n            withChild: e\n          };\n        };\n      return o(i, t), s(i, e);\n    }\n    setDirectionStrategy() {\n      const t = \"UD\" === this.options.hierarchical.direction || \"DU\" === this.options.hierarchical.direction;\n      this.direction = t ? new OC(this) : new CC(this);\n    }\n    _getCenterPosition(t) {\n      let e = 1e9,\n        i = -1e9;\n      for (let o = 0; o < t.length; o++) {\n        let s;\n        if (void 0 !== t[o].id) s = t[o];else {\n          const e = t[o];\n          s = this.body.nodes[e];\n        }\n        const n = this.direction.getPosition(s);\n        e = Math.min(e, n), i = Math.max(i, n);\n      }\n      return .5 * (e + i);\n    }\n  }\n  class AC {\n    constructor(t, e, i, o) {\n      var s, n;\n      this.body = t, this.canvas = e, this.selectionHandler = i, this.interactionHandler = o, this.editMode = !1, this.manipulationDiv = void 0, this.editModeDiv = void 0, this.closeDiv = void 0, this._domEventListenerCleanupQueue = [], this.temporaryUIFunctions = {}, this.temporaryEventFunctions = [], this.touchTime = 0, this.temporaryIds = {\n        nodes: [],\n        edges: []\n      }, this.guiEnabled = !1, this.inMode = !1, this.selectedControlNode = void 0, this.options = {}, this.defaultOptions = {\n        enabled: !1,\n        initiallyActive: !1,\n        addNode: !0,\n        addEdge: !0,\n        editNode: void 0,\n        editEdge: !0,\n        deleteNode: !0,\n        deleteEdge: !0,\n        controlNodeStyle: {\n          shape: \"dot\",\n          size: 6,\n          color: {\n            background: \"#ff0000\",\n            border: \"#3c3c3c\",\n            highlight: {\n              background: \"#07f968\",\n              border: \"#3c3c3c\"\n            }\n          },\n          borderWidth: 2,\n          borderWidthSelected: 2\n        }\n      }, wo(this.options, this.defaultOptions), this.body.emitter.on(\"destroy\", () => {\n        this._clean();\n      }), this.body.emitter.on(\"_dataChanged\", Ho(s = this._restore).call(s, this)), this.body.emitter.on(\"_resetData\", Ho(n = this._restore).call(n, this));\n    }\n    _restore() {\n      !1 !== this.inMode && (!0 === this.options.initiallyActive ? this.enableEditMode() : this.disableEditMode());\n    }\n    setOptions(t, e, i) {\n      void 0 !== e && (void 0 !== e.locale ? this.options.locale = e.locale : this.options.locale = i.locale, void 0 !== e.locales ? this.options.locales = e.locales : this.options.locales = i.locales), void 0 !== t && (\"boolean\" == typeof t ? this.options.enabled = t : (this.options.enabled = !0, xm(this.options, t)), !0 === this.options.initiallyActive && (this.editMode = !0), this._setup());\n    }\n    toggleEditMode() {\n      !0 === this.editMode ? this.disableEditMode() : this.enableEditMode();\n    }\n    enableEditMode() {\n      this.editMode = !0, this._clean(), !0 === this.guiEnabled && (this.manipulationDiv.style.display = \"block\", this.closeDiv.style.display = \"block\", this.editModeDiv.style.display = \"none\", this.showManipulatorToolbar());\n    }\n    disableEditMode() {\n      this.editMode = !1, this._clean(), !0 === this.guiEnabled && (this.manipulationDiv.style.display = \"none\", this.closeDiv.style.display = \"none\", this.editModeDiv.style.display = \"block\", this._createEditButton());\n    }\n    showManipulatorToolbar() {\n      if (this._clean(), this.manipulationDOM = {}, !0 === this.guiEnabled) {\n        var t, e;\n        this.editMode = !0, this.manipulationDiv.style.display = \"block\", this.closeDiv.style.display = \"block\";\n        const i = this.selectionHandler.getSelectedNodeCount(),\n          o = this.selectionHandler.getSelectedEdgeCount(),\n          s = i + o,\n          n = this.options.locales[this.options.locale];\n        let r = !1;\n        !1 !== this.options.addNode && (this._createAddNodeButton(n), r = !0), !1 !== this.options.addEdge && (!0 === r ? this._createSeperator(1) : r = !0, this._createAddEdgeButton(n)), 1 === i && \"function\" == typeof this.options.editNode ? (!0 === r ? this._createSeperator(2) : r = !0, this._createEditNodeButton(n)) : 1 === o && 0 === i && !1 !== this.options.editEdge && (!0 === r ? this._createSeperator(3) : r = !0, this._createEditEdgeButton(n)), 0 !== s && (i > 0 && !1 !== this.options.deleteNode || 0 === i && !1 !== this.options.deleteEdge) && (!0 === r && this._createSeperator(4), this._createDeleteButton(n)), this._bindElementEvents(this.closeDiv, Ho(t = this.toggleEditMode).call(t, this)), this._temporaryBindEvent(\"select\", Ho(e = this.showManipulatorToolbar).call(e, this));\n      }\n      this.body.emitter.emit(\"_redraw\");\n    }\n    addNodeMode() {\n      var t;\n      if (!0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = \"addNode\", !0 === this.guiEnabled) {\n        var e;\n        const t = this.options.locales[this.options.locale];\n        this.manipulationDOM = {}, this._createBackButton(t), this._createSeperator(), this._createDescription(t.addDescription || this.options.locales.en.addDescription), this._bindElementEvents(this.closeDiv, Ho(e = this.toggleEditMode).call(e, this));\n      }\n      this._temporaryBindEvent(\"click\", Ho(t = this._performAddNode).call(t, this));\n    }\n    editNode() {\n      !0 !== this.editMode && this.enableEditMode(), this._clean();\n      const t = this.selectionHandler.getSelectedNodes()[0];\n      if (void 0 !== t) {\n        if (this.inMode = \"editNode\", \"function\" != typeof this.options.editNode) throw new Error(\"No function has been configured to handle the editing of nodes.\");\n        if (!0 !== t.isCluster) {\n          const e = xm({}, t.options, !1);\n          if (e.x = t.x, e.y = t.y, 2 !== this.options.editNode.length) throw new Error(\"The function for edit does not support two arguments (data, callback)\");\n          this.options.editNode(e, t => {\n            null != t && \"editNode\" === this.inMode && this.body.data.nodes.getDataSet().update(t), this.showManipulatorToolbar();\n          });\n        } else alert(this.options.locales[this.options.locale].editClusterError || this.options.locales.en.editClusterError);\n      } else this.showManipulatorToolbar();\n    }\n    addEdgeMode() {\n      var t, e, i, o, s;\n      if (!0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = \"addEdge\", !0 === this.guiEnabled) {\n        var n;\n        const t = this.options.locales[this.options.locale];\n        this.manipulationDOM = {}, this._createBackButton(t), this._createSeperator(), this._createDescription(t.edgeDescription || this.options.locales.en.edgeDescription), this._bindElementEvents(this.closeDiv, Ho(n = this.toggleEditMode).call(n, this));\n      }\n      this._temporaryBindUI(\"onTouch\", Ho(t = this._handleConnect).call(t, this)), this._temporaryBindUI(\"onDragEnd\", Ho(e = this._finishConnect).call(e, this)), this._temporaryBindUI(\"onDrag\", Ho(i = this._dragControlNode).call(i, this)), this._temporaryBindUI(\"onRelease\", Ho(o = this._finishConnect).call(o, this)), this._temporaryBindUI(\"onDragStart\", Ho(s = this._dragStartEdge).call(s, this)), this._temporaryBindUI(\"onHold\", () => {});\n    }\n    editEdgeMode() {\n      if (!0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = \"editEdge\", \"object\" != typeof this.options.editEdge || \"function\" != typeof this.options.editEdge.editWithoutDrag || (this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0], void 0 === this.edgeBeingEditedId)) {\n        if (!0 === this.guiEnabled) {\n          var t;\n          const e = this.options.locales[this.options.locale];\n          this.manipulationDOM = {}, this._createBackButton(e), this._createSeperator(), this._createDescription(e.editEdgeDescription || this.options.locales.en.editEdgeDescription), this._bindElementEvents(this.closeDiv, Ho(t = this.toggleEditMode).call(t, this));\n        }\n        if (this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0], void 0 !== this.edgeBeingEditedId) {\n          var e, i, o, s;\n          const t = this.body.edges[this.edgeBeingEditedId],\n            n = this._getNewTargetNode(t.from.x, t.from.y),\n            r = this._getNewTargetNode(t.to.x, t.to.y);\n          this.temporaryIds.nodes.push(n.id), this.temporaryIds.nodes.push(r.id), this.body.nodes[n.id] = n, this.body.nodeIndices.push(n.id), this.body.nodes[r.id] = r, this.body.nodeIndices.push(r.id), this._temporaryBindUI(\"onTouch\", Ho(e = this._controlNodeTouch).call(e, this)), this._temporaryBindUI(\"onTap\", () => {}), this._temporaryBindUI(\"onHold\", () => {}), this._temporaryBindUI(\"onDragStart\", Ho(i = this._controlNodeDragStart).call(i, this)), this._temporaryBindUI(\"onDrag\", Ho(o = this._controlNodeDrag).call(o, this)), this._temporaryBindUI(\"onDragEnd\", Ho(s = this._controlNodeDragEnd).call(s, this)), this._temporaryBindUI(\"onMouseMove\", () => {}), this._temporaryBindEvent(\"beforeDrawing\", e => {\n            const i = t.edgeType.findBorderPositions(e);\n            !1 === n.selected && (n.x = i.from.x, n.y = i.from.y), !1 === r.selected && (r.x = i.to.x, r.y = i.to.y);\n          }), this.body.emitter.emit(\"_redraw\");\n        } else this.showManipulatorToolbar();\n      } else {\n        const t = this.body.edges[this.edgeBeingEditedId];\n        this._performEditEdge(t.from.id, t.to.id);\n      }\n    }\n    deleteSelected() {\n      !0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = \"delete\";\n      const t = this.selectionHandler.getSelectedNodeIds(),\n        e = this.selectionHandler.getSelectedEdgeIds();\n      let i;\n      if (t.length > 0) {\n        for (let e = 0; e < t.length; e++) if (!0 === this.body.nodes[t[e]].isCluster) return void alert(this.options.locales[this.options.locale].deleteClusterError || this.options.locales.en.deleteClusterError);\n        \"function\" == typeof this.options.deleteNode && (i = this.options.deleteNode);\n      } else e.length > 0 && \"function\" == typeof this.options.deleteEdge && (i = this.options.deleteEdge);\n      if (\"function\" == typeof i) {\n        const o = {\n          nodes: t,\n          edges: e\n        };\n        if (2 !== i.length) throw new Error(\"The function for delete does not support two arguments (data, callback)\");\n        i(o, t => {\n          null != t && \"delete\" === this.inMode ? (this.body.data.edges.getDataSet().remove(t.edges), this.body.data.nodes.getDataSet().remove(t.nodes), this.body.emitter.emit(\"startSimulation\"), this.showManipulatorToolbar()) : (this.body.emitter.emit(\"startSimulation\"), this.showManipulatorToolbar());\n        });\n      } else this.body.data.edges.getDataSet().remove(e), this.body.data.nodes.getDataSet().remove(t), this.body.emitter.emit(\"startSimulation\"), this.showManipulatorToolbar();\n    }\n    _setup() {\n      !0 === this.options.enabled ? (this.guiEnabled = !0, this._createWrappers(), !1 === this.editMode ? this._createEditButton() : this.showManipulatorToolbar()) : (this._removeManipulationDOM(), this.guiEnabled = !1);\n    }\n    _createWrappers() {\n      var t, e;\n      (void 0 === this.manipulationDiv && (this.manipulationDiv = document.createElement(\"div\"), this.manipulationDiv.className = \"vis-manipulation\", !0 === this.editMode ? this.manipulationDiv.style.display = \"block\" : this.manipulationDiv.style.display = \"none\", this.canvas.frame.appendChild(this.manipulationDiv)), void 0 === this.editModeDiv && (this.editModeDiv = document.createElement(\"div\"), this.editModeDiv.className = \"vis-edit-mode\", !0 === this.editMode ? this.editModeDiv.style.display = \"none\" : this.editModeDiv.style.display = \"block\", this.canvas.frame.appendChild(this.editModeDiv)), void 0 === this.closeDiv) && (this.closeDiv = document.createElement(\"button\"), this.closeDiv.className = \"vis-close\", this.closeDiv.setAttribute(\"aria-label\", null !== (t = null === (e = this.options.locales[this.options.locale]) || void 0 === e ? void 0 : e.close) && void 0 !== t ? t : this.options.locales.en.close), this.closeDiv.style.display = this.manipulationDiv.style.display, this.canvas.frame.appendChild(this.closeDiv));\n    }\n    _getNewTargetNode(t, e) {\n      const i = xm({}, this.options.controlNodeStyle);\n      i.id = \"targetNode\" + sE(), i.hidden = !1, i.physics = !1, i.x = t, i.y = e;\n      const o = this.body.functions.createNode(i);\n      return o.shape.boundingBox = {\n        left: t,\n        right: t,\n        top: e,\n        bottom: e\n      }, o;\n    }\n    _createEditButton() {\n      var t;\n      this._clean(), this.manipulationDOM = {}, fm(this.editModeDiv);\n      const e = this.options.locales[this.options.locale],\n        i = this._createButton(\"editMode\", \"vis-edit vis-edit-mode\", e.edit || this.options.locales.en.edit);\n      this.editModeDiv.appendChild(i), this._bindElementEvents(i, Ho(t = this.toggleEditMode).call(t, this));\n    }\n    _clean() {\n      this.inMode = !1, !0 === this.guiEnabled && (fm(this.editModeDiv), fm(this.manipulationDiv), this._cleanupDOMEventListeners()), this._cleanupTemporaryNodesAndEdges(), this._unbindTemporaryUIs(), this._unbindTemporaryEvents(), this.body.emitter.emit(\"restorePhysics\");\n    }\n    _cleanupDOMEventListeners() {\n      for (const e of Jc(t = this._domEventListenerCleanupQueue).call(t, 0)) {\n        var t;\n        e();\n      }\n    }\n    _removeManipulationDOM() {\n      this._clean(), fm(this.manipulationDiv), fm(this.editModeDiv), fm(this.closeDiv), this.manipulationDiv && this.canvas.frame.removeChild(this.manipulationDiv), this.editModeDiv && this.canvas.frame.removeChild(this.editModeDiv), this.closeDiv && this.canvas.frame.removeChild(this.closeDiv), this.manipulationDiv = void 0, this.editModeDiv = void 0, this.closeDiv = void 0;\n    }\n    _createSeperator() {\n      let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;\n      this.manipulationDOM[\"seperatorLineDiv\" + t] = document.createElement(\"div\"), this.manipulationDOM[\"seperatorLineDiv\" + t].className = \"vis-separator-line\", this.manipulationDiv.appendChild(this.manipulationDOM[\"seperatorLineDiv\" + t]);\n    }\n    _createAddNodeButton(t) {\n      var e;\n      const i = this._createButton(\"addNode\", \"vis-add\", t.addNode || this.options.locales.en.addNode);\n      this.manipulationDiv.appendChild(i), this._bindElementEvents(i, Ho(e = this.addNodeMode).call(e, this));\n    }\n    _createAddEdgeButton(t) {\n      var e;\n      const i = this._createButton(\"addEdge\", \"vis-connect\", t.addEdge || this.options.locales.en.addEdge);\n      this.manipulationDiv.appendChild(i), this._bindElementEvents(i, Ho(e = this.addEdgeMode).call(e, this));\n    }\n    _createEditNodeButton(t) {\n      var e;\n      const i = this._createButton(\"editNode\", \"vis-edit\", t.editNode || this.options.locales.en.editNode);\n      this.manipulationDiv.appendChild(i), this._bindElementEvents(i, Ho(e = this.editNode).call(e, this));\n    }\n    _createEditEdgeButton(t) {\n      var e;\n      const i = this._createButton(\"editEdge\", \"vis-edit\", t.editEdge || this.options.locales.en.editEdge);\n      this.manipulationDiv.appendChild(i), this._bindElementEvents(i, Ho(e = this.editEdgeMode).call(e, this));\n    }\n    _createDeleteButton(t) {\n      var e;\n      let i;\n      i = this.options.rtl ? \"vis-delete-rtl\" : \"vis-delete\";\n      const o = this._createButton(\"delete\", i, t.del || this.options.locales.en.del);\n      this.manipulationDiv.appendChild(o), this._bindElementEvents(o, Ho(e = this.deleteSelected).call(e, this));\n    }\n    _createBackButton(t) {\n      var e;\n      const i = this._createButton(\"back\", \"vis-back\", t.back || this.options.locales.en.back);\n      this.manipulationDiv.appendChild(i), this._bindElementEvents(i, Ho(e = this.showManipulatorToolbar).call(e, this));\n    }\n    _createButton(t, e, i) {\n      let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : \"vis-label\";\n      return this.manipulationDOM[t + \"Div\"] = document.createElement(\"button\"), this.manipulationDOM[t + \"Div\"].className = \"vis-button \" + e, this.manipulationDOM[t + \"Label\"] = document.createElement(\"div\"), this.manipulationDOM[t + \"Label\"].className = o, this.manipulationDOM[t + \"Label\"].innerText = i, this.manipulationDOM[t + \"Div\"].appendChild(this.manipulationDOM[t + \"Label\"]), this.manipulationDOM[t + \"Div\"];\n    }\n    _createDescription(t) {\n      this.manipulationDOM.descriptionLabel = document.createElement(\"div\"), this.manipulationDOM.descriptionLabel.className = \"vis-none\", this.manipulationDOM.descriptionLabel.innerText = t, this.manipulationDiv.appendChild(this.manipulationDOM.descriptionLabel);\n    }\n    _temporaryBindEvent(t, e) {\n      this.temporaryEventFunctions.push({\n        event: t,\n        boundFunction: e\n      }), this.body.emitter.on(t, e);\n    }\n    _temporaryBindUI(t, e) {\n      if (void 0 === this.body.eventListeners[t]) throw new Error(\"This UI function does not exist. Typo? You tried: \" + t + \" possible are: \" + zp(Jl(this.body.eventListeners)));\n      this.temporaryUIFunctions[t] = this.body.eventListeners[t], this.body.eventListeners[t] = e;\n    }\n    _unbindTemporaryUIs() {\n      for (const t in this.temporaryUIFunctions) Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions, t) && (this.body.eventListeners[t] = this.temporaryUIFunctions[t], delete this.temporaryUIFunctions[t]);\n      this.temporaryUIFunctions = {};\n    }\n    _unbindTemporaryEvents() {\n      for (let t = 0; t < this.temporaryEventFunctions.length; t++) {\n        const e = this.temporaryEventFunctions[t].event,\n          i = this.temporaryEventFunctions[t].boundFunction;\n        this.body.emitter.off(e, i);\n      }\n      this.temporaryEventFunctions = [];\n    }\n    _bindElementEvents(t, e) {\n      const i = new Xm(t, {});\n      lE(i, e), this._domEventListenerCleanupQueue.push(() => {\n        i.destroy();\n      });\n      const o = t => {\n        let {\n          keyCode: i,\n          key: o\n        } = t;\n        \"Enter\" !== o && \" \" !== o && 13 !== i && 32 !== i || e();\n      };\n      t.addEventListener(\"keyup\", o, !1), this._domEventListenerCleanupQueue.push(() => {\n        t.removeEventListener(\"keyup\", o, !1);\n      });\n    }\n    _cleanupTemporaryNodesAndEdges() {\n      for (let i = 0; i < this.temporaryIds.edges.length; i++) {\n        var t;\n        this.body.edges[this.temporaryIds.edges[i]].disconnect(), delete this.body.edges[this.temporaryIds.edges[i]];\n        const o = Mp(t = this.body.edgeIndices).call(t, this.temporaryIds.edges[i]);\n        var e;\n        if (-1 !== o) Jc(e = this.body.edgeIndices).call(e, o, 1);\n      }\n      for (let t = 0; t < this.temporaryIds.nodes.length; t++) {\n        var i;\n        delete this.body.nodes[this.temporaryIds.nodes[t]];\n        const e = Mp(i = this.body.nodeIndices).call(i, this.temporaryIds.nodes[t]);\n        var o;\n        if (-1 !== e) Jc(o = this.body.nodeIndices).call(o, e, 1);\n      }\n      this.temporaryIds = {\n        nodes: [],\n        edges: []\n      };\n    }\n    _controlNodeTouch(t) {\n      this.selectionHandler.unselectAll(), this.lastTouch = this.body.functions.getPointer(t.center), this.lastTouch.translation = wo({}, this.body.view.translation);\n    }\n    _controlNodeDragStart() {\n      const t = this.lastTouch,\n        e = this.selectionHandler._pointerToPositionObject(t),\n        i = this.body.nodes[this.temporaryIds.nodes[0]],\n        o = this.body.nodes[this.temporaryIds.nodes[1]],\n        s = this.body.edges[this.edgeBeingEditedId];\n      this.selectedControlNode = void 0;\n      const n = i.isOverlappingWith(e),\n        r = o.isOverlappingWith(e);\n      !0 === n ? (this.selectedControlNode = i, s.edgeType.from = i) : !0 === r && (this.selectedControlNode = o, s.edgeType.to = o), void 0 !== this.selectedControlNode && this.selectionHandler.selectObject(this.selectedControlNode), this.body.emitter.emit(\"_redraw\");\n    }\n    _controlNodeDrag(t) {\n      this.body.emitter.emit(\"disablePhysics\");\n      const e = this.body.functions.getPointer(t.center),\n        i = this.canvas.DOMtoCanvas(e);\n      void 0 !== this.selectedControlNode ? (this.selectedControlNode.x = i.x, this.selectedControlNode.y = i.y) : this.interactionHandler.onDrag(t), this.body.emitter.emit(\"_redraw\");\n    }\n    _controlNodeDragEnd(t) {\n      const e = this.body.functions.getPointer(t.center),\n        i = this.selectionHandler._pointerToPositionObject(e),\n        o = this.body.edges[this.edgeBeingEditedId];\n      if (void 0 === this.selectedControlNode) return;\n      this.selectionHandler.unselectAll();\n      const s = this.selectionHandler._getAllNodesOverlappingWith(i);\n      let n;\n      for (let t = s.length - 1; t >= 0; t--) if (s[t] !== this.selectedControlNode.id) {\n        n = this.body.nodes[s[t]];\n        break;\n      }\n      if (void 0 !== n && void 0 !== this.selectedControlNode) {\n        if (!0 === n.isCluster) alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError);else {\n          const t = this.body.nodes[this.temporaryIds.nodes[0]];\n          this.selectedControlNode.id === t.id ? this._performEditEdge(n.id, o.to.id) : this._performEditEdge(o.from.id, n.id);\n        }\n      } else o.updateEdgeType(), this.body.emitter.emit(\"restorePhysics\");\n      this.body.emitter.emit(\"_redraw\");\n    }\n    _handleConnect(t) {\n      if (new Date().valueOf() - this.touchTime > 100) {\n        this.lastTouch = this.body.functions.getPointer(t.center), this.lastTouch.translation = wo({}, this.body.view.translation), this.interactionHandler.drag.pointer = this.lastTouch, this.interactionHandler.drag.translation = this.lastTouch.translation;\n        const e = this.lastTouch,\n          i = this.selectionHandler.getNodeAt(e);\n        if (void 0 !== i) if (!0 === i.isCluster) alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError);else {\n          const t = this._getNewTargetNode(i.x, i.y);\n          this.body.nodes[t.id] = t, this.body.nodeIndices.push(t.id);\n          const e = this.body.functions.createEdge({\n            id: \"connectionEdge\" + sE(),\n            from: i.id,\n            to: t.id,\n            physics: !1,\n            smooth: {\n              enabled: !0,\n              type: \"continuous\",\n              roundness: .5\n            }\n          });\n          this.body.edges[e.id] = e, this.body.edgeIndices.push(e.id), this.temporaryIds.nodes.push(t.id), this.temporaryIds.edges.push(e.id);\n        }\n        this.touchTime = new Date().valueOf();\n      }\n    }\n    _dragControlNode(t) {\n      const e = this.body.functions.getPointer(t.center),\n        i = this.selectionHandler._pointerToPositionObject(e);\n      let o;\n      void 0 !== this.temporaryIds.edges[0] && (o = this.body.edges[this.temporaryIds.edges[0]].fromId);\n      const s = this.selectionHandler._getAllNodesOverlappingWith(i);\n      let n;\n      for (let t = s.length - 1; t >= 0; t--) {\n        var r;\n        if (-1 === Mp(r = this.temporaryIds.nodes).call(r, s[t])) {\n          n = this.body.nodes[s[t]];\n          break;\n        }\n      }\n      if (t.controlEdge = {\n        from: o,\n        to: n ? n.id : void 0\n      }, this.selectionHandler.generateClickEvent(\"controlNodeDragging\", t, e), void 0 !== this.temporaryIds.nodes[0]) {\n        const t = this.body.nodes[this.temporaryIds.nodes[0]];\n        t.x = this.canvas._XconvertDOMtoCanvas(e.x), t.y = this.canvas._YconvertDOMtoCanvas(e.y), this.body.emitter.emit(\"_redraw\");\n      } else this.interactionHandler.onDrag(t);\n    }\n    _finishConnect(t) {\n      const e = this.body.functions.getPointer(t.center),\n        i = this.selectionHandler._pointerToPositionObject(e);\n      let o;\n      void 0 !== this.temporaryIds.edges[0] && (o = this.body.edges[this.temporaryIds.edges[0]].fromId);\n      const s = this.selectionHandler._getAllNodesOverlappingWith(i);\n      let n;\n      for (let t = s.length - 1; t >= 0; t--) {\n        var r;\n        if (-1 === Mp(r = this.temporaryIds.nodes).call(r, s[t])) {\n          n = this.body.nodes[s[t]];\n          break;\n        }\n      }\n      this._cleanupTemporaryNodesAndEdges(), void 0 !== n && (!0 === n.isCluster ? alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError) : void 0 !== this.body.nodes[o] && void 0 !== this.body.nodes[n.id] && this._performAddEdge(o, n.id)), t.controlEdge = {\n        from: o,\n        to: n ? n.id : void 0\n      }, this.selectionHandler.generateClickEvent(\"controlNodeDragEnd\", t, e), this.body.emitter.emit(\"_redraw\");\n    }\n    _dragStartEdge(t) {\n      const e = this.lastTouch;\n      this.selectionHandler.generateClickEvent(\"dragStart\", t, e, void 0, !0);\n    }\n    _performAddNode(t) {\n      const e = {\n        id: sE(),\n        x: t.pointer.canvas.x,\n        y: t.pointer.canvas.y,\n        label: \"new\"\n      };\n      if (\"function\" == typeof this.options.addNode) {\n        if (2 !== this.options.addNode.length) throw this.showManipulatorToolbar(), new Error(\"The function for add does not support two arguments (data,callback)\");\n        this.options.addNode(e, t => {\n          null != t && \"addNode\" === this.inMode && this.body.data.nodes.getDataSet().add(t), this.showManipulatorToolbar();\n        });\n      } else this.body.data.nodes.getDataSet().add(e), this.showManipulatorToolbar();\n    }\n    _performAddEdge(t, e) {\n      const i = {\n        from: t,\n        to: e\n      };\n      if (\"function\" == typeof this.options.addEdge) {\n        if (2 !== this.options.addEdge.length) throw new Error(\"The function for connect does not support two arguments (data,callback)\");\n        this.options.addEdge(i, t => {\n          null != t && \"addEdge\" === this.inMode && (this.body.data.edges.getDataSet().add(t), this.selectionHandler.unselectAll(), this.showManipulatorToolbar());\n        });\n      } else this.body.data.edges.getDataSet().add(i), this.selectionHandler.unselectAll(), this.showManipulatorToolbar();\n    }\n    _performEditEdge(t, e) {\n      const i = {\n        id: this.edgeBeingEditedId,\n        from: t,\n        to: e,\n        label: this.body.data.edges.get(this.edgeBeingEditedId).label\n      };\n      let o = this.options.editEdge;\n      if (\"object\" == typeof o && (o = o.editWithoutDrag), \"function\" == typeof o) {\n        if (2 !== o.length) throw new Error(\"The function for edit does not support two arguments (data, callback)\");\n        o(i, t => {\n          null == t || \"editEdge\" !== this.inMode ? (this.body.edges[i.id].updateEdgeType(), this.body.emitter.emit(\"_redraw\"), this.showManipulatorToolbar()) : (this.body.data.edges.getDataSet().update(t), this.selectionHandler.unselectAll(), this.showManipulatorToolbar());\n        });\n      } else this.body.data.edges.getDataSet().update(i), this.selectionHandler.unselectAll(), this.showManipulatorToolbar();\n    }\n  }\n  const RC = \"string\",\n    jC = \"boolean\",\n    LC = \"number\",\n    HC = \"array\",\n    WC = \"object\",\n    VC = [\"arrow\", \"bar\", \"box\", \"circle\", \"crow\", \"curve\", \"diamond\", \"image\", \"inv_curve\", \"inv_triangle\", \"triangle\", \"vee\"],\n    qC = {\n      borderWidth: {\n        number: LC\n      },\n      borderWidthSelected: {\n        number: LC,\n        undefined: \"undefined\"\n      },\n      brokenImage: {\n        string: RC,\n        undefined: \"undefined\"\n      },\n      chosen: {\n        label: {\n          boolean: jC,\n          function: \"function\"\n        },\n        node: {\n          boolean: jC,\n          function: \"function\"\n        },\n        __type__: {\n          object: WC,\n          boolean: jC\n        }\n      },\n      color: {\n        border: {\n          string: RC\n        },\n        background: {\n          string: RC\n        },\n        highlight: {\n          border: {\n            string: RC\n          },\n          background: {\n            string: RC\n          },\n          __type__: {\n            object: WC,\n            string: RC\n          }\n        },\n        hover: {\n          border: {\n            string: RC\n          },\n          background: {\n            string: RC\n          },\n          __type__: {\n            object: WC,\n            string: RC\n          }\n        },\n        __type__: {\n          object: WC,\n          string: RC\n        }\n      },\n      opacity: {\n        number: LC,\n        undefined: \"undefined\"\n      },\n      fixed: {\n        x: {\n          boolean: jC\n        },\n        y: {\n          boolean: jC\n        },\n        __type__: {\n          object: WC,\n          boolean: jC\n        }\n      },\n      font: {\n        align: {\n          string: RC\n        },\n        color: {\n          string: RC\n        },\n        size: {\n          number: LC\n        },\n        face: {\n          string: RC\n        },\n        background: {\n          string: RC\n        },\n        strokeWidth: {\n          number: LC\n        },\n        strokeColor: {\n          string: RC\n        },\n        vadjust: {\n          number: LC\n        },\n        multi: {\n          boolean: jC,\n          string: RC\n        },\n        bold: {\n          color: {\n            string: RC\n          },\n          size: {\n            number: LC\n          },\n          face: {\n            string: RC\n          },\n          mod: {\n            string: RC\n          },\n          vadjust: {\n            number: LC\n          },\n          __type__: {\n            object: WC,\n            string: RC\n          }\n        },\n        boldital: {\n          color: {\n            string: RC\n          },\n          size: {\n            number: LC\n          },\n          face: {\n            string: RC\n          },\n          mod: {\n            string: RC\n          },\n          vadjust: {\n            number: LC\n          },\n          __type__: {\n            object: WC,\n            string: RC\n          }\n        },\n        ital: {\n          color: {\n            string: RC\n          },\n          size: {\n            number: LC\n          },\n          face: {\n            string: RC\n          },\n          mod: {\n            string: RC\n          },\n          vadjust: {\n            number: LC\n          },\n          __type__: {\n            object: WC,\n            string: RC\n          }\n        },\n        mono: {\n          color: {\n            string: RC\n          },\n          size: {\n            number: LC\n          },\n          face: {\n            string: RC\n          },\n          mod: {\n            string: RC\n          },\n          vadjust: {\n            number: LC\n          },\n          __type__: {\n            object: WC,\n            string: RC\n          }\n        },\n        __type__: {\n          object: WC,\n          string: RC\n        }\n      },\n      group: {\n        string: RC,\n        number: LC,\n        undefined: \"undefined\"\n      },\n      heightConstraint: {\n        minimum: {\n          number: LC\n        },\n        valign: {\n          string: RC\n        },\n        __type__: {\n          object: WC,\n          boolean: jC,\n          number: LC\n        }\n      },\n      hidden: {\n        boolean: jC\n      },\n      icon: {\n        face: {\n          string: RC\n        },\n        code: {\n          string: RC\n        },\n        size: {\n          number: LC\n        },\n        color: {\n          string: RC\n        },\n        weight: {\n          string: RC,\n          number: LC\n        },\n        __type__: {\n          object: WC\n        }\n      },\n      id: {\n        string: RC,\n        number: LC\n      },\n      image: {\n        selected: {\n          string: RC,\n          undefined: \"undefined\"\n        },\n        unselected: {\n          string: RC,\n          undefined: \"undefined\"\n        },\n        __type__: {\n          object: WC,\n          string: RC\n        }\n      },\n      imagePadding: {\n        top: {\n          number: LC\n        },\n        right: {\n          number: LC\n        },\n        bottom: {\n          number: LC\n        },\n        left: {\n          number: LC\n        },\n        __type__: {\n          object: WC,\n          number: LC\n        }\n      },\n      label: {\n        string: RC,\n        undefined: \"undefined\"\n      },\n      labelHighlightBold: {\n        boolean: jC\n      },\n      level: {\n        number: LC,\n        undefined: \"undefined\"\n      },\n      margin: {\n        top: {\n          number: LC\n        },\n        right: {\n          number: LC\n        },\n        bottom: {\n          number: LC\n        },\n        left: {\n          number: LC\n        },\n        __type__: {\n          object: WC,\n          number: LC\n        }\n      },\n      mass: {\n        number: LC\n      },\n      physics: {\n        boolean: jC\n      },\n      scaling: {\n        min: {\n          number: LC\n        },\n        max: {\n          number: LC\n        },\n        label: {\n          enabled: {\n            boolean: jC\n          },\n          min: {\n            number: LC\n          },\n          max: {\n            number: LC\n          },\n          maxVisible: {\n            number: LC\n          },\n          drawThreshold: {\n            number: LC\n          },\n          __type__: {\n            object: WC,\n            boolean: jC\n          }\n        },\n        customScalingFunction: {\n          function: \"function\"\n        },\n        __type__: {\n          object: WC\n        }\n      },\n      shadow: {\n        enabled: {\n          boolean: jC\n        },\n        color: {\n          string: RC\n        },\n        size: {\n          number: LC\n        },\n        x: {\n          number: LC\n        },\n        y: {\n          number: LC\n        },\n        __type__: {\n          object: WC,\n          boolean: jC\n        }\n      },\n      shape: {\n        string: [\"custom\", \"ellipse\", \"circle\", \"database\", \"box\", \"text\", \"image\", \"circularImage\", \"diamond\", \"dot\", \"star\", \"triangle\", \"triangleDown\", \"square\", \"icon\", \"hexagon\"]\n      },\n      ctxRenderer: {\n        function: \"function\"\n      },\n      shapeProperties: {\n        borderDashes: {\n          boolean: jC,\n          array: HC\n        },\n        borderRadius: {\n          number: LC\n        },\n        interpolation: {\n          boolean: jC\n        },\n        useImageSize: {\n          boolean: jC\n        },\n        useBorderWithImage: {\n          boolean: jC\n        },\n        coordinateOrigin: {\n          string: [\"center\", \"top-left\"]\n        },\n        __type__: {\n          object: WC\n        }\n      },\n      size: {\n        number: LC\n      },\n      title: {\n        string: RC,\n        dom: \"dom\",\n        undefined: \"undefined\"\n      },\n      value: {\n        number: LC,\n        undefined: \"undefined\"\n      },\n      widthConstraint: {\n        minimum: {\n          number: LC\n        },\n        maximum: {\n          number: LC\n        },\n        __type__: {\n          object: WC,\n          boolean: jC,\n          number: LC\n        }\n      },\n      x: {\n        number: LC\n      },\n      y: {\n        number: LC\n      },\n      __type__: {\n        object: WC\n      }\n    },\n    UC = {\n      configure: {\n        enabled: {\n          boolean: jC\n        },\n        filter: {\n          boolean: jC,\n          string: RC,\n          array: HC,\n          function: \"function\"\n        },\n        container: {\n          dom: \"dom\"\n        },\n        showButton: {\n          boolean: jC\n        },\n        __type__: {\n          object: WC,\n          boolean: jC,\n          string: RC,\n          array: HC,\n          function: \"function\"\n        }\n      },\n      edges: {\n        arrows: {\n          to: {\n            enabled: {\n              boolean: jC\n            },\n            scaleFactor: {\n              number: LC\n            },\n            type: {\n              string: VC\n            },\n            imageHeight: {\n              number: LC\n            },\n            imageWidth: {\n              number: LC\n            },\n            src: {\n              string: RC\n            },\n            __type__: {\n              object: WC,\n              boolean: jC\n            }\n          },\n          middle: {\n            enabled: {\n              boolean: jC\n            },\n            scaleFactor: {\n              number: LC\n            },\n            type: {\n              string: VC\n            },\n            imageWidth: {\n              number: LC\n            },\n            imageHeight: {\n              number: LC\n            },\n            src: {\n              string: RC\n            },\n            __type__: {\n              object: WC,\n              boolean: jC\n            }\n          },\n          from: {\n            enabled: {\n              boolean: jC\n            },\n            scaleFactor: {\n              number: LC\n            },\n            type: {\n              string: VC\n            },\n            imageWidth: {\n              number: LC\n            },\n            imageHeight: {\n              number: LC\n            },\n            src: {\n              string: RC\n            },\n            __type__: {\n              object: WC,\n              boolean: jC\n            }\n          },\n          __type__: {\n            string: [\"from\", \"to\", \"middle\"],\n            object: WC\n          }\n        },\n        endPointOffset: {\n          from: {\n            number: LC\n          },\n          to: {\n            number: LC\n          },\n          __type__: {\n            object: WC,\n            number: LC\n          }\n        },\n        arrowStrikethrough: {\n          boolean: jC\n        },\n        background: {\n          enabled: {\n            boolean: jC\n          },\n          color: {\n            string: RC\n          },\n          size: {\n            number: LC\n          },\n          dashes: {\n            boolean: jC,\n            array: HC\n          },\n          __type__: {\n            object: WC,\n            boolean: jC\n          }\n        },\n        chosen: {\n          label: {\n            boolean: jC,\n            function: \"function\"\n          },\n          edge: {\n            boolean: jC,\n            function: \"function\"\n          },\n          __type__: {\n            object: WC,\n            boolean: jC\n          }\n        },\n        color: {\n          color: {\n            string: RC\n          },\n          highlight: {\n            string: RC\n          },\n          hover: {\n            string: RC\n          },\n          inherit: {\n            string: [\"from\", \"to\", \"both\"],\n            boolean: jC\n          },\n          opacity: {\n            number: LC\n          },\n          __type__: {\n            object: WC,\n            string: RC\n          }\n        },\n        dashes: {\n          boolean: jC,\n          array: HC\n        },\n        font: {\n          color: {\n            string: RC\n          },\n          size: {\n            number: LC\n          },\n          face: {\n            string: RC\n          },\n          background: {\n            string: RC\n          },\n          strokeWidth: {\n            number: LC\n          },\n          strokeColor: {\n            string: RC\n          },\n          align: {\n            string: [\"horizontal\", \"top\", \"middle\", \"bottom\"]\n          },\n          vadjust: {\n            number: LC\n          },\n          multi: {\n            boolean: jC,\n            string: RC\n          },\n          bold: {\n            color: {\n              string: RC\n            },\n            size: {\n              number: LC\n            },\n            face: {\n              string: RC\n            },\n            mod: {\n              string: RC\n            },\n            vadjust: {\n              number: LC\n            },\n            __type__: {\n              object: WC,\n              string: RC\n            }\n          },\n          boldital: {\n            color: {\n              string: RC\n            },\n            size: {\n              number: LC\n            },\n            face: {\n              string: RC\n            },\n            mod: {\n              string: RC\n            },\n            vadjust: {\n              number: LC\n            },\n            __type__: {\n              object: WC,\n              string: RC\n            }\n          },\n          ital: {\n            color: {\n              string: RC\n            },\n            size: {\n              number: LC\n            },\n            face: {\n              string: RC\n            },\n            mod: {\n              string: RC\n            },\n            vadjust: {\n              number: LC\n            },\n            __type__: {\n              object: WC,\n              string: RC\n            }\n          },\n          mono: {\n            color: {\n              string: RC\n            },\n            size: {\n              number: LC\n            },\n            face: {\n              string: RC\n            },\n            mod: {\n              string: RC\n            },\n            vadjust: {\n              number: LC\n            },\n            __type__: {\n              object: WC,\n              string: RC\n            }\n          },\n          __type__: {\n            object: WC,\n            string: RC\n          }\n        },\n        hidden: {\n          boolean: jC\n        },\n        hoverWidth: {\n          function: \"function\",\n          number: LC\n        },\n        label: {\n          string: RC,\n          undefined: \"undefined\"\n        },\n        labelHighlightBold: {\n          boolean: jC\n        },\n        length: {\n          number: LC,\n          undefined: \"undefined\"\n        },\n        physics: {\n          boolean: jC\n        },\n        scaling: {\n          min: {\n            number: LC\n          },\n          max: {\n            number: LC\n          },\n          label: {\n            enabled: {\n              boolean: jC\n            },\n            min: {\n              number: LC\n            },\n            max: {\n              number: LC\n            },\n            maxVisible: {\n              number: LC\n            },\n            drawThreshold: {\n              number: LC\n            },\n            __type__: {\n              object: WC,\n              boolean: jC\n            }\n          },\n          customScalingFunction: {\n            function: \"function\"\n          },\n          __type__: {\n            object: WC\n          }\n        },\n        selectionWidth: {\n          function: \"function\",\n          number: LC\n        },\n        selfReferenceSize: {\n          number: LC\n        },\n        selfReference: {\n          size: {\n            number: LC\n          },\n          angle: {\n            number: LC\n          },\n          renderBehindTheNode: {\n            boolean: jC\n          },\n          __type__: {\n            object: WC\n          }\n        },\n        shadow: {\n          enabled: {\n            boolean: jC\n          },\n          color: {\n            string: RC\n          },\n          size: {\n            number: LC\n          },\n          x: {\n            number: LC\n          },\n          y: {\n            number: LC\n          },\n          __type__: {\n            object: WC,\n            boolean: jC\n          }\n        },\n        smooth: {\n          enabled: {\n            boolean: jC\n          },\n          type: {\n            string: [\"dynamic\", \"continuous\", \"discrete\", \"diagonalCross\", \"straightCross\", \"horizontal\", \"vertical\", \"curvedCW\", \"curvedCCW\", \"cubicBezier\"]\n          },\n          roundness: {\n            number: LC\n          },\n          forceDirection: {\n            string: [\"horizontal\", \"vertical\", \"none\"],\n            boolean: jC\n          },\n          __type__: {\n            object: WC,\n            boolean: jC\n          }\n        },\n        title: {\n          string: RC,\n          undefined: \"undefined\"\n        },\n        width: {\n          number: LC\n        },\n        widthConstraint: {\n          maximum: {\n            number: LC\n          },\n          __type__: {\n            object: WC,\n            boolean: jC,\n            number: LC\n          }\n        },\n        value: {\n          number: LC,\n          undefined: \"undefined\"\n        },\n        __type__: {\n          object: WC\n        }\n      },\n      groups: {\n        useDefaultGroups: {\n          boolean: jC\n        },\n        __any__: qC,\n        __type__: {\n          object: WC\n        }\n      },\n      interaction: {\n        dragNodes: {\n          boolean: jC\n        },\n        dragView: {\n          boolean: jC\n        },\n        hideEdgesOnDrag: {\n          boolean: jC\n        },\n        hideEdgesOnZoom: {\n          boolean: jC\n        },\n        hideNodesOnDrag: {\n          boolean: jC\n        },\n        hover: {\n          boolean: jC\n        },\n        keyboard: {\n          enabled: {\n            boolean: jC\n          },\n          speed: {\n            x: {\n              number: LC\n            },\n            y: {\n              number: LC\n            },\n            zoom: {\n              number: LC\n            },\n            __type__: {\n              object: WC\n            }\n          },\n          bindToWindow: {\n            boolean: jC\n          },\n          autoFocus: {\n            boolean: jC\n          },\n          __type__: {\n            object: WC,\n            boolean: jC\n          }\n        },\n        multiselect: {\n          boolean: jC\n        },\n        navigationButtons: {\n          boolean: jC\n        },\n        selectable: {\n          boolean: jC\n        },\n        selectConnectedEdges: {\n          boolean: jC\n        },\n        hoverConnectedEdges: {\n          boolean: jC\n        },\n        tooltipDelay: {\n          number: LC\n        },\n        zoomView: {\n          boolean: jC\n        },\n        zoomSpeed: {\n          number: LC\n        },\n        __type__: {\n          object: WC\n        }\n      },\n      layout: {\n        randomSeed: {\n          undefined: \"undefined\",\n          number: LC,\n          string: RC\n        },\n        improvedLayout: {\n          boolean: jC\n        },\n        clusterThreshold: {\n          number: LC\n        },\n        hierarchical: {\n          enabled: {\n            boolean: jC\n          },\n          levelSeparation: {\n            number: LC\n          },\n          nodeSpacing: {\n            number: LC\n          },\n          treeSpacing: {\n            number: LC\n          },\n          blockShifting: {\n            boolean: jC\n          },\n          edgeMinimization: {\n            boolean: jC\n          },\n          parentCentralization: {\n            boolean: jC\n          },\n          direction: {\n            string: [\"UD\", \"DU\", \"LR\", \"RL\"]\n          },\n          sortMethod: {\n            string: [\"hubsize\", \"directed\"]\n          },\n          shakeTowards: {\n            string: [\"leaves\", \"roots\"]\n          },\n          __type__: {\n            object: WC,\n            boolean: jC\n          }\n        },\n        __type__: {\n          object: WC\n        }\n      },\n      manipulation: {\n        enabled: {\n          boolean: jC\n        },\n        initiallyActive: {\n          boolean: jC\n        },\n        addNode: {\n          boolean: jC,\n          function: \"function\"\n        },\n        addEdge: {\n          boolean: jC,\n          function: \"function\"\n        },\n        editNode: {\n          function: \"function\"\n        },\n        editEdge: {\n          editWithoutDrag: {\n            function: \"function\"\n          },\n          __type__: {\n            object: WC,\n            boolean: jC,\n            function: \"function\"\n          }\n        },\n        deleteNode: {\n          boolean: jC,\n          function: \"function\"\n        },\n        deleteEdge: {\n          boolean: jC,\n          function: \"function\"\n        },\n        controlNodeStyle: qC,\n        __type__: {\n          object: WC,\n          boolean: jC\n        }\n      },\n      nodes: qC,\n      physics: {\n        enabled: {\n          boolean: jC\n        },\n        barnesHut: {\n          theta: {\n            number: LC\n          },\n          gravitationalConstant: {\n            number: LC\n          },\n          centralGravity: {\n            number: LC\n          },\n          springLength: {\n            number: LC\n          },\n          springConstant: {\n            number: LC\n          },\n          damping: {\n            number: LC\n          },\n          avoidOverlap: {\n            number: LC\n          },\n          __type__: {\n            object: WC\n          }\n        },\n        forceAtlas2Based: {\n          theta: {\n            number: LC\n          },\n          gravitationalConstant: {\n            number: LC\n          },\n          centralGravity: {\n            number: LC\n          },\n          springLength: {\n            number: LC\n          },\n          springConstant: {\n            number: LC\n          },\n          damping: {\n            number: LC\n          },\n          avoidOverlap: {\n            number: LC\n          },\n          __type__: {\n            object: WC\n          }\n        },\n        repulsion: {\n          centralGravity: {\n            number: LC\n          },\n          springLength: {\n            number: LC\n          },\n          springConstant: {\n            number: LC\n          },\n          nodeDistance: {\n            number: LC\n          },\n          damping: {\n            number: LC\n          },\n          __type__: {\n            object: WC\n          }\n        },\n        hierarchicalRepulsion: {\n          centralGravity: {\n            number: LC\n          },\n          springLength: {\n            number: LC\n          },\n          springConstant: {\n            number: LC\n          },\n          nodeDistance: {\n            number: LC\n          },\n          damping: {\n            number: LC\n          },\n          avoidOverlap: {\n            number: LC\n          },\n          __type__: {\n            object: WC\n          }\n        },\n        maxVelocity: {\n          number: LC\n        },\n        minVelocity: {\n          number: LC\n        },\n        solver: {\n          string: [\"barnesHut\", \"repulsion\", \"hierarchicalRepulsion\", \"forceAtlas2Based\"]\n        },\n        stabilization: {\n          enabled: {\n            boolean: jC\n          },\n          iterations: {\n            number: LC\n          },\n          updateInterval: {\n            number: LC\n          },\n          onlyDynamicEdges: {\n            boolean: jC\n          },\n          fit: {\n            boolean: jC\n          },\n          __type__: {\n            object: WC,\n            boolean: jC\n          }\n        },\n        timestep: {\n          number: LC\n        },\n        adaptiveTimestep: {\n          boolean: jC\n        },\n        wind: {\n          x: {\n            number: LC\n          },\n          y: {\n            number: LC\n          },\n          __type__: {\n            object: WC\n          }\n        },\n        __type__: {\n          object: WC,\n          boolean: jC\n        }\n      },\n      autoResize: {\n        boolean: jC\n      },\n      clickToUse: {\n        boolean: jC\n      },\n      locale: {\n        string: RC\n      },\n      locales: {\n        __any__: {\n          any: \"any\"\n        },\n        __type__: {\n          object: WC\n        }\n      },\n      height: {\n        string: RC\n      },\n      width: {\n        string: RC\n      },\n      __type__: {\n        object: WC\n      }\n    },\n    YC = {\n      nodes: {\n        borderWidth: [1, 0, 10, 1],\n        borderWidthSelected: [2, 0, 10, 1],\n        color: {\n          border: [\"color\", \"#2B7CE9\"],\n          background: [\"color\", \"#97C2FC\"],\n          highlight: {\n            border: [\"color\", \"#2B7CE9\"],\n            background: [\"color\", \"#D2E5FF\"]\n          },\n          hover: {\n            border: [\"color\", \"#2B7CE9\"],\n            background: [\"color\", \"#D2E5FF\"]\n          }\n        },\n        opacity: [0, 0, 1, .1],\n        fixed: {\n          x: !1,\n          y: !1\n        },\n        font: {\n          color: [\"color\", \"#343434\"],\n          size: [14, 0, 100, 1],\n          face: [\"arial\", \"verdana\", \"tahoma\"],\n          background: [\"color\", \"none\"],\n          strokeWidth: [0, 0, 50, 1],\n          strokeColor: [\"color\", \"#ffffff\"]\n        },\n        hidden: !1,\n        labelHighlightBold: !0,\n        physics: !0,\n        scaling: {\n          min: [10, 0, 200, 1],\n          max: [30, 0, 200, 1],\n          label: {\n            enabled: !1,\n            min: [14, 0, 200, 1],\n            max: [30, 0, 200, 1],\n            maxVisible: [30, 0, 200, 1],\n            drawThreshold: [5, 0, 20, 1]\n          }\n        },\n        shadow: {\n          enabled: !1,\n          color: \"rgba(0,0,0,0.5)\",\n          size: [10, 0, 20, 1],\n          x: [5, -30, 30, 1],\n          y: [5, -30, 30, 1]\n        },\n        shape: [\"ellipse\", \"box\", \"circle\", \"database\", \"diamond\", \"dot\", \"square\", \"star\", \"text\", \"triangle\", \"triangleDown\", \"hexagon\"],\n        shapeProperties: {\n          borderDashes: !1,\n          borderRadius: [6, 0, 20, 1],\n          interpolation: !0,\n          useImageSize: !1\n        },\n        size: [25, 0, 200, 1]\n      },\n      edges: {\n        arrows: {\n          to: {\n            enabled: !1,\n            scaleFactor: [1, 0, 3, .05],\n            type: \"arrow\"\n          },\n          middle: {\n            enabled: !1,\n            scaleFactor: [1, 0, 3, .05],\n            type: \"arrow\"\n          },\n          from: {\n            enabled: !1,\n            scaleFactor: [1, 0, 3, .05],\n            type: \"arrow\"\n          }\n        },\n        endPointOffset: {\n          from: [0, -10, 10, 1],\n          to: [0, -10, 10, 1]\n        },\n        arrowStrikethrough: !0,\n        color: {\n          color: [\"color\", \"#848484\"],\n          highlight: [\"color\", \"#848484\"],\n          hover: [\"color\", \"#848484\"],\n          inherit: [\"from\", \"to\", \"both\", !0, !1],\n          opacity: [1, 0, 1, .05]\n        },\n        dashes: !1,\n        font: {\n          color: [\"color\", \"#343434\"],\n          size: [14, 0, 100, 1],\n          face: [\"arial\", \"verdana\", \"tahoma\"],\n          background: [\"color\", \"none\"],\n          strokeWidth: [2, 0, 50, 1],\n          strokeColor: [\"color\", \"#ffffff\"],\n          align: [\"horizontal\", \"top\", \"middle\", \"bottom\"]\n        },\n        hidden: !1,\n        hoverWidth: [1.5, 0, 5, .1],\n        labelHighlightBold: !0,\n        physics: !0,\n        scaling: {\n          min: [1, 0, 100, 1],\n          max: [15, 0, 100, 1],\n          label: {\n            enabled: !0,\n            min: [14, 0, 200, 1],\n            max: [30, 0, 200, 1],\n            maxVisible: [30, 0, 200, 1],\n            drawThreshold: [5, 0, 20, 1]\n          }\n        },\n        selectionWidth: [1.5, 0, 5, .1],\n        selfReferenceSize: [20, 0, 200, 1],\n        selfReference: {\n          size: [20, 0, 200, 1],\n          angle: [Math.PI / 2, -6 * Math.PI, 6 * Math.PI, Math.PI / 8],\n          renderBehindTheNode: !0\n        },\n        shadow: {\n          enabled: !1,\n          color: \"rgba(0,0,0,0.5)\",\n          size: [10, 0, 20, 1],\n          x: [5, -30, 30, 1],\n          y: [5, -30, 30, 1]\n        },\n        smooth: {\n          enabled: !0,\n          type: [\"dynamic\", \"continuous\", \"discrete\", \"diagonalCross\", \"straightCross\", \"horizontal\", \"vertical\", \"curvedCW\", \"curvedCCW\", \"cubicBezier\"],\n          forceDirection: [\"horizontal\", \"vertical\", \"none\"],\n          roundness: [.5, 0, 1, .05]\n        },\n        width: [1, 0, 30, 1]\n      },\n      layout: {\n        hierarchical: {\n          enabled: !1,\n          levelSeparation: [150, 20, 500, 5],\n          nodeSpacing: [100, 20, 500, 5],\n          treeSpacing: [200, 20, 500, 5],\n          blockShifting: !0,\n          edgeMinimization: !0,\n          parentCentralization: !0,\n          direction: [\"UD\", \"DU\", \"LR\", \"RL\"],\n          sortMethod: [\"hubsize\", \"directed\"],\n          shakeTowards: [\"leaves\", \"roots\"]\n        }\n      },\n      interaction: {\n        dragNodes: !0,\n        dragView: !0,\n        hideEdgesOnDrag: !1,\n        hideEdgesOnZoom: !1,\n        hideNodesOnDrag: !1,\n        hover: !1,\n        keyboard: {\n          enabled: !1,\n          speed: {\n            x: [10, 0, 40, 1],\n            y: [10, 0, 40, 1],\n            zoom: [.02, 0, .1, .005]\n          },\n          bindToWindow: !0,\n          autoFocus: !0\n        },\n        multiselect: !1,\n        navigationButtons: !1,\n        selectable: !0,\n        selectConnectedEdges: !0,\n        hoverConnectedEdges: !0,\n        tooltipDelay: [300, 0, 1e3, 25],\n        zoomView: !0,\n        zoomSpeed: [1, .1, 2, .1]\n      },\n      manipulation: {\n        enabled: !1,\n        initiallyActive: !1\n      },\n      physics: {\n        enabled: !0,\n        barnesHut: {\n          theta: [.5, .1, 1, .05],\n          gravitationalConstant: [-2e3, -3e4, 0, 50],\n          centralGravity: [.3, 0, 10, .05],\n          springLength: [95, 0, 500, 5],\n          springConstant: [.04, 0, 1.2, .005],\n          damping: [.09, 0, 1, .01],\n          avoidOverlap: [0, 0, 1, .01]\n        },\n        forceAtlas2Based: {\n          theta: [.5, .1, 1, .05],\n          gravitationalConstant: [-50, -500, 0, 1],\n          centralGravity: [.01, 0, 1, .005],\n          springLength: [95, 0, 500, 5],\n          springConstant: [.08, 0, 1.2, .005],\n          damping: [.4, 0, 1, .01],\n          avoidOverlap: [0, 0, 1, .01]\n        },\n        repulsion: {\n          centralGravity: [.2, 0, 10, .05],\n          springLength: [200, 0, 500, 5],\n          springConstant: [.05, 0, 1.2, .005],\n          nodeDistance: [100, 0, 500, 5],\n          damping: [.09, 0, 1, .01]\n        },\n        hierarchicalRepulsion: {\n          centralGravity: [.2, 0, 10, .05],\n          springLength: [100, 0, 500, 5],\n          springConstant: [.01, 0, 1.2, .005],\n          nodeDistance: [120, 0, 500, 5],\n          damping: [.09, 0, 1, .01],\n          avoidOverlap: [0, 0, 1, .01]\n        },\n        maxVelocity: [50, 0, 150, 1],\n        minVelocity: [.1, .01, .5, .01],\n        solver: [\"barnesHut\", \"forceAtlas2Based\", \"repulsion\", \"hierarchicalRepulsion\"],\n        timestep: [.5, .01, 1, .01],\n        wind: {\n          x: [0, -10, 10, .1],\n          y: [0, -10, 10, .1]\n        }\n      }\n    },\n    XC = (t, e, i) => {\n      var o;\n      return !(!_u(t).call(t, \"physics\") || !_u(o = YC.physics.solver).call(o, e) || i.physics.solver === e || \"wind\" === e);\n    };\n  var KC = Object.freeze({\n    __proto__: null,\n    allOptions: UC,\n    configuratorHideOption: XC,\n    configureOptions: YC\n  });\n  class GC {\n    constructor() {}\n    getDistances(t, e, i) {\n      const o = {},\n        s = t.edges;\n      for (let t = 0; t < e.length; t++) {\n        const i = {};\n        o[e[t]] = i;\n        for (let o = 0; o < e.length; o++) i[e[o]] = t == o ? 0 : 1e9;\n      }\n      for (let t = 0; t < i.length; t++) {\n        const e = s[i[t]];\n        !0 === e.connected && void 0 !== o[e.fromId] && void 0 !== o[e.toId] && (o[e.fromId][e.toId] = 1, o[e.toId][e.fromId] = 1);\n      }\n      const n = e.length;\n      for (let t = 0; t < n; t++) {\n        const i = e[t],\n          s = o[i];\n        for (let t = 0; t < n - 1; t++) {\n          const r = e[t],\n            a = o[r];\n          for (let h = t + 1; h < n; h++) {\n            const t = e[h],\n              n = o[t],\n              d = Math.min(a[t], a[i] + s[t]);\n            a[t] = d, n[r] = d;\n          }\n        }\n      }\n      return o;\n    }\n  }\n  class ZC {\n    constructor(t, e, i) {\n      this.body = t, this.springLength = e, this.springConstant = i, this.distanceSolver = new GC();\n    }\n    setOptions(t) {\n      t && (t.springLength && (this.springLength = t.springLength), t.springConstant && (this.springConstant = t.springConstant));\n    }\n    solve(t, e) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n      const o = this.distanceSolver.getDistances(this.body, t, e);\n      this._createL_matrix(o), this._createK_matrix(o), this._createE_matrix();\n      let s = 0;\n      const n = Math.max(1e3, Math.min(10 * this.body.nodeIndices.length, 6e3));\n      let r = 1e9,\n        a = 0,\n        h = 0,\n        d = 0,\n        l = 0,\n        c = 0;\n      for (; r > .01 && s < n;) for (s += 1, [a, r, h, d] = this._getHighestEnergyNode(i), l = r, c = 0; l > 1 && c < 5;) c += 1, this._moveNode(a, h, d), [l, h, d] = this._getEnergy(a);\n    }\n    _getHighestEnergyNode(t) {\n      const e = this.body.nodeIndices,\n        i = this.body.nodes;\n      let o = 0,\n        s = e[0],\n        n = 0,\n        r = 0;\n      for (let a = 0; a < e.length; a++) {\n        const h = e[a];\n        if (!0 !== i[h].predefinedPosition || !0 === i[h].isCluster && !0 === t || !0 !== i[h].options.fixed.x || !0 !== i[h].options.fixed.y) {\n          const [t, e, i] = this._getEnergy(h);\n          o < t && (o = t, s = h, n = e, r = i);\n        }\n      }\n      return [s, o, n, r];\n    }\n    _getEnergy(t) {\n      const [e, i] = this.E_sums[t];\n      return [Math.sqrt(e ** 2 + i ** 2), e, i];\n    }\n    _moveNode(t, e, i) {\n      const o = this.body.nodeIndices,\n        s = this.body.nodes;\n      let n = 0,\n        r = 0,\n        a = 0;\n      const h = s[t].x,\n        d = s[t].y,\n        l = this.K_matrix[t],\n        c = this.L_matrix[t];\n      for (let e = 0; e < o.length; e++) {\n        const i = o[e];\n        if (i !== t) {\n          const t = s[i].x,\n            e = s[i].y,\n            o = l[i],\n            u = c[i],\n            p = 1 / ((h - t) ** 2 + (d - e) ** 2) ** 1.5;\n          n += o * (1 - u * (d - e) ** 2 * p), r += o * (u * (h - t) * (d - e) * p), a += o * (1 - u * (h - t) ** 2 * p);\n        }\n      }\n      const u = (e / n + i / r) / (r / n - a / r),\n        p = -(r * u + e) / n;\n      s[t].x += p, s[t].y += u, this._updateE_matrix(t);\n    }\n    _createL_matrix(t) {\n      const e = this.body.nodeIndices,\n        i = this.springLength;\n      this.L_matrix = [];\n      for (let o = 0; o < e.length; o++) {\n        this.L_matrix[e[o]] = {};\n        for (let s = 0; s < e.length; s++) this.L_matrix[e[o]][e[s]] = i * t[e[o]][e[s]];\n      }\n    }\n    _createK_matrix(t) {\n      const e = this.body.nodeIndices,\n        i = this.springConstant;\n      this.K_matrix = [];\n      for (let o = 0; o < e.length; o++) {\n        this.K_matrix[e[o]] = {};\n        for (let s = 0; s < e.length; s++) this.K_matrix[e[o]][e[s]] = i * t[e[o]][e[s]] ** -2;\n      }\n    }\n    _createE_matrix() {\n      const t = this.body.nodeIndices,\n        e = this.body.nodes;\n      this.E_matrix = {}, this.E_sums = {};\n      for (let e = 0; e < t.length; e++) this.E_matrix[t[e]] = [];\n      for (let i = 0; i < t.length; i++) {\n        const o = t[i],\n          s = e[o].x,\n          n = e[o].y;\n        let r = 0,\n          a = 0;\n        for (let h = i; h < t.length; h++) {\n          const d = t[h];\n          if (d !== o) {\n            const t = e[d].x,\n              l = e[d].y,\n              c = 1 / Math.sqrt((s - t) ** 2 + (n - l) ** 2);\n            this.E_matrix[o][h] = [this.K_matrix[o][d] * (s - t - this.L_matrix[o][d] * (s - t) * c), this.K_matrix[o][d] * (n - l - this.L_matrix[o][d] * (n - l) * c)], this.E_matrix[d][i] = this.E_matrix[o][h], r += this.E_matrix[o][h][0], a += this.E_matrix[o][h][1];\n          }\n        }\n        this.E_sums[o] = [r, a];\n      }\n    }\n    _updateE_matrix(t) {\n      const e = this.body.nodeIndices,\n        i = this.body.nodes,\n        o = this.E_matrix[t],\n        s = this.K_matrix[t],\n        n = this.L_matrix[t],\n        r = i[t].x,\n        a = i[t].y;\n      let h = 0,\n        d = 0;\n      for (let l = 0; l < e.length; l++) {\n        const c = e[l];\n        if (c !== t) {\n          const t = o[l],\n            e = t[0],\n            u = t[1],\n            p = i[c].x,\n            g = i[c].y,\n            f = 1 / Math.sqrt((r - p) ** 2 + (a - g) ** 2),\n            m = s[c] * (r - p - n[c] * (r - p) * f),\n            y = s[c] * (a - g - n[c] * (a - g) * f);\n          o[l] = [m, y], h += m, d += y;\n          const b = this.E_sums[c];\n          b[0] += m - e, b[1] += y - u;\n        }\n      }\n      this.E_sums[t] = [h, d];\n    }\n  }\n  function QC(t, e, i) {\n    var o, s, n, r;\n    if (!(this instanceof QC)) throw new SyntaxError(\"Constructor must be called with the new operator\");\n    this.options = {}, this.defaultOptions = {\n      locale: \"en\",\n      locales: My,\n      clickToUse: !1\n    }, wo(this.options, this.defaultOptions), this.body = {\n      container: t,\n      nodes: {},\n      nodeIndices: [],\n      edges: {},\n      edgeIndices: [],\n      emitter: {\n        on: Ho(o = this.on).call(o, this),\n        off: Ho(s = this.off).call(s, this),\n        emit: Ho(n = this.emit).call(n, this),\n        once: Ho(r = this.once).call(r, this)\n      },\n      eventListeners: {\n        onTap: function () {},\n        onTouch: function () {},\n        onDoubleTap: function () {},\n        onHold: function () {},\n        onDragStart: function () {},\n        onDrag: function () {},\n        onDragEnd: function () {},\n        onMouseWheel: function () {},\n        onPinch: function () {},\n        onMouseMove: function () {},\n        onRelease: function () {},\n        onContext: function () {}\n      },\n      data: {\n        nodes: null,\n        edges: null\n      },\n      functions: {\n        createNode: function () {},\n        createEdge: function () {},\n        getPointer: function () {}\n      },\n      modules: {},\n      view: {\n        scale: 1,\n        translation: {\n          x: 0,\n          y: 0\n        }\n      },\n      selectionBox: {\n        show: !1,\n        position: {\n          start: {\n            x: 0,\n            y: 0\n          },\n          end: {\n            x: 0,\n            y: 0\n          }\n        }\n      }\n    }, this.bindEventListeners(), this.images = new Iy(() => this.body.emitter.emit(\"_requestRedraw\")), this.groups = new jv(), this.canvas = new uE(this.body), this.selectionHandler = new EO(this.body, this.canvas), this.interactionHandler = new mE(this.body, this.canvas, this.selectionHandler), this.view = new pE(this.body, this.canvas), this.renderer = new hE(this.body, this.canvas), this.physics = new Jx(this.body), this.layoutEngine = new NC(this.body), this.clustering = new aE(this.body), this.manipulation = new AC(this.body, this.canvas, this.selectionHandler, this.interactionHandler), this.nodesHandler = new cx(this.body, this.images, this.groups, this.layoutEngine), this.edgesHandler = new qx(this.body, this.images, this.groups), this.body.modules.kamadaKawai = new ZC(this.body, 150, .05), this.body.modules.clustering = this.clustering, this.canvas._create(), this.setOptions(i), this.setData(e);\n  }\n  Go(QC.prototype), QC.prototype.setOptions = function (t) {\n    if (null === t && (t = void 0), void 0 !== t) {\n      !0 === Zm.validate(t, UC) && console.error(\"%cErrors have been found in the supplied options object.\", Gm);\n      if (wm([\"locale\", \"locales\", \"clickToUse\"], this.options, t), void 0 !== t.locale && (t.locale = function (t, e) {\n        try {\n          const [o, s] = e.split(/[-_ /]/, 2),\n            n = null != o ? o.toLowerCase() : null,\n            r = null != s ? s.toUpperCase() : null;\n          if (n && r) {\n            const e = n + \"-\" + r;\n            if (Object.prototype.hasOwnProperty.call(t, e)) return e;\n            var i;\n            console.warn(Iu(i = \"Unknown variant \".concat(r, \" of language \")).call(i, n, \".\"));\n          }\n          if (n) {\n            const e = n;\n            if (Object.prototype.hasOwnProperty.call(t, e)) return e;\n            console.warn(\"Unknown language \".concat(n));\n          }\n          return console.warn(\"Unknown locale \".concat(e, \", falling back to English.\")), \"en\";\n        } catch (t) {\n          return console.error(t), console.warn(\"Unexpected error while normalizing locale \".concat(e, \", falling back to English.\")), \"en\";\n        }\n      }(t.locales || this.options.locales, t.locale)), t = this.layoutEngine.setOptions(t.layout, t), this.canvas.setOptions(t), this.groups.setOptions(t.groups), this.nodesHandler.setOptions(t.nodes), this.edgesHandler.setOptions(t.edges), this.physics.setOptions(t.physics), this.manipulation.setOptions(t.manipulation, t, this.options), this.interactionHandler.setOptions(t.interaction), this.renderer.setOptions(t.interaction), this.selectionHandler.setOptions(t.interaction), void 0 !== t.groups && this.body.emitter.emit(\"refreshNodes\"), \"configure\" in t && (this.configurator || (this.configurator = new Ym(this, this.body.container, YC, this.canvas.pixelRatio, XC)), this.configurator.setOptions(t.configure)), this.configurator && !0 === this.configurator.options.enabled) {\n        const t = {\n          nodes: {},\n          edges: {},\n          layout: {},\n          interaction: {},\n          manipulation: {},\n          physics: {},\n          global: {}\n        };\n        xm(t.nodes, this.nodesHandler.options), xm(t.edges, this.edgesHandler.options), xm(t.layout, this.layoutEngine.options), xm(t.interaction, this.selectionHandler.options), xm(t.interaction, this.renderer.options), xm(t.interaction, this.interactionHandler.options), xm(t.manipulation, this.manipulation.options), xm(t.physics, this.physics.options), xm(t.global, this.canvas.options), xm(t.global, this.options), this.configurator.setModuleOptions(t);\n      }\n      void 0 !== t.clickToUse ? !0 === t.clickToUse ? void 0 === this.activator && (this.activator = new Um(this.canvas.frame), this.activator.on(\"change\", () => {\n        this.body.emitter.emit(\"activate\");\n      })) : (void 0 !== this.activator && (this.activator.destroy(), delete this.activator), this.body.emitter.emit(\"activate\")) : this.body.emitter.emit(\"activate\"), this.canvas.setSize(), this.body.emitter.emit(\"startSimulation\");\n    }\n  }, QC.prototype._updateVisibleIndices = function () {\n    const t = this.body.nodes,\n      e = this.body.edges;\n    this.body.nodeIndices = [], this.body.edgeIndices = [];\n    for (const e in t) Object.prototype.hasOwnProperty.call(t, e) && (this.clustering._isClusteredNode(e) || !1 !== t[e].options.hidden || this.body.nodeIndices.push(t[e].id));\n    for (const i in e) if (Object.prototype.hasOwnProperty.call(e, i)) {\n      const o = e[i],\n        s = t[o.fromId],\n        n = t[o.toId],\n        r = void 0 !== s && void 0 !== n;\n      !this.clustering._isClusteredEdge(i) && !1 === o.options.hidden && r && !1 === s.options.hidden && !1 === n.options.hidden && this.body.edgeIndices.push(o.id);\n    }\n  }, QC.prototype.bindEventListeners = function () {\n    this.body.emitter.on(\"_dataChanged\", () => {\n      this.edgesHandler._updateState(), this.body.emitter.emit(\"_dataUpdated\");\n    }), this.body.emitter.on(\"_dataUpdated\", () => {\n      this.clustering._updateState(), this._updateVisibleIndices(), this._updateValueRange(this.body.nodes), this._updateValueRange(this.body.edges), this.body.emitter.emit(\"startSimulation\"), this.body.emitter.emit(\"_requestRedraw\");\n    });\n  }, QC.prototype.setData = function (t) {\n    if (this.body.emitter.emit(\"resetPhysics\"), this.body.emitter.emit(\"_resetData\"), this.selectionHandler.unselectAll(), t && t.dot && (t.nodes || t.edges)) throw new SyntaxError('Data must contain either parameter \"dot\" or  parameter pair \"nodes\" and \"edges\", but not both.');\n    if (this.setOptions(t && t.options), t && t.dot) {\n      console.warn(\"The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);\");\n      const e = Cy(t.dot);\n      this.setData(e);\n    } else if (t && t.gephi) {\n      console.warn(\"The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);\");\n      const e = Sy(t.gephi);\n      this.setData(e);\n    } else this.nodesHandler.setData(t && t.nodes, !0), this.edgesHandler.setData(t && t.edges, !0), this.body.emitter.emit(\"_dataChanged\"), this.body.emitter.emit(\"_dataLoaded\"), this.body.emitter.emit(\"initPhysics\");\n  }, QC.prototype.destroy = function () {\n    this.body.emitter.emit(\"destroy\"), this.body.emitter.off(), this.off(), delete this.groups, delete this.canvas, delete this.selectionHandler, delete this.interactionHandler, delete this.view, delete this.renderer, delete this.physics, delete this.layoutEngine, delete this.clustering, delete this.manipulation, delete this.nodesHandler, delete this.edgesHandler, delete this.configurator, delete this.images;\n    for (const t in this.body.nodes) Object.prototype.hasOwnProperty.call(this.body.nodes, t) && delete this.body.nodes[t];\n    for (const t in this.body.edges) Object.prototype.hasOwnProperty.call(this.body.edges, t) && delete this.body.edges[t];\n    fm(this.body.container);\n  }, QC.prototype._updateValueRange = function (t) {\n    let e,\n      i,\n      o,\n      s = 0;\n    for (e in t) if (Object.prototype.hasOwnProperty.call(t, e)) {\n      const n = t[e].getValue();\n      void 0 !== n && (i = void 0 === i ? n : Math.min(n, i), o = void 0 === o ? n : Math.max(n, o), s += n);\n    }\n    if (void 0 !== i && void 0 !== o) for (e in t) Object.prototype.hasOwnProperty.call(t, e) && t[e].setValueRange(i, o, s);\n  }, QC.prototype.isActive = function () {\n    return !this.activator || this.activator.active;\n  }, QC.prototype.setSize = function () {\n    return this.canvas.setSize.apply(this.canvas, arguments);\n  }, QC.prototype.canvasToDOM = function () {\n    return this.canvas.canvasToDOM.apply(this.canvas, arguments);\n  }, QC.prototype.DOMtoCanvas = function () {\n    return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);\n  }, QC.prototype.findNode = function () {\n    return this.clustering.findNode.apply(this.clustering, arguments);\n  }, QC.prototype.isCluster = function () {\n    return this.clustering.isCluster.apply(this.clustering, arguments);\n  }, QC.prototype.openCluster = function () {\n    return this.clustering.openCluster.apply(this.clustering, arguments);\n  }, QC.prototype.cluster = function () {\n    return this.clustering.cluster.apply(this.clustering, arguments);\n  }, QC.prototype.getNodesInCluster = function () {\n    return this.clustering.getNodesInCluster.apply(this.clustering, arguments);\n  }, QC.prototype.clusterByConnection = function () {\n    return this.clustering.clusterByConnection.apply(this.clustering, arguments);\n  }, QC.prototype.clusterByHubsize = function () {\n    return this.clustering.clusterByHubsize.apply(this.clustering, arguments);\n  }, QC.prototype.updateClusteredNode = function () {\n    return this.clustering.updateClusteredNode.apply(this.clustering, arguments);\n  }, QC.prototype.getClusteredEdges = function () {\n    return this.clustering.getClusteredEdges.apply(this.clustering, arguments);\n  }, QC.prototype.getBaseEdge = function () {\n    return this.clustering.getBaseEdge.apply(this.clustering, arguments);\n  }, QC.prototype.getBaseEdges = function () {\n    return this.clustering.getBaseEdges.apply(this.clustering, arguments);\n  }, QC.prototype.updateEdge = function () {\n    return this.clustering.updateEdge.apply(this.clustering, arguments);\n  }, QC.prototype.clusterOutliers = function () {\n    return this.clustering.clusterOutliers.apply(this.clustering, arguments);\n  }, QC.prototype.getSeed = function () {\n    return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);\n  }, QC.prototype.enableEditMode = function () {\n    return this.manipulation.enableEditMode.apply(this.manipulation, arguments);\n  }, QC.prototype.disableEditMode = function () {\n    return this.manipulation.disableEditMode.apply(this.manipulation, arguments);\n  }, QC.prototype.addNodeMode = function () {\n    return this.manipulation.addNodeMode.apply(this.manipulation, arguments);\n  }, QC.prototype.editNode = function () {\n    return this.manipulation.editNode.apply(this.manipulation, arguments);\n  }, QC.prototype.editNodeMode = function () {\n    return console.warn(\"Deprecated: Please use editNode instead of editNodeMode.\"), this.manipulation.editNode.apply(this.manipulation, arguments);\n  }, QC.prototype.addEdgeMode = function () {\n    return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);\n  }, QC.prototype.editEdgeMode = function () {\n    return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);\n  }, QC.prototype.deleteSelected = function () {\n    return this.manipulation.deleteSelected.apply(this.manipulation, arguments);\n  }, QC.prototype.getPositions = function () {\n    return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);\n  }, QC.prototype.getPosition = function () {\n    return this.nodesHandler.getPosition.apply(this.nodesHandler, arguments);\n  }, QC.prototype.storePositions = function () {\n    return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);\n  }, QC.prototype.moveNode = function () {\n    return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);\n  }, QC.prototype.getBoundingBox = function () {\n    return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);\n  }, QC.prototype.getConnectedNodes = function (t) {\n    return void 0 !== this.body.nodes[t] ? this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments) : this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);\n  }, QC.prototype.getConnectedEdges = function () {\n    return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);\n  }, QC.prototype.startSimulation = function () {\n    return this.physics.startSimulation.apply(this.physics, arguments);\n  }, QC.prototype.stopSimulation = function () {\n    return this.physics.stopSimulation.apply(this.physics, arguments);\n  }, QC.prototype.stabilize = function () {\n    return this.physics.stabilize.apply(this.physics, arguments);\n  }, QC.prototype.getSelection = function () {\n    return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);\n  }, QC.prototype.setSelection = function () {\n    return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);\n  }, QC.prototype.getSelectedNodes = function () {\n    return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler, arguments);\n  }, QC.prototype.getSelectedEdges = function () {\n    return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler, arguments);\n  }, QC.prototype.getNodeAt = function () {\n    const t = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);\n    return void 0 !== t && void 0 !== t.id ? t.id : t;\n  }, QC.prototype.getEdgeAt = function () {\n    const t = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);\n    return void 0 !== t && void 0 !== t.id ? t.id : t;\n  }, QC.prototype.selectNodes = function () {\n    return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);\n  }, QC.prototype.selectEdges = function () {\n    return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);\n  }, QC.prototype.unselectAll = function () {\n    this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments), this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler), this.redraw();\n  }, QC.prototype.redraw = function () {\n    return this.renderer.redraw.apply(this.renderer, arguments);\n  }, QC.prototype.getScale = function () {\n    return this.view.getScale.apply(this.view, arguments);\n  }, QC.prototype.getViewPosition = function () {\n    return this.view.getViewPosition.apply(this.view, arguments);\n  }, QC.prototype.fit = function () {\n    return this.view.fit.apply(this.view, arguments);\n  }, QC.prototype.moveTo = function () {\n    return this.view.moveTo.apply(this.view, arguments);\n  }, QC.prototype.focus = function () {\n    return this.view.focus.apply(this.view, arguments);\n  }, QC.prototype.releaseNode = function () {\n    return this.view.releaseNode.apply(this.view, arguments);\n  }, QC.prototype.getOptionsFromConfigurator = function () {\n    let t = {};\n    return this.configurator && (t = this.configurator.getOptions.apply(this.configurator)), t;\n  };\n  const $C = Cy;\n  t.Network = QC, t.NetworkImages = Iy, t.networkDOTParser = ky, t.networkGephiParser = Ty, t.networkOptions = KC, t.parseDOTNetwork = $C, t.parseGephiNetwork = Sy;\n});\n//# sourceMappingURL=vis-network.min.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}