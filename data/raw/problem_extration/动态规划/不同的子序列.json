{
  "id": "AP_103fc0d4",
  "title": "不同的子序列",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/distinct-subsequences/",
  "description": "一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。\n\n字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，\"ACE\" 是 \"ABCDE\" 的一个子序列，而 \"AEC\" 不是）",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "递推",
    "初始化"
  ],
  "difficulty": null,
  "solution_approach": "使用动态规划方法解决子序列计数问题。通过定义一个二维dp数组，其中dp[i][j]表示以i-1为结尾的s子序列中出现以j-1为结尾的t的个数，来计算字符串s中包含多少个t作为其子序列。",
  "key_insights": [
    {
      "content": "通过将dp[i][j]设计为以i-1和j-1为结尾的子串匹配情况，可以有效利用之前的状态来进行当前状态的推导，从而避免了重复计算。"
    },
    {
      "content": "在递推公式中同时考虑了字符相等时使用当前字符匹配以及不使用当前字符匹配两种情况，确保了所有可能性都被考虑到。"
    },
    {
      "content": "dp数组的初始化需要特别注意边界条件，如dp[0][0]设为1，表示空字符串s可以变成空字符串t的一种方式；而dp[i][0]都设置为1，因为空字符串是任何非空字符串的子序列之一。"
    },
    {
      "content": "遍历顺序从上到下、从左至右保证了每个状态都是基于已计算出的结果进行更新的。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "这道题目如果不是子序列，而是要求连续序列的，那就可以考虑用KMP。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int numDistinct(string s, string t) { vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1)); for (int i = 0; i < s.size(); i++) dp[i][0] = 1; for (int j = 1; j < t.size(); j++) dp[0][j] = 0; for (int i = 1; i <= s.size(); i++) { for (int j = 1; j <= t.size(); j++) { if (s[i - 1] == t[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j]; } } } return dp[s.size()][t.size();}}",
          "description": "C++解决方案，使用动态规划计算子序列个数。"
        },
        {
          "language": "java",
          "code": "class Solution { public int numDistinct(String s, String t) { int[][] dp = new int[s.length() + 1][t.length() + 1]; for (int i = 0; i < s.length() + 1; i++) { dp[i][0] = 1; } for (int i = 1; i < s.length() + 1; i++) { for (int j = 1; j < t.length() + 1; j++) { if (s.charAt(i - 1) == t.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; }else{ dp[i][j] = dp[i - 1][j]; } } } return dp[s.length()][t.length();}}",
          "description": "Java解决方案，同样采用动态规划方法解决子序列计数问题。"
        },
        {
          "language": "python",
          "code": "class Solution: def numDistinct(self, s: str, t: str) -> int: dp = [[0] * (len(t)+1) for _ in range(len(s)+1)] for i in range(len(s)): dp[i][0] = 1 for j in range(1, len(t)): dp[0][j] = 0 for i in range(1, len(s)+1): for j in range(1, len(t)+1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]",
          "description": "Python解决方案，利用动态规划来计算字符串s中出现字符串t作为子序列的次数。"
        },
        {
          "language": "python3",
          "code": "class SolutionDP2: def numDistinct(self, s: str, t: str) -> int: n1, n2 = len(s), len(t) if n1 < n2: return 0 dp = [0 for _ in range(n2 + 1)] dp[0] = 1 for i in range(1, n1 + 1): prev = dp.copy() end = i if i < n2 else n2 for j in range(1, end + 1): if s[i - 1] == t[j - 1]: dp[j] = prev[j - 1] + prev[j] else: dp[j] = prev[j] return dp[-1]",
          "description": "Python3解决方案，通过优化空间复杂度（使用滚动数组）来减少内存使用，同时保持动态规划逻辑不变。"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution { public int numDistinct(String s, String t) { int[][] dp = new int[s.length() + 1][t.length() + 1]; for (int i = 0; i < s.length() + 1; i++) { dp[i][0] = 1; } for (int i = 1; i < s.length() + 1; i++) { for (int j = 1; j < t.length() + 1; j++) { if (s.charAt(i - 1) == t.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; }else{ dp[i][j] = dp[i - 1][j]; } } } return dp[s.length()][t.length(); } }",
          "description": "使用动态规划计算字符串t在字符串s的子序列中出现的次数"
        },
        {
          "language": "python",
          "code": "class Solution: def numDistinct(self, s: str, t: str) -> int: dp = [[0] * (len(t)+1) for _ in range(len(s)+1)] for i in range(len(s)): dp[i][0] = 1 for j in range(1, len(t)): dp[0][j] = 0 for i in range(1, len(s)+1): for j in range(1, len(t)+1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]",
          "description": "使用动态规划计算字符串t在字符串s的子序列中出现的次数"
        },
        {
          "language": "python",
          "code": "class SolutionDP2: def numDistinct(self, s: str, t: str) -> int: n1, n2 = len(s), len(t) if n1 < n2: return 0 dp = [0 for _ in range(n2 + 1)] dp[0] = 1 for i in range(1, n1 + 1): prev = dp.copy() end = i if i < n2 else n2 for j in range(1, end + 1): if s[i - 1] == t[j - 1]: dp[j] = prev[j - 1] + prev[j] else: dp[j] = prev[j] return dp[-1]",
          "description": "使用空间优化后的动态规划计算字符串t在字符串s的子序列中出现的次数"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int numDistinct(string s, string t) {vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1)); for (int i = 0; i < s.size(); i++) dp[i][0] = 1; for (int j = 1; j < t.size(); j++) dp[0][j] = 0; for (int i = 1; i <= s.size(); i++) {for (int j = 1; j <= t.size(); j++) {if (s[i - 1] == t[j - 1]) {dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];} else {dp[i][j] = dp[i - 1][j];}}} return dp[s.size()][t.size()];}};",
          "description": "C++版本的解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public int numDistinct(String s, String t) {int[][] dp = new int[s.length() + 1][t.length() + 1]; for (int i = 0; i < s.length() + 1; i++) {dp[i][0] = 1;} for (int i = 1; i < s.length() + 1; i++) {for (int j = 1; j < t.length() + 1; j++) {if (s.charAt(i - 1) == t.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];}else{dp[i][j] = dp[i - 1][j];}}} return dp[s.length()][t.length()];}}",
          "description": "Java版本的解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def numDistinct(self, s: str, t: str) -> int: dp = [[0] * (len(t)+1) for _ in range(len(s)+1)] for i in range(len(s)): dp[i][0] = 1 for j in range(1, len(t)): dp[0][j] = 0 for i in range(1, len(s)+1): for j in range(1, len(t)+1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]",
          "description": "Python版本的解决方案"
        },
        {
          "language": "python3",
          "code": "class SolutionDP2: def numDistinct(self, s: str, t: str) -> int: n1, n2 = len(s), len(t) if n1 < n2: return 0 dp = [0 for _ in range(n2 + 1)] dp[0] = 1 for i in range(1, n1 + 1): prev = dp.copy() end = i if i < n2 else n2 for j in range(1, end + 1): if s[i - 1] == t[j - 1]: dp[j] = prev[j - 1] + prev[j] else: dp[j] = prev[j] return dp[-1]",
          "description": "使用滚动数组优化空间复杂度的Python3版本解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "class Solution:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int numDistinct(string s, string t) {vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1)); for (int i = 0; i < s.size(); i++) dp[i][0] = 1; for (int j = 1; j < t.size(); j++) dp[0][j] = 0; for (int i = 1; i <= s.size(); i++) {for (int j = 1; j <= t.size(); j++) {if (s[i - 1] == t[j - 1]) {dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];} else {dp[i][j] = dp[i - 1][j];}}} return dp[s.size()][t.size()];}};",
          "description": "C++解决方案，使用动态规划计算字符串s中出现字符串t作为子序列的次数。"
        },
        {
          "language": "java",
          "code": "class Solution {public int numDistinct(String s, String t) {int[][] dp = new int[s.length() + 1][t.length() + 1]; for (int i = 0; i < s.length() + 1; i++) {dp[i][0] = 1;} for (int i = 1; i < s.length() + 1; i++) {for (int j = 1; j < t.length() + 1; j++) {if (s.charAt(i - 1) == t.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];}else{dp[i][j] = dp[i - 1][j];}}} return dp[s.length()][t.length()];}}",
          "description": "Java解决方案，使用动态规划计算字符串s中出现字符串t作为子序列的次数。"
        },
        {
          "language": "python",
          "code": "class Solution: def numDistinct(self, s: str, t: str) -> int: dp = [[0] * (len(t)+1) for _ in range(len(s)+1)] for i in range(len(s)): dp[i][0] = 1 for j in range(1, len(t)): dp[0][j] = 0 for i in range(1, len(s)+1): for j in range(1, len(t)+1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]",
          "description": "Python解决方案，使用动态规划计算字符串s中出现字符串t作为子序列的次数。"
        },
        {
          "language": "python3",
          "code": "class SolutionDP2: def numDistinct(self, s: str, t: str) -> int: n1, n2 = len(s), len(t) if n1 < n2: return 0 dp = [0 for _ in range(n2 + 1)] dp[0] = 1 for i in range(1, n1 + 1): prev = dp.copy() end = i if i < n2 else n2 for j in range(1, end + 1): if s[i - 1] == t[j - 1]: dp[j] = prev[j - 1] + prev[j] else: dp[j] = prev[j] return dp[-1]",
          "description": "Python3解决方案，通过空间压缩技术优化动态规划方法，减少内存消耗。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python3:",
      "text": "class SolutionDP2:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int numDistinct(string s, string t) {\n        vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1));\n        for (int i = 0; i < s.size(); i++) dp[i][0] = 1;\n        for (int j = 1; j < t.size(); j++) dp[0][j] = 0;\n        for (int i = 1; i <= s.size(); i++) {\n            for (int j = 1; j <= t.size(); j++) {\n                if (s[i - 1] == t[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[s.size()][t.size()];\n    }\n};",
          "description": "C++版本的解决方案，使用动态规划计算字符串s中出现t作为子序列的数量。"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int numDistinct(String s, String t) {\n        int[][] dp = new int[s.length() + 1][t.length() + 1];\n        for (int i = 0; i < s.length() + 1; i++) {\n            dp[i][0] = 1;\n        }\n        for (int i = 1; i < s.length() + 1; i++) {\n            for (int j = 1; j < t.length() + 1; j++) {\n                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                }else{\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[s.length()][t.length()];\n    }\n}",
          "description": "Java版本的解决方案，实现功能与C++版相同，但使用了Java特有的语法和数据结构。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]\n        for i in range(len(s)):\n            dp[i][0] = 1\n        for j in range(1, len(t)):\n            dp[0][j] = 0\n        for i in range(1, len(s)+1):\n            for j in range(1, len(t)+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j]\n        return dp[-1][-1]",
          "description": "Python版本的解决方案，使用列表推导式初始化dp数组，并实现了与上述两种语言相同的逻辑来解决问题。"
        },
        {
          "language": "python3",
          "code": "class SolutionDP2:\n    def numDistinct(self, s: str, t: str) -> int:\n        n1, n2 = len(s), len(t)\n        if n1 < n2:\n            return 0\n\n        dp = [0 for _ in range(n2 + 1)]\n        dp[0] = 1\n\n        for i in range(1, n1 + 1):\n            prev = dp.copy()\n            end = i if i < n2 else n2\n            for j in range(1, end + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[j] = prev[j - 1] + prev[j]\n                else:\n                    dp[j] = prev[j]\n        return dp[-1]",
          "description": "Python3版本的解决方案，通过空间优化减少了内存消耗，同时保持算法的效率。"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n * m)",
    "space_complexity": "O(n * m)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int numDistinct(string s, string t) {vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1)); for (int i = 0; i < s.size(); i++) dp[i][0] = 1; for (int j = 1; j < t.size(); j++) dp[0][j] = 0; for (int i = 1; i <= s.size(); i++) {for (int j = 1; j <= t.size(); j++) {if (s[i - 1] == t[j - 1]) {dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];} else {dp[i][j] = dp[i - 1][j];}}} return dp[s.size()][t.size()];}};",
      "description": "C++实现：计算一个字符串作为另一个字符串子序列出现的次数"
    },
    {
      "language": "java",
      "code": "class Solution {public int numDistinct(String s, String t) {int[][] dp = new int[s.length() + 1][t.length() + 1]; for (int i = 0; i < s.length() + 1; i++) {dp[i][0] = 1;} for (int i = 1; i < s.length() + 1; i++) {for (int j = 1; j < t.length() + 1; j++) {if (s.charAt(i - 1) == t.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];}else{dp[i][j] = dp[i - 1][j];}}} return dp[s.length()][t.length()];}}",
      "description": "Java实现：计算一个字符串作为另一个字符串子序列出现的次数"
    },
    {
      "language": "python",
      "code": "class Solution: def numDistinct(self, s: str, t: str) -> int: dp = [[0] * (len(t)+1) for _ in range(len(s)+1)] for i in range(len(s)): dp[i][0] = 1 for j in range(1, len(t)): dp[0][j] = 0 for i in range(1, len(s)+1): for j in range(1, len(t)+1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]",
      "description": "Python实现：计算一个字符串作为另一个字符串子序列出现的次数"
    },
    {
      "language": "python3",
      "code": "class SolutionDP2: def numDistinct(self, s: str, t: str) -> int: n1, n2 = len(s), len(t) if n1 < n2: return 0 dp = [0 for _ in range(n2 + 1)] dp[0] = 1 for i in range(1, n1 + 1): prev = dp.copy() end = i if i < n2 else n2 for j in range(1, end + 1): if s[i - 1] == t[j - 1]: dp[j] = prev[j - 1] + prev[j] else: dp[j] = prev[j] return dp[-1]",
      "description": "Python3优化实现：通过压缩动态规划数组减少空间复杂度，计算一个字符串作为另一个字符串子序列出现的次数"
    }
  ],
  "common_mistakes": [
    "忽视了当s[i-1]与t[j-1]相等时还需要考虑不使用s[i-1]进行匹配的情况。",
    "初始化dp数组时，对于dp[0][0]的值设置错误（应该是1）。",
    "遍历顺序不当导致无法正确利用先前计算的结果。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%A4%BA%E4%BE%8B.jpg",
      "description": "该图片展示了两个示例，用于解释如何通过动态规划算法计算字符串 `s` 中可以得到字符串 `t` 的子序列数量。",
      "context": "该图片展示了字符串s和t的例子，帮助理解如何计算s的子序列中t出现的次数。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20221222165412.png",
      "description": "这张图片展示了动态规划（DP）表格中状态转移的过程，箭头指示了从 `dp[i-1][j-1]`、`dp[i-1][j]` 和 `dp[i][j-1]` 到 `dp[i][j]` 的更新路径。",
      "context": "该图展示了dp数组中元素是如何从上方和左上方推导而来的，帮助理解dp[i][j]的初始化过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20221222165412.png",
      "description": "这张图片展示了动态规划（DP）表格中状态转移的过程，箭头指示了从 `dp[i-1][j-1]`、`dp[i-1][j]` 和 `dp[i][j-1]` 到 `dp[i][j]` 的更新路径。",
      "context": "该图片展示了dp数组中元素是如何从上方和左上方推导而来的，帮助理解dp[i][j]的初始化过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg",
      "description": "这张图片展示了使用动态规划算法解决子序列问题的过程，具体为字符串 \"baegg\" 和 \"bag\" 的匹配情况。",
      "context": "该图片展示了以字符串s:\"baegg\"和t:\"bag\"为例推导动态规划dp数组状态的过程，帮助理解代码逻辑。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%A4%BA%E4%BE%8B.jpg",
      "description": "GIF展示了通过动态规划方法计算字符串s中t作为子序列出现次数的过程。",
      "context": "该GIF动画展示了如何通过动态规划方法计算字符串s中作为子序列出现的t的数量的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20221222165412.png",
      "description": "GIF展示了动态规划数组dp的填充过程，特别强调了初始化步骤以及如何根据递推公式从上方和左上方单元格更新当前单元格值。",
      "context": "该GIF动画展示了动态规划数组dp[i][j]如何从上方和左上方的状态推导而来，帮助理解初始化时dp[i][0]与dp[0][j]的值设定。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg",
      "description": "GIF展示了通过动态规划算法计算字符串s中子序列t出现次数的过程，逐步更新dp数组的状态。",
      "context": "该GIF动画展示了如何根据给定的字符串s和t推导动态规划dp数组的过程，帮助理解算法中状态转移的具体步骤。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\不同的子序列.txt",
  "extracted_at": "2025-07-20T12:12:15.959943",
  "raw_content": "不同的子序列\n力扣题目链接(https://leetcode.cn/problems/distinct-subsequences/)\n\n给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。\n\n字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，\"ACE\" 是 \"ABCDE\" 的一个子序列，而 \"AEC\" 不是）\n\n题目数据保证答案符合 32 位带符号整数范围。\n\nhttps://file1.kamacoder.com/i/algo/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%A4%BA%E4%BE%8B.jpg\n\n提示：\n\n0 <= s.length, t.length <= 1000\ns 和 t 由英文字母组成\n\n\n#思路\n这道题目如果不是子序列，而是要求连续序列的，那就可以考虑用KMP。\n\n这道题目相对于72. 编辑距离，简单了不少，因为本题相当于只有删除操作，不用考虑替换增加之类的。\n\n但相对于刚讲过的动态规划：392.判断子序列 (https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html)就有难度了，这道题目双指针法可就做不了了，来看看动规五部曲分析如下：\n\n确定dp数组（dp table）以及下标的含义\ndp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。\n\n为什么i-1，j-1 这么定义我在 718. 最长重复子数组 (https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html)中做了详细的讲解。\n\n确定递推公式\n这一类问题，基本是要分析两种情况\n\ns[i - 1] 与 t[j - 1]相等\ns[i - 1] 与 t[j - 1] 不相等\n当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。\n\n一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1][j-1]。\n\n一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。\n\n这里可能有录友不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。\n\n例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。\n\n当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。\n\n所以当s[i - 1] 与 t[j - 1]相等时，dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n\n当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1][j]\n\n所以递推公式为：dp[i][j] = dp[i - 1][j];\n\n这里可能有录友还疑惑，为什么只考虑 “不用s[i - 1]来匹配” 这种情况， 不考虑 “不用t[j - 1]来匹配” 的情况呢。\n\n这里大家要明确，我们求的是 s 中有多少个 t，而不是 求t中有多少个s，所以只考虑 s中删除元素的情况，即 不用s[i - 1]来匹配 的情况。\n\ndp数组如何初始化\n从递推公式dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] = dp[i - 1][j]; 中可以看出dp[i][j] 是从上方和左上方推导而来，如图：，那么 dp[i][0] 和dp[0][j]是一定要初始化的。\n\nhttps://file1.kamacoder.com/i/algo/20221222165412.png\n\n每次当初始化的时候，都要回顾一下dp[i][j]的定义，不要凭感觉初始化。\n\ndp[i][0]表示什么呢？\n\ndp[i][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。\n\n那么dp[i][0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。\n\n再来看dp[0][j]，dp[0][j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。\n\n那么dp[0][j]一定都是0，s如论如何也变成不了t。\n\n最后就要看一个特殊位置了，即：dp[0][0] 应该是多少。\n\ndp[0][0]应该是1，空字符串s，可以删除0个元素，变成空字符串t。\n\n初始化分析完毕，代码如下：\n\nvector<vector<long long>> dp(s.size() + 1, vector<long long>(t.size() + 1));\nfor (int i = 0; i <= s.size(); i++) dp[i][0] = 1;\nfor (int j = 1; j <= t.size(); j++) dp[0][j] = 0; // 其实这行代码可以和dp数组初始化的时候放在一起，但我为了凸显初始化的逻辑，所以还是加上了。\n\n确定遍历顺序\n从递推公式dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] = dp[i - 1][j]; 中可以看出dp[i][j]都是根据左上方和正上方推出来的。\n\nhttps://file1.kamacoder.com/i/algo/20221222165412.png\n\n所以遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。\n\n代码如下：\n\nfor (int i = 1; i <= s.size(); i++) {\n    for (int j = 1; j <= t.size(); j++) {\n        if (s[i - 1] == t[j - 1]) {\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n        } else {\n            dp[i][j] = dp[i - 1][j];\n        }\n    }\n}\n举例推导dp数组\n以s：\"baegg\"，t：\"bag\"为例，推导dp数组状态如下：\n\nhttps://file1.kamacoder.com/i/algo/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg\n\n如果写出来的代码怎么改都通过不了，不妨把dp数组打印出来，看一看，是不是这样的。\n\n动规五部曲分析完毕，代码如下：\n\nclass Solution {\npublic:\n    int numDistinct(string s, string t) {\n        vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1));\n        for (int i = 0; i < s.size(); i++) dp[i][0] = 1;\n        for (int j = 1; j < t.size(); j++) dp[0][j] = 0;\n        for (int i = 1; i <= s.size(); i++) {\n            for (int j = 1; j <= t.size(); j++) {\n                if (s[i - 1] == t[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[s.size()][t.size()];\n    }\n};\n时间复杂度: O(n * m)\n空间复杂度: O(n * m)\n#其他语言版本\n#Java：\nclass Solution {\n    public int numDistinct(String s, String t) {\n        int[][] dp = new int[s.length() + 1][t.length() + 1];\n        for (int i = 0; i < s.length() + 1; i++) {\n            dp[i][0] = 1;\n        }\n        \n        for (int i = 1; i < s.length() + 1; i++) {\n            for (int j = 1; j < t.length() + 1; j++) {\n                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                }else{\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        \n        return dp[s.length()][t.length()];\n    }\n}\n#Python：\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]\n        for i in range(len(s)):\n            dp[i][0] = 1\n        for j in range(1, len(t)):\n            dp[0][j] = 0\n        for i in range(1, len(s)+1):\n            for j in range(1, len(t)+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j]\n        return dp[-1][-1]\n#Python3:\nclass SolutionDP2:\n    \"\"\"\n    既然dp[i]只用到dp[i - 1]的状态，\n    我们可以通过缓存dp[i - 1]的状态来对dp进行压缩，\n    减少空间复杂度。\n    （原理等同同于滚动数组）\n    \"\"\"\n    \n    def numDistinct(self, s: str, t: str) -> int:\n        n1, n2 = len(s), len(t)\n        if n1 < n2:\n            return 0\n\n        dp = [0 for _ in range(n2 + 1)]\n        dp[0] = 1\n\n        for i in range(1, n1 + 1):\n            # 必须深拷贝\n            # 不然prev[i]和dp[i]是同一个地址的引用\n            prev = dp.copy()\n            # 剪枝，保证s的长度大于等于t\n            # 因为对于任意i，i > n1, dp[i] = 0\n            # 没必要跟新状态。 \n            end = i if i < n2 else n2\n            for j in range(1, end + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[j] = prev[j - 1] + prev[j]\n                else:\n                    dp[j] = prev[j]\n        return dp[-1]"
}