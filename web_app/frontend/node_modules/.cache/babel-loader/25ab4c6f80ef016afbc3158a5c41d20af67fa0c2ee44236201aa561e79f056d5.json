{"ast":null,"code":"import React,{useState,useCallback}from'react';import{Card,Input,Button,Select,Space,Typography,message,Row,Col,Divider}from'antd';import{PlayCircleOutlined,UserOutlined,CodeOutlined,BulbOutlined}from'@ant-design/icons';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const{Title,Text,Paragraph}=Typography;const{Option}=Select;const{TextArea}=Input;const CustomAlgorithmEditor=_ref=>{let{onExecute,isExecuting=false}=_ref;const[code,setCode]=useState('');const[dataStructure,setDataStructure]=useState('array');const[inputData,setInputData]=useState('');const[algorithmName,setAlgorithmName]=useState('');const[description,setDescription]=useState('');// 数据结构模板\nconst dataStructureTemplates={array:{name:'数组',template:`function customAlgorithm(arr) {\n  const steps = [];\n  const n = arr.length;\n  let data = [...arr];\n  \n  // 添加初始步骤\n  steps.push({\n    id: 0,\n    description: \"开始处理数组\",\n    data: [...data],\n    highlights: [],\n    comparisons: []\n  });\n  \n  // 在这里实现你的算法逻辑\n  for (let i = 0; i < n; i++) {\n    steps.push({\n      id: steps.length,\n      description: \\`处理索引 \\${i}: \\${data[i]}\\`,\n      data: [...data],\n      highlights: [i],\n      comparisons: []\n    });\n  }\n  \n  return steps;\n}`,defaultData:'[64, 34, 25, 12, 22, 11, 90]',description:'适用于排序、搜索等数组操作算法'},stack:{name:'栈',template:`function customStackAlgorithm(operations) {\n  const steps = [];\n  const stack = [];\n  \n  steps.push({\n    id: 0,\n    description: \"初始化空栈\",\n    data: [...stack],\n    highlights: [],\n    operation: 'init'\n  });\n  \n  operations.forEach((op, index) => {\n    if (op.type === 'push') {\n      stack.push(op.value);\n      steps.push({\n        id: steps.length,\n        description: \\`入栈: \\${op.value}\\`,\n        data: [...stack],\n        highlights: [stack.length - 1],\n        operation: 'push'\n      });\n    } else if (op.type === 'pop') {\n      const popped = stack.pop();\n      steps.push({\n        id: steps.length,\n        description: \\`出栈: \\${popped || 'empty'}\\`,\n        data: [...stack],\n        highlights: [],\n        operation: 'pop'\n      });\n    }\n  });\n  \n  return steps;\n}`,defaultData:'[{\"type\":\"push\",\"value\":1},{\"type\":\"push\",\"value\":2},{\"type\":\"pop\"},{\"type\":\"push\",\"value\":3}]',description:'适用于栈相关算法，如括号匹配、表达式求值等'},queue:{name:'队列',template:`function customQueueAlgorithm(operations) {\n  const steps = [];\n  const queue = [];\n  \n  steps.push({\n    id: 0,\n    description: \"初始化空队列\",\n    data: [...queue],\n    highlights: [],\n    operation: 'init'\n  });\n  \n  operations.forEach((op, index) => {\n    if (op.type === 'enqueue') {\n      queue.push(op.value);\n      steps.push({\n        id: steps.length,\n        description: \\`入队: \\${op.value}\\`,\n        data: [...queue],\n        highlights: [queue.length - 1],\n        operation: 'enqueue'\n      });\n    } else if (op.type === 'dequeue') {\n      const dequeued = queue.shift();\n      steps.push({\n        id: steps.length,\n        description: \\`出队: \\${dequeued || 'empty'}\\`,\n        data: [...queue],\n        highlights: [],\n        operation: 'dequeue'\n      });\n    }\n  });\n  \n  return steps;\n}`,defaultData:'[{\"type\":\"enqueue\",\"value\":1},{\"type\":\"enqueue\",\"value\":2},{\"type\":\"dequeue\"},{\"type\":\"enqueue\",\"value\":3}]',description:'适用于队列相关算法，如BFS、任务调度等'},tree:{name:'二叉树',template:`function customTreeAlgorithm(treeData) {\n  const steps = [];\n  \n  // 树的遍历示例\n  function traverse(node, path = []) {\n    if (!node) return;\n    \n    steps.push({\n      id: steps.length,\n      description: \\`访问节点: \\${node.value}\\`,\n      data: treeData,\n      highlights: [node.id],\n      path: [...path, node.id],\n      operation: 'visit'\n    });\n    \n    if (node.left) traverse(node.left, [...path, node.id]);\n    if (node.right) traverse(node.right, [...path, node.id]);\n  }\n  \n  steps.push({\n    id: 0,\n    description: \"开始遍历二叉树\",\n    data: treeData,\n    highlights: [],\n    operation: 'init'\n  });\n  \n  traverse(treeData);\n  return steps;\n}`,defaultData:'{\"id\":1,\"value\":10,\"left\":{\"id\":2,\"value\":5,\"left\":{\"id\":4,\"value\":3},\"right\":{\"id\":5,\"value\":7}},\"right\":{\"id\":3,\"value\":15,\"left\":{\"id\":6,\"value\":12},\"right\":{\"id\":7,\"value\":18}}}',description:'适用于二叉树相关算法，如遍历、搜索、平衡等'},graph:{name:'图',template:`function customGraphAlgorithm(graphData) {\n  const steps = [];\n  const { nodes, edges } = graphData;\n  const visited = new Set();\n  \n  steps.push({\n    id: 0,\n    description: \"开始图算法\",\n    data: graphData,\n    highlights: [],\n    visited: [],\n    operation: 'init'\n  });\n  \n  // DFS示例\n  function dfs(nodeId) {\n    if (visited.has(nodeId)) return;\n    \n    visited.add(nodeId);\n    steps.push({\n      id: steps.length,\n      description: \\`访问节点: \\${nodeId}\\`,\n      data: graphData,\n      highlights: [nodeId],\n      visited: Array.from(visited),\n      operation: 'visit'\n    });\n    \n    // 访问邻接节点\n    edges.filter(edge => edge.from === nodeId)\n         .forEach(edge => dfs(edge.to));\n  }\n  \n  if (nodes.length > 0) {\n    dfs(nodes[0].id);\n  }\n  \n  return steps;\n}`,defaultData:'{\"nodes\":[{\"id\":\"A\",\"value\":\"A\"},{\"id\":\"B\",\"value\":\"B\"},{\"id\":\"C\",\"value\":\"C\"},{\"id\":\"D\",\"value\":\"D\"}],\"edges\":[{\"from\":\"A\",\"to\":\"B\"},{\"from\":\"A\",\"to\":\"C\"},{\"from\":\"B\",\"to\":\"D\"},{\"from\":\"C\",\"to\":\"D\"}]}',description:'适用于图相关算法，如DFS、BFS、最短路径等'}};const handleDataStructureChange=useCallback(value=>{setDataStructure(value);const template=dataStructureTemplates[value];setCode(template.template);setInputData(template.defaultData);},[]);const handleExecute=useCallback(()=>{if(!code.trim()){message.error('请输入算法代码');return;}if(!inputData.trim()){message.error('请输入测试数据');return;}try{// 验证输入数据格式\nconst parsedData=JSON.parse(inputData);onExecute(code,dataStructure,parsedData);}catch(error){message.error('输入数据格式错误，请检查JSON格式');}},[code,dataStructure,inputData,onExecute]);const handleSaveTemplate=useCallback(()=>{if(!algorithmName.trim()){message.error('请输入算法名称');return;}// 保存到本地存储\nconst savedAlgorithms=JSON.parse(localStorage.getItem('customAlgorithms')||'[]');const newAlgorithm={id:Date.now().toString(),name:algorithmName,description,dataStructure,code,inputData,createdAt:new Date().toISOString()};savedAlgorithms.push(newAlgorithm);localStorage.setItem('customAlgorithms',JSON.stringify(savedAlgorithms));message.success('算法模板已保存');setAlgorithmName('');setDescription('');},[algorithmName,description,dataStructure,code,inputData]);const currentTemplate=dataStructureTemplates[dataStructure];return/*#__PURE__*/_jsx(Card,{title:/*#__PURE__*/_jsxs(Space,{children:[/*#__PURE__*/_jsx(CodeOutlined,{}),\"\\u81EA\\u5B9A\\u4E49\\u7B97\\u6CD5\\u7F16\\u8F91\\u5668\"]}),children:/*#__PURE__*/_jsxs(Row,{gutter:[24,16],children:[/*#__PURE__*/_jsx(Col,{span:8,children:/*#__PURE__*/_jsxs(Space,{direction:\"vertical\",style:{width:'100%'},size:\"middle\",children:[/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(Text,{strong:true,children:\"\\u6570\\u636E\\u7ED3\\u6784\\u7C7B\\u578B\"}),/*#__PURE__*/_jsx(Select,{value:dataStructure,onChange:handleDataStructureChange,style:{width:'100%',marginTop:8},placeholder:\"\\u9009\\u62E9\\u6570\\u636E\\u7ED3\\u6784\",children:Object.entries(dataStructureTemplates).map(_ref2=>{let[key,template]=_ref2;return/*#__PURE__*/_jsx(Option,{value:key,children:template.name},key);})}),/*#__PURE__*/_jsx(Paragraph,{style:{marginTop:8,fontSize:12,color:'#666'},children:currentTemplate===null||currentTemplate===void 0?void 0:currentTemplate.description})]}),/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(Text,{strong:true,children:\"\\u6D4B\\u8BD5\\u6570\\u636E\"}),/*#__PURE__*/_jsx(TextArea,{value:inputData,onChange:e=>setInputData(e.target.value),placeholder:\"\\u8F93\\u5165JSON\\u683C\\u5F0F\\u7684\\u6D4B\\u8BD5\\u6570\\u636E\",rows:4,style:{marginTop:8}})]}),/*#__PURE__*/_jsx(Divider,{}),/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(Text,{strong:true,children:\"\\u4FDD\\u5B58\\u4E3A\\u6A21\\u677F\"}),/*#__PURE__*/_jsx(Input,{value:algorithmName,onChange:e=>setAlgorithmName(e.target.value),placeholder:\"\\u7B97\\u6CD5\\u540D\\u79F0\",style:{marginTop:8}}),/*#__PURE__*/_jsx(TextArea,{value:description,onChange:e=>setDescription(e.target.value),placeholder:\"\\u7B97\\u6CD5\\u63CF\\u8FF0\",rows:2,style:{marginTop:8}}),/*#__PURE__*/_jsx(Button,{icon:/*#__PURE__*/_jsx(UserOutlined,{}),onClick:handleSaveTemplate,style:{marginTop:8,width:'100%'},children:\"\\u4FDD\\u5B58\\u6A21\\u677F\"})]})]})}),/*#__PURE__*/_jsx(Col,{span:16,children:/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsxs(\"div\",{style:{display:'flex',justifyContent:'space-between',alignItems:'center',marginBottom:8},children:[/*#__PURE__*/_jsx(Text,{strong:true,children:\"\\u7B97\\u6CD5\\u4EE3\\u7801\"}),/*#__PURE__*/_jsx(Button,{type:\"primary\",icon:/*#__PURE__*/_jsx(PlayCircleOutlined,{}),onClick:handleExecute,loading:isExecuting,children:\"\\u6267\\u884C\\u7B97\\u6CD5\"})]}),/*#__PURE__*/_jsx(TextArea,{value:code,onChange:e=>setCode(e.target.value),placeholder:\"\\u5728\\u8FD9\\u91CC\\u7F16\\u5199\\u4F60\\u7684\\u7B97\\u6CD5\\u4EE3\\u7801...\",rows:20,style:{fontFamily:'Monaco, Menlo, \"Ubuntu Mono\", monospace',fontSize:'13px'}}),/*#__PURE__*/_jsx(\"div\",{style:{marginTop:8},children:/*#__PURE__*/_jsxs(Text,{type:\"secondary\",style:{fontSize:12},children:[/*#__PURE__*/_jsx(BulbOutlined,{style:{marginRight:4}}),\"\\u63D0\\u793A\\uFF1A\\u7B97\\u6CD5\\u51FD\\u6570\\u5FC5\\u987B\\u8FD4\\u56DE\\u5305\\u542B\\u6B65\\u9AA4\\u4FE1\\u606F\\u7684\\u6570\\u7EC4\\uFF0C\\u6BCF\\u4E2A\\u6B65\\u9AA4\\u5305\\u542Bid\\u3001description\\u3001data\\u7B49\\u5B57\\u6BB5\"]})})]})})]})});};export default CustomAlgorithmEditor;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}