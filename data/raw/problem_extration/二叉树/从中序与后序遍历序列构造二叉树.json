{
  "id": "AP_e2b2084a",
  "title": "从中序与后序遍历序列构造二叉树",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",
  "description": "根据一棵树的中序遍历与后序遍历构造二叉树。\n\n注意: 你可以假设树中没有重复的元素。\n\n例如，给出\n\n中序遍历 inorder = [9,3,15,20,7]\n后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：\n\nhttps://file1.kamacoder.com/i/algo/20210203154316774.png",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "分治法",
    "递归"
  ],
  "data_structure_tags": [
    "数组",
    "二叉树"
  ],
  "technique_tags": [
    "循环不变量",
    "边界条件处理"
  ],
  "difficulty": null,
  "solution_approach": "通过递归方法，利用后序遍历序列的最后一个元素作为当前子树的根节点，并在中序遍历序列中找到该元素的位置来划分左右子树。然后基于划分后的中序和后序数组递归构造二叉树。",
  "key_insights": [
    {
      "content": "选择后序遍历序列中的最后一个元素作为当前处理的子树的根节点，这是因为后序遍历的特点是最后访问根节点。"
    },
    {
      "content": "利用在中序遍历中找到的根节点位置，可以将中序序列划分为左子树和右子树两部分。这一步骤对于后续正确地分割后序序列至关重要。"
    },
    {
      "content": "在整个过程中，无论是对中序还是后序数组进行分割时，都必须严格遵循相同的切割标准（如左闭右开），以确保逻辑的一致性和准确性。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private: TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {if (postorder.size() == 0) return NULL;int rootValue = postorder[postorder.size() - 1];TreeNode* root = new TreeNode(rootValue);if (postorder.size() == 1) return root;int delimiterIndex;for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {if (inorder[delimiterIndex] == rootValue) break;}vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end());postorder.resize(postorder.size() - 1);vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());root->left = traversal(leftInorder, leftPostorder);root->right = traversal(rightInorder, rightPostorder);return root;}public: TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {if (inorder.size() == 0 || postorder.size() == 0) return NULL;return traversal(inorder, postorder);}};",
          "description": "根据中序与后序遍历序列构造二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution {private: TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {if (postorderBegin == postorderEnd) return NULL;int rootValue = postorder[postorderEnd - 1];TreeNode* root = new TreeNode(rootValue);if (postorderEnd - postorderBegin == 1) return root;int delimiterIndex;for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {if (inorder[delimiterIndex] == rootValue) break;}int leftInorderBegin = inorderBegin;int leftInorderEnd = delimiterIndex;int rightInorderBegin = delimiterIndex + 1;int rightInorderEnd = inorderEnd;int leftPostorderBegin =  postorderBegin;int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin;int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);int rightPostorderEnd = postorderEnd - 1;root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);return root;}public: TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {if (inorder.size() == 0 || postorder.size() == 0) return NULL;return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());}};",
          "description": "优化后的版本，使用下标索引避免重复定义数组，从而减少时间和空间开销"
        },
        {
          "language": "java",
          "code": "class Solution {Map<Integer, Integer> map; public TreeNode buildTree(int[] inorder, int[] postorder) {map = new HashMap<>();for (int i = 0; i < inorder.length; i++) {map.put(inorder[i], i);}return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);}public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {if (inBegin >= inEnd || postBegin >= postEnd) {return null;}int rootIndex = map.get(postorder[postEnd - 1]);TreeNode root = new TreeNode(inorder[rootIndex]);int lenOfLeft = rootIndex - inBegin;root.left = findNode(inorder, inBegin, rootIndex, postorder, postBegin, postBegin + lenOfLeft);root.right = findNode(inorder, rootIndex + 1, inEnd, postorder, postBegin + lenOfLeft, postEnd - 1);return root;}}",
          "description": "Java版本的解法，利用HashMap来快速查找中间节点的位置"
        },
        {
          "language": "python",
          "code": "class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode: if not postorder: return None root_val = postorder[-1] root = TreeNode(root_val) separator_idx = inorder.index(root_val) inorder_left = inorder[:separator_idx] inorder_right = inorder[separator_idx + 1:] postorder_left = postorder[:len(inorder_left)] postorder_right = postorder[len(inorder_left): len(postorder) - 1] root.left = self.buildTree(inorder_left, postorder_left) root.right = self.buildTree(inorder_right, postorder_right) return root",
          "description": "Python版本的解法，递归地构建二叉树"
        }
      ],
      "subsections": []
    },
    {
      "name": "相关题目推荐",
      "text": "#105.从前序与中序遍历序列构造二叉树",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution { private: TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) { if (postorder.size() == 0) return NULL; int rootValue = postorder[postorder.size() - 1]; TreeNode* root = new TreeNode(rootValue); if (postorder.size() == 1) return root; int delimiterIndex; for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) { if (inorder[delimiterIndex] == rootValue) break; } vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex); vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end()); postorder.resize(postorder.size() - 1); vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size()); vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end()); root->left = traversal(leftInorder, leftPostorder); root->right = traversal(rightInorder, rightPostorder); return root; } public: TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) { if (inorder.size() == 0 || postorder.size() == 0) return NULL; return traversal(inorder, postorder); } };",
          "description": "根据中序与后序遍历序列构造二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution { private: TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) { if (postorderBegin == postorderEnd) return NULL; int rootValue = postorder[postorderEnd - 1]; TreeNode* root = new TreeNode(rootValue); if (postorderEnd - postorderBegin == 1) return root; int delimiterIndex; for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) { if (inorder[delimiterIndex] == rootValue) break; } int leftInorderBegin = inorderBegin; int leftInorderEnd = delimiterIndex; int rightInorderBegin = delimiterIndex + 1; int rightInorderEnd = inorderEnd; int leftPostorderBegin = postorderBegin; int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin); int rightPostorderEnd = postorderEnd - 1; root->left = traversal(inorder, leftInorderBegin, leftInorderEnd, postorder, leftPostorderBegin, leftPostorderEnd); root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd); return root; } public: TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) { if (inorder.size() == 0 || postorder.size() == 0) return NULL; return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size()); } };",
          "description": "使用索引优化的根据中序与后序遍历序列构造二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution { private: TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& preorder, int preorderBegin, int preorderEnd) { if (preorderBegin == preorderEnd) return NULL; int rootValue = preorder[preorderBegin]; TreeNode* root = new TreeNode(rootValue); if (preorderEnd - preorderBegin == 1) return root; int delimiterIndex; for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) { if (inorder[delimiterIndex] == rootValue) break; } int leftInorderBegin = inorderBegin; int leftInorderEnd = delimiterIndex; int rightInorderBegin = delimiterIndex + 1; int rightInorderEnd = inorderEnd; int leftPreorderBegin = preorderBegin + 1; int leftPreorderEnd = preorderBegin + 1 + delimiterIndex - inorderBegin; int rightPreorderBegin = preorderBegin + 1 + (delimiterIndex - inorderBegin); int rightPreorderEnd = preorderEnd; root->left = traversal(inorder, leftInorderBegin, leftInorderEnd, preorder, leftPreorderBegin, leftPreorderEnd); root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd); return root; } public: TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) { if (inorder.size() == 0 || preorder.size() == 0) return NULL; return traversal(inorder, 0, inorder.size(), preorder, 0, preorder.size()); } };",
          "description": "根据前序与中序遍历序列构造二叉树"
        },
        {
          "language": "java",
          "code": "class Solution { Map<Integer, Integer> map; public TreeNode buildTree(int[] inorder, int[] postorder) { map = new HashMap<>(); for (int i = 0; i < inorder.length; i++) { map.put(inorder[i], i); } return findNode(inorder, 0, inorder.length, postorder, 0, postorder.length); } public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) { if (inBegin >= inEnd || postBegin >= postEnd) { return null; } int rootIndex = map.get(postorder[postEnd - 1]); TreeNode root = new TreeNode(inorder[rootIndex]); int lenOfLeft = rootIndex - inBegin; root.left = findNode(inorder, inBegin, rootIndex, postorder, postBegin, postBegin + lenOfLeft); root.right = findNode(inorder, rootIndex + 1, inEnd, postorder, postBegin + lenOfLeft, postEnd - 1); return root; } }",
          "description": "Java版本，根据中序与后序遍历序列构造二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode: if not preorder: return None root_val = preorder[0] root = TreeNode(root_val) separator_idx = inorder.index(root_val) inorder_left = inorder[:separator_idx] inorder_right = inorder[separator_idx + 1:] preorder_left = preorder[1:1 + len(inorder_left)] preorder_right = preorder[1 + len(inorder_left):] root.left = self.buildTree(preorder_left, inorder_left) root.right = self.buildTree(preorder_right, inorder_right) return root",
          "description": "Python版本，根据前序与中序遍历序列构造二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode: if not postorder: return None root_val = postorder[-1] root = TreeNode(root_val) separator_idx = inorder.index(root_val) inorder_left = inorder[:separator_idx] inorder_right = inorder[separator_idx + 1:] postorder_left = postorder[:len(inorder_left)] postorder_right = postorder[len(inorder_left): len(postorder) - 1] root.left = self.buildTree(inorder_left, postorder_left) root.right = self.buildTree(inorder_right, postorder_right) return root",
          "description": "Python版本，根据中序与后序遍历序列构造二叉树"
        }
      ],
      "subsections": []
    },
    {
      "name": "105.从前序与中序遍历序列构造二叉树",
      "text": "力扣题目链接(https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {\n        if (postorder.size() == 0) return NULL;\n\n        int rootValue = postorder[postorder.size() - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (postorder.size() == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n\n        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);\n        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end());\n\n        postorder.resize(postorder.size() - 1);\n\n        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());\n        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());\n\n        root->left = traversal(leftInorder, leftPostorder);\n        root->right = traversal(rightInorder, rightPostorder);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        return traversal(inorder, postorder);\n    }\n};",
          "description": "构造二叉树（中序与后序遍历）"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {\n        if (postorderBegin == postorderEnd) return NULL;\n\n        int rootValue = postorder[postorderEnd - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (postorderEnd - postorderBegin == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n\n        int leftInorderBegin = inorderBegin;\n        int leftInorderEnd = delimiterIndex;\n        int rightInorderBegin = delimiterIndex + 1;\n        int rightInorderEnd = inorderEnd;\n\n        int leftPostorderBegin = postorderBegin;\n        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin;\n        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);\n        int rightPostorderEnd = postorderEnd - 1;\n\n        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd, postorder, leftPostorderBegin, leftPostorderEnd);\n        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());\n    }\n};",
          "description": "构造二叉树（中序与后序遍历，使用索引）"
        },
        {
          "language": "java",
          "code": "class Solution {\n    Map<Integer, Integer> map;  // 方便根据数值查找位置\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        map = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) { // 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        }\n\n        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  // 前闭后开\n    }\n\n    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {\n        if (inBegin >= inEnd || postBegin >= postEnd) {  // 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        }\n        int rootIndex = map.get(postorder[postEnd - 1]);  // 找到后序遍历的最后一个元素在中序遍历中的位置\n        TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点\n        int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数\n        root.left = findNode(inorder, inBegin, rootIndex, postorder, postBegin, postBegin + lenOfLeft);\n        root.right = findNode(inorder, rootIndex + 1, inEnd, postorder, postBegin + lenOfLeft, postEnd - 1);\n\n        return root;\n    }\n}",
          "description": "构造二叉树（中序与后序遍历，Java版本）"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        if not postorder:\n            return None\n\n        root_val = postorder[-1]\n        root = TreeNode(root_val)\n\n        separator_idx = inorder.index(root_val)\n\n        inorder_left = inorder[:separator_idx]\n        inorder_right = inorder[separator_idx + 1:]\n\n        postorder_left = postorder[:len(inorder_left)]\n        postorder_right = postorder[len(inorder_left): len(postorder) - 1]\n\n        root.left = self.buildTree(inorder_left, postorder_left)\n        root.right = self.buildTree(inorder_right, postorder_right)\n\n        return root",
          "description": "构造二叉树（中序与后序遍历，Python版本）"
        }
      ],
      "subsections": []
    },
    {
      "name": "思路",
      "text": "首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private:    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {        if (postorder.size() == 0) return NULL;        int rootValue = postorder[postorder.size() - 1];        TreeNode* root = new TreeNode(rootValue);        if (postorder.size() == 1) return root;        int delimiterIndex;        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {            if (inorder[delimiterIndex] == rootValue) break;        }        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end());        postorder.resize(postorder.size() - 1);        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());        root->left = traversal(leftInorder, leftPostorder);        root->right = traversal(rightInorder, rightPostorder);        return root;    }public:    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {        if (inorder.size() == 0 || postorder.size() == 0) return NULL;        return traversal(inorder, postorder);    }};",
          "description": "C++实现：根据中序与后序遍历序列构造二叉树"
        },
        {
          "language": "java",
          "code": "class Solution {    Map<Integer, Integer> map;    public TreeNode buildTree(int[] inorder, int[] postorder) {        map = new HashMap<>();        for (int i = 0; i < inorder.length; i++) {            map.put(inorder[i], i);        }        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);    }    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {        if (inBegin >= inEnd || postBegin >= postEnd) {            return null;        }        int rootIndex = map.get(postorder[postEnd - 1]);        TreeNode root = new TreeNode(inorder[rootIndex]);        int lenOfLeft = rootIndex - inBegin;        root.left = findNode(inorder, inBegin, rootIndex, postorder, postBegin, postBegin + lenOfLeft);        root.right = findNode(inorder, rootIndex + 1, inEnd, postorder, postBegin + lenOfLeft, postEnd - 1);        return root;    }}",
          "description": "Java实现：根据中序与后序遍历序列构造二叉树"
        },
        {
          "language": "python",
          "code": "class Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:        if not postorder:            return None        root_val = postorder[-1]        root = TreeNode(root_val)        separator_idx = inorder.index(root_val)        inorder_left = inorder[:separator_idx]        inorder_right = inorder[separator_idx + 1:]        postorder_left = postorder[:len(inorder_left)]        postorder_right = postorder[len(inorder_left): len(postorder) - 1]        root.left = self.buildTree(inorder_left, postorder_left)        root.right = self.buildTree(inorder_right, postorder_right)        return root",
          "description": "Python实现：根据中序与后序遍历序列构造二叉树"
        }
      ],
      "subsections": []
    },
    {
      "name": "思考题",
      "text": "前序和中序可以唯一确定一棵二叉树。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {\n        if (postorder.size() == 0) return NULL;\n\n        int rootValue = postorder[postorder.size() - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (postorder.size() == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n\n        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);\n        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );\n\n        postorder.resize(postorder.size() - 1);\n\n        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());\n        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());\n\n        root->left = traversal(leftInorder, leftPostorder);\n        root->right = traversal(rightInorder, rightPostorder);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        return traversal(inorder, postorder);\n    }\n};",
          "description": "使用C++实现的根据中序与后序遍历序列构造二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {\n        if (postorderBegin == postorderEnd) return NULL;\n\n        int rootValue = postorder[postorderEnd - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (postorderEnd - postorderBegin == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n\n        int leftInorderBegin = inorderBegin;\n        int leftInorderEnd = delimiterIndex;\n        int rightInorderBegin = delimiterIndex + 1;\n        int rightInorderEnd = inorderEnd;\n\n        int leftPostorderBegin =  postorderBegin;\n        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin;\n        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);\n        int rightPostorderEnd = postorderEnd - 1;\n\n        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);\n        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());\n    }\n};",
          "description": "使用C++优化后的版本，通过索引而非复制数组来分割序列"
        },
        {
          "language": "java",
          "code": "class Solution {\n    Map<Integer, Integer> map;  \n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        map = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) { \n            map.put(inorder[i], i);\n        }\n\n        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  \n    }\n\n    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {\n        if (inBegin >= inEnd || postBegin >= postEnd) {  \n            return null;\n        }\n        int rootIndex = map.get(postorder[postEnd - 1]);  \n        TreeNode root = new TreeNode(inorder[rootIndex]);  \n        int lenOfLeft = rootIndex - inBegin;  \n        root.left = findNode(inorder, inBegin, rootIndex,\n                            postorder, postBegin, postBegin + lenOfLeft);\n        root.right = findNode(inorder, rootIndex + 1, inEnd,\n                            postorder, postBegin + lenOfLeft, postEnd - 1);\n\n        return root;\n    }\n}",
          "description": "使用Java实现的根据中序与后序遍历序列构造二叉树"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        if not postorder:\n            return None\n\n        root_val = postorder[-1]\n        root = TreeNode(root_val)\n\n        separator_idx = inorder.index(root_val)\n\n        inorder_left = inorder[:separator_idx]\n        inorder_right = inorder[separator_idx + 1:]\n\n        postorder_left = postorder[:len(inorder_left)]\n        postorder_right = postorder[len(inorder_left): len(postorder) - 1]\n\n        root.left = self.buildTree(inorder_left, postorder_left)\n        root.right = self.buildTree(inorder_right, postorder_right)\n\n        return root",
          "description": "使用Python实现的根据中序与后序遍历序列构造二叉树"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "之前我们讲的二叉树题目都是各种遍历二叉树，这次开始构造二叉树了，思路其实比较简单，但是真正代码实现出来并不容易。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {\n        if (postorder.size() == 0) return NULL;\n\n        int rootValue = postorder[postorder.size() - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (postorder.size() == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n\n        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);\n        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );\n\n        postorder.resize(postorder.size() - 1);\n\n        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());\n        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());\n\n        root->left = traversal(leftInorder, leftPostorder);\n        root->right = traversal(rightInorder, rightPostorder);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        return traversal(inorder, postorder);\n    }\n};",
          "description": "C++实现的从中序与后序遍历序列构造二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {\n        if (postorderBegin == postorderEnd) return NULL;\n\n        int rootValue = postorder[postorderEnd - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (postorderEnd - postorderBegin == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n\n        int leftInorderBegin = inorderBegin;\n        int leftInorderEnd = delimiterIndex;\n        int rightInorderBegin = delimiterIndex + 1;\n        int rightInorderEnd = inorderEnd;\n\n        int leftPostorderBegin =  postorderBegin;\n        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin;\n        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);\n        int rightPostorderEnd = postorderEnd - 1;\n\n        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);\n        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());\n    }\n};",
          "description": "C++通过索引优化的从中序与后序遍历序列构造二叉树"
        },
        {
          "language": "java",
          "code": "class Solution {\n    Map<Integer, Integer> map;  \n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        map = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            map.put(inorder[i], i);\n        }\n\n        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  \n    }\n\n    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {\n        if (inBegin >= inEnd || postBegin >= postEnd) {  \n            return null;\n        }\n        int rootIndex = map.get(postorder[postEnd - 1]);  \n        TreeNode root = new TreeNode(inorder[rootIndex]);  \n        int lenOfLeft = rootIndex - inBegin;  \n        root.left = findNode(inorder, inBegin, rootIndex,\n                            postorder, postBegin, postBegin + lenOfLeft);\n        root.right = findNode(inorder, rootIndex + 1, inEnd,\n                            postorder, postBegin + lenOfLeft, postEnd - 1);\n\n        return root;\n    }\n}",
          "description": "Java实现的从中序与后序遍历序列构造二叉树"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        if not postorder:\n            return None\n\n        root_val = postorder[-1]\n        root = TreeNode(root_val)\n\n        separator_idx = inorder.index(root_val)\n\n        inorder_left = inorder[:separator_idx]\n        inorder_right = inorder[separator_idx + 1:]\n\n        postorder_left = postorder[:len(inorder_left)]\n        postorder_right = postorder[len(inorder_left): len(postorder) - 1]\n\n        root.left = self.buildTree(inorder_left, postorder_left)\n        root.right = self.buildTree(inorder_right, postorder_right)\n\n        return root",
          "description": "Python实现的从中序与后序遍历序列构造二叉树"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {private:    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {        if (postorder.size() == 0) return NULL;        int rootValue = postorder[postorder.size() - 1];        TreeNode* root = new TreeNode(rootValue);        if (postorder.size() == 1) return root;        int delimiterIndex;        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {            if (inorder[delimiterIndex] == rootValue) break;        }        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end());        postorder.resize(postorder.size() - 1);        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());        root->left = traversal(leftInorder, leftPostorder);        root->right = traversal(rightInorder, rightPostorder);        return root;    }public:    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {        if (inorder.size() == 0 || postorder.size() == 0) return NULL;        return traversal(inorder, postorder);    }};",
          "description": "根据中序与后序遍历序列构造二叉树的C++实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {private:    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {        if (postorderBegin == postorderEnd) return NULL;        int rootValue = postorder[postorderEnd - 1];        TreeNode* root = new TreeNode(rootValue);        if (postorderEnd - postorderBegin == 1) return root;        int delimiterIndex;        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {            if (inorder[delimiterIndex] == rootValue) break;        }        int leftInorderBegin = inorderBegin;        int leftInorderEnd = delimiterIndex;        int rightInorderBegin = delimiterIndex + 1;        int rightInorderEnd = inorderEnd;        int leftPostorderBegin =  postorderBegin;        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin;        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);        int rightPostorderEnd = postorderEnd - 1;        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);        return root;    }public:    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {        if (inorder.size() == 0 || postorder.size() == 0) return NULL;        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());    }};",
          "description": "根据中序与后序遍历序列构造二叉树的C++优化版本"
        },
        {
          "language": "java",
          "code": "class Solution {    Map<Integer, Integer> map;    public TreeNode buildTree(int[] inorder, int[] postorder) {        map = new HashMap<>();        for (int i = 0; i < inorder.length; i++) {            map.put(inorder[i], i);        }        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);    }    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {        if (inBegin >= inEnd || postBegin >= postEnd) {            return null;        }        int rootIndex = map.get(postorder[postEnd - 1]);        TreeNode root = new TreeNode(inorder[rootIndex]);        int lenOfLeft = rootIndex - inBegin;        root.left = findNode(inorder, inBegin, rootIndex, postorder, postBegin, postBegin + lenOfLeft);        root.right = findNode(inorder, rootIndex + 1, inEnd, postorder, postBegin + lenOfLeft, postEnd - 1);        return root;    }}",
          "description": "根据中序与后序遍历序列构造二叉树的Java实现"
        },
        {
          "language": "java",
          "code": "class Solution {    public TreeNode buildTree(int[] inorder, int[] postorder) {        if(postorder.length == 0 || inorder.length == 0)            return null;        return buildHelper(inorder, 0, inorder.length, postorder, 0, postorder.length);    }    private TreeNode buildHelper(int[] inorder, int inorderStart, int inorderEnd, int[] postorder, int postorderStart, int postorderEnd){        if(postorderStart == postorderEnd)            return null;        int rootVal = postorder[postorderEnd - 1];        TreeNode root = new TreeNode(rootVal);        int middleIndex;        for (middleIndex = inorderStart; middleIndex < inorderEnd; middleIndex++){            if(inorder[middleIndex] == rootVal)                break;        }        int leftInorderStart = inorderStart;        int leftInorderEnd = middleIndex;        int rightInorderStart = middleIndex + 1;        int rightInorderEnd = inorderEnd;        int leftPostorderStart = postorderStart;        int leftPostorderEnd = postorderStart + (middleIndex - inorderStart);        int rightPostorderStart = leftPostorderEnd;        int rightPostorderEnd = postorderEnd - 1;        root.left = buildHelper(inorder, leftInorderStart, leftInorderEnd,  postorder, leftPostorderStart, leftPostorderEnd);        root.right = buildHelper(inorder, rightInorderStart, rightInorderEnd, postorder, rightPostorderStart, rightPostorderEnd);        return root;    }}",
          "description": "根据中序与后序遍历序列构造二叉树的另一种Java实现"
        },
        {
          "language": "java",
          "code": "class Solution {    Map<Integer, Integer> map;    public TreeNode buildTree(int[] preorder, int[] inorder) {        map = new HashMap<>();        for (int i = 0; i < inorder.length; i++) {            map.put(inorder[i], i);        }        return findNode(preorder, 0, preorder.length, inorder,  0, inorder.length);    }    public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) {        if (preBegin >= preEnd || inBegin >= inEnd) {            return null;        }        int rootIndex = map.get(preorder[preBegin]);        TreeNode root = new TreeNode(inorder[rootIndex]);        int lenOfLeft = rootIndex - inBegin;        root.left = findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1, inorder, inBegin, rootIndex);        root.right = findNode(preorder, preBegin + lenOfLeft + 1, preEnd, inorder, rootIndex + 1, inEnd);        return root;    }}",
          "description": "根据前序与中序遍历序列构造二叉树的Java实现"
        },
        {
          "language": "python",
          "code": "class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:        if not preorder:            return None        root_val = preorder[0]        root = TreeNode(root_val)        separator_idx = inorder.index(root_val)        inorder_left = inorder[:separator_idx]        inorder_right = inorder[separator_idx + 1:]        preorder_left = preorder[1:1 + len(inorder_left)]        preorder_right = preorder[1 + len(inorder_left):]        root.left = self.buildTree(preorder_left, inorder_left)        root.right = self.buildTree(preorder_right, inorder_right)        return root",
          "description": "根据前序与中序遍历序列构造二叉树的Python实现"
        },
        {
          "language": "python",
          "code": "class Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:        if not postorder:            return None        root_val = postorder[-1]        root = TreeNode(root_val)        separator_idx = inorder.index(root_val)        inorder_left = inorder[:separator_idx]        inorder_right = inorder[separator_idx + 1:]        postorder_left = postorder[:len(inorder_left)]        postorder_right = postorder[len(inorder_left): len(postorder) - 1]        root.left = self.buildTree(inorder_left, postorder_left)        root.right = self.buildTree(inorder_right, postorder_right)        return root",
          "description": "根据中序与后序遍历序列构造二叉树的Python实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "106.从中序与后序遍历序列构造二叉树",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {\n        if (postorder.size() == 0) return NULL;\n\n        int rootValue = postorder[postorder.size() - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (postorder.size() == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n\n        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);\n        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );\n\n        postorder.resize(postorder.size() - 1);\n\n        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());\n        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());\n\n        root->left = traversal(leftInorder, leftPostorder);\n        root->right = traversal(rightInorder, rightPostorder);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        return traversal(inorder, postorder);\n    }\n};",
          "description": "从后序和中序遍历序列构造二叉树"
        },
        {
          "language": "java",
          "code": "class Solution {\n    Map<Integer, Integer> map;  // 方便根据数值查找位置\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        map = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) { // 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        }\n\n        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  // 前闭后开\n    }\n\n    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {\n        if (inBegin >= inEnd || postBegin >= postEnd) {  // 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        }\n        int rootIndex = map.get(postorder[postEnd - 1]);  // 找到后序遍历的最后一个元素在中序遍历中的位置\n        TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点\n        int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数\n        root.left = findNode(inorder, inBegin, rootIndex,\n                            postorder, postBegin, postBegin + lenOfLeft);\n        root.right = findNode(inorder, rootIndex + 1, inEnd,\n                             postorder, postBegin + lenOfLeft, postEnd - 1);\n\n        return root;\n    }\n}",
          "description": "从后序和中序遍历序列构造二叉树"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        if not postorder:\n            return None\n\n        root_val = postorder[-1]\n        root = TreeNode(root_val)\n\n        separator_idx = inorder.index(root_val)\n\n        inorder_left = inorder[:separator_idx]\n        inorder_right = inorder[separator_idx + 1:]\n\n        postorder_left = postorder[:len(inorder_left)]\n        postorder_right = postorder[len(inorder_left): len(postorder) - 1]\n\n        root.left = self.buildTree(inorder_left, postorder_left)\n        root.right = self.buildTree(inorder_right, postorder_right)\n\n        return root",
          "description": "从后序和中序遍历序列构造二叉树"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "105.从前序与中序遍历序列构造二叉树",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {\n        if (postorder.size() == 0) return NULL;\n\n        int rootValue = postorder[postorder.size() - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (postorder.size() == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n\n        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);\n        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end());\n\n        postorder.resize(postorder.size() - 1);\n\n        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());\n        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());\n\n        root->left = traversal(leftInorder, leftPostorder);\n        root->right = traversal(rightInorder, rightPostorder);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        return traversal(inorder, postorder);\n    }\n};",
          "description": "从后序与中序遍历序列构造二叉树的C++实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {\n        if (postorderBegin == postorderEnd) return NULL;\n\n        int rootValue = postorder[postorderEnd - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (postorderEnd - postorderBegin == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n\n        int leftInorderBegin = inorderBegin;\n        int leftInorderEnd = delimiterIndex;\n        int rightInorderBegin = delimiterIndex + 1;\n        int rightInorderEnd = inorderEnd;\n\n        int leftPostorderBegin =  postorderBegin;\n        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin;\n        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);\n        int rightPostorderEnd = postorderEnd - 1;\n\n        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);\n        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());\n    }\n};",
          "description": "通过下标索引优化的从后序与中序遍历序列构造二叉树的C++实现"
        },
        {
          "language": "java",
          "code": "class Solution {\n    Map<Integer, Integer> map;  \n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        map = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            map.put(inorder[i], i);\n        }\n\n        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  \n    }\n\n    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {\n        if (inBegin >= inEnd || postBegin >= postEnd) {  \n            return null;\n        }\n        int rootIndex = map.get(postorder[postEnd - 1]);  \n        TreeNode root = new TreeNode(inorder[rootIndex]);  \n        int lenOfLeft = rootIndex - inBegin;  \n        root.left = findNode(inorder, inBegin, rootIndex,\n                            postorder, postBegin, postBegin + lenOfLeft);\n        root.right = findNode(inorder, rootIndex + 1, inEnd,\n                            postorder, postBegin + lenOfLeft, postEnd - 1);\n\n        return root;\n    }\n}",
          "description": "使用哈希表辅助的从后序与中序遍历序列构造二叉树的Java实现"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\n        if not preorder:\n            return None\n\n        root_val = preorder[0]\n        root = TreeNode(root_val)\n\n        separator_idx = inorder.index(root_val)\n\n        inorder_left = inorder[:separator_idx]\n        inorder_right = inorder[separator_idx + 1:]\n\n        preorder_left = preorder[1:1 + len(inorder_left)]\n        preorder_right = preorder[1 + len(inorder_left):]\n\n        root.left = self.buildTree(preorder_left, inorder_left)\n        root.right = self.buildTree(preorder_right, inorder_right)\n\n        return root",
          "description": "从前序与中序遍历序列构造二叉树的Python实现"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        if not postorder:\n            return None\n\n        root_val = postorder[-1]\n        root = TreeNode(root_val)\n\n        separator_idx = inorder.index(root_val)\n\n        inorder_left = inorder[:separator_idx]\n        inorder_right = inorder[separator_idx + 1:]\n\n        postorder_left = postorder[:len(inorder_left)]\n        postorder_right = postorder[len(inorder_left): len(postorder) - 1]\n\n        root.left = self.buildTree(inorder_left, postorder_left)\n        root.right = self.buildTree(inorder_right, postorder_right)\n\n        return root",
          "description": "从后序与中序遍历序列构造二叉树的Python实现"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {private: TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) { if (postorder.size() == 0) return NULL; int rootValue = postorder[postorder.size() - 1]; TreeNode* root = new TreeNode(rootValue); if (postorder.size() == 1) return root; int delimiterIndex; for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) { if (inorder[delimiterIndex] == rootValue) break; } vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex); vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end()); postorder.resize(postorder.size() - 1); vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size()); vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end()); root->left = traversal(leftInorder, leftPostorder); root->right = traversal(rightInorder, rightPostorder); return root; }public: TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) { if (inorder.size() == 0 || postorder.size() == 0) return NULL; return traversal(inorder, postorder); }};",
      "description": "根据中序和后序遍历序列构造二叉树"
    },
    {
      "language": "java",
      "code": "class Solution { Map<Integer, Integer> map; public TreeNode buildTree(int[] inorder, int[] postorder) { map = new HashMap<>(); for (int i = 0; i < inorder.length; i++) { map.put(inorder[i], i); } return findNode(inorder, 0, inorder.length, postorder,0, postorder.length); } public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) { if (inBegin >= inEnd || postBegin >= postEnd) { return null; } int rootIndex = map.get(postorder[postEnd - 1]); TreeNode root = new TreeNode(inorder[rootIndex]); int lenOfLeft = rootIndex - inBegin; root.left = findNode(inorder, inBegin, rootIndex, postorder, postBegin, postBegin + lenOfLeft); root.right = findNode(inorder, rootIndex + 1, inEnd, postorder, postBegin + lenOfLeft, postEnd - 1); return root; }};",
      "description": "根据中序和后序遍历序列构造二叉树"
    },
    {
      "language": "python",
      "code": "class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode: if not postorder: return None root_val = postorder[-1] root = TreeNode(root_val) separator_idx = inorder.index(root_val) inorder_left = inorder[:separator_idx] inorder_right = inorder[separator_idx + 1:] postorder_left = postorder[:len(inorder_left)] postorder_right = postorder[len(inorder_left): len(postorder) - 1] root.left = self.buildTree(inorder_left, postorder_left) root.right = self.buildTree(inorder_right, postorder_right) return root;",
      "description": "根据中序和后序遍历序列构造二叉树"
    }
  ],
  "common_mistakes": [
    "未考虑空树或单节点树的情况。",
    "混淆了中序与后序数组的切割顺序，应该先根据后序确定根再切分中序。",
    "忽略了维护一致的切割区间定义，导致递归调用时参数错误。",
    "忘记了从后序列表中移除已经使用的根节点值，影响后续正确的数组分割。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210203154316774.png",
      "description": "这是一棵二叉树的示意图，根节点为3，左子节点为9，右子节点为20（其左子节点为15，右子节点为7）。",
      "context": "该图片展示了根据给定的中序遍历 [9,3,15,20,7] 和后序遍历 [9,15,7,20,3] 构造出的具体二叉树结构。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210203154249860.png",
      "description": "这张图片展示了通过中序和后序遍历序列构建二叉树的过程，红框标记当前节点，蓝线指示分割区间。",
      "context": "该图片展示了根据中序和后序遍历序列重建二叉树的具体步骤流程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210203154626672.png",
      "description": "这是一棵二叉树的示意图，根节点为3，左子节点为9，右子节点为20（其左子节点为15，右子节点为7）。",
      "context": "该图片展示了根据给定的前序遍历 [3,9,20,15,7] 和中序遍历 [9,3,15,20,7] 构造出的具体二叉树结构。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210203154720326.png",
      "description": "这张图片展示了两棵结构相同的二叉树（tree1 和 tree2），每个节点的值分别为 1、2、3，可用于比较或操作二叉树的算法分析。",
      "context": "该图片展示了两棵具有相同前序和后序遍历结果但结构不同的二叉树，用以说明仅凭前序和后序遍历无法唯一确定一棵二叉树。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210203154316774.png",
      "description": "GIF展示了根据中序和后序遍历序列递归构建二叉树的过程。",
      "context": "GIF动画展示了根据中序和后序遍历序列构建二叉树的具体步骤。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210203154249860.png",
      "description": "GIF展示了根据中序和后序遍历数组重建二叉树的过程。",
      "context": "该GIF动画展示了如何根据给定的中序和后序遍历序列递归地构建唯一二叉树的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\二叉树\\从中序与后序遍历序列构造二叉树.txt",
  "extracted_at": "2025-07-19T18:28:41.225273",
  "raw_content": "从中序与后序遍历序列构造二叉树\n力扣题目链接(https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n根据一棵树的中序遍历与后序遍历构造二叉树。\n\n注意: 你可以假设树中没有重复的元素。\n\n例如，给出\n\n中序遍历 inorder = [9,3,15,20,7]\n后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：\n\nhttps://file1.kamacoder.com/i/algo/20210203154316774.png\n\n\n#思路\n首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。\n\n如果让我们肉眼看两个序列，画一棵二叉树的话，应该分分钟都可以画出来。\n\n流程如图：\n\nhttps://file1.kamacoder.com/i/algo/20210203154249860.png\n那么代码应该怎么写呢？\n\n说到一层一层切割，就应该想到了递归。\n\n来看一下一共分几步：\n\n第一步：如果数组大小为零的话，说明是空节点了。\n\n第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。\n\n第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点\n\n第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）\n\n第五步：切割后序数组，切成后序左数组和后序右数组\n\n第六步：递归处理左区间和右区间\n\n不难写出如下代码：（先把框架写出来）\n\nTreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {\n\n    // 第一步\n    if (postorder.size() == 0) return NULL;\n\n    // 第二步：后序遍历数组最后一个元素，就是当前的中间节点\n    int rootValue = postorder[postorder.size() - 1];\n    TreeNode* root = new TreeNode(rootValue);\n\n    // 叶子节点\n    if (postorder.size() == 1) return root;\n\n    // 第三步：找切割点\n    int delimiterIndex;\n    for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {\n        if (inorder[delimiterIndex] == rootValue) break;\n    }\n\n    // 第四步：切割中序数组，得到 中序左数组和中序右数组\n    // 第五步：切割后序数组，得到 后序左数组和后序右数组\n\n    // 第六步\n    root->left = traversal(中序左数组, 后序左数组);\n    root->right = traversal(中序右数组, 后序右数组);\n\n    return root;\n}\n难点大家应该发现了，就是如何切割，以及边界值找不好很容易乱套。\n\n此时应该注意确定切割的标准，是左闭右开，还有左开右闭，还是左闭右闭，这个就是不变量，要在递归中保持这个不变量。\n\n在切割的过程中会产生四个区间，把握不好不变量的话，一会左闭右开，一会左闭右闭，必然乱套！\n\n我在数组：每次遇到二分法，都是一看就会，一写就废 (https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html)和数组：这个循环可以转懵很多人！ (https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html)中都强调过循环不变量的重要性，在二分查找以及螺旋矩阵的求解中，坚持循环不变量非常重要，本题也是。\n\n首先要切割中序数组，为什么先切割中序数组呢？\n\n切割点在后序数组的最后一个元素，就是用这个元素来切割中序数组的，所以必要先切割中序数组。\n\n中序数组相对比较好切，找到切割点（后序数组的最后一个元素）在中序数组的位置，然后切割，如下代码中我坚持左闭右开的原则：\n\n// 找到中序遍历的切割点\nint delimiterIndex;\nfor (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {\n    if (inorder[delimiterIndex] == rootValue) break;\n}\n\n// 左闭右开区间：[0, delimiterIndex)\nvector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);\n// [delimiterIndex + 1, end)\nvector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );\n接下来就要切割后序数组了。\n\n首先后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。\n\n后序数组的切割点怎么找？\n\n后序数组没有明确的切割元素来进行左右切割，不像中序数组有明确的切割点，切割点左右分开就可以了。\n\n此时有一个很重的点，就是中序数组大小一定是和后序数组的大小相同的（这是必然）。\n\n中序数组我们都切成了左中序数组和右中序数组了，那么后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组。\n\n代码如下：\n\n// postorder 舍弃末尾元素，因为这个元素就是中间节点，已经用过了\npostorder.resize(postorder.size() - 1);\n\n// 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)\nvector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());\n// [leftInorder.size(), end)\nvector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());\n此时，中序数组切成了左中序数组和右中序数组，后序数组切割成左后序数组和右后序数组。\n\n接下来可以递归了，代码如下：\n\nroot->left = traversal(leftInorder, leftPostorder);\nroot->right = traversal(rightInorder, rightPostorder);\n完整代码如下：\n\nclass Solution {\nprivate:\n    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {\n        if (postorder.size() == 0) return NULL;\n\n        // 后序遍历数组最后一个元素，就是当前的中间节点\n        int rootValue = postorder[postorder.size() - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        // 叶子节点\n        if (postorder.size() == 1) return root;\n\n        // 找到中序遍历的切割点\n        int delimiterIndex;\n        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n\n        // 切割中序数组\n        // 左闭右开区间：[0, delimiterIndex)\n        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);\n        // [delimiterIndex + 1, end)\n        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );\n\n        // postorder 舍弃末尾元素\n        postorder.resize(postorder.size() - 1);\n\n        // 切割后序数组\n        // 依然左闭右开，注意这里使用了左中序数组大小作为切割点\n        // [0, leftInorder.size)\n        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());\n        // [leftInorder.size(), end)\n        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());\n\n        root->left = traversal(leftInorder, leftPostorder);\n        root->right = traversal(rightInorder, rightPostorder);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        return traversal(inorder, postorder);\n    }\n};\n\n相信大家自己就算是思路清晰， 代码写出来一定是各种问题，所以一定要加日志来调试，看看是不是按照自己思路来切割的，不要大脑模拟，那样越想越糊涂。\n\n加了日志的代码如下：（加了日志的代码不要在leetcode上提交，容易超时）\n\nclass Solution {\nprivate:\n    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {\n        if (postorder.size() == 0) return NULL;\n\n        int rootValue = postorder[postorder.size() - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (postorder.size() == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n\n        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);\n        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );\n\n        postorder.resize(postorder.size() - 1);\n\n        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());\n        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());\n\n        // 以下为日志\n        cout << \"----------\" << endl;\n\n        cout << \"leftInorder :\";\n        for (int i : leftInorder) {\n            cout << i << \" \";\n        }\n        cout << endl;\n\n        cout << \"rightInorder :\";\n        for (int i : rightInorder) {\n            cout << i << \" \";\n        }\n        cout << endl;\n\n        cout << \"leftPostorder :\";\n        for (int i : leftPostorder) {\n            cout << i << \" \";\n        }\n        cout << endl;\n         cout << \"rightPostorder :\";\n        for (int i : rightPostorder) {\n            cout << i << \" \";\n        }\n        cout << endl;\n\n        root->left = traversal(leftInorder, leftPostorder);\n        root->right = traversal(rightInorder, rightPostorder);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        return traversal(inorder, postorder);\n    }\n};\n此时应该发现了，如上的代码性能并不好，因为每层递归定义了新的vector（就是数组），既耗时又耗空间，但上面的代码是最好理解的，为了方便读者理解，所以用如上的代码来讲解。\n\n下面给出用下标索引写出的代码版本：（思路是一样的，只不过不用重复定义vector了，每次用下标索引来分割）\n\nclass Solution {\nprivate:\n    // 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)\n    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {\n        if (postorderBegin == postorderEnd) return NULL;\n\n        int rootValue = postorder[postorderEnd - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (postorderEnd - postorderBegin == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n        // 切割中序数组\n        // 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)\n        int leftInorderBegin = inorderBegin;\n        int leftInorderEnd = delimiterIndex;\n        // 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)\n        int rightInorderBegin = delimiterIndex + 1;\n        int rightInorderEnd = inorderEnd;\n\n        // 切割后序数组\n        // 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)\n        int leftPostorderBegin =  postorderBegin;\n        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; // 终止位置是 需要加上 中序区间的大小size\n        // 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)\n        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);\n        int rightPostorderEnd = postorderEnd - 1; // 排除最后一个元素，已经作为节点了\n\n        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);\n        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        // 左闭右开的原则\n        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());\n    }\n};\n那么这个版本写出来依然要打日志进行调试，打日志的版本如下：（该版本不要在leetcode上提交，容易超时）\n\nclass Solution {\nprivate:\n    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd) {\n        if (postorderBegin == postorderEnd) return NULL;\n\n        int rootValue = postorder[postorderEnd - 1];\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (postorderEnd - postorderBegin == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n        // 切割中序数组\n        // 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)\n        int leftInorderBegin = inorderBegin;\n        int leftInorderEnd = delimiterIndex;\n        // 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)\n        int rightInorderBegin = delimiterIndex + 1;\n        int rightInorderEnd = inorderEnd;\n\n        // 切割后序数组\n        // 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)\n        int leftPostorderBegin =  postorderBegin;\n        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; // 终止位置是 需要加上 中序区间的大小size\n        // 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)\n        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);\n        int rightPostorderEnd = postorderEnd - 1; // 排除最后一个元素，已经作为节点了\n\n        cout << \"----------\" << endl;\n        cout << \"leftInorder :\";\n        for (int i = leftInorderBegin; i < leftInorderEnd; i++) {\n            cout << inorder[i] << \" \";\n        }\n        cout << endl;\n\n        cout << \"rightInorder :\";\n        for (int i = rightInorderBegin; i < rightInorderEnd; i++) {\n            cout << inorder[i] << \" \";\n        }\n        cout << endl;\n\n        cout << \"leftpostorder :\";\n        for (int i = leftPostorderBegin; i < leftPostorderEnd; i++) {\n            cout << postorder[i] << \" \";\n        }\n        cout << endl;\n\n        cout << \"rightpostorder :\";\n        for (int i = rightPostorderBegin; i < rightPostorderEnd; i++) {\n            cout << postorder[i] << \" \";\n        }\n        cout << endl;\n\n        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);\n        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);\n\n        return root;\n    }\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.size() == 0 || postorder.size() == 0) return NULL;\n        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());\n    }\n};\n#相关题目推荐\n#105.从前序与中序遍历序列构造二叉树\n力扣题目链接(https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n根据一棵树的前序遍历与中序遍历构造二叉树。\n\n注意: 你可以假设树中没有重复的元素。\n\n例如，给出\n\n前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：\n\n105. 从前序与中序遍历序列构造二叉树 https://file1.kamacoder.com/i/algo/20210203154626672.png\n\n#思路\n本题和106是一样的道理。\n\n我就直接给出代码了。\n\n带日志的版本C++代码如下： （带日志的版本仅用于调试，不要在leetcode上提交，会超时）\n\nclass Solution {\nprivate:\n        TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& preorder, int preorderBegin, int preorderEnd) {\n        if (preorderBegin == preorderEnd) return NULL;\n\n        int rootValue = preorder[preorderBegin]; // 注意用preorderBegin 不要用0\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (preorderEnd - preorderBegin == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n        // 切割中序数组\n        // 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)\n        int leftInorderBegin = inorderBegin;\n        int leftInorderEnd = delimiterIndex;\n        // 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)\n        int rightInorderBegin = delimiterIndex + 1;\n        int rightInorderEnd = inorderEnd;\n\n        // 切割前序数组\n        // 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)\n        int leftPreorderBegin =  preorderBegin + 1;\n        int leftPreorderEnd = preorderBegin + 1 + delimiterIndex - inorderBegin; // 终止位置是起始位置加上中序左区间的大小size\n        // 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)\n        int rightPreorderBegin = preorderBegin + 1 + (delimiterIndex - inorderBegin);\n        int rightPreorderEnd = preorderEnd;\n\n        cout << \"----------\" << endl;\n        cout << \"leftInorder :\";\n        for (int i = leftInorderBegin; i < leftInorderEnd; i++) {\n            cout << inorder[i] << \" \";\n        }\n        cout << endl;\n\n        cout << \"rightInorder :\";\n        for (int i = rightInorderBegin; i < rightInorderEnd; i++) {\n            cout << inorder[i] << \" \";\n        }\n        cout << endl;\n\n        cout << \"leftPreorder :\";\n        for (int i = leftPreorderBegin; i < leftPreorderEnd; i++) {\n            cout << preorder[i] << \" \";\n        }\n        cout << endl;\n\n        cout << \"rightPreorder :\";\n        for (int i = rightPreorderBegin; i < rightPreorderEnd; i++) {\n            cout << preorder[i] << \" \";\n        }\n        cout << endl;\n\n\n        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);\n        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);\n\n        return root;\n    }\n\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        if (inorder.size() == 0 || preorder.size() == 0) return NULL;\n        return traversal(inorder, 0, inorder.size(), preorder, 0, preorder.size());\n\n    }\n};\n105.从前序与中序遍历序列构造二叉树，最后版本，C++代码：\n\nclass Solution {\nprivate:\n        TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& preorder, int preorderBegin, int preorderEnd) {\n        if (preorderBegin == preorderEnd) return NULL;\n\n        int rootValue = preorder[preorderBegin]; // 注意用preorderBegin 不要用0\n        TreeNode* root = new TreeNode(rootValue);\n\n        if (preorderEnd - preorderBegin == 1) return root;\n\n        int delimiterIndex;\n        for (delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++) {\n            if (inorder[delimiterIndex] == rootValue) break;\n        }\n        // 切割中序数组\n        // 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)\n        int leftInorderBegin = inorderBegin;\n        int leftInorderEnd = delimiterIndex;\n        // 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)\n        int rightInorderBegin = delimiterIndex + 1;\n        int rightInorderEnd = inorderEnd;\n\n        // 切割前序数组\n        // 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)\n        int leftPreorderBegin =  preorderBegin + 1;\n        int leftPreorderEnd = preorderBegin + 1 + delimiterIndex - inorderBegin; // 终止位置是起始位置加上中序左区间的大小size\n        // 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)\n        int rightPreorderBegin = preorderBegin + 1 + (delimiterIndex - inorderBegin);\n        int rightPreorderEnd = preorderEnd;\n\n        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);\n        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);\n\n        return root;\n    }\n\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        if (inorder.size() == 0 || preorder.size() == 0) return NULL;\n\n        // 参数坚持左闭右开的原则\n        return traversal(inorder, 0, inorder.size(), preorder, 0, preorder.size());\n    }\n};\n#思考题\n前序和中序可以唯一确定一棵二叉树。\n\n后序和中序可以唯一确定一棵二叉树。\n\n那么前序和后序可不可以唯一确定一棵二叉树呢？\n\n前序和后序不能唯一确定一棵二叉树！，因为没有中序遍历无法确定左右部分，也就是无法分割。\n\n举一个例子：\n\n106.从中序与后序遍历序列构造二叉树2 https://file1.kamacoder.com/i/algo/20210203154720326.png\n\ntree1 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。\n\ntree2 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。\n\n那么tree1 和 tree2 的前序和后序完全相同，这是一棵树么，很明显是两棵树！\n\n所以前序和后序不能唯一确定一棵二叉树！\n\n#总结\n之前我们讲的二叉树题目都是各种遍历二叉树，这次开始构造二叉树了，思路其实比较简单，但是真正代码实现出来并不容易。\n\n所以要避免眼高手低，踏实地把代码写出来。\n\n我同时给出了添加日志的代码版本，因为这种题目是不太容易写出来调一调就能过的，所以一定要把流程日志打出来，看看符不符合自己的思路。\n\n大家遇到这种题目的时候，也要学会打日志来调试（如何打日志有时候也是个技术活），不要脑动模拟，脑动模拟很容易越想越乱。\n\n最后我还给出了为什么前序和中序可以唯一确定一棵二叉树，后序和中序可以唯一确定一棵二叉树，而前序和后序却不行。\n\n认真研究完本篇，相信大家对二叉树的构造会清晰很多。\n\n#其他语言版本\n#Java\n106.从中序与后序遍历序列构造二叉树\n\nclass Solution {\n    Map<Integer, Integer> map;  // 方便根据数值查找位置\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        map = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) { // 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        }\n\n        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  // 前闭后开\n    }\n\n    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {\n        // 参数里的范围都是前闭后开\n        if (inBegin >= inEnd || postBegin >= postEnd) {  // 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        }\n        int rootIndex = map.get(postorder[postEnd - 1]);  // 找到后序遍历的最后一个元素在中序遍历中的位置\n        TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点\n        int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数\n        root.left = findNode(inorder, inBegin, rootIndex,\n                            postorder, postBegin, postBegin + lenOfLeft);\n        root.right = findNode(inorder, rootIndex + 1, inEnd,\n                            postorder, postBegin + lenOfLeft, postEnd - 1);\n\n        return root;\n    }\n}\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        if(postorder.length == 0 || inorder.length == 0)\n            return null;\n        return buildHelper(inorder, 0, inorder.length, postorder, 0, postorder.length);\n    \n    }\n    private TreeNode buildHelper(int[] inorder, int inorderStart, int inorderEnd, int[] postorder, int postorderStart, int postorderEnd){\n        if(postorderStart == postorderEnd)\n            return null;\n        int rootVal = postorder[postorderEnd - 1];\n        TreeNode root = new TreeNode(rootVal);\n        int middleIndex;\n        for (middleIndex = inorderStart; middleIndex < inorderEnd; middleIndex++){\n            if(inorder[middleIndex] == rootVal)\n                break;\n        }\n\n        int leftInorderStart = inorderStart; \n        int leftInorderEnd = middleIndex;\n        int rightInorderStart = middleIndex + 1;\n        int rightInorderEnd = inorderEnd;\n\n\n        int leftPostorderStart = postorderStart;\n        int leftPostorderEnd = postorderStart + (middleIndex - inorderStart);\n        int rightPostorderStart = leftPostorderEnd;\n        int rightPostorderEnd = postorderEnd - 1;\n        root.left = buildHelper(inorder, leftInorderStart, leftInorderEnd,  postorder, leftPostorderStart, leftPostorderEnd);\n        root.right = buildHelper(inorder, rightInorderStart, rightInorderEnd, postorder, rightPostorderStart, rightPostorderEnd);\n\n        return root;\n    }  \n}\n105.从前序与中序遍历序列构造二叉树\n\nclass Solution {\n    Map<Integer, Integer> map;\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        map = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) { // 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        }\n\n        return findNode(preorder, 0, preorder.length, inorder,  0, inorder.length);  // 前闭后开\n    }\n\n    public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) {\n        // 参数里的范围都是前闭后开\n        if (preBegin >= preEnd || inBegin >= inEnd) {  // 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        }\n        int rootIndex = map.get(preorder[preBegin]);  // 找到前序遍历的第一个元素在中序遍历中的位置\n        TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点\n        int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定前序数列的个数\n        root.left = findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,\n                            inorder, inBegin, rootIndex);\n        root.right = findNode(preorder, preBegin + lenOfLeft + 1, preEnd,\n                            inorder, rootIndex + 1, inEnd);\n\n        return root;\n    }\n}\n#Python\n105.从前序与中序遍历序列构造二叉树\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\n        # 第一步: 特殊情况讨论: 树为空. 或者说是递归终止条件\n        if not preorder:\n            return None\n\n        # 第二步: 前序遍历的第一个就是当前的中间节点.\n        root_val = preorder[0]\n        root = TreeNode(root_val)\n\n        # 第三步: 找切割点.\n        separator_idx = inorder.index(root_val)\n\n        # 第四步: 切割inorder数组. 得到inorder数组的左,右半边.\n        inorder_left = inorder[:separator_idx]\n        inorder_right = inorder[separator_idx + 1:]\n\n        # 第五步: 切割preorder数组. 得到preorder数组的左,右半边.\n        # ⭐️ 重点1: 中序数组大小一定跟前序数组大小是相同的.\n        preorder_left = preorder[1:1 + len(inorder_left)]\n        preorder_right = preorder[1 + len(inorder_left):]\n\n        # 第六步: 递归\n        root.left = self.buildTree(preorder_left, inorder_left)\n        root.right = self.buildTree(preorder_right, inorder_right)\n        # 第七步: 返回答案\n        return root\n106.从中序与后序遍历序列构造二叉树\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\n        # 第一步: 特殊情况讨论: 树为空. (递归终止条件)\n        if not postorder:\n            return None\n\n        # 第二步: 后序遍历的最后一个就是当前的中间节点.\n        root_val = postorder[-1]\n        root = TreeNode(root_val)\n\n        # 第三步: 找切割点.\n        separator_idx = inorder.index(root_val)\n\n        # 第四步: 切割inorder数组. 得到inorder数组的左,右半边.\n        inorder_left = inorder[:separator_idx]\n        inorder_right = inorder[separator_idx + 1:]\n\n        # 第五步: 切割postorder数组. 得到postorder数组的左,右半边.\n        # ⭐️ 重点1: 中序数组大小一定跟后序数组大小是相同的.\n        postorder_left = postorder[:len(inorder_left)]\n        postorder_right = postorder[len(inorder_left): len(postorder) - 1]\n\n        # 第六步: 递归\n        root.left = self.buildTree(inorder_left, postorder_left)\n        root.right = self.buildTree(inorder_right, postorder_right)\n         # 第七步: 返回答案\n        return root"
}