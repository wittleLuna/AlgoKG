{
  "id": "AP_79a2a75d",
  "title": "孤岛的总面积",
  "alternative_titles": [],
  "platform": "kamacoder",
  "url": "https://kamacoder.com/problempage.php?pid=1173",
  "description": "一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。\n\n现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。\n\n输入描述\n\n第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。\n\n输出描述\n\n输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。\n\n输入",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "深度优先搜索",
    "广度优先搜索"
  ],
  "data_structure_tags": [
    "二维数组",
    "队列"
  ],
  "technique_tags": [
    "图的遍历",
    "边界条件处理"
  ],
  "difficulty": null,
  "solution_approach": "通过从矩阵边缘开始，使用DFS或BFS将所有与边缘相连的陆地（1）标记为水（0），之后遍历整个矩阵计算剩余未被标记的陆地数量来确定孤岛总面积。",
  "key_insights": [
    {
      "content": "首先处理位于边缘的所有岛屿部分，因为这些不会被视为孤岛。通过对边缘的陆地区域进行搜索并将其转换为水域，可以有效地隔离出内部的孤岛。"
    },
    {
      "content": "选择DFS或BFS均可解决问题，两者都是为了探索连通区域并将它们“淹没”。这种方法确保了只有完全不接触边界的岛屿才会被计数。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "本题使用dfs，bfs，并查集都是可以的。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) { // 向四个方向遍历\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        // 超过边界\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        // 不符合条件，不继续遍历\n        if (grid[nextx][nexty] == 0) continue;\n\n        dfs (grid, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "C++版本采用深度优先搜索（DFS）解决孤岛总面积问题。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n\n    cout << count << endl;\n}",
          "description": "C++版本采用广度优先搜索（BFS）解决孤岛总面积问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    private static int count = 0;\n    private static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 四个方向\n\n    private static void bfs(int[][] grid, int x, int y) {\n        Queue<int[]> que = new LinkedList<>();\n        que.add(new int[]{x, y});\n        grid[x][y] = 0; // 只要加入队列，立刻标记\n        count++;\n        while (!que.isEmpty()) {\n            int[] cur = que.poll();\n            int curx = cur[0];\n            int cury = cur[1];\n            for (int i = 0; i < 4; i++) {\n                int nextx = curx + dir[i][0];\n                int nexty = cury + dir[i][1];\n                if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue; // 越界了，直接跳过\n                if (grid[nextx][nexty] == 1) {\n                    que.add(new int[]{nextx, nexty});\n                    count++;\n                    grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] grid = new int[n][m];\n        \n        // 读取网格\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        \n        // 从左侧边，和右侧边向中间遍历\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0] == 1) bfs(grid, i, 0);\n            if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n        }\n        \n        // 从上边和下边向中间遍历\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) bfs(grid, 0, j);\n            if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n        }\n        \n        count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) bfs(grid, i, j);\n            }\n        }\n\n        System.out.println(count);\n    }\n}",
          "description": "Java版本采用广度优先搜索（BFS）解决孤岛总面积问题。"
        },
        {
          "language": "python",
          "code": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\ndef dfs(grid, x, y):\n    global count\n    grid[x][y] = 0\n    count += 1\n    for i, j in position:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n            continue\n        if grid[next_x][next_y] == 1: \n            dfs(grid, next_x, next_y)\n                \nn, m = map(int, input().split())\n\n# 邻接矩阵\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n\n# 清除边界上的连通分量\nfor i in range(n):\n    if grid[i][0] == 1: \n        dfs(grid, i, 0)\n    if grid[i][m - 1] == 1: \n        dfs(grid, i, m - 1)\n\nfor j in range(m):\n    if grid[0][j] == 1: \n        dfs(grid, 0, j)\n    if grid[n - 1][j] == 1: \n        dfs(grid, n - 1, j)\n    \ncount = 0 # 将count重置为0\n# 统计内部所有剩余的连通分量\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1:\n            dfs(grid, i, j)\n            \nprint(count)",
          "description": "Python版本采用深度优先搜索（DFS）解决孤岛总面积问题。"
        },
        {
          "language": "python",
          "code": "from collections import deque\n\n# 处理输入\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    g.append(row)\n\n# 定义四个方向、孤岛面积（遍历完边缘后会被重置）\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\n\n# 广搜\ndef bfs(r, c):\n    global count\n    q = deque()\n    q.append((r, c))\n    g[r][c] = 0\n    count += 1\n\n    while q:\n        r, c = q.popleft()\n        for di in directions:\n            next_r = r + di[0]\n            next_c = c + di[1]\n            if next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\n                continue\n            if g[next_r][next_c] == 1:\n                q.append((next_r, next_c))\n                g[next_r][next_c] = 0\n                count += 1\n\n\nfor i in range(n):\n    if g[i][0] == 1: \n        bfs(i, 0)\n    if g[i][m-1] == 1: \n        bfs(i, m-1)\n\nfor i in range(m):\n    if g[0][i] == 1: \n        bfs(0, i)\n    if g[n-1][i] == 1: \n        bfs(n-1, i)\n\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] == 1: \n            bfs(i, j)\n\nprint(count)",
          "description": "Python版本采用广度优先搜索（BFS）解决孤岛总面积问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (grid[nextx][nexty] == 0) continue;\n        dfs (grid, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "C++ 深度优先搜索实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "C++ 广度优先搜索实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    private static int count = 0;\n    private static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    private static void bfs(int[][] grid, int x, int y) {\n        Queue<int[]> que = new LinkedList<>();\n        que.add(new int[]{x, y});\n        grid[x][y] = 0;\n        count++;\n        while (!que.isEmpty()) {\n            int[] cur = que.poll();\n            int curx = cur[0];\n            int cury = cur[1];\n            for (int i = 0; i < 4; i++) {\n                int nextx = curx + dir[i][0];\n                int nexty = cury + dir[i][1];\n                if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue;\n                if (grid[nextx][nexty] == 1) {\n                    que.add(new int[]{nextx, nexty});\n                    count++;\n                    grid[nextx][nexty] = 0;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] grid = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0] == 1) bfs(grid, i, 0);\n            if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n        }\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) bfs(grid, 0, j);\n            if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n        }\n        count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) bfs(grid, i, j);\n            }\n        }\n        System.out.println(count);\n    }\n}",
          "description": "Java 广度优先搜索实现"
        },
        {
          "language": "python",
          "code": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\ndef dfs(grid, x, y):\n    global count\n    grid[x][y] = 0\n    count += 1\n    for i, j in position:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n            continue\n        if grid[next_x][next_y] == 1: \n            dfs(grid, next_x, next_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nfor i in range(n):\n    if grid[i][0] == 1: \n        dfs(grid, i, 0)\n    if grid[i][m - 1] == 1: \n        dfs(grid, i, m - 1)\nfor j in range(m):\n    if grid[0][j] == 1: \n        dfs(grid, 0, j)\n    if grid[n - 1][j] == 1: \n        dfs(grid, n - 1, j)\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1:\n            dfs(grid, i, j)\nprint(count)",
          "description": "Python 深度优先搜索实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    g.append(row)\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\ndef bfs(r, c):\n    global count\n    q = deque()\n    q.append((r, c))\n    g[r][c] = 0\n    count += 1\n    while q:\n        r, c = q.popleft()\n        for di in directions:\n            next_r = r + di[0]\n            next_c = c + di[1]\n            if next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\n                continue\n            if g[next_r][next_c] == 1:\n                q.append((next_r, next_c))\n                g[next_r][next_c] = 0\n                count += 1\nfor i in range(n):\n    if g[i][0] == 1: \n        bfs(i, 0)\n    if g[i][m-1] == 1: \n        bfs(i, m-1)\nfor i in range(m):\n    if g[0][i] == 1: \n        bfs(0, i)\n    if g[n-1][i] == 1: \n        bfs(n-1, i)\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] == 1: \n            bfs(i, j)\nprint(count)",
          "description": "Python 广度优先搜索实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) { // 向四个方向遍历\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        // 超过边界\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        // 不符合条件，不继续遍历\n        if (grid[nextx][nexty] == 0) continue;\n\n        dfs (grid, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "使用深度优先搜索（DFS）解决孤岛总面积问题的C++代码"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n\n    cout << count << endl;\n}",
          "description": "使用广度优先搜索（BFS）解决孤岛总面积问题的C++代码"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    private static int count = 0;\n    private static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 四个方向\n\n    private static void bfs(int[][] grid, int x, int y) {\n        Queue<int[]> que = new LinkedList<>();\n        que.add(new int[]{x, y});\n        grid[x][y] = 0; // 只要加入队列，立刻标记\n        count++;\n        while (!que.isEmpty()) {\n            int[] cur = que.poll();\n            int curx = cur[0];\n            int cury = cur[1];\n            for (int i = 0; i < 4; i++) {\n                int nextx = curx + dir[i][0];\n                int nexty = cury + dir[i][1];\n                if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue; // 越界了，直接跳过\n                if (grid[nextx][nexty] == 1) {\n                    que.add(new int[]{nextx, nexty});\n                    count++;\n                    grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] grid = new int[n][m];\n        \n        // 读取网格\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        \n        // 从左侧边，和右侧边向中间遍历\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0] == 1) bfs(grid, i, 0);\n            if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n        }\n        \n        // 从上边和下边向中间遍历\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) bfs(grid, 0, j);\n            if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n        }\n        \n        count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) bfs(grid, i, j);\n            }\n        }\n\n        System.out.println(count);\n    }\n}",
          "description": "使用广度优先搜索（BFS）解决孤岛总面积问题的Java代码"
        },
        {
          "language": "python",
          "code": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\n\ndef dfs(grid, x, y):\n    global count\n    grid[x][y] = 0\n    count += 1\n    for i, j in position:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n            continue\n        if grid[next_x][next_y] == 1: \n            dfs(grid, next_x, next_y)\n                 \nn, m = map(int, input().split())\n\n# 邻接矩阵\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n\n# 清除边界上的连通分量\nfor i in range(n):\n    if grid[i][0] == 1: \n        dfs(grid, i, 0)\n    if grid[i][m - 1] == 1: \n        dfs(grid, i, m - 1)\n\nfor j in range(m):\n    if grid[0][j] == 1: \n        dfs(grid, 0, j)\n    if grid[n - 1][j] == 1: \n        dfs(grid, n - 1, j)\n    \ncount = 0 # 将count重置为0\n# 统计内部所有剩余的连通分量\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1:\n            dfs(grid, i, j)\n              \nprint(count)",
          "description": "使用深度优先搜索（DFS）解决孤岛总面积问题的Python代码"
        },
        {
          "language": "python",
          "code": "from collections import deque\n\n# 处理输入\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    g.append(row)\n\n# 定义四个方向、孤岛面积（遍历完边缘后会被重置）\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\n\n# 广搜\ndef bfs(r, c):\n    global count\n    q = deque()\n    q.append((r, c))\n    g[r][c] = 0\n    count += 1\n\n    while q:\n        r, c = q.popleft()\n        for di in directions:\n            next_r = r + di[0]\n            next_c = c + di[1]\n            if next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\n                continue\n            if g[next_r][next_c] == 1:\n                q.append((next_r, next_c))\n                g[next_r][next_c] = 0\n                count += 1\n\n\nfor i in range(n):\n    if g[i][0] == 1: \n        bfs(i, 0)\n    if g[i][m-1] == 1: \n        bfs(i, m-1)\n\nfor i in range(m):\n    if g[0][i] == 1: \n        bfs(0, i)\n    if g[n-1][i] == 1: \n        bfs(n-1, i)\n\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] == 1: \n            bfs(i, j)\n\nprint(count)",
          "description": "使用广度优先搜索（BFS）解决孤岛总面积问题的Python代码"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (grid[nextx][nexty] == 0) continue;\n        dfs (grid, nextx, nexty);\n    }\n}\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "C++版使用深度优先搜索计算孤岛总面积"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0;\n            }\n        }\n    }\n}\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "C++版使用广度优先搜索计算孤岛总面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\nprivate static int count = 0;\nprivate static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\nprivate static void bfs(int[][] grid, int x, int y) {\n    Queue<int[]> que = new LinkedList<>();\n    que.add(new int[]{x, y});\n    grid[x][y] = 0;\n    count++;\n    while (!que.isEmpty()) {\n        int[] cur = que.poll();\n        int curx = cur[0];\n        int cury = cur[1];\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue;\n            if (grid[nextx][nexty] == 1) {\n                que.add(new int[]{nextx, nexty});\n                count++;\n                grid[nextx][nexty] = 0;\n            }\n        }\n    }\n}\npublic static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    int n = scanner.nextInt();\n    int m = scanner.nextInt();\n    int[][] grid = new int[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            grid[i][j] = scanner.nextInt();\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) bfs(grid, i, j);\n        }\n    }\n    System.out.println(count);\n}}",
          "description": "Java版使用广度优先搜索计算孤岛总面积"
        },
        {
          "language": "python",
          "code": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\ndef dfs(grid, x, y):\n    global count\n    grid[x][y] = 0\n    count += 1\n    for i, j in position:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n            continue\n        if grid[next_x][next_y] == 1: \n            dfs(grid, next_x, next_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nfor i in range(n):\n    if grid[i][0] == 1: \n        dfs(grid, i, 0)\n    if grid[i][m - 1] == 1: \n        dfs(grid, i, m - 1)\nfor j in range(m):\n    if grid[0][j] == 1: \n        dfs(grid, 0, j)\n    if grid[n - 1][j] == 1: \n        dfs(grid, n - 1, j)\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1:\n            dfs(grid, i, j)\nprint(count)",
          "description": "Python版使用深度优先搜索计算孤岛总面积"
        },
        {
          "language": "python",
          "code": "from collections import deque\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    g.append(row)\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\ndef bfs(r, c):\n    global count\n    q = deque()\n    q.append((r, c))\n    g[r][c] = 0\n    count += 1\n    while q:\n        r, c = q.popleft()\n        for di in directions:\n            next_r = r + di[0]\n            next_c = c + di[1]\n            if next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\n                continue\n            if g[next_r][next_c] == 1:\n                q.append((next_r, next_c))\n                g[next_r][next_c] = 0\n                count += 1\nfor i in range(n):\n    if g[i][0] == 1: \n        bfs(i, 0)\n    if g[i][m-1] == 1: \n        bfs(i, m-1)\nfor i in range(m):\n    if g[0][i] == 1: \n        bfs(0, i)\n    if g[n-1][i] == 1: \n        bfs(n-1, i)\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] == 1: \n            bfs(i, j)\nprint(count)",
          "description": "Python版使用广度优先搜索计算孤岛总面积"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (grid[nextx][nexty] == 0) continue;\n\n        dfs (grid, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "C++深度优先搜索计算孤岛总面积"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "C++广度优先搜索计算孤岛总面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    private static int count = 0;\n    private static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    private static void bfs(int[][] grid, int x, int y) {\n        Queue<int[]> que = new LinkedList<>();\n        que.add(new int[]{x, y});\n        grid[x][y] = 0;\n        count++;\n        while (!que.isEmpty()) {\n            int[] cur = que.poll();\n            int curx = cur[0];\n            int cury = cur[1];\n            for (int i = 0; i < 4; i++) {\n                int nextx = curx + dir[i][0];\n                int nexty = cury + dir[i][1];\n                if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue;\n                if (grid[nextx][nexty] == 1) {\n                    que.add(new int[]{nextx, nexty});\n                    count++;\n                    grid[nextx][nexty] = 0;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] grid = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0] == 1) bfs(grid, i, 0);\n            if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n        }\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) bfs(grid, 0, j);\n            if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n        }\n        count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) bfs(grid, i, j);\n            }\n        }\n        System.out.println(count);\n    }\n}",
          "description": "Java广度优先搜索计算孤岛总面积"
        },
        {
          "language": "python",
          "code": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\ndef dfs(grid, x, y):\n    global count\n    grid[x][y] = 0\n    count += 1\n    for i, j in position:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n            continue\n        if grid[next_x][next_y] == 1: \n            dfs(grid, next_x, next_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nfor i in range(n):\n    if grid[i][0] == 1: \n        dfs(grid, i, 0)\n    if grid[i][m - 1] == 1: \n        dfs(grid, i, m - 1)\nfor j in range(m):\n    if grid[0][j] == 1: \n        dfs(grid, 0, j)\n    if grid[n - 1][j] == 1: \n        dfs(grid, n - 1, j)\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1:\n            dfs(grid, i, j)\nprint(count)",
          "description": "Python深度优先搜索计算孤岛总面积"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndef bfs(r, c):\n    global count\n    q = deque()\n    q.append((r, c))\n    g[r][c] = 0\n    count += 1\n    while q:\n        r, c = q.popleft()\n        for di in directions:\n            next_r = r + di[0]\n            next_c = c + di[1]\n            if next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\n                continue\n            if g[next_r][next_c] == 1:\n                q.append((next_r, next_c))\n                g[next_r][next_c] = 0\n                count += 1\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    g.append(row)\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\nfor i in range(n):\n    if g[i][0] == 1: \n        bfs(i, 0)\n    if g[i][m-1] == 1: \n        bfs(i, m-1)\nfor i in range(m):\n    if g[0][i] == 1: \n        bfs(0, i)\n    if g[n-1][i] == 1: \n        bfs(n-1, i)\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] == 1: \n            bfs(i, j)\nprint(count)",
          "description": "Python广度优先搜索计算孤岛总面积"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <queue>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (grid[nextx][nexty] == 0) continue;\n        dfs (grid, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "使用深度优先搜索计算孤岛总面积"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "使用广度优先搜索计算孤岛总面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    private static int count = 0;\n    private static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    private static void bfs(int[][] grid, int x, int y) {\n        Queue<int[]> que = new LinkedList<>();\n        que.add(new int[]{x, y});\n        grid[x][y] = 0;\n        count++;\n        while (!que.isEmpty()) {\n            int[] cur = que.poll();\n            int curx = cur[0];\n            int cury = cur[1];\n            for (int i = 0; i < 4; i++) {\n                int nextx = curx + dir[i][0];\n                int nexty = cury + dir[i][1];\n                if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue;\n                if (grid[nextx][nexty] == 1) {\n                    que.add(new int[]{nextx, nexty});\n                    count++;\n                    grid[nextx][nexty] = 0;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] grid = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0] == 1) bfs(grid, i, 0);\n            if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n        }\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) bfs(grid, 0, j);\n            if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n        }\n        count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) bfs(grid, i, j);\n            }\n        }\n        System.out.println(count);\n    }\n}",
          "description": "Java版本的广度优先搜索实现"
        },
        {
          "language": "python",
          "code": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\ndef dfs(grid, x, y):\n    global count\n    grid[x][y] = 0\n    count += 1\n    for i, j in position:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n            continue\n        if grid[next_x][next_y] == 1: \n            dfs(grid, next_x, next_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nfor i in range(n):\n    if grid[i][0] == 1: \n        dfs(grid, i, 0)\n    if grid[i][m - 1] == 1: \n        dfs(grid, i, m - 1)\nfor j in range(m):\n    if grid[0][j] == 1: \n        dfs(grid, 0, j)\n    if grid[n - 1][j] == 1: \n        dfs(grid, n - 1, j)\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1:\n            dfs(grid, i, j)\nprint(count)",
          "description": "Python版本的深度优先搜索实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    g.append(row)\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\ndef bfs(r, c):\n    global count\n    q = deque()\n    q.append((r, c))\n    g[r][c] = 0\n    count += 1\n    while q:\n        r, c = q.popleft()\n        for di in directions:\n            next_r = r + di[0]\n            next_c = c + di[1]\n            if next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\n                continue\n            if g[next_r][next_c] == 1:\n                q.append((next_r, next_c))\n                g[next_r][next_c] = 0\n                count += 1\nfor i in range(n):\n    if g[i][0] == 1: \n        bfs(i, 0)\n    if g[i][m-1] == 1: \n        bfs(i, m-1)\nfor i in range(m):\n    if g[0][i] == 1: \n        bfs(0, i)\n    if g[n-1][i] == 1: \n        bfs(n-1, i)\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] == 1: \n            bfs(i, j)\nprint(count)",
          "description": "Python版本的广度优先搜索实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) { // 向四个方向遍历\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        // 超过边界\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        // 不符合条件，不继续遍历\n        if (grid[nextx][nexty] == 0) continue;\n\n        dfs (grid, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "使用深度优先搜索(DFS)计算孤岛总面积的C++实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n\n    cout << count << endl;\n}",
          "description": "使用广度优先搜索(BFS)计算孤岛总面积的C++实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    private static int count = 0;\n    private static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 四个方向\n\n    private static void bfs(int[][] grid, int x, int y) {\n        Queue<int[]> que = new LinkedList<>();\n        que.add(new int[]{x, y});\n        grid[x][y] = 0; // 只要加入队列，立刻标记\n        count++;\n        while (!que.isEmpty()) {\n            int[] cur = que.poll();\n            int curx = cur[0];\n            int cury = cur[1];\n            for (int i = 0; i < 4; i++) {\n                int nextx = curx + dir[i][0];\n                int nexty = cury + dir[i][1];\n                if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue; // 越界了，直接跳过\n                if (grid[nextx][nexty] == 1) {\n                    que.add(new int[]{nextx, nexty});\n                    count++;\n                    grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] grid = new int[n][m];\n        \n        // 读取网格\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        \n        // 从左侧边，和右侧边向中间遍历\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0] == 1) bfs(grid, i, 0);\n            if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n        }\n        \n        // 从上边和下边向中间遍历\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) bfs(grid, 0, j);\n            if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n        }\n        \n        count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) bfs(grid, i, j);\n            }\n        }\n\n        System.out.println(count);\n    }\n}",
          "description": "使用广度优先搜索(BFS)计算孤岛总面积的Java实现"
        },
        {
          "language": "python",
          "code": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\ndef dfs(grid, x, y):\n    global count\n    grid[x][y] = 0\n    count += 1\n    for i, j in position:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n            continue\n        if grid[next_x][next_y] == 1: \n            dfs(grid, next_x, next_y)\n                \nn, m = map(int, input().split())\n\n# 邻接矩阵\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n\n# 清除边界上的连通分量\nfor i in range(n):\n    if grid[i][0] == 1: \n        dfs(grid, i, 0)\n    if grid[i][m - 1] == 1: \n        dfs(grid, i, m - 1)\n\nfor j in range(m):\n    if grid[0][j] == 1: \n        dfs(grid, 0, j)\n    if grid[n - 1][j] == 1: \n        dfs(grid, n - 1, j)\n    \ncount = 0 # 将count重置为0\n# 统计内部所有剩余的连通分量\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1:\n            dfs(grid, i, j)\n            \nprint(count)",
          "description": "使用深度优先搜索(DFS)计算孤岛总面积的Python实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\n\n# 处理输入\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    g.append(row)\n\n# 定义四个方向、孤岛面积（遍历完边缘后会被重置）\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\n\n# 广搜\ndef bfs(r, c):\n    global count\n    q = deque()\n    q.append((r, c))\n    g[r][c] = 0\n    count += 1\n\n    while q:\n        r, c = q.popleft()\n        for di in directions:\n            next_r = r + di[0]\n            next_c = c + di[1]\n            if next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\n                continue\n            if g[next_r][next_c] == 1:\n                q.append((next_r, next_c))\n                g[next_r][next_c] = 0\n                count += 1\n\n\nfor i in range(n):\n    if g[i][0] == 1: \n        bfs(i, 0)\n    if g[i][m-1] == 1: \n        bfs(i, m-1)\n\nfor i in range(m):\n    if g[0][i] == 1: \n        bfs(0, i)\n    if g[n-1][i] == 1: \n        bfs(n-1, i)\n\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] == 1: \n            bfs(i, j)\n\nprint(count)",
          "description": "使用广度优先搜索(BFS)计算孤岛总面积的Python实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "import java.util.*;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) { // 向四个方向遍历\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        // 超过边界\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        // 不符合条件，不继续遍历\n        if (grid[nextx][nexty] == 0) continue;\n\n        dfs (grid, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "C++版本的深度优先搜索实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n\n    cout << count << endl;\n}",
          "description": "C++版本的广度优先搜索实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    private static int count = 0;\n    private static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 四个方向\n\n    private static void bfs(int[][] grid, int x, int y) {\n        Queue<int[]> que = new LinkedList<>();\n        que.add(new int[]{x, y});\n        grid[x][y] = 0; // 只要加入队列，立刻标记\n        count++;\n        while (!que.isEmpty()) {\n            int[] cur = que.poll();\n            int curx = cur[0];\n            int cury = cur[1];\n            for (int i = 0; i < 4; i++) {\n                int nextx = curx + dir[i][0];\n                int nexty = cury + dir[i][1];\n                if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue; // 越界了，直接跳过\n                if (grid[nextx][nexty] == 1) {\n                    que.add(new int[]{nextx, nexty});\n                    count++;\n                    grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] grid = new int[n][m];\n\n        // 读取网格\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n\n        // 从左侧边，和右侧边向中间遍历\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0] == 1) bfs(grid, i, 0);\n            if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n        }\n\n        // 从上边和下边向中间遍历\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) bfs(grid, 0, j);\n            if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n        }\n\n        count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) bfs(grid, i, j);\n            }\n        }\n\n        System.out.println(count);\n    }\n}",
          "description": "Java版本的广度优先搜索实现"
        },
        {
          "language": "python",
          "code": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\ndef dfs(grid, x, y):\n    global count\n    grid[x][y] = 0\n    count += 1\n    for i, j in position:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n            continue\n        if grid[next_x][next_y] == 1: \n            dfs(grid, next_x, next_y)\n\nn, m = map(int, input().split())\n\n# 邻接矩阵\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n\n# 清除边界上的连通分量\nfor i in range(n):\n    if grid[i][0] == 1: \n        dfs(grid, i, 0)\n    if grid[i][m - 1] == 1: \n        dfs(grid, i, m - 1)\n\nfor j in range(m):\n    if grid[0][j] == 1: \n        dfs(grid, 0, j)\n    if grid[n - 1][j] == 1: \n        dfs(grid, n - 1, j)\n\ncount = 0 # 将count重置为0\n# 统计内部所有剩余的连通分量\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1:\n            dfs(grid, i, j)\n\nprint(count)",
          "description": "Python版本的深度优先搜索实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\n\n# 处理输入\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    g.append(row)\n\n# 定义四个方向、孤岛面积（遍历完边缘后会被重置）\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\n\n# 广搜\ndef bfs(r, c):\n    global count\n    q = deque()\n    q.append((r, c))\n    g[r][c] = 0\n    count += 1\n\n    while q:\n        r, c = q.popleft()\n        for di in directions:\n            next_r = r + di[0]\n            next_c = c + di[1]\n            if next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\n                continue\n            if g[next_r][next_c] == 1:\n                q.append((next_r, next_c))\n                g[next_r][next_c] = 0\n                count += 1\n\n\nfor i in range(n):\n    if g[i][0] == 1: \n        bfs(i, 0)\n    if g[i][m-1] == 1: \n        bfs(i, m-1)\n\nfor i in range(m):\n    if g[0][i] == 1: \n        bfs(0, i)\n    if g[n-1][i] == 1: \n        bfs(n-1, i)\n\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] == 1: \n            bfs(i, j)\n\nprint(count)",
          "description": "Python版本的广度优先搜索实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "#深搜版",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (grid[nextx][nexty] == 0) continue;\n        dfs (grid, nextx, nexty);\n    }\n}\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "使用深度优先搜索（DFS）解决孤岛总面积问题的C++实现。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0;\n            }\n        }\n    }\n}\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "使用广度优先搜索（BFS）解决孤岛总面积问题的C++实现。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\nprivate static int count = 0;\nprivate static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\nprivate static void bfs(int[][] grid, int x, int y) {\nQueue<int[]> que = new LinkedList<>();\nque.add(new int[]{x, y});\ngrid[x][y] = 0;\ncount++;\nwhile (!que.isEmpty()) {\nint[] cur = que.poll();\nint curx = cur[0];\nint cury = cur[1];\nfor (int i = 0; i < 4; i++) {\nint nextx = curx + dir[i][0];\nint nexty = cury + dir[i][1];\nif (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue;\nif (grid[nextx][nexty] == 1) {\nque.add(new int[]{nextx, nexty});\ncount++;\ngrid[nextx][nexty] = 0;\n}\n}\n}\n}\npublic static void main(String[] args) {\nScanner scanner = new Scanner(System.in);\nint n = scanner.nextInt();\nint m = scanner.nextInt();\nint[][] grid = new int[n][m];\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ngrid[i][j] = scanner.nextInt();\n}\n}\nfor (int i = 0; i < n; i++) {\nif (grid[i][0] == 1) bfs(grid, i, 0);\nif (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n}\nfor (int j = 0; j < m; j++) {\nif (grid[0][j] == 1) bfs(grid, 0, j);\nif (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n}\ncount = 0;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nif (grid[i][j] == 1) bfs(grid, i, j);\n}\n}\nSystem.out.println(count);\n}\n}",
          "description": "使用广度优先搜索（BFS）解决孤岛总面积问题的Java实现。"
        },
        {
          "language": "python",
          "code": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\ndef dfs(grid, x, y):\nglobal count\ngrid[x][y] = 0\ncount += 1\nfor i, j in position:\nnext_x = x + i\nnext_y = y + j\nif next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\ncontinue\nif grid[next_x][next_y] == 1: \ndfs(grid, next_x, next_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\ngrid.append(list(map(int, input().split())))\nfor i in range(n):\nif grid[i][0] == 1: \ndfs(grid, i, 0)\nif grid[i][m - 1] == 1: \ndfs(grid, i, m - 1)\nfor j in range(m):\nif grid[0][j] == 1: \ndfs(grid, 0, j)\nif grid[n - 1][j] == 1: \ndfs(grid, n - 1, j)\ncount = 0\nfor i in range(n):\nfor j in range(m):\nif grid[i][j] == 1:\ndfs(grid, i, j)\nprint(count)",
          "description": "使用深度优先搜索（DFS）解决孤岛总面积问题的Python实现。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\nrow = list(map(int, input().split()))\ng.append(row)\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\ndef bfs(r, c):\nglobal count\nq = deque()\nq.append((r, c))\ng[r][c] = 0\ncount += 1\nwhile q:\nr, c = q.popleft()\nfor di in directions:\nnext_r = r + di[0]\nnext_c = c + di[1]\nif next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\ncontinue\nif g[next_r][next_c] == 1:\nq.append((next_r, next_c))\ng[next_r][next_c] = 0\ncount += 1\nfor i in range(n):\nif g[i][0] == 1: \nbfs(i, 0)\nif g[i][m-1] == 1: \nbfs(i, m-1)\nfor i in range(m):\nif g[0][i] == 1: \nbfs(0, i)\nif g[n-1][i] == 1: \nbfs(n-1, i)\ncount = 0\nfor i in range(n):\nfor j in range(m):\nif g[i][j] == 1: \nbfs(i, j)\nprint(count)",
          "description": "使用广度优先搜索（BFS）解决孤岛总面积问题的Python实现。"
        }
      ],
      "subsections": []
    },
    {
      "name": "深搜版",
      "text": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) { // 向四个方向遍历\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        // 超过边界\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        // 不符合条件，不继续遍历\n        if (grid[nextx][nexty] == 0) continue;\n\n        dfs (grid, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "使用深度优先搜索(DFS)解决孤岛总面积问题的C++实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n\n    cout << count << endl;\n}",
          "description": "使用广度优先搜索(BFS)解决孤岛总面积问题的C++实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    private static int count = 0;\n    private static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 四个方向\n\n    private static void bfs(int[][] grid, int x, int y) {\n        Queue<int[]> que = new LinkedList<>();\n        que.add(new int[]{x, y});\n        grid[x][y] = 0; // 只要加入队列，立刻标记\n        count++;\n        while (!que.isEmpty()) {\n            int[] cur = que.poll();\n            int curx = cur[0];\n            int cury = cur[1];\n            for (int i = 0; i < 4; i++) {\n                int nextx = curx + dir[i][0];\n                int nexty = cury + dir[i][1];\n                if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue; // 越界了，直接跳过\n                if (grid[nextx][nexty] == 1) {\n                    que.add(new int[]{nextx, nexty});\n                    count++;\n                    grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] grid = new int[n][m];\n        \n        // 读取网格\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        \n        // 从左侧边，和右侧边向中间遍历\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0] == 1) bfs(grid, i, 0);\n            if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n        }\n        \n        // 从上边和下边向中间遍历\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) bfs(grid, 0, j);\n            if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n        }\n        \n        count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) bfs(grid, i, j);\n            }\n        }\n\n        System.out.println(count);\n    }\n}",
          "description": "使用广度优先搜索(BFS)解决孤岛总面积问题的Java实现"
        },
        {
          "language": "python",
          "code": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\n\ndef dfs(grid, x, y):\n    global count\n    grid[x][y] = 0\n    count += 1\n    for i, j in position:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n            continue\n        if grid[next_x][next_y] == 1: \n            dfs(grid, next_x, next_y)\n                 \nn, m = map(int, input().split())\n\n# 邻接矩阵\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n\n# 清除边界上的连通分量\nfor i in range(n):\n    if grid[i][0] == 1: \n        dfs(grid, i, 0)\n    if grid[i][m - 1] == 1: \n        dfs(grid, i, m - 1)\n\nfor j in range(m):\n    if grid[0][j] == 1: \n        dfs(grid, 0, j)\n    if grid[n - 1][j] == 1: \n        dfs(grid, n - 1, j)\n    \ncount = 0 # 将count重置为0\n# 统计内部所有剩余的连通分量\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1:\n            dfs(grid, i, j)\n            \nprint(count)",
          "description": "使用深度优先搜索(DFS)解决孤岛总面积问题的Python实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\n\n# 处理输入\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    g.append(row)\n\n# 定义四个方向、孤岛面积（遍历完边缘后会被重置）\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\n\n# 广搜\ndef bfs(r, c):\n    global count\n    q = deque()\n    q.append((r, c))\n    g[r][c] = 0\n    count += 1\n\n    while q:\n        r, c = q.popleft()\n        for di in directions:\n            next_r = r + di[0]\n            next_c = c + di[1]\n            if next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\n                continue\n            if g[next_r][next_c] == 1:\n                q.append((next_r, next_c))\n                g[next_r][next_c] = 0\n                count += 1\n\n\nfor i in range(n):\n    if g[i][0] == 1: \n        bfs(i, 0)\n    if g[i][m-1] == 1: \n        bfs(i, m-1)\n\nfor i in range(m):\n    if g[0][i] == 1: \n        bfs(0, i)\n    if g[n-1][i] == 1: \n        bfs(n-1, i)\n\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] == 1: \n            bfs(i, j)\n\nprint(count)",
          "description": "使用广度优先搜索(BFS)解决孤岛总面积问题的Python实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "广搜版",
      "text": "from collections import deque",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) { // 向四个方向遍历\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        // 超过边界\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        // 不符合条件，不继续遍历\n        if (grid[nextx][nexty] == 0) continue;\n\n        dfs (grid, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
          "description": "C++深度优先搜索实现孤岛面积计算"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n\n    cout << count << endl;\n}",
          "description": "C++广度优先搜索实现孤岛面积计算"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    private static int count = 0;\n    private static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 四个方向\n\n    private static void bfs(int[][] grid, int x, int y) {\n        Queue<int[]> que = new LinkedList<>();\n        que.add(new int[]{x, y});\n        grid[x][y] = 0; // 只要加入队列，立刻标记\n        count++;\n        while (!que.isEmpty()) {\n            int[] cur = que.poll();\n            int curx = cur[0];\n            int cury = cur[1];\n            for (int i = 0; i < 4; i++) {\n                int nextx = curx + dir[i][0];\n                int nexty = cury + dir[i][1];\n                if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue; // 越界了，直接跳过\n                if (grid[nextx][nexty] == 1) {\n                    que.add(new int[]{nextx, nexty});\n                    count++;\n                    grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] grid = new int[n][m];\n        \n        // 读取网格\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        \n        // 从左侧边，和右侧边向中间遍历\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0] == 1) bfs(grid, i, 0);\n            if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n        }\n        \n        // 从上边和下边向中间遍历\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) bfs(grid, 0, j);\n            if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n        }\n        \n        count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) bfs(grid, i, j);\n            }\n        }\n\n        System.out.println(count);\n    }\n}",
          "description": "Java广度优先搜索实现孤岛面积计算"
        },
        {
          "language": "python",
          "code": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\ndef dfs(grid, x, y):\n    global count\n    grid[x][y] = 0\n    count += 1\n    for i, j in position:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n            continue\n        if grid[next_x][next_y] == 1: \n            dfs(grid, next_x, next_y)\n\nn, m = map(int, input().split())\n# 邻接矩阵\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n\n# 清除边界上的连通分量\nfor i in range(n):\n    if grid[i][0] == 1: \n        dfs(grid, i, 0)\n    if grid[i][m - 1] == 1: \n        dfs(grid, i, m - 1)\n\nfor j in range(m):\n    if grid[0][j] == 1: \n        dfs(grid, 0, j)\n    if grid[n - 1][j] == 1: \n        dfs(grid, n - 1, j)\n\ncount = 0 # 将count重置为0\n# 统计内部所有剩余的连通分量\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1:\n            dfs(grid, i, j)\n\nprint(count)",
          "description": "Python深度优先搜索实现孤岛面积计算"
        },
        {
          "language": "python",
          "code": "from collections import deque\n\n# 处理输入\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    g.append(row)\n\n# 定义四个方向、孤岛面积（遍历完边缘后会被重置）\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\n\n# 广搜\ndef bfs(r, c):\n    global count\n    q = deque()\n    q.append((r, c))\n    g[r][c] = 0\n    count += 1\n\n    while q:\n        r, c = q.popleft()\n        for di in directions:\n            next_r = r + di[0]\n            next_c = c + di[1]\n            if next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\n                continue\n            if g[next_r][next_c] == 1:\n                q.append((next_r, next_c))\n                g[next_r][next_c] = 0\n                count += 1\n\nfor i in range(n):\n    if g[i][0] == 1: \n        bfs(i, 0)\n    if g[i][m-1] == 1: \n        bfs(i, m-1)\n\nfor i in range(m):\n    if g[0][i] == 1: \n        bfs(0, i)\n    if g[n-1][i] == 1: \n        bfs(n-1, i)\n\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] == 1: \n            bfs(i, j)\n\nprint(count)",
          "description": "Python广度优先搜索实现孤岛面积计算"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) { // 向四个方向遍历\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        // 超过边界\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        // 不符合条件，不继续遍历\n        if (grid[nextx][nexty] == 0) continue;\n\n        dfs (grid, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}",
      "description": null
    },
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n\n    cout << count << endl;\n}",
      "description": null
    },
    {
      "language": "java",
      "code": "import java.util.*;\npublic class Main {\n    private static int count = 0;\n    private static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 四个方向\n\n    private static void bfs(int[][] grid, int x, int y) {\n        Queue<int[]> que = new LinkedList<>();\n        que.add(new int[]{x, y});\n        grid[x][y] = 0; // 只要加入队列，立刻标记\n        count++;\n        while (!que.isEmpty()) {\n            int[] cur = que.poll();\n            int curx = cur[0];\n            int cury = cur[1];\n            for (int i = 0; i < 4; i++) {\n                int nextx = curx + dir[i][0];\n                int nexty = cury + dir[i][1];\n                if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue; // 越界了，直接跳过\n                if (grid[nextx][nexty] == 1) {\n                    que.add(new int[]{nextx, nexty});\n                    count++;\n                    grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] grid = new int[n][m];\n        \n        // 读取网格\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        \n        // 从左侧边，和右侧边向中间遍历\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0] == 1) bfs(grid, i, 0);\n            if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n        }\n        \n        // 从上边和下边向中间遍历\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) bfs(grid, 0, j);\n            if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n        }\n        \n        count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) bfs(grid, i, j);\n            }\n        }\n\n        System.out.println(count);\n    }\n}",
      "description": null
    },
    {
      "language": "python",
      "code": "position = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\ndef dfs(grid, x, y):\n    global count\n    grid[x][y] = 0\n    count += 1\n    for i, j in position:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n            continue\n        if grid[next_x][next_y] == 1: \n            dfs(grid, next_x, next_y)\n                \nn, m = map(int, input().split())\n\n# 邻接矩阵\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n\n# 清除边界上的连通分量\nfor i in range(n):\n    if grid[i][0] == 1: \n        dfs(grid, i, 0)\n    if grid[i][m - 1] == 1: \n        dfs(grid, i, m - 1)\n\nfor j in range(m):\n    if grid[0][j] == 1: \n        dfs(grid, 0, j)\n    if grid[n - 1][j] == 1: \n        dfs(grid, n - 1, j)\n    \ncount = 0 # 将count重置为0\n# 统计内部所有剩余的连通分量\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1:\n            dfs(grid, i, j)\n            \nprint(count)",
      "description": null
    },
    {
      "language": "python",
      "code": "from collections import deque\n\n# 处理输入\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    g.append(row)\n\n# 定义四个方向、孤岛面积（遍历完边缘后会被重置）\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\n\n# 广搜\ndef bfs(r, c):\n    global count\n    q = deque()\n    q.append((r, c))\n    g[r][c] = 0\n    count += 1\n\n    while q:\n        r, c = q.popleft()\n        for di in directions:\n            next_r = r + di[0]\n            next_c = c + di[1]\n            if next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\n                continue\n            if g[next_r][next_c] == 1:\n                q.append((next_r, next_c))\n                g[next_r][next_c] = 0\n                count += 1\n\n\nfor i in range(n):\n    if g[i][0] == 1: \n        bfs(i, 0)\n    if g[i][m-1] == 1: \n        bfs(i, m-1)\n\nfor i in range(m):\n    if g[0][i] == 1: \n        bfs(0, i)\n    if g[n-1][i] == 1: \n        bfs(n-1, i)\n\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] == 1: \n            bfs(i, j)\n\nprint(count)",
      "description": null
    }
  ],
  "common_mistakes": [
    "忘记初始化访问状态或其他标志变量，导致无限循环或遗漏某些节点。",
    "在实现DFS时递归层数过深可能导致栈溢出。",
    "没有正确处理边界情况，如矩阵大小为1x1的情况。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240517105557.png",
      "description": "这张图片展示了一个二维数组（矩阵），其中包含多个“1”和“0”，可用于算法中的岛屿问题或连通分量分析。",
      "context": "该图展示了在给定矩阵中，位于中心部分且不与边缘接触的孤岛示例，帮助理解如何根据题目要求识别并计算孤岛面积。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20220830104632.png",
      "description": "这张图片展示了一个二维数组（矩阵）中的岛屿问题，其中“1”表示陆地，“0”表示水域，黄色高亮部分可能表示特定的岛屿或路径。",
      "context": "展示了地图周围四个边的陆地被标记为绿色的情况，用以说明如何识别并处理边界上的陆地。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20220830104651.png",
      "description": "这张图片展示了一个二维数组（矩阵）中的特定元素（值为1），可能用于解释或解决与矩阵相关的算法问题，如岛屿数量或路径查找。",
      "context": "展示了将地图周边的陆地（标记为1）变为海洋（标记为0）后的地图状态。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240517105557.png",
      "description": "GIF展示了从矩阵边缘开始，通过将接触边界的陆地单元格标记为水域来排除非孤岛区域的过程。",
      "context": "GIF动画展示了通过DFS或BFS方法将与边界相连的陆地标记为海洋的过程，以便后续计算孤岛总面积。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20220830104632.png",
      "description": "GIF展示了从矩阵边缘开始，将所有与边缘相连的陆地标记为海洋的过程。",
      "context": "GIF动画展示了从地图四周开始，将所有与边界相连的陆地标记为海洋的过程，帮助理解如何识别并处理非边缘陆地。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20220830104651.png",
      "description": "GIF展示了从地图边缘开始，将所有与边缘相连的陆地单元格（标记为1）转换为海洋（标记为0）的过程。",
      "context": "此GIF展示了将地图边缘的陆地标记为海洋后的新地图状态，帮助理解如何通过改变边缘陆地来识别并计算不与边界相连的内陆区域。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\图论\\孤岛的总面积.txt",
  "extracted_at": "2025-07-21T14:06:20.815016",
  "raw_content": "孤岛的总面积\n卡码网：101. 孤岛的总面积(https://kamacoder.com/problempage.php?pid=1173)\n\n题目描述\n\n给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。\n\n现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。\n\n输入描述\n\n第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。\n\n输出描述\n\n输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。\n\n输入示例\n\n4 5\n1 1 0 0 0\n1 1 0 0 0\n0 0 1 0 0\n0 0 0 1 1\n输出示例：\n\n1\n\n提示信息：\n\nhttps://file1.kamacoder.com/i/algo/20240517105557.png\n\n在矩阵中心部分的岛屿，因为没有任何一个单元格接触到矩阵边缘，所以该岛屿属于孤岛，总面积为 1。\n\n数据范围：\n\n1 <= M, N <= 50。\n\n#思路\n\n\n本题使用dfs，bfs，并查集都是可以的。\n\n本题要求找到不靠边的陆地面积，那么我们只要从周边找到陆地然后 通过 dfs或者bfs 将周边靠陆地且相邻的陆地都变成海洋，然后再去重新遍历地图 统计此时还剩下的陆地就可以了。\n\n如图，在遍历地图周围四个边，靠地图四边的陆地，都为绿色，\n\nhttps://file1.kamacoder.com/i/algo/20220830104632.png\n\n在遇到地图周边陆地的时候，将1都变为0，此时地图为这样：\n\nhttps://file1.kamacoder.com/i/algo/20220830104651.png\n\n然后我们再去遍历这个地图，遇到有陆地的地方，去采用深搜或者广搜，边统计所有陆地。\n\n如果对深搜或者广搜不够了解，建议先看这里：深度优先搜索精讲 https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html，广度优先搜索精讲 https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%BF%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html。\n\n采用深度优先搜索的代码如下：\n\n#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向\nvoid dfs(vector<vector<int>>& grid, int x, int y) {\n    grid[x][y] = 0;\n    for (int i = 0; i < 4; i++) { // 向四个方向遍历\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        // 超过边界\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        // 不符合条件，不继续遍历\n        if (grid[nextx][nexty] == 0) continue;\n\n        dfs (grid, nextx, nexty);\n    }\n    return;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) dfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) dfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n    cout << count << endl;\n}\n采用广度优先搜索的代码如下：\n\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(vector<vector<int>>& grid, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    grid[x][y] = 0; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    // 从左侧边，和右侧边 向中间遍历\n    for (int i = 0; i < n; i++) {\n        if (grid[i][0] == 1) bfs(grid, i, 0);\n        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n    }\n    // 从上边和下边 向中间遍历\n    for (int j = 0; j < m; j++) {\n        if (grid[0][j] == 1) bfs(grid, 0, j);\n        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) count++;\n        }\n    }\n\n    cout << count << endl;\n}\n\n#其他语言版本\n#Java\n\nimport java.util.*;\n\npublic class Main {\n    private static int count = 0;\n    private static final int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 四个方向\n\n    private static void bfs(int[][] grid, int x, int y) {\n        Queue<int[]> que = new LinkedList<>();\n        que.add(new int[]{x, y});\n        grid[x][y] = 0; // 只要加入队列，立刻标记\n        count++;\n        while (!que.isEmpty()) {\n            int[] cur = que.poll();\n            int curx = cur[0];\n            int cury = cur[1];\n            for (int i = 0; i < 4; i++) {\n                int nextx = curx + dir[i][0];\n                int nexty = cury + dir[i][1];\n                if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length) continue; // 越界了，直接跳过\n                if (grid[nextx][nexty] == 1) {\n                    que.add(new int[]{nextx, nexty});\n                    count++;\n                    grid[nextx][nexty] = 0; // 只要加入队列立刻标记\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] grid = new int[n][m];\n        \n        // 读取网格\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n        \n        // 从左侧边，和右侧边向中间遍历\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0] == 1) bfs(grid, i, 0);\n            if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);\n        }\n        \n        // 从上边和下边向中间遍历\n        for (int j = 0; j < m; j++) {\n            if (grid[0][j] == 1) bfs(grid, 0, j);\n            if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);\n        }\n        \n        count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) bfs(grid, i, j);\n            }\n        }\n\n        System.out.println(count);\n    }\n}\n\n\n\n#Python\n#深搜版\nposition = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ncount = 0\n\ndef dfs(grid, x, y):\n    global count\n    grid[x][y] = 0\n    count += 1\n    for i, j in position:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_y < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n            continue\n        if grid[next_x][next_y] == 1: \n            dfs(grid, next_x, next_y)\n                \nn, m = map(int, input().split())\n\n# 邻接矩阵\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n\n# 清除边界上的连通分量\nfor i in range(n):\n    if grid[i][0] == 1: \n        dfs(grid, i, 0)\n    if grid[i][m - 1] == 1: \n        dfs(grid, i, m - 1)\n\nfor j in range(m):\n    if grid[0][j] == 1: \n        dfs(grid, 0, j)\n    if grid[n - 1][j] == 1: \n        dfs(grid, n - 1, j)\n    \ncount = 0 # 将count重置为0\n# 统计内部所有剩余的连通分量\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1:\n            dfs(grid, i, j)\n            \nprint(count)\n#广搜版\nfrom collections import deque\n\n# 处理输入\nn, m = list(map(int, input().split()))\ng = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    g.append(row)\n\n# 定义四个方向、孤岛面积（遍历完边缘后会被重置）\ndirections = [[0,1], [1,0], [-1,0], [0,-1]]\ncount = 0\n\n# 广搜\ndef bfs(r, c):\n    global count\n    q = deque()\n    q.append((r, c))\n    g[r][c] = 0\n    count += 1\n\n    while q:\n        r, c = q.popleft()\n        for di in directions:\n            next_r = r + di[0]\n            next_c = c + di[1]\n            if next_c < 0 or next_c >= m or next_r < 0 or next_r >= n:\n                continue\n            if g[next_r][next_c] == 1:\n                q.append((next_r, next_c))\n                g[next_r][next_c] = 0\n                count += 1\n\n\nfor i in range(n):\n    if g[i][0] == 1: \n        bfs(i, 0)\n    if g[i][m-1] == 1: \n        bfs(i, m-1)\n\nfor i in range(m):\n    if g[0][i] == 1: \n        bfs(0, i)\n    if g[n-1][i] == 1: \n        bfs(n-1, i)\n\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] == 1: \n            bfs(i, j)\n\nprint(count)\ndirection = [[1, 0], [-1, 0], [0, 1], [0, -1]]\nresult = 0\n\n# 深度搜尋\ndef dfs(grid, y, x):\n    grid[y][x] = 0\n    global result \n    result += 1\n    \n    for i, j in direction:\n        next_x = x + j\n        next_y = y + i\n        if (next_x < 0 or next_y < 0 or\n            next_x >= len(grid[0]) or next_y >= len(grid)\n        ):\n            continue\n        if grid[next_y][next_x] == 1 and not visited[next_y][next_x]:\n            visited[next_y][next_x] = True\n            dfs(grid, next_y, next_x)    \n\n\n# 讀取輸入值\nn, m = map(int, input().split())\ngrid = []\nvisited = [[False] * m for _ in range(n)]\n\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n\n# 處理邊界\nfor j in range(m):\n    # 上邊界\n    if grid[0][j] == 1 and not visited[0][j]: \n        visited[0][j] = True\n        dfs(grid, 0, j)\n    # 下邊界\n    if grid[n - 1][j] == 1 and not visited[n - 1][j]: \n        visited[n - 1][j] = True\n        dfs(grid, n - 1, j)\n    \nfor i in range(n):\n    # 左邊界\n    if grid[i][0] == 1 and not visited[i][0]: \n        visited[i][0] = True\n        dfs(grid, i, 0)\n    # 右邊界\n    if grid[i][m - 1] == 1 and not visited[i][m - 1]: \n        visited[i][m - 1] = True\n        dfs(grid, i, m - 1)\n    \n# 計算孤島總面積\nresult = 0  # 初始化，避免使用到處理邊界時所產生的累加值\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            visited[i][j] = True\n            dfs(grid, i, j)\n\n# 輸出孤島的總面積\nprint(result)"
}