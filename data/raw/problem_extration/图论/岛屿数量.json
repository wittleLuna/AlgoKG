{
  "id": "AP_b5cb841a",
  "title": "岛屿数量",
  "alternative_titles": [],
  "platform": "kamacoder",
  "url": "https://kamacoder.com/problempage.php?pid=1171",
  "description": "一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。\n\n输入描述：\n\n第一行包含两个整数 N, M，表示矩阵的行数和列数。\n\n后续 N 行，每行包含 M 个数字，数字为 1 或者 0。\n\n输出描述：\n\n输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。\n\n输入",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "深度优先搜索",
    "广度优先搜索",
    "并查集"
  ],
  "data_structure_tags": [
    "二维数组",
    "布尔型标记数组"
  ],
  "technique_tags": [
    "递归",
    "图遍历",
    "队列"
  ],
  "difficulty": null,
  "solution_approach": "使用DFS或BFS算法遍历矩阵中的每个未访问过的陆地节点，将与之相连的所有陆地标记为已访问。每当遇到一个新的未访问过的陆地时，岛屿计数器加一。关键在于如何避免重复访问同一个节点，这可以通过在加入队列时立即标记节点已被访问来实现。",
  "key_insights": [
    {
      "content": "岛屿由水平或垂直方向上相邻的陆地组成，斜向连接不算作同一岛屿。"
    },
    {
      "content": "在版本一中，通过在外层判断合法性来避免不必要的递归调用；而在版本二中，则是在递归函数内部直接加入终止条件（如遇到海水或已经访问过的节点）。"
    },
    {
      "content": "对于BFS，重要的是在节点加入队列时就标记为已访问，而不是从队列取出时再标记，以防止重复添加节点导致超时。"
    },
    {
      "content": "此题可以采用多种方法求解，包括但不限于DFS、BFS和并查集，但核心思想都是遍历所有连通的陆地区域。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "注意题目中每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的DFS解决岛屿数量问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的DFS解决岛屿数量问题，带终止条件"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的DFS解决岛屿数量问题"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本的DFS解决岛屿数量问题"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本的DFS解决岛屿数量问题，带终止条件"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                bfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的BFS解决岛屿数量问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的BFS解决岛屿数量问题"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的BFS解决岛屿数量问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "深度优先搜索",
      "text": "以下代码使用dfs实现，如果对dfs不太了解的话，建议按照代码随想录的讲解顺序学习。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的DFS实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的DFS实现，带有终止条件"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的DFS实现"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本的DFS实现"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本的DFS实现，带有终止条件"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 没有访问过的 同时 是陆地的\n\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本一：使用DFS计算岛屿数量"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本二：使用DFS计算岛屿数量"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本：使用DFS计算岛屿数量"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本一：使用DFS计算岛屿数量"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本二：使用DFS计算岛屿数量"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本：使用BFS计算岛屿数量"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};//下右上左逆时针遍历\n\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本：使用BFS计算岛屿数量"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本：使用BFS计算岛屿数量"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "使用深度优先搜索(DFS)计算岛屿数量的C++实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "使用深度优先搜索(DFS)计算岛屿数量的另一种C++实现"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "使用深度优先搜索(DFS)计算岛屿数量的Java实现"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "使用深度优先搜索(DFS)计算岛屿数量的Python实现"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "使用深度优先搜索(DFS)计算岛屿数量的另一种Python实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                bfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "使用广度优先搜索(BFS)计算岛屿数量的C++实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "使用广度优先搜索(BFS)计算岛屿数量的Java实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "使用广度优先搜索(BFS)计算岛屿数量的Python实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 没有访问过的 同时 是陆地的\n\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本一：使用深度优先搜索(DFS)计算岛屿数量。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本二：使用深度优先搜索(DFS)计算岛屿数量，带有终止条件。"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本：使用深度优先搜索(DFS)计算岛屿数量。"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本一：使用深度优先搜索(DFS)计算岛屿数量。"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本二：使用深度优先搜索(DFS)计算岛屿数量，带有终止条件。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本：使用广度优先搜索(BFS)计算岛屿数量。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n    static class pair{\n        int first, second;\n        pair(int first, int second){\n            this.first = first;\n            this.second = second;\n        }\n    }\n}",
          "description": "Java版本：使用广度优先搜索(BFS)计算岛屿数量。"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本：使用广度优先搜索(BFS)计算岛屿数量。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 没有访问过的 同时 是陆地的\n\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本一：使用DFS计算岛屿数量"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本二：使用DFS计算岛屿数量"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本：使用DFS计算岛屿数量"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本一：使用DFS计算岛屿数量"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本二：使用DFS计算岛屿数量"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本：使用BFS计算岛屿数量"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};//下右上左逆时针遍历\n\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}\nclass pair {\n    int first, second;\n    public pair(int first, int second) {\n        this.first = first;\n        this.second = second;\n    }\n}",
          "description": "Java版本：使用BFS计算岛屿数量"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本：使用BFS计算岛屿数量"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "其实本题是 dfs，bfs 模板题，但正是因为是模板题，所以大家或者一些题解把重要的细节都很忽略了，我这里把大家没注意的但以后会踩的坑 都给列出来了。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; \nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  \n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++;\n                dfs(grid, visited, i, j); \n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的深度优先搜索实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; \nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return; \n    visited[x][y] = true; \n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  \n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                dfs(grid, visited, i, j); \n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的另一种深度优先搜索实现，包含终止条件"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的深度优先搜索实现"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  \ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本的深度优先搜索实现"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  \ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本的另一种深度优先搜索实现，包含终止条件"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; \nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true; \n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  \n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true; \n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                bfs(grid, visited, i, j); \n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的广度优先搜索实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的广度优先搜索实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的广度优先搜索实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的深度优先搜索方法解决岛屿数量问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的另一种深度优先搜索方法解决岛屿数量问题"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的深度优先搜索方法解决岛屿数量问题"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本的一种深度优先搜索方法解决岛屿数量问题"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本的另一种深度优先搜索方法解决岛屿数量问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                bfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的广度优先搜索方法解决岛屿数量问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的广度优先搜索方法解决岛屿数量问题"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的广度优先搜索方法解决岛屿数量问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "import java.util.Scanner;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 没有访问过的 同时 是陆地的\n\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "使用DFS计算岛屿数量的C++代码"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "另一种使用DFS（带终止条件）计算岛屿数量的C++代码"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "使用DFS计算岛屿数量的Java代码"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "使用DFS计算岛屿数量的Python代码版本一"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "使用DFS（带终止条件）计算岛屿数量的Python代码版本二"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "使用BFS计算岛屿数量的C++代码"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n    static class pair {\n        int first, second;\n        pair(int f, int s) {\n            first = f;\n            second = s;\n        }\n    }\n}",
          "description": "使用BFS计算岛屿数量的Java代码"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "使用BFS计算岛屿数量的Python代码"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "版本一",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的DFS解决岛屿数量问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本二的DFS解决岛屿数量问题，具有更明显的终止条件"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的DFS解决岛屿数量问题"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本一的DFS解决岛屿数量问题"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本二的DFS解决岛屿数量问题，具有明确的终止条件"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                bfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的BFS解决岛屿数量问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n    static class pair{\n        int first, second;\n        pair(int first, int second){\n            this.first = first;\n            this.second = second;\n        }\n    }\n}",
          "description": "Java版本的BFS解决岛屿数量问题"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的BFS解决岛屿数量问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "广度优先搜索",
      "text": "如果不熟悉广搜，建议先看 广搜理论基础。 https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%BF%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "版本一的C++代码实现，用于计算岛屿数量。"
        },
        {
          "language": "C++",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "版本二的C++代码实现，用于计算岛屿数量。"
        },
        {
          "language": "Java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的代码实现，用于计算岛屿数量。"
        },
        {
          "language": "Python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本一的代码实现，用于计算岛屿数量。"
        },
        {
          "language": "Python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本二的代码实现，用于计算岛屿数量。"
        },
        {
          "language": "C++",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                bfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的广度优先搜索实现，用于计算岛屿数量。"
        },
        {
          "language": "Java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n    static class pair {\n        int first, second;\n        pair(int a, int b) {\n            this.first = a;\n            this.second = b;\n        }\n    }\n}",
          "description": "Java版本的广度优先搜索实现，用于计算岛屿数量。"
        },
        {
          "language": "Python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的广度优先搜索实现，用于计算岛屿数量。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的深度优先搜索解决岛屿数量问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本二的深度优先搜索解决岛屿数量问题"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的深度优先搜索解决岛屿数量问题"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本一的深度优先搜索解决岛屿数量问题"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本二的深度优先搜索解决岛屿数量问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                bfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的广度优先搜索解决岛屿数量问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n    static class pair {\n        int first, second;\n        pair(int f, int s) { first = f; second = s; }\n    }\n}",
          "description": "Java版本的广度优先搜索解决岛屿数量问题"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的广度优先搜索解决岛屿数量问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 没有访问过的 同时 是陆地的\n\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本一：使用深度优先搜索计算岛屿数量。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本二：使用深度优先搜索计算岛屿数量，包含明确终止条件。"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本：使用深度优先搜索计算岛屿数量。"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本一：使用深度优先搜索计算岛屿数量。"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本二：使用深度优先搜索计算岛屿数量，包含明确终止条件。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本：使用广度优先搜索计算岛屿数量。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};//下右上左逆时针遍历\n\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}\nclass pair{\n    int first, second;\n    public pair(int first, int second){\n        this.first = first;\n        this.second = second;\n    }\n}",
          "description": "Java版本：使用广度优先搜索计算岛屿数量。"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本：使用广度优先搜索计算岛屿数量。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <queue>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++深度优先搜索实现岛屿数量计算"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "改进版C++深度优先搜索实现岛屿数量计算"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java深度优先搜索实现岛屿数量计算"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本一深度优先搜索实现岛屿数量计算"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本二深度优先搜索实现岛屿数量计算"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                bfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++广度优先搜索实现岛屿数量计算"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}\nclass pair {\n    int first, second;\n    public pair(int first, int second) {\n        this.first = first;\n        this.second = second;\n    }\n}",
          "description": "Java广度优先搜索实现岛屿数量计算"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python广度优先搜索实现岛屿数量计算"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "c++",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 没有访问过的 同时 是陆地的\n\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的深度优先搜索实现岛屿数量计算。"
        },
        {
          "language": "c++",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的另一种深度优先搜索实现岛屿数量计算。"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的深度优先搜索实现岛屿数量计算。"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本的一种深度优先搜索实现岛屿数量计算。"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本的另一种深度优先搜索实现岛屿数量计算。"
        },
        {
          "language": "c++",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的广度优先搜索实现岛屿数量计算。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};//下右上左逆时针遍历\n\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的广度优先搜索实现岛屿数量计算。"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的广度优先搜索实现岛屿数量计算。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "import java.util.Scanner;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的DFS算法实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本带有终止条件的DFS算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的DFS算法实现"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本的DFS算法实现"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本带有终止条件的DFS算法实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                bfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的BFS算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}\nclass pair{\n    int first;\n    int second;\n    public pair(int first, int second) {\n        this.first = first;\n        this.second = second;\n    }\n}",
          "description": "Java版本的BFS算法实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的BFS算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "版本一",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的深度优先搜索实现，用于计算给定矩阵中的岛屿数量。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本二的深度优先搜索实现，增加了终止条件，用于计算给定矩阵中的岛屿数量。"
        },
        {
          "language": "java",
          "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid){\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nexty]==1){\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1){\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
          "description": "Java版本的深度优先搜索实现，用于计算给定矩阵中的岛屿数量。"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本一的深度优先搜索实现，用于计算给定矩阵中的岛屿数量。"
        },
        {
          "language": "python",
          "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n    print(res)",
          "description": "Python版本二的深度优先搜索实现，增加了终止条件，用于计算给定矩阵中的岛屿数量。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true;\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++;\n                bfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
          "description": "C++版本的广度优先搜索实现，用于计算给定矩阵中的岛屿数量。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();\n        queue.add(new pair(x, y));\n        visited[x][y] = true;\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;\n            for (int i = 0; i < 4; i++) {\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}\nclass pair{\n    int first, second;\n    public pair(int f, int s) {\n        first = f;\n        second = s;\n    }\n}",
          "description": "Java版本的广度优先搜索实现，用于计算给定矩阵中的岛屿数量。"
        },
        {
          "language": "python",
          "code": "from collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的广度优先搜索实现，用于计算给定矩阵中的岛屿数量。"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++;\n                dfs(grid, visited, i, j);\n            }\n        }\n    }\n\n    cout << result << endl;\n}",
      "description": "使用深度优先搜索(DFS)方法计算岛屿数量"
    },
    {
      "language": "java",
      "code": "import java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}",
      "description": "Java版本的深度优先搜索(DFS)算法实现，用于计算矩阵中的岛屿数量"
    },
    {
      "language": "python",
      "code": "direction = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef dfs(grid, visited, x, y):\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    print(res)",
      "description": "Python版本的深度优先搜索(DFS)算法实现，用以计算给定二维数组中的岛屿数目"
    }
  ],
  "common_mistakes": [
    "忽略边界检查导致数组越界错误。",
    "仅考虑正方形网格而非矩形网格的情况。",
    "忘记更新访问状态导致无限循环。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240516111613.png",
      "description": "这张图片展示了一个二维数组（矩阵），其中包含多个子矩阵，每个子矩阵由连续的1组成，红色边框标出了这些子矩阵的边界，体现了图像分割或连通区域检测的算法思想。",
      "context": "该图片展示了如何根据给定的矩阵计算岛屿数量，其中每个1代表陆地，0代表水域，帮助理解题目中提到的岛屿计数规则。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20220726094200.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20220726094200.png",
      "context": "该图片展示了三个独立的岛屿，用以说明即使陆地单元格在对角线上相邻也不被视为同一岛屿的一部分。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20220726094200.png",
      "description": "这张图片展示了一个二维数组（矩阵）的示例，其中包含“1”和“0”，用于算法问题（如岛屿数量问题）的分析，右侧代码注释提示了相关解题思路。",
      "context": "该图片展示了通过水平和竖直方向连接形成的三个独立岛屿，用于说明即使在斜向相邻的情况下，这些陆地仍被视为分离的岛屿。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20250124094043.png",
      "description": "这张图片展示了使用广度优先搜索（BFS）算法在二维数组中进行遍历的过程，逐步将符合条件的元素加入队列并标记已访问状态。",
      "context": "该图片展示了当从队列中取出节点后再标记为已访问时，导致的重复加入队列问题，从而解释了广度优先搜索中超时的原因。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240516111613.png",
      "description": "GIF展示了通过DFS算法遍历矩阵，标记并计数岛屿的过程。",
      "context": "GIF动画展示了如何通过DFS或BFS算法遍历矩阵以计算岛屿数量的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20220726094200.png",
      "description": "GIF展示了通过深度优先搜索（DFS）方法遍历网格以计算岛屿数量的过程。",
      "context": "GIF动画展示了如何通过深度优先搜索(DFS)方法遍历并标记相连的陆地，以计算给定地图上的岛屿总数。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20250124094043.png",
      "description": "GIF展示了广度优先搜索过程中，由于在节点从队列取出时才标记为已访问而导致的重复加入队列问题。",
      "context": "GIF动画展示了在广度优先搜索过程中，如果从队列中取出节点后再标记为已访问，则会导致许多节点被重复加入队列的情况。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\图论\\岛屿数量.txt",
  "extracted_at": "2025-07-21T15:13:08.598730",
  "raw_content": "岛屿数量\n卡码网题目链接（ACM模式）(https://kamacoder.com/problempage.php?pid=1171)\n\n题目描述：\n\n给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。\n\n输入描述：\n\n第一行包含两个整数 N, M，表示矩阵的行数和列数。\n\n后续 N 行，每行包含 M 个数字，数字为 1 或者 0。\n\n输出描述：\n\n输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。\n\n输入示例：\n\n4 5\n1 1 0 0 0\n1 1 0 0 0\n0 0 1 0 0\n0 0 0 1 1\n输出示例：\n\n3\n\n提示信息\nhttps://file1.kamacoder.com/i/algo/20240516111613.png\n\n\n根据测试案例中所展示，岛屿数量共有 3 个，所以输出 3。\n\n数据范围：\n\n1 <= N, M <= 50\n#思路\n\n注意题目中每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n\n也就是说斜角度链接是不算了， 例如示例二，是三个岛屿，如图：\n\nhttps://file1.kamacoder.com/i/algo/20220726094200.png\n\n这道题题目是 DFS，BFS，并查集，基础题目。\n\n本题思路，是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。\n\n在遇到标记过的陆地节点和海洋节点的时候直接跳过。 这样计数器就是最终岛屿的数量。\n\n那么如何把节点陆地所能遍历到的陆地都标记上呢，就可以使用 DFS，BFS或者并查集。\n\n#深度优先搜索\n以下代码使用dfs实现，如果对dfs不太了解的话，建议按照代码随想录的讲解顺序学习。\n\nC++代码如下：\n\n// 版本一 \n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 没有访问过的 同时 是陆地的\n\n            visited[nextx][nexty] = true;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                visited[i][j] = true;\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n\n    cout << result << endl;\n}\n很多录友可能有疑惑，为什么 以上代码中的dfs函数，没有终止条件呢？ 感觉递归没有终止很危险。\n\n其实终止条件 就写在了 调用dfs的地方，如果遇到不合法的方向，直接不会去调用dfs。\n\n当然也可以这么写：\n\n// 版本二\n#include <iostream>\n#include <vector>\nusing namespace std;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n    cout << result << endl;\n}\n这里大家应该能看出区别了，无疑就是版本一中 调用dfs 的条件判断 放在了 版本二 的 终止条件位置上。\n\n版本一的写法是 ：下一个节点是否能合法已经判断完了，传进dfs函数的就是合法节点。\n\n版本二的写法是：不管节点是否合法，上来就dfs，然后在终止条件的地方进行判断，不合法再return。\n\n理论上来讲，版本一的效率更高一些，因为避免了 没有意义的递归调用，在调用dfs之前，就做合法性判断。 但从写法来说，可能版本二 更利于理解一些。（不过其实都差不太多）\n\n很多同学看了同一道题目，都是dfs，写法却不一样，有时候有终止条件，有时候连终止条件都没有，其实这就是根本原因，两种写法而已。\n\n#总结\n其实本题是 dfs，bfs 模板题，但正是因为是模板题，所以大家或者一些题解把重要的细节都很忽略了，我这里把大家没注意的但以后会踩的坑 都给列出来了。\n\n本篇我只给出的dfs的写法，大家发现我写的还是比较细的，那么后面我再单独给出本题的bfs写法，虽然是模板题，但依然有很多注意的点，敬请期待！\n\n#其他语言版本\n#Java\nimport java.util.Scanner;\n\npublic class Main {\n    public static int[][] dir ={{0,1},{1,0},{-1,0},{0,-1}};\n    public static void dfs(boolean[][] visited,int x,int y ,int [][]grid)\n    {\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextY<0||nextX<0||nextX>= grid.length||nextY>=grid[0].length)\n                continue;\n            if(!visited[nextX][nextY]&&grid[nextX][nextY]==1)\n            {\n                visited[nextX][nextY]=true;\n                dfs(visited,nextX,nextY,grid);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m= sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j]=sc.nextInt();\n            }\n        }\n        boolean[][]visited =new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(!visited[i][j]&&grid[i][j]==1)\n                {\n                    ans++;\n                    visited[i][j]=true;\n                    dfs(visited,i,j,grid);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}\n\n#Python\n版本一\n\ndirection = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\n\n\ndef dfs(grid, visited, x, y):\n    \"\"\"\n    对一块陆地进行深度优先遍历并标记\n    \"\"\"\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        # 下标越界，跳过\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        # 未访问的陆地，标记并调用深度优先搜索\n        if not visited[next_x][next_y] and grid[next_x][next_y] == 1:\n            visited[next_x][next_y] = True\n            dfs(grid, visited, next_x, next_y)\n\n\nif __name__ == '__main__':  \n    # 版本一\n    n, m = map(int, input().split())\n    \n    # 邻接矩阵\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    \n    # 访问表\n    visited = [[False] * m for _ in range(n)]\n    \n    res = 0\n    for i in range(n):\n        for j in range(m):\n            # 判断：如果当前节点是陆地，res+1并标记访问该节点，使用深度搜索标记相邻陆地。\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                visited[i][j] = True\n                dfs(grid, visited, i, j)\n    \n    print(res)\n版本二\n\ndirection = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向：上、右、下、左\n\n\ndef dfs(grid, visited, x, y):\n    \"\"\"\n    对一块陆地进行深度优先遍历并标记\n    \"\"\"\n    # 与版本一的差别，在调用前增加判断终止条件\n    if visited[x][y] or grid[x][y] == 0:\n        return\n    visited[x][y] = True\n\n    for i, j in direction:\n        next_x = x + i\n        next_y = y + j\n        # 下标越界，跳过\n        if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n            continue\n        # 由于判断条件放在了方法首部，此处直接调用dfs方法\n        dfs(grid, visited, next_x, next_y)\n\n\nif __name__ == '__main__':\n    # 版本二\n    n, m = map(int, input().split())\n\n    # 邻接矩阵\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n\n    # 访问表\n    visited = [[False] * m for _ in range(n)]\n\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            # 判断：如果当前节点是陆地，res+1并标记访问该节点，使用深度搜索标记相邻陆地。\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                dfs(grid, visited, i, j)\n\n    print(res)\n\n思路\n\n注意题目中每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n\n也就是说斜角度链接是不算了， 例如示例二，是三个岛屿，如图：\n\nhttps://file1.kamacoder.com/i/algo/20220726094200.png\n\n这道题题目是 DFS，BFS，并查集，基础题目。\n\n本题思路:遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。\n\n再遇到标记过的陆地节点和海洋节点的时候直接跳过。 这样计数器就是最终岛屿的数量。\n\n那么如果把节点陆地所能遍历到的陆地都标记上呢，就可以使用 DFS，BFS或者并查集。\n\n#广度优先搜索\n如果不熟悉广搜，建议先看 广搜理论基础。 https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%BF%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html\n\n不少同学用广搜做这道题目的时候，超时了。 这里有一个广搜中很重要的细节：\n\n根本原因是只要 加入队列就代表 走过，就需要标记，而不是从队列拿出来的时候再去标记走过。\n\n很多同学可能感觉这有区别吗？\n\n如果从队列拿出节点，再去标记这个节点走过，就会发生下图所示的结果，会导致很多节点重复加入队列。\n\nhttps://file1.kamacoder.com/i/algo/20250124094043.png\n\n超时写法 （从队列中取出节点再标记，注意代码注释的地方）\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        visited[curx][cury] = true; // 从队列中取出在标记走过\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == '1') {\n                que.push({nextx, nexty});\n            }\n        }\n    }\n\n}\n加入队列 就代表走过，立刻标记，正确写法： （注意代码注释的地方）\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == '1') {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true; // 只要加入队列立刻标记\n            }\n        }\n    }\n\n}\n以上两个版本其实，其实只有细微区别，就是 visited[x][y] = true; 放在的地方，这取决于我们对 代码中队列的定义，队列中的节点就表示已经走过的节点。 所以只要加入队列，立即标记该节点走过。\n\n本题完整广搜代码：\n\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    queue<pair<int, int>> que;\n    que.push({x, y});\n    visited[x][y] = true; // 只要加入队列，立刻标记\n    while(!que.empty()) {\n        pair<int ,int> cur = que.front(); que.pop();\n        int curx = cur.first;\n        int cury = cur.second;\n        for (int i = 0; i < 4; i++) {\n            int nextx = curx + dir[i][0];\n            int nexty = cury + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                que.push({nextx, nexty});\n                visited[nextx][nexty] = true; // 只要加入队列立刻标记\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                result++; // 遇到没访问过的陆地，+1\n                bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n            }\n        }\n    }\n\n\n    cout << result << endl;\n}\n\n#其他语言版本\n#Java\nimport java.util.*;\n\npublic class Main {\n    public static int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};//下右上左逆时针遍历\n\n    public static void bfs(int[][] grid, boolean[][] visited, int x, int y) {\n        Queue<pair> queue = new LinkedList<pair>();//定义坐标队列，没有现成的pair类，在下面自定义了\n        queue.add(new pair(x, y));\n        visited[x][y] = true;//遇到入队直接标记为优先，\n        // 否则出队时才标记的话会导致重复访问，比如下方节点会在右下顺序的时候被第二次访问入队\n        while (!queue.isEmpty()) {\n            int curX = queue.peek().first;\n            int curY = queue.poll().second;//当前横纵坐标\n            for (int i = 0; i < 4; i++) {\n                //顺时针遍历新节点next，下面记录坐标\n                int nextX = curX + dir[i][0];\n                int nextY = curY + dir[i][1];\n                if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length) {\n                    continue;\n                }//去除越界部分\n                if (!visited[nextX][nextY] && grid[nextX][nextY] == 1) {\n                    queue.add(new pair(nextX, nextY));\n                    visited[nextX][nextY] = true;//逻辑同上\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int[][] grid = new int[m][n];\n        boolean[][] visited = new boolean[m][n];\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    ans++;\n                    bfs(grid, visited, i, j);\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}\n#Python\n\nfrom collections import deque\ndirections = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ndef bfs(grid, visited, x, y):\n    que = deque([])\n    que.append([x,y])\n    visited[x][y] = True\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in directions:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_y < 0 or next_x < 0 or next_x >= len(grid) or next_y >= len(grid[0]):\n                continue\n            if not visited[next_x][next_y] and grid[next_x][next_y] == 1: \n                visited[next_x][next_y] = True\n                que.append([next_x, next_y])\n\n\ndef main():\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, input().split())))\n    visited = [[False] * m for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and not visited[i][j]:\n                res += 1\n                bfs(grid, visited, i, j)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()"
}