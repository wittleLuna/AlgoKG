{
  "id": "AP_0bbb574f",
  "title": "最长递增子序列",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/longest-increasing-subsequence/",
  "description": "一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n\n子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "Dynamic Programming"
  ],
  "data_structure_tags": [
    "Array"
  ],
  "technique_tags": [
    "Memoization",
    "State Transition"
  ],
  "difficulty": null,
  "solution_approach": "通过动态规划的方式解决最长递增子序列问题。定义dp[i]为以nums[i]结尾的最长递增子序列长度，利用状态转移方程dp[i] = max(dp[i], dp[j] + 1) for j in [0, i-1] if nums[i] > nums[j]来计算每一个位置i的最大递增子序列长度，并最终返回整个数组中dp[i]的最大值。",
  "key_insights": [
    {
      "content": "dp[i]表示以nums[i]结尾的最长递增子序列长度是关键。这样的定义确保了可以基于之前的状态（dp[j]）构建当前状态（dp[i]），并且直接比较nums[i]与前面所有元素的关系来决定是否能形成更长的递增子序列。"
    },
    {
      "content": "使用if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1)作为状态转移方程，能够有效地从较短的递增子序列扩展到更长的序列。这里的关键在于只当新的数大于旧序列尾部时才尝试延长子序列。"
    },
    {
      "content": "遍历顺序是从前向后遍历i，对于每个i，再从前向后遍历j，这样保证了每次更新dp[i]时都已经考虑了所有可能的子序列。"
    },
    {
      "content": "通过维护一个result变量记录过程中遇到的最大dp[i]值，可以在遍历结束后直接得到最长递增子序列的长度。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "首先通过本题大家要明确什么是子序列，“子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序”。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lengthOfLIS(vector<int>& nums) {if (nums.size() <= 1) return nums.size();vector<int> dp(nums.size(), 1);int result = 0;for (int i = 1; i < nums.size(); i++) {for (int j = 0; j < i; j++) {if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);}if (dp[i] > result) result = dp[i];}return result;}};",
          "description": "C++实现的最长递增子序列问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int lengthOfLIS(int[] nums) {if (nums.length <= 1) return nums.length;int[] dp = new int[nums.length];int res = 1;Arrays.fill(dp, 1);for (int i = 1; i < dp.length; i++) {for (int j = 0; j < i; j++) {if (nums[i] > nums[j]) {dp[i] = Math.max(dp[i], dp[j] + 1);}}res = Math.max(res, dp[i]);}return res;}}",
          "description": "Java实现的最长递增子序列问题"
        },
        {
          "language": "python",
          "code": "class Solution: def lengthOfLIS(self, nums: List[int]) -> int: if len(nums) <= 1: return len(nums) dp = [1] * len(nums) result = 1 for i in range(1, len(nums)): for j in range(0, i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) result = max(result, dp[i]) return result",
          "description": "Python实现的动态规划方法求解最长递增子序列问题"
        },
        {
          "language": "python",
          "code": "class Solution: def lengthOfLIS(self, nums: List[int]) -> int: if len(nums) <= 1: return len(nums) tails = [nums[0]] for num in nums[1:]: if num > tails[-1]: tails.append(num) else: left, right = 0, len(tails) - 1 while left < right: mid = (left + right) // 2 if tails[mid] < num: left = mid + 1 else: right = mid tails[left] = num return len(tails)",
          "description": "Python实现的贪心算法+二分查找求解最长递增子序列问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "本题最关键的是要想到dp[i]由哪些状态可以推出来，并取最大值，那么很自然就能想到递推公式：dp[i] = max(dp[i], dp[j] + 1);",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lengthOfLIS(vector<int>& nums) {if (nums.size() <= 1) return nums.size();vector<int> dp(nums.size(), 1);int result = 0;for (int i = 1; i < nums.size(); i++) {for (int j = 0; j < i; j++) {if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);}if (dp[i] > result) result = dp[i];}return result;}};",
          "description": "C++实现的最长递增子序列问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int lengthOfLIS(int[] nums) {if (nums.length <= 1) return nums.length;int[] dp = new int[nums.length];int res = 1;Arrays.fill(dp, 1);for (int i = 1; i < dp.length; i++) {for (int j = 0; j < i; j++) {if (nums[i] > nums[j]) {dp[i] = Math.max(dp[i], dp[j] + 1);}}res = Math.max(res, dp[i]);}return res;}}",
          "description": "Java实现的最长递增子序列问题"
        },
        {
          "language": "python",
          "code": "class Solution: def lengthOfLIS(self, nums: List[int]) -> int: if len(nums) <= 1: return len(nums) dp = [1] * len(nums) result = 1 for i in range(1, len(nums)): for j in range(0, i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) result = max(result, dp[i]) return result",
          "description": "Python实现的动态规划版本的最长递增子序列问题"
        },
        {
          "language": "python",
          "code": "class Solution: def lengthOfLIS(self, nums: List[int]) -> int: if len(nums) <= 1: return len(nums) tails = [nums[0]] for num in nums[1:]: if num > tails[-1]: tails.append(num) else: left, right = 0, len(tails) - 1 while left < right: mid = (left + right) // 2 if tails[mid] < num: left = mid + 1 else: right = mid tails[left] = num return len(tails)",
          "description": "Python实现的贪心算法版本的最长递增子序列问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lengthOfLIS(vector<int>& nums) {if (nums.size() <= 1) return nums.size();vector<int> dp(nums.size(), 1);int result = 0;for (int i = 1; i < nums.size(); i++) {for (int j = 0; j < i; j++) {if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);}if (dp[i] > result) result = dp[i];}return result;}};",
          "description": "C++实现的最长递增子序列解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public int lengthOfLIS(int[] nums) {if (nums.length <= 1) return nums.length;int[] dp = new int[nums.length];int res = 1;Arrays.fill(dp, 1);for (int i = 1; i < dp.length; i++) {for (int j = 0; j < i; j++) {if (nums[i] > nums[j]) {dp[i] = Math.max(dp[i], dp[j] + 1);}}res = Math.max(res, dp[i]);}return res;}}",
          "description": "Java实现的最长递增子序列解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def lengthOfLIS(self, nums: List[int]) -> int: if len(nums) <= 1: return len(nums) dp = [1] * len(nums) result = 1 for i in range(1, len(nums)): for j in range(0, i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) result = max(result, dp[i]) return result",
          "description": "Python使用动态规划实现的最长递增子序列解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def lengthOfLIS(self, nums: List[int]) -> int: if len(nums) <= 1: return len(nums) tails = [nums[0]] for num in nums[1:]: if num > tails[-1]: tails.append(num) else: left, right = 0, len(tails) - 1 while left < right: mid = (left + right) // 2 if tails[mid] < num: left = mid + 1 else: right = mid tails[left] = num return len(tails)",
          "description": "Python使用贪心算法结合二分查找实现的最长递增子序列解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lengthOfLIS(vector<int>& nums) {if (nums.size() <= 1) return nums.size(); vector<int> dp(nums.size(), 1); int result = 0; for (int i = 1; i < nums.size(); i++) {for (int j = 0; j < i; j++) {if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);} if (dp[i] > result) result = dp[i];} return result;}};",
          "description": "C++实现的最长递增子序列问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int lengthOfLIS(int[] nums) {if (nums.length <= 1) return nums.length; int[] dp = new int[nums.length]; int res = 1; Arrays.fill(dp, 1); for (int i = 1; i < dp.length; i++) {for (int j = 0; j < i; j++) {if (nums[i] > nums[j]) {dp[i] = Math.max(dp[i], dp[j] + 1);}} res = Math.max(res, dp[i]);} return res;}}",
          "description": "Java实现的最长递增子序列问题"
        },
        {
          "language": "python",
          "code": "class Solution: def lengthOfLIS(self, nums: List[int]) -> int: if len(nums) <= 1: return len(nums) dp = [1] * len(nums) result = 1 for i in range(1, len(nums)): for j in range(0, i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) result = max(result, dp[i]) return result",
          "description": "Python实现的最长递增子序列问题（动态规划法）"
        },
        {
          "language": "python",
          "code": "class Solution: def lengthOfLIS(self, nums: List[int]) -> int: if len(nums) <= 1: return len(nums) tails = [nums[0]] for num in nums[1:]: if num > tails[-1]: tails.append(num) else: left, right = 0, len(tails) - 1 while left < right: mid = (left + right) // 2 if tails[mid] < num: left = mid + 1 else: right = mid tails[left] = num return len(tails)",
          "description": "Python实现的最长递增子序列问题（贪心+二分查找法）"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "DP",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lengthOfLIS(vector<int>& nums) {if (nums.size() <= 1) return nums.size();vector<int> dp(nums.size(), 1);int result = 0;for (int i = 1; i < nums.size(); i++) {for (int j = 0; j < i; j++) {if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);}if (dp[i] > result) result = dp[i];}return result;}};",
          "description": "C++实现的最长递增子序列"
        },
        {
          "language": "java",
          "code": "class Solution {public int lengthOfLIS(int[] nums) {if (nums.length <= 1) return nums.length;int[] dp = new int[nums.length];int res = 1;Arrays.fill(dp, 1);for (int i = 1; i < dp.length; i++) {for (int j = 0; j < i; j++) {if (nums[i] > nums[j]) {dp[i] = Math.max(dp[i], dp[j] + 1);}}res = Math.max(res, dp[i]);}return res;}}",
          "description": "Java实现的最长递增子序列"
        },
        {
          "language": "python",
          "code": "class Solution: def lengthOfLIS(self, nums: List[int]) -> int: if len(nums) <= 1: return len(nums) dp = [1] * len(nums) result = 1 for i in range(1, len(nums)): for j in range(0, i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) result = max(result, dp[i]) return result",
          "description": "Python实现的最长递增子序列（动态规划方法）"
        },
        {
          "language": "python",
          "code": "class Solution: def lengthOfLIS(self, nums: List[int]) -> int: if len(nums) <= 1: return len(nums) tails = [nums[0]] for num in nums[1:]: if num > tails[-1]: tails.append(num) else: left, right = 0, len(tails) - 1 while left < right: mid = (left + right) // 2 if tails[mid] < num: left = mid + 1 else: right = mid tails[left] = num return len(tails)",
          "description": "Python实现的最长递增子序列（贪心+二分查找方法）"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int lengthOfLIS(vector<int>& nums) {if (nums.size() <= 1) return nums.size();vector<int> dp(nums.size(), 1);int result = 0;for (int i = 1; i < nums.size(); i++) {for (int j = 0; j < i; j++) {if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);}if (dp[i] > result) result = dp[i];}return result;}};",
      "description": "使用动态规划找到最长递增子序列长度"
    },
    {
      "language": "java",
      "code": "class Solution {public int lengthOfLIS(int[] nums) {if (nums.length <= 1) return nums.length;int[] dp = new int[nums.length];int res = 1;Arrays.fill(dp, 1);for (int i = 1; i < dp.length; i++) {for (int j = 0; j < i; j++) {if (nums[i] > nums[j]) {dp[i] = Math.max(dp[i], dp[j] + 1);}}res = Math.max(res, dp[i]);}return res;}}",
      "description": "Java实现，通过动态规划计算最长递增子序列"
    },
    {
      "language": "python",
      "code": "class Solution: def lengthOfLIS(self, nums: List[int]) -> int: if len(nums) <= 1: return len(nums) dp = [1] * len(nums) result = 1 for i in range(1, len(nums)): for j in range(0, i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) result = max(result, dp[i]) return result",
      "description": "Python版本的动态规划解法来找出最长递增子序列"
    },
    {
      "language": "python",
      "code": "class Solution: def lengthOfLIS(self, nums: List[int]) -> int: if len(nums) <= 1: return len(nums) tails = [nums[0]] for num in nums[1:]: if num > tails[-1]: tails.append(num) else: left, right = 0, len(tails) - 1 while left < right: mid = (left + right) // 2 if tails[mid] < num: left = mid + 1 else: right = mid tails[left] = num return len(tails)",
      "description": "Python贪心算法加二分查找实现最长递增子序列"
    }
  ],
  "common_mistakes": [
    "忽略了dp数组初始化应为1，因为每个元素自身至少构成一个长度为1的递增子序列。",
    "在更新dp[i]时直接赋值而不是取最大值，导致未能正确维护最长递增子序列长度。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210110170945618.jpg",
      "description": "这张图片展示了通过动态规划算法逐步更新数组元素的过程，以解决特定问题。",
      "context": "该图片展示了给定数组[0,1,0,3,2]作为输入时，动态规划数组dp的变化过程，帮助理解如何通过代码逐步计算最长递增子序列的长度。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210110170945618.jpg",
      "description": "GIF展示了通过遍历数组来更新动态规划数组dp的过程，以寻找最长递增子序列。",
      "context": "该GIF动画展示了给定数组[0,1,0,3,2]时，动态规划数组dp随算法执行过程中的变化情况。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\最长递增子序列.txt",
  "extracted_at": "2025-07-20T21:30:30.423493",
  "raw_content": "最长递增子序列\n力扣题目链接(https://leetcode.cn/problems/longest-increasing-subsequence/)\n\n给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n\n子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n\n示例 1：\n\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n示例 2：\n\n输入：nums = [0,1,0,3,2,3]\n输出：4\n示例 3：\n\n输入：nums = [7,7,7,7,7,7,7]\n输出：1\n提示：\n\n1 <= nums.length <= 2500\n-10^4 <= nums[i] <= 104\n\n\n#思路\n首先通过本题大家要明确什么是子序列，“子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序”。\n\n本题也是代码随想录中子序列问题的第一题，如果没接触过这种题目的话，本题还是很难的，甚至想暴力去搜索也不知道怎么搜。 子序列问题是动态规划解决的经典问题，当前下标i的递增子序列长度，其实和i之前的下标j的子序列长度有关系，那又是什么样的关系呢。\n\n接下来，我们依然用动规五部曲来详细分析一波：\n\ndp[i]的定义\n本题中，正确定义dp数组的含义十分重要。\n\ndp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度\n\n为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在 做 递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。\n\n状态转移方程\n位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。\n\n所以：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);\n\n注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值。\n\ndp[i]的初始化\n每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.\n\n确定遍历顺序\ndp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。\n\nj其实就是遍历0到i-1，那么是从前到后，还是从后到前遍历都无所谓，只要吧 0 到 i-1 的元素都遍历了就行了。 所以默认习惯 从前向后遍历。\n\n遍历i的循环在外层，遍历j则在内层，代码如下：\n\nfor (int i = 1; i < nums.size(); i++) {\n    for (int j = 0; j < i; j++) {\n        if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);\n    }\n    if (dp[i] > result) result = dp[i]; // 取长的子序列\n}\n举例推导dp数组\n输入：[0,1,0,3,2]，dp数组的变化如下：\n\nhttps://file1.kamacoder.com/i/algo/20210110170945618.jpg\n\n如果代码写出来，但一直AC不了，那么就把dp数组打印出来，看看对不对！\n\n以上五部分析完毕，C++代码如下：\n\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        if (nums.size() <= 1) return nums.size();\n        vector<int> dp(nums.size(), 1);\n        int result = 0;\n        for (int i = 1; i < nums.size(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);\n            }\n            if (dp[i] > result) result = dp[i]; // 取长的子序列\n        }\n        return result;\n    }\n};\n时间复杂度: O(n^2)\n空间复杂度: O(n)\n#总结\n本题最关键的是要想到dp[i]由哪些状态可以推出来，并取最大值，那么很自然就能想到递推公式：dp[i] = max(dp[i], dp[j] + 1);\n\n子序列问题是动态规划的一个重要系列，本题算是入门题目，好戏刚刚开始！\n\n#其他语言版本\n#Java：\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        if (nums.length <= 1) return nums.length;\n        int[] dp = new int[nums.length];\n        int res = 1;\n        Arrays.fill(dp, 1);\n        for (int i = 1; i < dp.length; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n    }\n}\n#Python：\nDP\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        if len(nums) <= 1:\n            return len(nums)\n        dp = [1] * len(nums)\n        result = 1\n        for i in range(1, len(nums)):\n            for j in range(0, i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n            result = max(result, dp[i]) #取长的子序列\n        return result\n贪心\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        if len(nums) <= 1:\n            return len(nums)\n        \n        tails = [nums[0]]  # 存储递增子序列的尾部元素\n        for num in nums[1:]:\n            if num > tails[-1]:\n                tails.append(num)  # 如果当前元素大于递增子序列的最后一个元素，直接加入到子序列末尾\n            else:\n                # 使用二分查找找到当前元素在递增子序列中的位置，并替换对应位置的元素\n                left, right = 0, len(tails) - 1\n                while left < right:\n                    mid = (left + right) // 2\n                    if tails[mid] < num:\n                        left = mid + 1\n                    else:\n                        right = mid\n                tails[left] = num\n        \n        return len(tails)  # 返回递增子序列的长度"
}