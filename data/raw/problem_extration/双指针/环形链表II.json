{
  "id": "AP_f0857903",
  "title": "环形链表II",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/linked-list-cycle-ii/",
  "description": "题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n说明：不允许修改给定的链表。\n\nhttps://file1.kamacoder.com/i/algo/20200816110112704.png",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "双指针",
    "链表"
  ],
  "data_structure_tags": [
    "链表"
  ],
  "technique_tags": [
    "快慢指针"
  ],
  "difficulty": null,
  "solution_approach": "首先使用快慢指针法判断链表中是否存在环。如果存在环，则利用数学关系通过调整两个指针的位置找到环形入口。",
  "key_insights": [
    {
      "content": "快指针每次移动两步而慢指针每次仅移动一步，在环内，快指针相对于慢指针每轮循环靠近一个节点的距离，最终会在某个点相遇。"
    },
    {
      "content": "当快慢指针首次在环内相遇后，保持一个指针不动并从头结点开始另一个新的指针同时向前移动，两者相遇之处即为环的起点。"
    },
    {
      "content": "从起始点到环入口的距离等于从相遇点出发围绕环回到入口所需的距离，这是基于快慢指针相遇时所走过的节点数关系得出的结论。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "这道题目，不仅考察对链表的操作，而且还需要一些数学运算。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: ListNode *detectCycle(ListNode *head) {ListNode* fast = head;ListNode* slow = head;while(fast != NULL && fast->next != NULL) {slow = slow->next;fast = fast->next->next;if (slow == fast) {ListNode* index1 = fast;ListNode* index2 = head;while (index1 != index2) {index1 = index1->next;index2 = index2->next;}return index2;} }return NULL;}};",
          "description": "C++实现，使用快慢指针检测环的存在，并找到环的入口。"
        },
        {
          "language": "java",
          "code": "public class Solution {public ListNode detectCycle(ListNode head) {ListNode slow = head;ListNode fast = head;while (fast != null && fast.next != null) {slow = slow.next;fast = fast.next.next;if (slow == fast) {ListNode index1 = fast;ListNode index2 = head;while (index1 != index2) {index1 = index1.next;index2 = index2.next;}return index1;}}return null;}}",
          "description": "Java实现，逻辑与C++版本相同，使用快慢指针定位环的起点。"
        },
        {
          "language": "python",
          "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None",
          "description": "Python实现，采用快慢双指针法来查找链表中的环及其入口节点。"
        }
      ],
      "subsections": []
    },
    {
      "name": "判断链表是否有环",
      "text": "可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: ListNode *detectCycle(ListNode *head) {ListNode* fast = head;ListNode* slow = head;while(fast != NULL && fast->next != NULL) {slow = slow->next;fast = fast->next->next;if (slow == fast) {ListNode* index1 = fast;ListNode* index2 = head;while (index1 != index2) {index1 = index1->next;index2 = index2->next;}return index2;} }return NULL;}};",
          "description": "使用快慢指针法检测环形链表的入口节点"
        },
        {
          "language": "java",
          "code": "public class Solution {public ListNode detectCycle(ListNode head) {ListNode slow = head;ListNode fast = head;while (fast != null && fast.next != null) {slow = slow.next;fast = fast.next.next;if (slow == fast) {ListNode index1 = fast;ListNode index2 = head;while (index1 != index2) {index1 = index1.next;index2 = index2.next;}return index1;}} return null;}}",
          "description": "使用快慢指针法检测环形链表的入口节点"
        },
        {
          "language": "python",
          "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None",
          "description": "使用快慢指针法检测环形链表的入口节点"
        }
      ],
      "subsections": []
    },
    {
      "name": "如果有环，如何找到这个环的入口",
      "text": "此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: ListNode* detectCycle(ListNode* head) {ListNode* fast = head; ListNode* slow = head; while(fast != NULL && fast->next != NULL) {slow = slow->next; fast = fast->next->next;if (slow == fast) {ListNode* index1 = fast; ListNode* index2 = head;while (index1 != index2) {index1 = index1->next; index2 = index2->next;}return index2;}}return NULL;}};",
          "description": "使用快慢指针检测链表是否有环，并找到环的入口"
        },
        {
          "language": "java",
          "code": "public class Solution {public ListNode detectCycle(ListNode head) {ListNode slow = head; ListNode fast = head; while (fast != null && fast.next != null) {slow = slow.next; fast = fast.next.next;if (slow == fast) {ListNode index1 = fast; ListNode index2 = head;while (index1 != index2) {index1 = index1.next; index2 = index2.next;}return index1;}}return null;}}",
          "description": "Java版本，使用快慢指针检测链表是否有环，并找到环的入口"
        },
        {
          "language": "python",
          "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None",
          "description": "Python版本一，使用快慢指针检测链表是否有环，并找到环的入口"
        },
        {
          "language": "python",
          "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: visited = set() while head: if head in visited: return head visited.add(head) head = head.next return None",
          "description": "Python版本二，使用集合来检测链表是否有环，并找到环的入口"
        }
      ],
      "subsections": []
    },
    {
      "name": "补充",
      "text": "在推理过程中，大家可能有一个疑问就是：为什么第一次在环中相遇，slow的 步数 是 x+y 而不是 x + 若干环的长度 + y 呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != NULL && fast->next != NULL) { slow = slow->next; fast = fast->next->next; if (slow == fast) { ListNode* index1 = fast; ListNode* index2 = head; while (index1 != index2) { index1 = index1->next; index2 = index2->next; } return index2; } } return NULL; } };",
          "description": "使用快慢指针法检测链表中的环，并找到环的入口。"
        },
        {
          "language": "java",
          "code": "public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { ListNode index1 = fast; ListNode index2 = head; while (index1 != index2) { index1 = index1.next; index2 = index2.next; } return index1; } } return null; } }",
          "description": "使用快慢指针法检测链表中的环，并找到环的入口。"
        },
        {
          "language": "python",
          "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None",
          "description": "使用快慢指针法检测链表中的环，并找到环的入口。"
        },
        {
          "language": "python",
          "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: visited = set() while head: if head in visited: return head visited.add(head) head = head.next return None",
          "description": "通过集合记录访问过的节点来检测链表中的环，并找到环的入口。"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "这次可以说把环形链表这道题目的各个细节，完完整整的证明了一遍，说这是全网最详细讲解不为过吧。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: ListNode* detectCycle(ListNode* head) {ListNode* fast = head;ListNode* slow = head;while(fast != NULL && fast->next != NULL) {slow = slow->next;fast = fast->next->next;if (slow == fast) {ListNode* index1 = fast;ListNode* index2 = head;while (index1 != index2) {index1 = index1->next;index2 = index2->next;}return index2;}}return NULL;}};",
          "description": "C++版本的环形链表II解法"
        },
        {
          "language": "java",
          "code": "public class Solution {public ListNode detectCycle(ListNode head) {ListNode slow = head;ListNode fast = head;while (fast != null && fast.next != null) {slow = slow.next;fast = fast.next.next;if (slow == fast) {// 有环ListNode index1 = fast;ListNode index2 = head;// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口while (index1 != index2) {index1 = index1.next;index2 = index2.next;}return index1;}}return null;}}",
          "description": "Java版本的环形链表II解法"
        },
        {
          "language": "python",
          "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None",
          "description": "Python版本一（快慢指针法）的环形链表II解法"
        },
        {
          "language": "python",
          "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: visited = set() while head: if head in visited: return head visited.add(head) head = head.next return None",
          "description": "Python版本二（集合法）的环形链表II解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { ListNode index1 = fast; ListNode index2 = head; while (index1 != index2) { index1 = index1.next; index2 = index2.next; } return index1; } } return null; } }",
          "description": "使用快慢指针法检测链表中是否有环，并找到环的起始节点。"
        },
        {
          "language": "cpp",
          "code": "struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != NULL && fast->next != NULL) { slow = slow->next; fast = fast->next->next; if (slow == fast) { ListNode* index1 = fast; ListNode* index2 = head; while (index1 != index2) { index1 = index1->next; index2 = index2->next; } return index2; } } return NULL; } };",
          "description": "利用快慢指针确定链表中的环，并定位到环的入口节点。"
        },
        {
          "language": "python",
          "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None",
          "description": "通过移动两个指针，一个快一个慢，在链表中寻找环及其起始位置。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "public class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: ListNode* detectCycle(ListNode* head) {ListNode* fast = head;ListNode* slow = head;while(fast != NULL && fast->next != NULL) {slow = slow->next;fast = fast->next->next;if (slow == fast) {ListNode* index1 = fast;ListNode* index2 = head;while (index1 != index2) {index1 = index1->next;index2 = index2->next;}return index2;} }return NULL;}};",
          "description": "C++实现的环形链表II解决方案"
        },
        {
          "language": "java",
          "code": "public class Solution {public ListNode detectCycle(ListNode head) {ListNode slow = head;ListNode fast = head;while (fast != null && fast.next != null) {slow = slow.next;fast = fast.next.next;if (slow == fast) {ListNode index1 = fast;ListNode index2 = head;while (index1 != index2) {index1 = index1.next;index2 = index2.next;}return index1;}}return null;}}",
          "description": "Java实现的环形链表II解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None",
          "description": "Python版本一（快慢指针法）实现的环形链表II解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: visited = set() while head: if head in visited: return head visited.add(head) head = head.next return None",
          "description": "Python版本二（集合法）实现的环形链表II解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "（版本一）快慢指针法",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: ListNode *detectCycle(ListNode *head) {ListNode* fast = head;ListNode* slow = head;while(fast != NULL && fast->next != NULL) {slow = slow->next;fast = fast->next->next;if (slow == fast) {ListNode* index1 = fast;ListNode* index2 = head;while (index1 != index2) {index1 = index1->next;index2 = index2->next;}return index2;} }return NULL;}};",
          "description": "使用快慢指针法检测环形链表的入口"
        },
        {
          "language": "java",
          "code": "public class Solution {public ListNode detectCycle(ListNode head) {ListNode slow = head;ListNode fast = head;while (fast != null && fast.next != null) {slow = slow.next;fast = fast.next.next;if (slow == fast) {ListNode index1 = fast;ListNode index2 = head;while (index1 != index2) {index1 = index1.next;index2 = index2.next;}return index1;}}return null;}}",
          "description": "Java版本，使用快慢指针法来找到环形链表的入口"
        },
        {
          "language": "python",
          "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None",
          "description": "Python版本，采用快慢指针方法识别环形链表中的环入口"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n)",
    "space_complexity": "O(1)",
    "explanation": "快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n"
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: ListNode *detectCycle(ListNode *head) {ListNode* fast = head;ListNode* slow = head;while(fast != NULL && fast->next != NULL) {slow = slow->next;fast = fast->next->next;if (slow == fast) {ListNode* index1 = fast;ListNode* index2 = head;while (index1 != index2) {index1 = index1->next;index2 = index2->next;}return index2;} }return NULL;}};",
      "description": ""
    },
    {
      "language": "java",
      "code": "public class Solution {public ListNode detectCycle(ListNode head) {ListNode slow = head;ListNode fast = head;while (fast != null && fast.next != null) {slow = slow.next;fast = fast.next.next;if (slow == fast) {ListNode index1 = fast;ListNode index2 = head;while (index1 != index2) {index1 = index1.next;index2 = index2.next;}return index1;}}return null;}}",
      "description": ""
    },
    {
      "language": "python",
      "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None",
      "description": ""
    },
    {
      "language": "python",
      "code": "class Solution: def detectCycle(self, head: ListNode) -> ListNode: visited = set() while head: if head in visited: return head visited.add(head) head = head.next return None",
      "description": ""
    }
  ],
  "common_mistakes": [
    "未考虑到边缘情况如空链表或单元素链表。",
    "假设快慢指针一定在第一次环绕时相遇，实际上可能需要多次环绕才能相遇。",
    "忘记处理无环的情况，即确保程序能够正确返回null。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20200816110112704.png",
      "description": "这张图片展示了两个示例，描述了如何检测链表中的环及其连接点，涉及链表数据结构和相关算法。",
      "context": "该图片展示了环形链表的结构，帮助理解题目中提到的环形链表及如何通过快慢指针法判断链表是否存在环并找到环的入口。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210318162236720.png",
      "description": "这张图片展示了链表中的快慢指针算法，其中“fast”指针和“slow”指针分别指向链表的前两个节点。",
      "context": "该图展示了在环形链表中，当fast指针每次移动两步而slow指针每次移动一步时，两指针如何最终在环内相遇的过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20220925103433.png",
      "description": "这张图片展示了链表中环形结构的检测方法，通过快慢指针（fast和slow）在环内相遇来确定环的入口节点。",
      "context": "该图展示了链表中环的结构以及slow指针和fast指针相遇的位置，帮助理解如何通过两个指针来确定环的入口。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210318165123581.png",
      "description": "这张图片展示了使用快慢指针算法在链表中检测环的入口节点的过程，具体分析了slow和fast指针相遇时各自走过的节点数。",
      "context": "该图片展示了当快慢指针在环形链表中首次相遇时的情况，帮助解释为什么慢指针的步数可以表示为x+y而不是x加上若干环长度再加上y。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/2021031816503266.png",
      "description": "这张图片展示了使用快慢指针（fast和slow）检测链表中环的入口点的算法过程，图中将三个环展开成直线来直观表示环的长度和入口位置。",
      "context": "该图展示了当链表中的慢指针和快指针同时从环入口出发时，它们在环内移动直至再次相遇于环入口的情形，用以说明两者相遇点与环结构之间的关系。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/2021031816515727.png",
      "description": "这张图片展示了使用快慢指针（Floyd 判圈算法）检测链表中环的入口点的过程。",
      "context": "此图展示了当slow指针刚进入环时，fast指针可能位于环内任意位置的情况，用于解释两者相遇点的逻辑。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif",
      "description": "GIF展示了使用快慢指针方法检测链表中环的过程，其中快指针每次移动两步而慢指针每次移动一步，最终两者在环内某点相遇。",
      "context": "该GIF动画展示了使用快慢指针法检测链表中是否存在环的过程，其中快指针每次移动两步，慢指针每次移动一步，直至两者在环内相遇。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%EF%BC%88%E6%B1%82%E5%85%A5%E5%8F%A3%EF%BC%89.gif",
      "description": "GIF展示了在环形链表中，通过快慢指针找到环入口节点的过程。",
      "context": "该GIF动画展示了如何通过两个指针（一个从头结点出发，另一个从链表中两指针首次相遇的位置出发）同时每次移动一步来找到环形链表的入口节点。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\双指针\\环形链表II.txt",
  "extracted_at": "2025-07-21T02:28:50.450379",
  "raw_content": "环形链表II\n力扣题目链接(https://leetcode.cn/problems/linked-list-cycle-ii/)\n\n题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n说明：不允许修改给定的链表。\n\nhttps://file1.kamacoder.com/i/algo/20200816110112704.png\n\n\n#思路\n这道题目，不仅考察对链表的操作，而且还需要一些数学运算。\n\n主要考察两知识点：\n\n判断链表是否环\n如果有环，如何找到这个环的入口\n#判断链表是否有环\n可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。\n\n为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢\n\n首先第一点：fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。\n\n那么来看一下，为什么fast指针和slow指针一定会相遇呢？\n\n可以画一个环，然后让 fast指针在任意一个节点开始追赶slow指针。\n\n会发现最终都是这种情况， 如下图：\n\nhttps://file1.kamacoder.com/i/algo/20210318162236720.png\n\nfast和slow各自再走一步， fast和slow就相遇了\n\n这是因为fast是走两步，slow是走一步，其实相对于slow来说，fast是一个节点一个节点的靠近slow的，所以fast一定可以和slow重合。\n\n动画如下：\n\nhttps://file1.kamacoder.com/i/algo/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif\n\n#如果有环，如何找到这个环的入口\n此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。\n\n假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：\n\nhttps://file1.kamacoder.com/i/algo/20220925103433.png\n\n那么相遇时： slow指针走过的节点数为: x + y， fast指针走过的节点数：x + y + n (y + z)，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。\n\n因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：\n\n(x + y) * 2 = x + y + n (y + z)\n\n两边消掉一个（x+y）: x + y = n (y + z)\n\n因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。\n\n所以要求x ，将x单独放在左面：x = n (y + z) - y ,\n\n再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：x = (n - 1) (y + z) + z 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。\n\n这个公式说明什么呢？\n\n先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。\n\n当 n为1的时候，公式就化解为 x = z，\n\n这就意味着，从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。\n\n也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。\n\n让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。\n\n动画如下：\n\nhttps://file1.kamacoder.com/i/algo/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%EF%BC%88%E6%B1%82%E5%85%A5%E5%8F%A3%EF%BC%89.gif\n\n那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。\n\n其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。\n\n代码如下：\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast != NULL && fast->next != NULL) {\n            slow = slow->next;\n            fast = fast->next->next;\n            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇\n            if (slow == fast) {\n                ListNode* index1 = fast;\n                ListNode* index2 = head;\n                while (index1 != index2) {\n                    index1 = index1->next;\n                    index2 = index2->next;\n                }\n                return index2; // 返回环的入口\n            }\n        }\n        return NULL;\n    }\n};\n时间复杂度: O(n)，快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n\n空间复杂度: O(1)\n#补充\n在推理过程中，大家可能有一个疑问就是：为什么第一次在环中相遇，slow的 步数 是 x+y 而不是 x + 若干环的长度 + y 呢？\n\n即文章链表：环找到了，那入口呢？ (opens new window)中如下的地方：\n\nhttps://file1.kamacoder.com/i/algo/20210318165123581.png\n\n首先slow进环的时候，fast一定是先进环来了。\n\n如果slow进环入口，fast也在环入口，那么把这个环展开成直线，就是如下图的样子：\n\nhttps://file1.kamacoder.com/i/algo/2021031816503266.png\n\n可以看出如果slow 和 fast同时在环入口开始走，一定会在环入口3相遇，slow走了一圈，fast走了两圈。\n\n重点来了，slow进环的时候，fast一定是在环的任意一个位置，如图：\n\nhttps://file1.kamacoder.com/i/algo/2021031816515727.png\n\n那么fast指针走到环入口3的时候，已经走了k + n 个节点，slow相应的应该走了(k + n) / 2 个节点。\n\n因为k是小于n的（图中可以看出），所以(k + n) / 2 一定小于n。\n\n也就是说slow一定没有走到环入口3，而fast已经到环入口3了。\n\n这说明什么呢？\n\n在slow开始走的那一环已经和fast相遇了。\n\n那有同学又说了，为什么fast不能跳过去呢？ 在刚刚已经说过一次了，fast相对于slow是一次移动一个节点，所以不可能跳过去。\n\n好了，这次把为什么第一次在环中相遇，slow的 步数 是 x+y 而不是 x + 若干环的长度 + y ，用数学推理了一下，算是对链表：环找到了，那入口呢？ (opens new window)的补充。\n\n#总结\n这次可以说把环形链表这道题目的各个细节，完完整整的证明了一遍，说这是全网最详细讲解不为过吧。\n\n#其他语言版本\n#Java：\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {// 有环\n                ListNode index1 = fast;\n                ListNode index2 = head;\n                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口\n                while (index1 != index2) {\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n        return null;\n    }\n}\n#Python：\n（版本一）快慢指针法\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n            # If there is a cycle, the slow and fast pointers will eventually meet\n            if slow == fast:\n                # Move one of the pointers back to the start of the list\n                slow = head\n                while slow != fast:\n                    slow = slow.next\n                    fast = fast.next\n                return slow\n        # If there is no cycle, return None\n        return None\n（版本二）集合法\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        visited = set()\n        \n        while head:\n            if head in visited:\n                return head\n            visited.add(head)\n            head = head.next\n        \n        return None"
}