{
  "id": "AP_cbd89067",
  "title": "下一个更大元素 I",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/next-greater-element-i/",
  "description": "两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。\n\n请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。\n\nnums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "单调栈"
  ],
  "data_structure_tags": [
    "栈",
    "哈希表"
  ],
  "technique_tags": [
    "空间换时间"
  ],
  "difficulty": null,
  "solution_approach": "使用单调栈和哈希表来解决下一个更大元素的问题。首先通过哈希表建立nums1中每个元素到其索引的映射，然后遍历nums2数组，在遍历过程中维护一个递增栈以找到每个元素右边的第一个较大值，并更新结果数组。",
  "key_insights": [
    {
      "content": "保持栈内元素从栈底到栈顶递增，当遇到当前元素大于栈顶时，说明找到了栈顶元素的下一个更大元素。"
    },
    {
      "content": "由于需要快速判断nums2中的元素是否属于nums1以及获取其在nums1中的位置，使用哈希表进行预处理可以大大提高效率。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "做本题之前，建议先做一下739. 每日温度(https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html)",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {stack<int> st;vector<int> result(nums1.size(), -1);if (nums1.size() == 0) return result;unordered_map<int, int> umap; for (int i = 0; i < nums1.size(); i++) {umap[nums1[i]] = i;}st.push(0);for (int i = 1; i < nums2.size(); i++) {while (!st.empty() && nums2[i] > nums2[st.top()]) {if (umap.count(nums2[st.top()]) > 0) {int index = umap[nums2[st.top()]];result[index] = nums2[i];}st.pop();}st.push(i);}return result;}};",
          "description": "C++版本的解决方案"
        },
        {
          "language": "c",
          "code": "int* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {int top = -1;int stack_len = nums2Size;int stack[stack_len];int* result_nums2 = (int *)malloc(sizeof(int) * nums2Size);int* result = (int *)malloc(sizeof(int) * nums1Size);*returnSize = nums1Size;stack[++top] = 0;for (int i = 0; i < nums2Size; i++) {result_nums2[i] = -1;}for (int i = 1; i < nums2Size; i++) {if (nums2[i] <= nums2[stack[top]]) {stack[++top] = i;} else {while ((top >= 0) && (nums2[i] > nums2[stack[top]])) {result_nums2[stack[top]] = nums2[i];top--;}stack[++top] = i;}}for (int i = 0; i < nums1Size; i++) {for (int j = 0; j < nums2Size; j++) {if (nums1[i] == nums2[j]) {result[i] = result_nums2[j];}}}return result;}",
          "description": "C语言版本的解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public int[] nextGreaterElement(int[] nums1, int[] nums2) {Stack<Integer> temp = new Stack<>();int[] res = new int[nums1.length];Arrays.fill(res,-1);HashMap<Integer, Integer> hashMap = new HashMap<>();for (int i = 0 ; i< nums1.length ; i++){hashMap.put(nums1[i],i);}temp.add(0);for (int i = 1; i < nums2.length; i++) {if (nums2[i] <= nums2[temp.peek()]) {temp.add(i);} else {while (!temp.isEmpty() && nums2[temp.peek()] < nums2[i]) {if (hashMap.containsKey(nums2[temp.peek()])){Integer index = hashMap.get(nums2[temp.peek()]);res[index] = nums2[i];}temp.pop();}temp.add(i);}}return res;}}",
          "description": "Java版本的解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]: result = [-1]*len(nums1) stack = [0] for i in range(1,len(nums2)): if nums2[i]<=nums2[stack[-1]]: stack.append(i) else: while len(stack)!=0 and nums2[i]>nums2[stack[-1]]: if nums2[stack[-1]] in nums1: index = nums1.index(nums2[stack[-1]]) result[index]=nums2[i] stack.pop() stack.append(i) return result",
          "description": "Python版本的解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#C",
      "resources": [],
      "code_snippets": [
        {
          "language": "c",
          "code": "int* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {int top = -1;int stack_len = nums2Size;int stack[stack_len];int* result_nums2 = (int *)malloc(sizeof(int) * nums2Size);int* result = (int *)malloc(sizeof(int) * nums1Size);*returnSize = nums1Size;stack[++top] = 0;for (int i = 0; i < nums2Size; i++) {result_nums2[i] = -1;}for (int i = 1; i < nums2Size; i++) {if (nums2[i] <= nums2[stack[top]]) {stack[++top] = i;} else {while ((top >= 0) && (nums2[i] > nums2[stack[top]])) {result_nums2[stack[top]] = nums2[i];top--;}stack[++top] = i;}}for (int i = 0; i < nums1Size; i++) {for (int j = 0; j < nums2Size; j++) {if (nums1[i] == nums2[j]) {result[i] = result_nums2[j];}}}return result;}",
          "description": null
        },
        {
          "language": "java",
          "code": "public int[] nextGreaterElement(int[] nums1, int[] nums2) {Stack<Integer> temp = new Stack<>();int[] res = new int[nums1.length];Arrays.fill(res,-1);HashMap<Integer, Integer> hashMap = new HashMap<>();for (int i = 0 ; i< nums1.length ; i++){hashMap.put(nums1[i],i);}temp.add(0);for (int i = 1; i < nums2.length; i++) {if (nums2[i] <= nums2[temp.peek()]) {temp.add(i);} else {while (!temp.isEmpty() && nums2[temp.peek()] < nums2[i]) {if (hashMap.containsKey(nums2[temp.peek()])){Integer index = hashMap.get(nums2[temp.peek()]);res[index] = nums2[i];}temp.pop();}temp.add(i);}}return res;}",
          "description": null
        },
        {
          "language": "java",
          "code": "public int[] nextGreaterElement(int[] nums1, int[] nums2) {HashMap<Integer, Integer> map = new HashMap<>();for (int i = 0; i < nums1.length; i++) {map.put(nums1[i], i);}int[] res = new int[nums1.length];Stack<Integer> stack = new Stack<>();Arrays.fill(res, -1);for (int i = 0; i < nums2.length; i++) {while (!stack.isEmpty() && nums2[stack.peek()] < nums2[i]) {int pre = nums2[stack.pop()];if (map.containsKey(pre)) {res[map.get(pre)] = nums2[i];}}stack.push(i);}return res;}",
          "description": null
        },
        {
          "language": "python",
          "code": "class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]: result = [-1]*len(nums1) stack = [0] for i in range(1,len(nums2)): if nums2[i]<=nums2[stack[-1]]: stack.append(i) else: while len(stack)!=0 and nums2[i]>nums2[stack[-1]]: if nums2[stack[-1]] in nums1: index = nums1.index(nums2[stack[-1]]) result[index]=nums2[i] stack.pop() stack.append(i) return result",
          "description": null
        },
        {
          "language": "python",
          "code": "class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]: stack = [] ans = [-1] * len(nums1) for i in range(len(nums2)): while len(stack) > 0 and nums2[i] > nums2[stack[-1]]: if nums2[stack[-1]] in nums1: index = nums1.index(nums2[stack[-1]]) ans[index] = nums2[i] stack.pop() stack.append(i) return ans",
          "description": null
        }
      ],
      "subsections": []
    },
    {
      "name": "C",
      "text": "/* 先用单调栈的方法计算出结果，再根据nums1中的元素去查找对应的结果 */",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {stack<int> st;vector<int> result(nums1.size(), -1);if (nums1.size() == 0) return result;unordered_map<int, int> umap; for (int i = 0; i < nums1.size(); i++) {umap[nums1[i]] = i;}st.push(0);for (int i = 1; i < nums2.size(); i++) {while (!st.empty() && nums2[i] > nums2[st.top()]) {if (umap.count(nums2[st.top()]) > 0) {int index = umap[nums2[st.top()]];result[index] = nums2[i];}st.pop();}st.push(i);}return result;}};",
          "description": "C++版本的解决方案，使用单调栈和哈希表来查找下一个更大元素。"
        },
        {
          "language": "c",
          "code": "int* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {int top = -1;int stack_len = nums2Size;int stack[stack_len];int* result_nums2 = (int *)malloc(sizeof(int) * nums2Size);int* result = (int *)malloc(sizeof(int) * nums1Size);*returnSize = nums1Size;stack[++top] = 0;for (int i = 0; i < nums2Size; i++) {result_nums2[i] = -1;}for (int i = 1; i < nums2Size; i++) {if (nums2[i] <= nums2[stack[top]]) {stack[++top] = i;} else {while ((top >= 0) && (nums2[i] > nums2[stack[top]])) {result_nums2[stack[top]] = nums2[i];top--;}stack[++top] = i;}}for (int i = 0; i < nums1Size; i++) {for (int j = 0; j < nums2Size; j++) {if (nums1[i] == nums2[j]) {result[i] = result_nums2[j];}}}}return result;",
          "description": "C语言版本的解决方案，同样利用了单调栈的思想来解决此问题。"
        },
        {
          "language": "java",
          "code": "class Solution {public int[] nextGreaterElement(int[] nums1, int[] nums2) {Stack<Integer> temp = new Stack<>();int[] res = new int[nums1.length];Arrays.fill(res,-1);HashMap<Integer, Integer> hashMap = new HashMap<>();for (int i = 0 ; i< nums1.length ; i++){hashMap.put(nums1[i],i);}temp.add(0);for (int i = 1; i < nums2.length; i++) {if (nums2[i] <= nums2[temp.peek()]) {temp.add(i);} else {while (!temp.isEmpty() && nums2[temp.peek()] < nums2[i]) {if (hashMap.containsKey(nums2[temp.peek()])){Integer index = hashMap.get(nums2[temp.peek()]);res[index] = nums2[i];}temp.pop();}temp.add(i);}}}return res;}}",
          "description": "Java版本的解决方案，通过使用栈和哈希映射来追踪下一个更大元素的位置。"
        },
        {
          "language": "python",
          "code": "class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]: result = [-1]*len(nums1) stack = [0] for i in range(1,len(nums2)): if nums2[i]<=nums2[stack[-1]]: stack.append(i) else: while len(stack)!=0 and nums2[i]>nums2[stack[-1]]: if nums2[stack[-1]] in nums1: index = nums1.index(nums2[stack[-1]]) result[index]=nums2[i] stack.pop() stack.append(i) return result",
          "description": "Python版本的解决方案，采用列表作为栈，并直接在循环中更新结果数组。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {stack<int> st;vector<int> result(nums1.size(), -1);if (nums1.size() == 0) return result;unordered_map<int, int> umap; for (int i = 0; i < nums1.size(); i++) {umap[nums1[i]] = i;}st.push(0);for (int i = 1; i < nums2.size(); i++) {while (!st.empty() && nums2[i] > nums2[st.top()]) {if (umap.count(nums2[st.top()]) > 0) {int index = umap[nums2[st.top()]];result[index] = nums2[i];}st.pop();}st.push(i);}return result;}};",
          "description": "C++实现版本二"
        },
        {
          "language": "c",
          "code": "int* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {int top = -1;int stack_len = nums2Size;int stack[stack_len];int* result_nums2 = (int *)malloc(sizeof(int) * nums2Size);int* result = (int *)malloc(sizeof(int) * nums1Size);*returnSize = nums1Size;stack[++top] = 0;for (int i = 0; i < nums2Size; i++) {result_nums2[i] = -1;}for (int i = 1; i < nums2Size; i++) {if (nums2[i] <= nums2[stack[top]]) {stack[++top] = i;} else {while ((top >= 0) && (nums2[i] > nums2[stack[top]])) {result_nums2[stack[top]] = nums2[i];top--;}stack[++top] = i;}}for (int i = 0; i < nums1Size; i++) {for (int j = 0; j < nums2Size; j++) {if (nums1[i] == nums2[j]) {result[i] = result_nums2[j];}}}return result;}",
          "description": "C语言实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int[] nextGreaterElement(int[] nums1, int[] nums2) {Stack<Integer> temp = new Stack<>();int[] res = new int[nums1.length];Arrays.fill(res,-1);HashMap<Integer, Integer> hashMap = new HashMap<>();for (int i = 0 ; i< nums1.length ; i++){hashMap.put(nums1[i],i);}temp.add(0);for (int i = 1; i < nums2.length; i++) {if (nums2[i] <= nums2[temp.peek()]) {temp.add(i);} else {while (!temp.isEmpty() && nums2[temp.peek()] < nums2[i]) {if (hashMap.containsKey(nums2[temp.peek()])){Integer index = hashMap.get(nums2[temp.peek()]);res[index] = nums2[i];}temp.pop();}temp.add(i);}}return res;}}",
          "description": "Java实现版本一"
        },
        {
          "language": "java",
          "code": "class Solution {public int[] nextGreaterElement(int[] nums1, int[] nums2) {HashMap<Integer, Integer> map = new HashMap<>();for (int i = 0; i < nums1.length; i++) {map.put(nums1[i], i);}int[] res = new int[nums1.length];Stack<Integer> stack = new Stack<>();Arrays.fill(res, -1);for (int i = 0; i < nums2.length; i++) {while (!stack.isEmpty() && nums2[stack.peek()] < nums2[i]) {int pre = nums2[stack.pop()];if (map.containsKey(pre)) {res[map.get(pre)] = nums2[i];}}stack.push(i);}return res;}}",
          "description": "Java实现版本二"
        },
        {
          "language": "python",
          "code": "class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]: result = [-1]*len(nums1) stack = [0] for i in range(1,len(nums2)): if nums2[i]<=nums2[stack[-1]]: stack.append(i) else: while len(stack)!=0 and nums2[i]>nums2[stack[-1]]: if nums2[stack[-1]] in nums1: index = nums1.index(nums2[stack[-1]]) result[index]=nums2[i] stack.pop() stack.append(i) return result",
          "description": "Python3实现版本一"
        },
        {
          "language": "python",
          "code": "class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]: stack = [] ans = [-1] * len(nums1) for i in range(len(nums2)): while len(stack) > 0 and nums2[i] > nums2[stack[-1]]: if nums2[stack[-1]] in nums1: index = nums1.index(nums2[stack[-1]]) ans[index] = nums2[i] stack.pop() stack.append(i) return ans",
          "description": "Python3实现版本二"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python3",
      "text": "# 版本一",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {stack<int> st;vector<int> result(nums1.size(), -1);if (nums1.size() == 0) return result;unordered_map<int, int> umap; for (int i = 0; i < nums1.size(); i++) {umap[nums1[i]] = i;}st.push(0);for (int i = 1; i < nums2.size(); i++) {if (nums2[i] < nums2[st.top()]) {st.push(i);} else if (nums2[i] == nums2[st.top()]) {st.push(i);} else {while (!st.empty() && nums2[i] > nums2[st.top()]) {if (umap.count(nums2[st.top()]) > 0) {int index = umap[nums2[st.top()]];result[index] = nums2[i];}st.pop();}st.push(i);}}}return result;}};",
          "description": "版本一的C++解决方案"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {stack<int> st;vector<int> result(nums1.size(), -1);if (nums1.size() == 0) return result;unordered_map<int, int> umap; for (int i = 0; i < nums1.size(); i++) {umap[nums1[i]] = i;}st.push(0);for (int i = 1; i < nums2.size(); i++) {while (!st.empty() && nums2[i] > nums2[st.top()]) {if (umap.count(nums2[st.top()]) > 0) {int index = umap[nums2[st.top()]];result[index] = nums2[i];}st.pop();}st.push(i);}}return result;}};",
          "description": "版本二的C++解决方案"
        },
        {
          "language": "c",
          "code": "int* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {int top = -1;int stack_len = nums2Size;int stack[stack_len];int* result_nums2 = (int *)malloc(sizeof(int) * nums2Size);int* result = (int *)malloc(sizeof(int) * nums1Size);*returnSize = nums1Size;stack[++top] = 0;for (int i = 0; i < nums2Size; i++) {result_nums2[i] = -1;}for (int i = 1; i < nums2Size; i++) {if (nums2[i] <= nums2[stack[top]]) {stack[++top] = i;} else {while ((top >= 0) && (nums2[i] > nums2[stack[top]])) {result_nums2[stack[top]] = nums2[i];top--;}stack[++top] = i;}}for (int i = 0; i < nums1Size; i++) {for (int j = 0; j < nums2Size; j++) {if (nums1[i] == nums2[j]) {result[i] = result_nums2[j];}}}}return result;}",
          "description": "C语言解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public int[] nextGreaterElement(int[] nums1, int[] nums2) {Stack<Integer> temp = new Stack<>();int[] res = new int[nums1.length];Arrays.fill(res,-1);HashMap<Integer, Integer> hashMap = new HashMap<>();for (int i = 0 ; i< nums1.length ; i++){hashMap.put(nums1[i],i);}temp.add(0);for (int i = 1; i < nums2.length; i++) {if (nums2[i] <= nums2[temp.peek()]) {temp.add(i);} else {while (!temp.isEmpty() && nums2[temp.peek()] < nums2[i]) {if (hashMap.containsKey(nums2[temp.peek()])){Integer index = hashMap.get(nums2[temp.peek()]);res[index] = nums2[i];}temp.pop();}temp.add(i);}}}return res;}}",
          "description": "Java版本一解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public int[] nextGreaterElement(int[] nums1, int[] nums2) {HashMap<Integer, Integer> map = new HashMap<>();for (int i = 0; i < nums1.length; i++) {map.put(nums1[i], i);}int[] res = new int[nums1.length];Stack<Integer> stack = new Stack<>();Arrays.fill(res, -1);for (int i = 0; i < nums2.length; i++) {while (!stack.isEmpty() && nums2[stack.peek()] < nums2[i]) {int pre = nums2[stack.pop()];if (map.containsKey(pre)) {res[map.get(pre)] = nums2[i];}}stack.push(i);}return res;}}",
          "description": "Java版本二解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]: result = [-1]*len(nums1) stack = [0] for i in range(1,len(nums2)): if nums2[i]<=nums2[stack[-1]]: stack.append(i) else: while len(stack)!=0 and nums2[i]>nums2[stack[-1]]: if nums2[stack[-1]] in nums1: index = nums1.index(nums2[stack[-1]]) result[index]=nums2[i] stack.pop() stack.append(i) return result",
          "description": "Python3版本一解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]: stack = [] ans = [-1] * len(nums1) for i in range(len(nums2)): while len(stack) > 0 and nums2[i] > nums2[stack[-1]]: if nums2[stack[-1]] in nums1: index = nums1.index(nums2[stack[-1]]) ans[index] = nums2[i] stack.pop() stack.append(i) return ans",
          "description": "Python3版本二解决方案"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "C++",
      "code": "class Solution {public: vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {stack<int> st;vector<int> result(nums1.size(), -1);if (nums1.size() == 0) return result;unordered_map<int, int> umap; for (int i = 0; i < nums1.size(); i++) {umap[nums1[i]] = i;}st.push(0);for (int i = 1; i < nums2.size(); i++) {while (!st.empty() && nums2[i] > nums2[st.top()]) {if (umap.count(nums2[st.top()]) > 0) {int index = umap[nums2[st.top()]];result[index] = nums2[i];}st.pop();}st.push(i);}return result;}};",
      "description": "使用单调栈和哈希表来解决下一个更大元素问题"
    },
    {
      "language": "C",
      "code": "int* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {int top = -1;int stack_len = nums2Size;int stack[stack_len];int* result_nums2 = (int *)malloc(sizeof(int) * nums2Size);int* result = (int *)malloc(sizeof(int) * nums1Size);*returnSize = nums1Size;stack[++top] = 0;for (int i = 0; i < nums2Size; i++) {result_nums2[i] = -1;}for (int i = 1; i < nums2Size; i++) {if (nums2[i] <= nums2[stack[top]]) {stack[++top] = i;} else {while ((top >= 0) && (nums2[i] > nums2[stack[top]])) {result_nums2[stack[top]] = nums2[i];top--;}stack[++top] = i;}}for (int i = 0; i < nums1Size; i++) {for (int j = 0; j < nums2Size; j++) {if (nums1[i] == nums2[j]) {result[i] = result_nums2[j];}}}return result;}",
      "description": "利用栈和额外数组来记录结果，然后根据nums1中的元素去查找对应的结果"
    },
    {
      "language": "Java",
      "code": "class Solution {public int[] nextGreaterElement(int[] nums1, int[] nums2) {Stack<Integer> temp = new Stack<>();int[] res = new int[nums1.length];Arrays.fill(res,-1);HashMap<Integer, Integer> hashMap = new HashMap<>();for (int i = 0 ; i< nums1.length ; i++){hashMap.put(nums1[i],i);}temp.add(0);for (int i = 1; i < nums2.length; i++) {if (nums2[i] <= nums2[temp.peek()]) {temp.add(i);} else {while (!temp.isEmpty() && nums2[temp.peek()] < nums2[i]) {if (hashMap.containsKey(nums2[temp.peek()])){Integer index = hashMap.get(nums2[temp.peek()]);res[index] = nums2[i];}temp.pop();}temp.add(i);}}return res;}}",
      "description": "通过栈和哈希映射处理下一个更大元素的问题"
    },
    {
      "language": "Python3",
      "code": "class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]: result = [-1]*len(nums1) stack = [0] for i in range(1,len(nums2)): if nums2[i]<=nums2[stack[-1]]: stack.append(i) else: while len(stack)!=0 and nums2[i]>nums2[stack[-1]]: if nums2[stack[-1]] in nums1: index = nums1.index(nums2[stack[-1]]) result[index]=nums2[i] stack.pop() stack.append(i) return result",
      "description": "采用单调栈的方法找到每一个元素右边第一个比自己大的数"
    }
  ],
  "common_mistakes": [
    "忘记初始化结果数组为-1，导致输出错误。",
    "不正确地处理了等于的情况，应当直接入栈而非跳过。",
    "没有考虑如何高效地检查nums2中的元素是否存在于nums1之中。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\单调栈\\下一个更大元素 I.txt",
  "extracted_at": "2025-07-21T00:37:36.991574",
  "raw_content": "下一个更大元素 I\n力扣题目链接(https://leetcode.cn/problems/next-greater-element-i/)\n\n给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。\n\n请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。\n\nnums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。\n\n示例 1:\n\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出: [-1,3,-1]\n解释:\n对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。\n对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。\n对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n\n示例 2:\n输入: nums1 = [2,4], nums2 = [1,2,3,4].\n输出: [3,-1]\n解释:\n对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。\n对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出-1 。\n\n提示：\n\n1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 10^4\nnums1和nums2中所有整数 互不相同\nnums1 中的所有整数同样出现在 nums2 中\n\n\n#思路\n做本题之前，建议先做一下739. 每日温度(https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html)\n\n在739. 每日温度 (https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html)中是求每个元素下一个比当前元素大的元素的位置。\n\n本题则是说nums1 是 nums2的子集，找nums1中的元素在nums2中下一个比当前元素大的元素。\n\n看上去和739. 每日温度 (https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html)就如出一辙了。\n\n几乎是一样的，但是这么绕了一下，其实还上升了一点难度。\n\n需要对单调栈使用的更熟练一些，才能顺利的把本题写出来。\n\n从题目示例中我们可以看出最后是要求nums1的每个元素在nums2中下一个比当前元素大的元素，那么就要定义一个和nums1一样大小的数组result来存放结果。\n\n一些同学可能看到两个数组都已经懵了，不知道要定一个一个多大的result数组来存放结果了。\n\n这么定义这个result数组初始化应该为多少呢？\n\n题目说如果不存在对应位置就输出 -1 ，所以result数组如果某位置没有被赋值，那么就应该是是-1，所以就初始化为-1。\n\n在遍历nums2的过程中，我们要判断nums2[i]是否在nums1中出现过，因为最后是要根据nums1元素的下标来更新result数组。\n\n注意题目中说是两个没有重复元素 的数组 nums1 和 nums2。\n\n没有重复元素，我们就可以用map来做映射了。根据数值快速找到下标，还可以判断nums2[i]是否在nums1中出现过。\n\nC++中，当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的。我在关于哈希表，你该了解这些！ (https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)中也做了详细的解释。\n\n那么预处理代码如下:\n\nunordered_map<int, int> umap; // key:下标元素，value：下标\nfor (int i = 0; i < nums1.size(); i++) {\n    umap[nums1[i]] = i;\n}\n使用单调栈，首先要想单调栈是从大到小还是从小到大。\n\n本题和739. 每日温度是一样的。\n\n栈头到栈底的顺序，要从小到大，也就是保持栈里的元素为递增顺序。只要保持递增，才能找到右边第一个比自己大的元素。\n\n可能这里有一些同学不理解，那么可以自己尝试一下用递减栈，能不能求出来。其实递减栈就是求右边第一个比自己小的元素了。\n\n接下来就要分析如下三种情况，一定要分析清楚。\n\n情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况\n此时满足递增栈（栈头到栈底的顺序），所以直接入栈。\n\n情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况\n如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！\n\n情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况\n此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。\n\n判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。\n\n记录结果这块逻辑有一点小绕，要清楚，此时栈顶元素在nums2数组中右面第一个大的元素是nums2[i]（即当前遍历元素）。\n\n代码如下：\n\nwhile (!st.empty() && nums2[i] > nums2[st.top()]) {\n    if (umap.count(nums2[st.top()]) > 0) { // 看map里是否存在这个元素\n        int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下标\n        result[index] = nums2[i];\n    }\n    st.pop();\n}\nst.push(i);\n以上分析完毕，C++代码如下：（其实本题代码和 739. 每日温度 (opens new window)是基本差不多的）\n\n// 版本一\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        stack<int> st;\n        vector<int> result(nums1.size(), -1);\n        if (nums1.size() == 0) return result;\n\n        unordered_map<int, int> umap; // key:下标元素，value：下标\n        for (int i = 0; i < nums1.size(); i++) {\n            umap[nums1[i]] = i;\n        }\n        st.push(0);\n        for (int i = 1; i < nums2.size(); i++) {\n            if (nums2[i] < nums2[st.top()]) {           // 情况一\n                st.push(i);\n            } else if (nums2[i] == nums2[st.top()]) {   // 情况二\n                st.push(i);\n            } else {                                    // 情况三\n                while (!st.empty() && nums2[i] > nums2[st.top()]) {\n                    if (umap.count(nums2[st.top()]) > 0) { // 看map里是否存在这个元素\n                        int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下标\n                        result[index] = nums2[i];\n                    }\n                    st.pop();\n                }\n                st.push(i);\n            }\n        }\n        return result;\n    }\n};\n针对版本一，进行代码精简后，代码如下：\n\n// 版本二\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        stack<int> st;\n        vector<int> result(nums1.size(), -1);\n        if (nums1.size() == 0) return result;\n\n        unordered_map<int, int> umap; // key:下标元素，value：下标\n        for (int i = 0; i < nums1.size(); i++) {\n            umap[nums1[i]] = i;\n        }\n        st.push(0);\n        for (int i = 1; i < nums2.size(); i++) {\n            while (!st.empty() && nums2[i] > nums2[st.top()]) {\n                if (umap.count(nums2[st.top()]) > 0) { // 看map里是否存在这个元素\n                    int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下标\n                    result[index] = nums2[i];\n                }\n                st.pop();\n            }\n            st.push(i);\n        }\n        return result;\n    }\n};\n精简的代码是直接把情况一二三都合并到了一起，其实这种代码精简是精简，但思路不是很清晰。\n\n建议大家把情况一二三想清楚了，先写出版本一的代码，然后在其基础上在做精简！\n\n#其他语言版本\n#C\n/* 先用单调栈的方法计算出结果，再根据nums1中的元素去查找对应的结果 */\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {\n\n    /* stcak */\n    int top = -1;\n    int stack_len = nums2Size;\n    int stack[stack_len];\n    //memset(stack, 0x00, sizeof(stack));\n\n    /* nums2 result */\n    int* result_nums2 = (int *)malloc(sizeof(int) * nums2Size);\n    //memset(result_nums2, 0x00, sizeof(int) * nums2Size);\n\n    /* result */\n    int* result = (int *)malloc(sizeof(int) * nums1Size);\n    //memset(result, 0x00, sizeof(int) * nums1Size);\n    *returnSize = nums1Size;\n\n    /* init */\n    stack[++top] = 0; /* stack loaded with array subscripts */\n\n    for (int i = 0; i < nums2Size; i++) {\n        result_nums2[i] = -1;\n    }\n\n    /* get the result_nums2 */\n    for (int i = 1; i < nums2Size; i++) {\n        if (nums2[i] <= nums2[stack[top]]) {\n            stack[++top] = i; /* push */\n        } else {\n            while ((top >= 0) && (nums2[i] > nums2[stack[top]])) {\n                result_nums2[stack[top]] = nums2[i];\n                top--; /* pop */\n            }\n            stack[++top] = i;\n        }\n    }\n\n    /* get the result */\n    for (int i = 0; i < nums1Size; i++) {\n        for (int j = 0; j < nums2Size; j++) {\n            if (nums1[i] == nums2[j]) {\n                result[i] = result_nums2[j];\n            }\n        }\n    }\n    return result;\n}\n#Java\nclass Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        Stack<Integer> temp = new Stack<>();\n        int[] res = new int[nums1.length];\n        Arrays.fill(res,-1);\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\n        for (int i = 0 ; i< nums1.length ; i++){\n            hashMap.put(nums1[i],i);\n        }\n        temp.add(0);\n        for (int i = 1; i < nums2.length; i++) {\n            if (nums2[i] <= nums2[temp.peek()]) {\n                temp.add(i);\n            } else {\n                while (!temp.isEmpty() && nums2[temp.peek()] < nums2[i]) {\n                    if (hashMap.containsKey(nums2[temp.peek()])){\n                        Integer index = hashMap.get(nums2[temp.peek()]);\n                        res[index] = nums2[i];\n                    }\n                    temp.pop();\n                }\n                temp.add(i);\n            }\n        }\n\n        return res;\n    }\n}\n\n// 版本2\nclass Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums1.length; i++) {\n            map.put(nums1[i], i);\n        }\n\n        int[] res = new int[nums1.length];\n        Stack<Integer> stack = new Stack<>();\n        Arrays.fill(res, -1);\n\n        for (int i = 0; i < nums2.length; i++) {\n            while (!stack.isEmpty() && nums2[stack.peek()] < nums2[i]) {\n                int pre = nums2[stack.pop()];\n                if (map.containsKey(pre)) {\n                    res[map.get(pre)] = nums2[i];\n                }\n            }\n            stack.push(i);\n        }\n\n        return res;\n    }\n}\n#Python3\n# 版本一\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        result = [-1]*len(nums1)\n        stack = [0]\n        for i in range(1,len(nums2)):\n            # 情况一情况二\n            if nums2[i]<=nums2[stack[-1]]:\n                stack.append(i)\n            # 情况三\n            else:\n                while len(stack)!=0 and nums2[i]>nums2[stack[-1]]:\n                    if nums2[stack[-1]] in nums1:\n                        index = nums1.index(nums2[stack[-1]])\n                        result[index]=nums2[i]\n                    stack.pop()                 \n                stack.append(i)\n        return result\n\n# 版本二\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        stack = []\n        # 创建答案数组\n        ans = [-1] * len(nums1)\n        for i in range(len(nums2)):\n            while len(stack) > 0 and nums2[i] > nums2[stack[-1]]:\n                # 判断 num1 是否有 nums2[stack[-1]]。如果没有这个判断会出现指针异常\n                if nums2[stack[-1]] in nums1:\n                    # 锁定 num1 检索的 index\n                    index = nums1.index(nums2[stack[-1]])\n                    # 更新答案数组\n                    ans[index] = nums2[i]\n                # 弹出小元素\n                # 这个代码一定要放在 if 外面。否则单调栈的逻辑就不成立了\n                stack.pop()\n            stack.append(i)\n        return ans"
}