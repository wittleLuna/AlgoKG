{
  "id": "AP_22f2d813",
  "title": "翻转二叉树",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/invert-binary-tree/",
  "description": "翻转一棵二叉树。\n\nhttps://file1.kamacoder.com/i/algo/20210203192644329.png\n\n这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，全当一个乐子哈）",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "递归",
    "迭代"
  ],
  "data_structure_tags": [
    "二叉树",
    "栈",
    "队列"
  ],
  "technique_tags": [
    "深度优先搜索(DFS)",
    "广度优先搜索(BFS)"
  ],
  "difficulty": null,
  "solution_approach": "通过遍历二叉树（前序、后序或层序遍历），在访问每个节点时交换其左右子节点来实现整棵树的翻转。",
  "key_insights": [
    {
      "content": "选择前序或后序遍历可以确保每个节点仅被处理一次，从而避免中序遍历可能引起的重复翻转问题。"
    },
    {
      "content": "对于任意给定的节点，简单地交换它的左子节点和右子节点即可逐步达到整个二叉树翻转的效果。"
    },
    {
      "content": "使用栈或队列辅助进行迭代遍历同样有效，并且可以在不改变遍历逻辑的情况下实现节点的翻转。"
    },
    {
      "content": "中序遍历不适合直接用于此问题，因为它会导致某些节点的孩子被翻转两次。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "题外话",
      "text": "这道题目是非常经典的题目，也是比较简单的题目（至少一看就会）。",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; swap(root->left, root->right); invertTree(root->left); invertTree(root->right); return root;}};",
          "description": "递归法翻转二叉树"
        },
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; stack<TreeNode*> st; st.push(root); while(!st.empty()) {TreeNode* node = st.top(); st.pop(); swap(node->left, node->right); if(node->right) st.push(node->right); if(node->left) st.push(node->left); } return root;}};",
          "description": "迭代法（前序遍历）翻转二叉树"
        },
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {stack<TreeNode*> st; if (root != NULL) st.push(root); while (!st.empty()) {TreeNode* node = st.top(); if (node != NULL) {st.pop(); if (node->right) st.push(node->right); if (node->left) st.push(node->left); st.push(node); st.push(NULL);} else {st.pop(); node = st.top(); st.pop(); swap(node->left, node->right);}}} return root;}};",
          "description": "迭代法统一写法（前序遍历）翻转二叉树"
        },
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {queue<TreeNode*> que; if (root != NULL) que.push(root); while (!que.empty()) {int size = que.size(); for (int i = 0; i < size; i++) {TreeNode* node = que.front(); que.pop(); swap(node->left, node->right); if (node->left) que.push(node->left); if (node->right) que.push(node->right);}}} return root;}};",
          "description": "广度优先遍历（层序遍历）翻转二叉树"
        },
        {
          "language": "Java",
          "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} invertTree(root.left); invertTree(root.right); swapChildren(root); return root;} private void swapChildren(TreeNode root) {TreeNode tmp = root.left; root.left = root.right; root.right = tmp;}}",
          "description": "DFS递归翻转二叉树"
        },
        {
          "language": "Java",
          "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} ArrayDeque<TreeNode> deque = new ArrayDeque<>(); deque.offer(root); while (!deque.isEmpty()) {int size = deque.size(); while (size-- > 0) {TreeNode node = deque.poll(); swap(node); if (node.left != null) deque.offer(node.left); if (node.right != null) deque.offer(node.right);}} return root;} public void swap(TreeNode root) {TreeNode temp = root.left; root.left = root.right; root.right = temp;}}",
          "description": "BFS翻转二叉树"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root",
          "description": "递归法（前序遍历）翻转二叉树"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() node.left, node.right = node.right, node.left if node.right: stack.append(node.right) if node.left: stack.append(node.left) return root",
          "description": "迭代法（前序遍历）翻转二叉树"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) root.left, root.right = root.right, root.left self.invertTree(root.left) return root",
          "description": "递归法（中序遍历）翻转二叉树"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) node.left, node.right = node.right, node.left if node.right: stack.append(node.right) return root",
          "description": "迭代法，伪中序遍历翻转二叉树"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) self.invertTree(root.right) root.left, root.right = root.right, root.left return root",
          "description": "递归法（后序遍历）翻转二叉树"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) if node.left: stack.append(node.left) node.left, node.right = node.right, node.left return root",
          "description": "迭代法，伪后序遍历翻转二叉树"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None queue = collections.deque([root]) while queue: node = queue.popleft() node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root",
          "description": "迭代法：广度优先遍历（层序遍历）翻转二叉树"
        }
      ],
      "subsections": []
    },
    {
      "name": "思路",
      "text": "我们之前介绍的都是各种方式遍历二叉树，这次要翻转了，感觉还是有点懵逼。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; swap(root->left, root->right); invertTree(root->left); invertTree(root->right); return root;}};",
          "description": "递归法前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; stack<TreeNode*> st; st.push(root); while(!st.empty()) {TreeNode* node = st.top(); st.pop(); swap(node->left, node->right); if(node->right) st.push(node->right); if(node->left) st.push(node->left); } return root;}};",
          "description": "迭代法前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {stack<TreeNode*> st; if (root != NULL) st.push(root); while (!st.empty()) {TreeNode* node = st.top(); if (node != NULL) {st.pop(); if (node->right) st.push(node->right); if (node->left) st.push(node->left); st.push(node); st.push(NULL);} else {st.pop(); node = st.top(); st.pop(); swap(node->left, node->right);}}} return root;}};",
          "description": "迭代法统一写法前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {queue<TreeNode*> que; if (root != NULL) que.push(root); while (!que.empty()) {int size = que.size(); for (int i = 0; i < size; i++) {TreeNode* node = que.front(); que.pop(); swap(node->left, node->right); if (node->left) que.push(node->left); if (node->right) que.push(node->right);}} return root;}};",
          "description": "广度优先遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; invertTree(root->left); swap(root->left, root->right); invertTree(root->left); return root;}};",
          "description": "递归中序遍历避免翻转两次"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {stack<TreeNode*> st; if (root != NULL) st.push(root); while (!st.empty()) {TreeNode* node = st.top(); if (node != NULL) {st.pop(); if (node->right) st.push(node->right); st.push(node); st.push(NULL); if (node->left) st.push(node->left);} else {st.pop(); node = st.top(); st.pop(); swap(node->left, node->right);}}} return root;}};",
          "description": "迭代法统一写法中序遍历"
        },
        {
          "language": "java",
          "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} invertTree(root.left); invertTree(root.right); swapChildren(root); return root;} private void swapChildren(TreeNode root) {TreeNode tmp = root.left; root.left = root.right; root.right = tmp;}}",
          "description": "DFS递归"
        },
        {
          "language": "java",
          "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} ArrayDeque<TreeNode> deque = new ArrayDeque<>(); deque.offer(root); while (!deque.isEmpty()) {int size = deque.size(); while (size-- > 0) {TreeNode node = deque.poll(); swap(node); if (node.left != null) deque.offer(node.left); if (node.right != null) deque.offer(node.right);}} return root;} public void swap(TreeNode root) {TreeNode temp = root.left; root.left = root.right; root.right = temp;}}",
          "description": "BFS"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root",
          "description": "递归法：前序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() node.left, node.right = node.right, node.left if node.right: stack.append(node.right) if node.left: stack.append(node.left) return root",
          "description": "迭代法：前序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) root.left, root.right = root.right, root.left self.invertTree(root.left) return root",
          "description": "递归法：中序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) node.left, node.right = node.right, node.left if node.right: stack.append(node.right) return root",
          "description": "迭代法，伪中序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) self.invertTree(root.right) root.left, root.right = root.right, root.left return root",
          "description": "递归法：后序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) if node.left: stack.append(node.left) node.left, node.right = node.right, node.left return root",
          "description": "迭代法，伪后序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None queue = collections.deque([root]) while queue: node = queue.popleft() node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root",
          "description": "迭代法：广度优先遍历（层序遍历）"
        }
      ],
      "subsections": []
    },
    {
      "name": "递归法",
      "text": "对于二叉树的递归法的前中后序遍历，已经在二叉树：前中后序递归遍历 (opens new window)详细讲解了。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (root == NULL) return root;\n        swap(root->left, root->right);\n        invertTree(root->left);\n        invertTree(root->right);\n        return root;\n    }\n};",
          "description": "递归法，前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (root == NULL) return root;\n        stack<TreeNode*> st;\n        st.push(root);\n        while(!st.empty()) {\n            TreeNode* node = st.top();\n            st.pop();\n            swap(node->left, node->right);\n            if(node->right) st.push(node->right);\n            if(node->left) st.push(node->left);\n        }\n        return root;\n    }\n};",
          "description": "迭代法，前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        stack<TreeNode*> st;\n        if (root != NULL) st.push(root);\n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            if (node != NULL) {\n                st.pop();\n                if (node->right) st.push(node->right);\n                if (node->left) st.push(node->left);\n                st.push(node);\n                st.push(NULL);\n            } else {\n                st.pop();\n                node = st.top();\n                st.pop();\n                swap(node->left, node->right);\n            }\n        }\n        return root;\n    }\n};",
          "description": "迭代法（统一写法），前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        queue<TreeNode*> que;\n        if (root != NULL) que.push(root);\n        while (!que.empty()) {\n            int size = que.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode* node = que.front();\n                que.pop();\n                swap(node->left, node->right);\n                if (node->left) que.push(node->left);\n                if (node->right) que.push(node->right);\n            }\n        }\n        return root;\n    }\n};",
          "description": "广度优先遍历（层序遍历）"
        },
        {
          "language": "java",
          "code": "class Solution {\n   public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    }\n\n    private void swapChildren(TreeNode root) {\n        TreeNode tmp = root.left;\n        root.left = root.right;\n        root.right = tmp;\n    }\n}",
          "description": "DFS递归"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {return null;}\n        ArrayDeque<TreeNode> deque = new ArrayDeque<>();\n        deque.offer(root);\n        while (!deque.isEmpty()) {\n            int size = deque.size();\n            while (size-- > 0) {\n                TreeNode node = deque.poll();\n                swap(node);\n                if (node.left != null) deque.offer(node.left);\n                if (node.right != null) deque.offer(node.right);\n            }\n        }\n        return root;\n    }\n\n    public void swap(TreeNode root) {\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n    }\n}",
          "description": "BFS"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root",
          "description": "递归法，前序遍历"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            node.left, node.right = node.right, node.left\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return root",
          "description": "迭代法，前序遍历"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        self.invertTree(root.left)\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        return root",
          "description": "递归法，中序遍历"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            node.left, node.right = node.right, node.left\n            if node.right:\n                stack.append(node.right)\n        return root",
          "description": "迭代法，伪中序遍历"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        root.left, root.right = root.right, root.left\n        return root",
          "description": "递归法，后序遍历"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n            node.left, node.right = node.right, node.left\n        return root",
          "description": "迭代法，伪后序遍历"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root: \n            return None\n        queue = collections.deque([root])\n        while queue:\n            node = queue.popleft()\n            node.left, node.right = node.right, node.left\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        return root",
          "description": "迭代法，广度优先遍历（层序遍历）"
        }
      ],
      "subsections": []
    },
    {
      "name": "迭代法",
      "text": "#深度优先遍历",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; swap(root->left, root->right); invertTree(root->left); invertTree(root->right); return root;}};",
          "description": "递归法，前序遍历"
        },
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; stack<TreeNode*> st; st.push(root); while(!st.empty()) {TreeNode* node = st.top(); st.pop(); swap(node->left, node->right); if(node->right) st.push(node->right); if(node->left) st.push(node->left);} return root;}};",
          "description": "迭代法，前序遍历"
        },
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {stack<TreeNode*> st; if (root != NULL) st.push(root); while (!st.empty()) {TreeNode* node = st.top(); if (node != NULL) {st.pop(); if (node->right) st.push(node->right); if (node->left) st.push(node->left); st.push(node); st.push(NULL);} else {st.pop(); node = st.top(); st.pop(); swap(node->left, node->right);}}} return root;}};",
          "description": "迭代法，统一写法前序遍历"
        },
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {queue<TreeNode*> que; if (root != NULL) que.push(root); while (!que.empty()) {int size = que.size(); for (int i = 0; i < size; i++) {TreeNode* node = que.front(); que.pop(); swap(node->left, node->right); if (node->left) que.push(node->left); if (node->right) que.push(node->right);}} return root;}};",
          "description": "广度优先遍历"
        },
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; invertTree(root->left); swap(root->left, root->right); invertTree(root->left); return root;}};",
          "description": "递归中序遍历特例"
        },
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {stack<TreeNode*> st; if (root != NULL) st.push(root); while (!st.empty()) {TreeNode* node = st.top(); if (node != NULL) {st.pop(); if (node->right) st.push(node->right); st.push(node); st.push(NULL); if (node->left) st.push(node->left);} else {st.pop(); node = st.top(); st.pop(); swap(node->left, node->right);}}} return root;}};",
          "description": "迭代法，统一写法中序遍历"
        },
        {
          "language": "Java",
          "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} invertTree(root.left); invertTree(root.right); swapChildren(root); return root;} private void swapChildren(TreeNode root) {TreeNode tmp = root.left; root.left = root.right; root.right = tmp;}}",
          "description": "DFS递归"
        },
        {
          "language": "Java",
          "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} ArrayDeque<TreeNode> deque = new ArrayDeque<>(); deque.offer(root); while (!deque.isEmpty()) {int size = deque.size(); while (size-- > 0) {TreeNode node = deque.poll(); swap(node); if (node.left != null) deque.offer(node.left); if (node.right != null) deque.offer(node.right);}} return root;} public void swap(TreeNode root) {TreeNode temp = root.left; root.left = root.right; root.right = temp;}}",
          "description": "BFS"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root",
          "description": "递归法，前序遍历"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() node.left, node.right = node.right, node.left if node.right: stack.append(node.right) if node.left: stack.append(node.left) return root",
          "description": "迭代法，前序遍历"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) root.left, root.right = root.right, root.left self.invertTree(root.left) return root",
          "description": "递归法，中序遍历特例"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) node.left, node.right = node.right, node.left if node.right: stack.append(node.right) return root",
          "description": "迭代法，伪中序遍历"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) self.invertTree(root.right) root.left, root.right = root.right, root.left return root",
          "description": "递归法，后序遍历"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) if node.left: stack.append(node.left) node.left, node.right = node.right, node.left return root",
          "description": "迭代法，伪后序遍历"
        },
        {
          "language": "Python",
          "code": "from collections import deque class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None queue = deque([root]) while queue: node = queue.popleft() node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root",
          "description": "迭代法，广度优先遍历"
        }
      ],
      "subsections": []
    },
    {
      "name": "深度优先遍历",
      "text": "二叉树：听说递归能做的，栈也能做！ (https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html)中给出了前中后序迭代方式的写法，所以本题可以很轻松的写出如下迭代法的代码：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (root == NULL) return root;\n        swap(root->left, root->right);\n        invertTree(root->left);\n        invertTree(root->right);\n        return root;\n    }\n};",
          "description": "递归法前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (root == NULL) return root;\n        stack<TreeNode*> st;\n        st.push(root);\n        while(!st.empty()) {\n            TreeNode* node = st.top();\n            st.pop();\n            swap(node->left, node->right);\n            if(node->right) st.push(node->right);\n            if(node->left) st.push(node->left);\n        }\n        return root;\n    }\n};",
          "description": "迭代法前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        stack<TreeNode*> st;\n        if (root != NULL) st.push(root);\n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            if (node != NULL) {\n                st.pop();\n                if (node->right) st.push(node->right);\n                if (node->left) st.push(node->left);\n                st.push(node);\n                st.push(NULL);\n            } else {\n                st.pop();\n                node = st.top();\n                st.pop();\n                swap(node->left, node->right);\n            }\n        }\n        return root;\n    }\n};",
          "description": "迭代法统一写法（前序遍历）"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        queue<TreeNode*> que;\n        if (root != NULL) que.push(root);\n        while (!que.empty()) {\n            int size = que.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode* node = que.front();\n                que.pop();\n                swap(node->left, node->right);\n                if (node->left) que.push(node->left);\n                if (node->right) que.push(node->right);\n            }\n        }\n        return root;\n    }\n};",
          "description": "广度优先遍历（层序遍历）"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (root == NULL) return root;\n        invertTree(root->left);\n        swap(root->left, root->right);\n        invertTree(root->left);\n        return root;\n    }\n};",
          "description": "递归法中序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        stack<TreeNode*> st;\n        if (root != NULL) st.push(root);\n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            if (node != NULL) {\n                st.pop();\n                if (node->right) st.push(node->right);\n                st.push(node);\n                st.push(NULL);\n                if (node->left) st.push(node->left);\n            } else {\n                st.pop();\n                node = st.top();\n                st.pop();\n                swap(node->left, node->right);\n            }\n        }\n        return root;\n    }\n};",
          "description": "迭代法统一写法（中序遍历）"
        },
        {
          "language": "java",
          "code": "class Solution {\n   public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    }\n\n    private void swapChildren(TreeNode root) {\n        TreeNode tmp = root.left;\n        root.left = root.right;\n        root.right = tmp;\n    }\n}",
          "description": "DFS递归"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {return null;}\n        ArrayDeque<TreeNode> deque = new ArrayDeque<>();\n        deque.offer(root);\n        while (!deque.isEmpty()) {\n            int size = deque.size();\n            while (size-- > 0) {\n                TreeNode node = deque.poll();\n                swap(node);\n                if (node.left != null) deque.offer(node.left);\n                if (node.right != null) deque.offer(node.right);\n            }\n        }\n        return root;\n    }\n\n    public void swap(TreeNode root) {\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n    }\n}",
          "description": "BFS"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root",
          "description": "递归法：前序遍历"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None      \n        stack = [root]        \n        while stack:\n            node = stack.pop()   \n            node.left, node.right = node.right, node.left                    \n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return root",
          "description": "迭代法：前序遍历"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        self.invertTree(root.left)\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        return root",
          "description": "递归法：中序遍历"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None      \n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            node.left, node.right = node.right, node.left # 放到中间，依然是前序遍历\n            if node.right:\n                stack.append(node.right)\n        return root",
          "description": "迭代法，伪中序遍历"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        root.left, root.right = root.right, root.left\n        return root",
          "description": "递归法：后序遍历"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        stack = [root]    \n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n            node.left, node.right = node.right, node.left               \n        return root",
          "description": "迭代法，伪后序遍历"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root: \n            return None\n\n        queue = collections.deque([root])    \n        while queue:\n            node = queue.popleft()\n            node.left, node.right = node.right, node.left\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        return root  ",
          "description": "迭代法：广度优先遍历（层序遍历）"
        }
      ],
      "subsections": []
    },
    {
      "name": "广度优先遍历",
      "text": "也就是层序遍历，层数遍历也是可以翻转这棵树的，因为层序遍历也可以把每个节点的左右孩子都翻转一遍，代码如下：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; swap(root->left, root->right); invertTree(root->left); invertTree(root->right); return root;}};",
          "description": "递归法，前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; stack<TreeNode*> st; st.push(root); while(!st.empty()) {TreeNode* node = st.top(); st.pop(); swap(node->left, node->right); if(node->right) st.push(node->right); if(node->left) st.push(node->left);} return root;}};",
          "description": "迭代法，前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {stack<TreeNode*> st; if (root != NULL) st.push(root); while (!st.empty()) {TreeNode* node = st.top(); if (node != NULL) {st.pop(); if (node->right) st.push(node->right); if (node->left) st.push(node->left); st.push(node); st.push(NULL);} else {st.pop(); node = st.top(); st.pop(); swap(node->left, node->right);}}} return root;}};",
          "description": "迭代法统一写法，前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {queue<TreeNode*> que; if (root != NULL) que.push(root); while (!que.empty()) {int size = que.size(); for (int i = 0; i < size; i++) {TreeNode* node = que.front(); que.pop(); swap(node->left, node->right); if (node->left) que.push(node->left); if (node->right) que.push(node->right);}} return root;}};",
          "description": "广度优先遍历"
        },
        {
          "language": "java",
          "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} invertTree(root.left); invertTree(root.right); swapChildren(root); return root;} private void swapChildren(TreeNode root) {TreeNode tmp = root.left; root.left = root.right; root.right = tmp;}}",
          "description": "DFS递归"
        },
        {
          "language": "java",
          "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} ArrayDeque<TreeNode> deque = new ArrayDeque<>(); deque.offer(root); while (!deque.isEmpty()) {int size = deque.size(); while (size-- > 0) {TreeNode node = deque.poll(); swap(node); if (node.left != null) deque.offer(node.left); if (node.right != null) deque.offer(node.right);}} return root;} public void swap(TreeNode root) {TreeNode temp = root.left; root.left = root.right; root.right = temp;}}",
          "description": "BFS"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root",
          "description": "递归法，前序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() node.left, node.right = node.right, node.left if node.right: stack.append(node.right) if node.left: stack.append(node.left) return root",
          "description": "迭代法，前序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) root.left, root.right = root.right, root.left self.invertTree(root.left) return root",
          "description": "递归法，中序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) node.left, node.right = node.right, node.left if node.right: stack.append(node.right) return root",
          "description": "伪中序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) self.invertTree(root.right) root.left, root.right = root.right, root.left return root",
          "description": "递归法，后序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) if node.left: stack.append(node.left) node.left, node.right = node.right, node.left return root",
          "description": "伪后序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None queue = collections.deque([root]) while queue: node = queue.popleft() node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root",
          "description": "广度优先遍历"
        }
      ],
      "subsections": []
    },
    {
      "name": "拓展",
      "text": "文中我指的是递归的中序遍历是不行的，因为使用递归的中序遍历，某些节点的左右孩子会翻转两次。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; swap(root->left, root->right); invertTree(root->left); invertTree(root->right); return root;}};",
          "description": "递归法前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; stack<TreeNode*> st; st.push(root); while(!st.empty()) {TreeNode* node = st.top(); st.pop(); swap(node->left, node->right); if(node->right) st.push(node->right); if(node->left) st.push(node->left);} return root;}};",
          "description": "迭代法前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {stack<TreeNode*> st; if (root != NULL) st.push(root); while (!st.empty()) {TreeNode* node = st.top(); if (node != NULL) {st.pop(); if (node->right) st.push(node->right); if (node->left) st.push(node->left); st.push(node); st.push(NULL);} else {st.pop(); node = st.top(); st.pop(); swap(node->left, node->right);}}} return root;}};",
          "description": "迭代法统一写法前序遍历"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {queue<TreeNode*> que; if (root != NULL) que.push(root); while (!que.empty()) {int size = que.size(); for (int i = 0; i < size; i++) {TreeNode* node = que.front(); que.pop(); swap(node->left, node->right); if (node->left) que.push(node->left); if (node->right) que.push(node->right);}} return root;}};",
          "description": "广度优先遍历"
        },
        {
          "language": "java",
          "code": "public class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} invertTree(root.left); invertTree(root.right); swapChildren(root); return root;} private void swapChildren(TreeNode root) {TreeNode tmp = root.left; root.left = root.right; root.right = tmp;}}",
          "description": "DFS递归"
        },
        {
          "language": "java",
          "code": "public class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} ArrayDeque<TreeNode> deque = new ArrayDeque<>(); deque.offer(root); while (!deque.isEmpty()) {int size = deque.size(); while (size-- > 0) {TreeNode node = deque.poll(); swap(node); if (node.left != null) deque.offer(node.left); if (node.right != null) deque.offer(node.right);}} return root;} public void swap(TreeNode root) {TreeNode temp = root.left; root.left = root.right; root.right = temp;}}",
          "description": "BFS"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root",
          "description": "递归法前序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() node.left, node.right = node.right, node.left if node.right: stack.append(node.right) if node.left: stack.append(node.left) return root",
          "description": "迭代法前序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) root.left, root.right = root.right, root.left self.invertTree(root.left) return root",
          "description": "递归法中序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) node.left, node.right = node.right, node.left if node.right: stack.append(node.right) return root",
          "description": "迭代法伪中序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) self.invertTree(root.right) root.left, root.right = root.right, root.left return root",
          "description": "递归法后序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) if node.left: stack.append(node.left) node.left, node.right = node.right, node.left return root",
          "description": "迭代法伪后序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None queue = collections.deque([root]) while queue: node = queue.popleft() node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root",
          "description": "迭代法广度优先遍历"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; swap(root->left, root->right); invertTree(root->left); invertTree(root->right); return root;}};",
          "description": "递归法翻转二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; stack<TreeNode*> st; st.push(root); while(!st.empty()) {TreeNode* node = st.top(); st.pop(); swap(node->left, node->right); if(node->right) st.push(node->right); if(node->left) st.push(node->left); } return root;}};",
          "description": "迭代法（前序遍历）翻转二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {stack<TreeNode*> st; if (root != NULL) st.push(root); while (!st.empty()) {TreeNode* node = st.top(); if (node != NULL) {st.pop(); if (node->right) st.push(node->right); if (node->left) st.push(node->left); st.push(node); st.push(NULL);} else {st.pop(); node = st.top(); st.pop(); swap(node->left, node->right);}}} return root;}};",
          "description": "迭代法统一写法（前序遍历）翻转二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {queue<TreeNode*> que; if (root != NULL) que.push(root); while (!que.empty()) {int size = que.size(); for (int i = 0; i < size; i++) {TreeNode* node = que.front(); que.pop(); swap(node->left, node->right); if (node->left) que.push(node->left); if (node->right) que.push(node->right);}}} return root;}};",
          "description": "广度优先遍历（层序遍历）翻转二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; invertTree(root->left); swap(root->left, root->right); invertTree(root->left); return root;}};",
          "description": "递归中序遍历方式翻转二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {stack<TreeNode*> st; if (root != NULL) st.push(root); while (!st.empty()) {TreeNode* node = st.top(); if (node != NULL) {st.pop(); if (node->right) st.push(node->right); st.push(node); st.push(NULL); if (node->left) st.push(node->left);} else {st.pop(); node = st.top(); st.pop(); swap(node->left, node->right);}}} return root;}};",
          "description": "迭代法统一写法（中序遍历）翻转二叉树"
        },
        {
          "language": "java",
          "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} invertTree(root.left); invertTree(root.right); swapChildren(root); return root;} private void swapChildren(TreeNode root) {TreeNode tmp = root.left; root.left = root.right; root.right = tmp;}}",
          "description": "Java版本DFS递归翻转二叉树"
        },
        {
          "language": "java",
          "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} ArrayDeque<TreeNode> deque = new ArrayDeque<>(); deque.offer(root); while (!deque.isEmpty()) {int size = deque.size(); while (size-- > 0) {TreeNode node = deque.poll(); swap(node); if (node.left != null) deque.offer(node.left); if (node.right != null) deque.offer(node.right);}} return root;} public void swap(TreeNode root) {TreeNode temp = root.left; root.left = root.right; root.right = temp;}}",
          "description": "Java版本BFS翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root",
          "description": "Python版本递归法（前序遍历）翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() node.left, node.right = node.right, node.left if node.right: stack.append(node.right) if node.left: stack.append(node.left) return root",
          "description": "Python版本迭代法（前序遍历）翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) root.left, root.right = root.right, root.left self.invertTree(root.left) return root",
          "description": "Python版本递归法（中序遍历）翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) node.left, node.right = node.right, node.left if node.right: stack.append(node.right) return root",
          "description": "Python版本迭代法伪中序遍历翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) self.invertTree(root.right) root.left, root.right = root.right, root.left return root",
          "description": "Python版本递归法（后序遍历）翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) if node.left: stack.append(node.left) node.left, node.right = node.right, node.left return root",
          "description": "Python版本迭代法伪后序遍历翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None queue = collections.deque([root]) while queue: node = queue.popleft() node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root",
          "description": "Python版本广度优先遍历（层序遍历）翻转二叉树"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java:",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution {\n   public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    }\n\n    private void swapChildren(TreeNode root) {\n        TreeNode tmp = root.left;\n        root.left = root.right;\n        root.right = tmp;\n    }\n}\n\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {return null;}\n        ArrayDeque<TreeNode> deque = new ArrayDeque<>();\n        deque.offer(root);\n        while (!deque.isEmpty()) {\n            int size = deque.size();\n            while (size-- > 0) {\n                TreeNode node = deque.poll();\n                swap(node);\n                if (node.left != null) deque.offer(node.left);\n                if (node.right != null) deque.offer(node.right);\n            }\n        }\n        return root;\n    }\n\n    public void swap(TreeNode root) {\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n    }\n}",
          "description": "Java版本的翻转二叉树，包括递归和迭代方法。"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root\n\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None      \n        stack = [root]        \n        while stack:\n            node = stack.pop()   \n            node.left, node.right = node.right, node.left                    \n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return root\n\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        self.invertTree(root.left)\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        return root\n\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None      \n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            node.left, node.right = node.right, node.left # 放到中间，依然是前序遍历\n            if node.right:\n                stack.append(node.right)\n        return root\n\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        root.left, root.right = root.right, root.left\n        return root\n\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        stack = [root]    \n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n            node.left, node.right = node.right, node.left               \n        return root\n\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root: \n            return None\n\n        queue = collections.deque([root])    \n        while queue:\n            node = queue.popleft()\n            node.left, node.right = node.right, node.left\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        return root",
          "description": "Python版本的翻转二叉树，涵盖了多种遍历方式（递归与迭代）。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java:",
      "text": "//DFS递归",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; swap(root->left, root->right);  // 中invertTree(root->left);         // 左invertTree(root->right);        // 右return root;}};",
          "description": "递归法翻转二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; stack<TreeNode*> st;st.push(root);while(!st.empty()) {TreeNode* node = st.top();              // 中st.pop();swap(node->left, node->right);if(node->right) st.push(node->right);   // 右if(node->left) st.push(node->left);     // 左}}return root;}};",
          "description": "迭代法（前序遍历）翻转二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);  // 右if (node->left) st.push(node->left);    // 左st.push(node);                          // 中st.push(NULL);} else {st.pop();node = st.top();st.pop();swap(node->left, node->right);          // 节点处理逻辑}}}return root;}};",
          "description": "迭代法统一写法（前序遍历）翻转二叉树"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {queue<TreeNode*> que;if (root != NULL) que.push(root);while (!que.empty()) {int size = que.size();for (int i = 0; i < size; i++) {TreeNode* node = que.front();que.pop();swap(node->left, node->right); // 节点处理if (node->left) que.push(node->left);if (node->right) que.push(node->right);}}}return root;}};",
          "description": "广度优先遍历（层序遍历）翻转二叉树"
        },
        {
          "language": "java",
          "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;}invertTree(root.left);invertTree(root.right);swapChildren(root);return root;}private void swapChildren(TreeNode root) {TreeNode tmp = root.left;root.left = root.right;root.right = tmp;}}",
          "description": "Java递归法翻转二叉树"
        },
        {
          "language": "java",
          "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;}ArrayDeque<TreeNode> deque = new ArrayDeque<>();deque.offer(root);while (!deque.isEmpty()) {int size = deque.size();while (size-- > 0) {TreeNode node = deque.poll();swap(node);if (node.left != null) deque.offer(node.left);if (node.right != null) deque.offer(node.right);}}}return root;}public void swap(TreeNode root) {TreeNode temp = root.left;root.left = root.right;root.right = temp;}}",
          "description": "Java广度优先遍历翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root",
          "description": "Python递归法前序遍历翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() node.left, node.right = node.right, node.left if node.right: stack.append(node.right) if node.left: stack.append(node.left) return root",
          "description": "Python迭代法前序遍历翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) root.left, root.right = root.right, root.left self.invertTree(root.left) return root",
          "description": "Python递归法中序遍历翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) node.left, node.right = node.right, node.left if node.right: stack.append(node.right) return root",
          "description": "Python迭代法伪中序遍历翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) self.invertTree(root.right) root.left, root.right = root.right, root.left return root",
          "description": "Python递归法后序遍历翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) if node.left: stack.append(node.left) node.left, node.right = node.right, node.left return root",
          "description": "Python迭代法伪后序遍历翻转二叉树"
        },
        {
          "language": "python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None queue = collections.deque([root]) while queue: node = queue.popleft() node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root",
          "description": "Python广度优先遍历翻转二叉树"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python:",
      "text": "递归法：前序遍历：",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; swap(root->left, root->right); invertTree(root->left); invertTree(root->right); return root;}};",
          "description": "递归法：前序遍历"
        },
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; stack<TreeNode*> st; st.push(root); while(!st.empty()) {TreeNode* node = st.top(); st.pop(); swap(node->left, node->right); if(node->right) st.push(node->right); if(node->left) st.push(node->left);} return root;}};",
          "description": "迭代法（前序遍历）"
        },
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {stack<TreeNode*> st; if (root != NULL) st.push(root); while (!st.empty()) {TreeNode* node = st.top(); if (node != NULL) {st.pop(); if (node->right) st.push(node->right); if (node->left) st.push(node->left); st.push(node); st.push(NULL);} else {st.pop(); node = st.top(); st.pop(); swap(node->left, node->right);}}} return root;}};",
          "description": "迭代法（统一写法-前序遍历）"
        },
        {
          "language": "C++",
          "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {queue<TreeNode*> que; if (root != NULL) que.push(root); while (!que.empty()) {int size = que.size(); for (int i = 0; i < size; i++) {TreeNode* node = que.front(); que.pop(); swap(node->left, node->right); if (node->left) que.push(node->left); if (node->right) que.push(node->right);}}} return root;}};",
          "description": "广度优先遍历（层序遍历）"
        },
        {
          "language": "Java",
          "code": "public class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} invertTree(root.left); invertTree(root.right); swapChildren(root); return root;} private void swapChildren(TreeNode root) {TreeNode tmp = root.left; root.left = root.right; root.right = tmp;}}",
          "description": "DFS递归"
        },
        {
          "language": "Java",
          "code": "public class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} ArrayDeque<TreeNode> deque = new ArrayDeque<>(); deque.offer(root); while (!deque.isEmpty()) {int size = deque.size(); while (size-- > 0) {TreeNode node = deque.poll(); swap(node); if (node.left != null) deque.offer(node.left); if (node.right != null) deque.offer(node.right);}} return root;} public void swap(TreeNode root) {TreeNode temp = root.left; root.left = root.right; root.right = temp;}}",
          "description": "BFS"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root",
          "description": "递归法：前序遍历"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() node.left, node.right = node.right, node.left if node.right: stack.append(node.right) if node.left: stack.append(node.left) return root",
          "description": "迭代法：前序遍历"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) root.left, root.right = root.right, root.left self.invertTree(root.left) return root",
          "description": "递归法：中序遍历"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) node.left, node.right = node.right, node.left if node.right: stack.append(node.right) return root",
          "description": "迭代法，伪中序遍历"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) self.invertTree(root.right) root.left, root.right = root.right, root.left return root",
          "description": "递归法：后序遍历"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) if node.left: stack.append(node.left) node.left, node.right = node.right, node.left return root",
          "description": "迭代法，伪后序遍历"
        },
        {
          "language": "Python",
          "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None queue = collections.deque([root]) while queue: node = queue.popleft() node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root",
          "description": "迭代法：广度优先遍历（层序遍历）"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "C++",
      "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; swap(root->left, root->right); invertTree(root->left); invertTree(root->right); return root;}};",
      "description": "递归法前序遍历翻转二叉树"
    },
    {
      "language": "C++",
      "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {if (root == NULL) return root; stack<TreeNode*> st; st.push(root); while(!st.empty()) {TreeNode* node = st.top(); st.pop(); swap(node->left, node->right); if(node->right) st.push(node->right); if(node->left) st.push(node->left);} return root;}};",
      "description": "迭代法前序遍历翻转二叉树"
    },
    {
      "language": "C++",
      "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {stack<TreeNode*> st; if (root != NULL) st.push(root); while (!st.empty()) {TreeNode* node = st.top(); if (node != NULL) {st.pop(); if (node->right) st.push(node->right); if (node->left) st.push(node->left); st.push(node); st.push(NULL);} else {st.pop(); node = st.top(); st.pop(); swap(node->left, node->right);}}} return root;}};",
      "description": "迭代法统一写法前序遍历翻转二叉树"
    },
    {
      "language": "C++",
      "code": "class Solution {public: TreeNode* invertTree(TreeNode* root) {queue<TreeNode*> que; if (root != NULL) que.push(root); while (!que.empty()) {int size = que.size(); for (int i = 0; i < size; i++) {TreeNode* node = que.front(); que.pop(); swap(node->left, node->right); if (node->left) que.push(node->left); if (node->right) que.push(node->right);}} return root;}};",
      "description": "广度优先遍历翻转二叉树"
    },
    {
      "language": "Java",
      "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} invertTree(root.left); invertTree(root.right); swapChildren(root); return root;} private void swapChildren(TreeNode root) {TreeNode tmp = root.left; root.left = root.right; root.right = tmp;}}",
      "description": "DFS递归前序遍历翻转二叉树"
    },
    {
      "language": "Java",
      "code": "class Solution {public TreeNode invertTree(TreeNode root) {if (root == null) {return null;} ArrayDeque<TreeNode> deque = new ArrayDeque<>(); deque.offer(root); while (!deque.isEmpty()) {int size = deque.size(); while (size-- > 0) {TreeNode node = deque.poll(); swap(node); if (node.left != null) deque.offer(node.left); if (node.right != null) deque.offer(node.right);}} return root;} public void swap(TreeNode root) {TreeNode temp = root.left; root.left = root.right; root.right = temp;}}",
      "description": "BFS层序遍历翻转二叉树"
    },
    {
      "language": "Python",
      "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root",
      "description": "递归法前序遍历翻转二叉树"
    },
    {
      "language": "Python",
      "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() node.left, node.right = node.right, node.left if node.right: stack.append(node.right) if node.left: stack.append(node.left) return root",
      "description": "迭代法前序遍历翻转二叉树"
    },
    {
      "language": "Python",
      "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) root.left, root.right = root.right, root.left self.invertTree(root.left) return root",
      "description": "递归法中序遍历翻转二叉树"
    },
    {
      "language": "Python",
      "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) node.left, node.right = node.right, node.left if node.right: stack.append(node.right) return root",
      "description": "迭代法伪中序遍历翻转二叉树"
    },
    {
      "language": "Python",
      "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None self.invertTree(root.left) self.invertTree(root.right) root.left, root.right = root.right, root.left return root",
      "description": "递归法后序遍历翻转二叉树"
    },
    {
      "language": "Python",
      "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None stack = [root] while stack: node = stack.pop() if node.right: stack.append(node.right) if node.left: stack.append(node.left) node.left, node.right = node.right, node.left return root",
      "description": "迭代法伪后序遍历翻转二叉树"
    },
    {
      "language": "Python",
      "code": "class Solution: def invertTree(self, root: TreeNode) -> TreeNode: if not root: return None queue = collections.deque([root]) while queue: node = queue.popleft() node.left, node.right = node.right, node.left if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root",
      "description": "迭代法广度优先遍历翻转二叉树"
    }
  ],
  "common_mistakes": [
    "使用中序遍历可能导致某些节点的左右孩子被翻转两次。",
    "忽略了空节点检查，导致程序错误或异常。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210203192644329.png",
      "description": "该图片展示了二叉树的镜像操作，输入为一棵二叉树，输出为其镜像树，体现了数据结构中二叉树的对称性变换算法。",
      "context": "这张图片展示了需要被翻转的二叉树示例，帮助理解题目要求。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210203192724351.png",
      "description": "这张图片展示了二叉树的翻转过程，即每个节点的左子节点和右子节点进行交换。",
      "context": "该图片展示了整棵树以中间分割线进行翻转的效果，帮助理解通过交换每个节点的左右孩子来实现二叉树翻转的过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.gif",
      "description": "这是一棵二叉树的示意图，根节点为4，展示了典型的树结构及其子节点关系。",
      "context": "该动画展示了通过前序遍历方式翻转二叉树的过程，帮助理解节点及其左右孩子是如何被交换的。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.gif",
      "description": "GIF展示了通过前序遍历递归翻转二叉树每个节点的左右子节点的过程。",
      "context": "该GIF动画展示了通过前序遍历方式翻转二叉树的过程，帮助理解节点左右孩子互换的具体步骤。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\二叉树\\翻转二叉树.txt",
  "extracted_at": "2025-07-20T09:47:22.488849",
  "raw_content": "翻转二叉树\n力扣题目链接(https://leetcode.cn/problems/invert-binary-tree/)\n\n翻转一棵二叉树。\n\nhttps://file1.kamacoder.com/i/algo/20210203192644329.png\n\n这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，全当一个乐子哈）\n\n\n#题外话\n这道题目是非常经典的题目，也是比较简单的题目（至少一看就会）。\n\n但正是因为这道题太简单，一看就会，一些同学都没有抓住起本质，稀里糊涂的就把这道题目过了。\n\n如果做过这道题的同学也建议认真看完，相信一定有所收获！\n\n#思路\n我们之前介绍的都是各种方式遍历二叉树，这次要翻转了，感觉还是有点懵逼。\n\n这得怎么翻转呢？\n\n如果要从整个树来看，翻转还真的挺复杂，整个树以中间分割线进行翻转，如图：\n\nhttps://file1.kamacoder.com/i/algo/20210203192724351.png\n\n可以发现想要翻转它，其实就把每一个节点的左右孩子交换一下就可以了。\n\n关键在于遍历顺序，前中后序应该选哪一种遍历顺序？ （一些同学这道题都过了，但是不知道自己用的是什么顺序）\n\n遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。\n\n注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果\n\n这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了\n\n那么层序遍历可以不可以呢？依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！\n\n#递归法\n对于二叉树的递归法的前中后序遍历，已经在二叉树：前中后序递归遍历 (opens new window)详细讲解了。\n\n我们下文以前序遍历为例，通过动画来看一下翻转的过程:\n\nhttps://file1.kamacoder.com/i/algo/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.gif\n\n我们来看一下递归三部曲：\n\n确定递归函数的参数和返回值\n参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。\n\n返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为TreeNode*。\n\nTreeNode* invertTree(TreeNode* root)\n确定终止条件\n当前节点为空的时候，就返回\n\nif (root == NULL) return root;\n确定单层递归的逻辑\n因为是前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。\n\nswap(root->left, root->right);\ninvertTree(root->left);\ninvertTree(root->right);\n基于这递归三步法，代码基本写完，C++代码如下：\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (root == NULL) return root;\n        swap(root->left, root->right);  // 中\n        invertTree(root->left);         // 左\n        invertTree(root->right);        // 右\n        return root;\n    }\n};\n#迭代法\n#深度优先遍历\n二叉树：听说递归能做的，栈也能做！ (https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html)中给出了前中后序迭代方式的写法，所以本题可以很轻松的写出如下迭代法的代码：\n\nC++代码迭代法（前序遍历）\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (root == NULL) return root;\n        stack<TreeNode*> st;\n        st.push(root);\n        while(!st.empty()) {\n            TreeNode* node = st.top();              // 中\n            st.pop();\n            swap(node->left, node->right);\n            if(node->right) st.push(node->right);   // 右\n            if(node->left) st.push(node->left);     // 左\n        }\n        return root;\n    }\n};\n如果这个代码看不懂的话可以再回顾一下二叉树：听说递归能做的，栈也能做！ (https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html)。\n\n我们在二叉树：前中后序迭代方式的统一写法 (https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html)中介绍了统一的写法，所以，本题也只需将文中的代码少做修改便可。\n\nC++代码如下迭代法（前序遍历）\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        stack<TreeNode*> st;\n        if (root != NULL) st.push(root);\n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            if (node != NULL) {\n                st.pop();\n                if (node->right) st.push(node->right);  // 右\n                if (node->left) st.push(node->left);    // 左\n                st.push(node);                          // 中\n                st.push(NULL);\n            } else {\n                st.pop();\n                node = st.top();\n                st.pop();\n                swap(node->left, node->right);          // 节点处理逻辑\n            }\n        }\n        return root;\n    }\n};\n如果上面这个代码看不懂，回顾一下文章二叉树：前中后序迭代方式的统一写法 (opens new window)。\n\n#广度优先遍历\n也就是层序遍历，层数遍历也是可以翻转这棵树的，因为层序遍历也可以把每个节点的左右孩子都翻转一遍，代码如下：\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        queue<TreeNode*> que;\n        if (root != NULL) que.push(root);\n        while (!que.empty()) {\n            int size = que.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode* node = que.front();\n                que.pop();\n                swap(node->left, node->right); // 节点处理\n                if (node->left) que.push(node->left);\n                if (node->right) que.push(node->right);\n            }\n        }\n        return root;\n    }\n};\n如果对以上代码不理解，或者不清楚二叉树的层序遍历，可以看这篇二叉树：层序遍历登场！(opens new window)\n\n#拓展\n文中我指的是递归的中序遍历是不行的，因为使用递归的中序遍历，某些节点的左右孩子会翻转两次。\n\n如果非要使用递归中序的方式写，也可以，如下代码就可以避免节点左右孩子翻转两次的情况：\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (root == NULL) return root;\n        invertTree(root->left);         // 左\n        swap(root->left, root->right);  // 中\n        invertTree(root->left);         // 注意 这里依然要遍历左孩子，因为中间节点已经翻转了\n        return root;\n    }\n};\n代码虽然可以，但这毕竟不是真正的递归中序遍历了。\n\n但使用迭代方式统一写法的中序是可以的。\n\n代码如下：\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        stack<TreeNode*> st;\n        if (root != NULL) st.push(root);\n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            if (node != NULL) {\n                st.pop();\n                if (node->right) st.push(node->right);  // 右\n                st.push(node);                          // 中\n                st.push(NULL);\n                if (node->left) st.push(node->left);    // 左\n\n            } else {\n                st.pop();\n                node = st.top();\n                st.pop();\n                swap(node->left, node->right);          // 节点处理逻辑\n            }\n        }\n        return root;\n    }\n};\n\n为什么这个中序就是可以的呢，因为这是用栈来遍历，而不是靠指针来遍历，避免了递归法中翻转了两次的情况，大家可以画图理解一下，这里有点意思的。\n\n#总结\n针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。\n\n二叉树解题的大忌就是自己稀里糊涂的过了（因为这道题相对简单），但是也不知道自己是怎么遍历的。\n\n这也是造成了二叉树的题目“一看就会，一写就废”的原因。\n\n针对翻转二叉树，我给出了一种递归，三种迭代（两种模拟深度优先遍历，一种层序遍历）的写法，都是之前我们讲过的写法，融汇贯通一下而已。\n\n大家一定也有自己的解法，但一定要成方法论，这样才能通用，才能举一反三！\n\n#其他语言版本\n#Java:\n//DFS递归\nclass Solution {\n   /**\n     * 前后序遍历都可以\n     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）\n     */\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    }\n\n    private void swapChildren(TreeNode root) {\n        TreeNode tmp = root.left;\n        root.left = root.right;\n        root.right = tmp;\n    }\n}\n\n//BFS\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {return null;}\n        ArrayDeque<TreeNode> deque = new ArrayDeque<>();\n        deque.offer(root);\n        while (!deque.isEmpty()) {\n            int size = deque.size();\n            while (size-- > 0) {\n                TreeNode node = deque.poll();\n                swap(node);\n                if (node.left != null) deque.offer(node.left);\n                if (node.right != null) deque.offer(node.right);\n            }\n        }\n        return root;\n    }\n\n    public void swap(TreeNode root) {\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n    }\n}\n#Python:\n递归法：前序遍历：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root\n迭代法：前序遍历：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None      \n        stack = [root]        \n        while stack:\n            node = stack.pop()   \n            node.left, node.right = node.right, node.left                   \n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return root\n递归法：中序遍历：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        self.invertTree(root.left)\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        return root\n迭代法，伪中序遍历（结果是对的，看起来像是中序遍历，实际上它是前序遍历，只不过把中间节点处理逻辑放到了中间。还是要用'统一写法'才是真正的中序遍历）：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None      \n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            node.left, node.right = node.right, node.left # 放到中间，依然是前序遍历\n            if node.right:\n                stack.append(node.right)\n        return root\n递归法：后序遍历：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        root.left, root.right = root.right, root.left\n        return root\n迭代法，伪后序遍历（结果是对的，看起来像是后序遍历，实际上它是前序遍历，只不过把中间节点处理逻辑放到了最后。还是要用'统一写法'才是真正的后序遍历）：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        stack = [root]    \n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n            node.left, node.right = node.right, node.left               \n     \n        return root\n迭代法：广度优先遍历（层序遍历）：\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root: \n            return None\n\n        queue = collections.deque([root])    \n        while queue:\n            node = queue.popleft()\n            node.left, node.right = node.right, node.left\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        return root"
}