{
  "id": "AP_0e9d8675",
  "title": "设计链表",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/design-linked-list/",
  "description": "题意：\n\n在链表类中实现这些功能：\n\nget(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\naddAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\naddAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\naddAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\ndeleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\nhttps://file1.kamacoder.com/i/algo/20200814200558953.png",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "链表"
  ],
  "data_structure_tags": [
    "单向链表",
    "双向链表"
  ],
  "technique_tags": [
    "虚拟头节点",
    "迭代遍历"
  ],
  "difficulty": null,
  "solution_approach": "通过定义一个链表类MyLinkedList实现链表的基本操作，包括获取指定位置元素、在头部/尾部/任意位置添加元素以及删除指定位置的元素。使用虚拟头节点简化边界条件处理。",
  "key_insights": [
    {
      "content": "引入虚拟头节点可以简化对于链表头部的操作逻辑，避免了直接处理真实头结点时需要额外考虑的情况。"
    },
    {
      "content": "在执行基于索引的位置操作前，必须检查给定索引是否有效（即是否位于合法范围内），以防止越界访问或错误操作。"
    },
    {
      "content": "使用双链表结构可以从头尾两个方向进行高效遍历，特别是在处理大范围索引时能显著提高效率。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "如果对链表的基础知识还不太懂，可以看这篇文章：关于链表，你该了解这些！(opens new window)",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class MyLinkedList {\npublic:\n    struct LinkedNode {\n        int val;\n        LinkedNode* next;\n        LinkedNode(int val):val(val), next(nullptr){}\n    };\n\n    MyLinkedList() {\n        _dummyHead = new LinkedNode(0);\n        _size = 0;\n    }\n\n    int get(int index) {\n        if (index > (_size - 1) || index < 0) {\n            return -1;\n        }\n        LinkedNode* cur = _dummyHead->next;\n        while(index--){\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n\n    void addAtHead(int val) {\n        LinkedNode* newNode = new LinkedNode(val);\n        newNode->next = _dummyHead->next;\n        _dummyHead->next = newNode;\n        _size++;\n    }\n\n    void addAtTail(int val) {\n        LinkedNode* newNode = new LinkedNode(val);\n        LinkedNode* cur = _dummyHead;\n        while(cur->next != nullptr){\n            cur = cur->next;\n        }\n        cur->next = newNode;\n        _size++;\n    }\n\n    void addAtIndex(int index, int val) {\n        if(index > _size) return;\n        if(index < 0) index = 0;        \n        LinkedNode* newNode = new LinkedNode(val);\n        LinkedNode* cur = _dummyHead;\n        while(index--) {\n            cur = cur->next;\n        }\n        newNode->next = cur->next;\n        cur->next = newNode;\n        _size++;\n    }\n\n    void deleteAtIndex(int index) {\n        if (index >= _size || index < 0) {\n            return;\n        }\n        LinkedNode* cur = _dummyHead;\n        while(index--) {\n            cur = cur ->next;\n        }\n        LinkedNode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        tmp=nullptr;\n        _size--;\n    }\n\nprivate:\n    int _size;\n    LinkedNode* _dummyHead;\n};",
          "description": "单链表实现"
        },
        {
          "language": "cpp",
          "code": "class MyLinkedList {\npublic:\n    struct DList {\n        int elem;\n        DList *next;\n        DList *prev;\n        DList(int elem) : elem(elem), next(nullptr), prev(nullptr) {};\n    };\n\n    MyLinkedList() {\n        sentinelNode = new DList(0);\n        sentinelNode->next = sentinelNode;\n        sentinelNode->prev = sentinelNode;\n        size = 0;\n    }\n\n    int get(int index) {\n        if (index > (size - 1) || index < 0) {\n            return -1;\n        }\n        int num;\n        int mid = size >> 1;\n        DList *curNode = sentinelNode;\n        if (index < mid) {\n            for (int i = 0; i < index + 1; i++) {\n                curNode = curNode->next;\n            }\n        } else {\n            for (int i = 0; i < size - index; i++) {\n                curNode = curNode->prev;\n            }\n        }\n        num = curNode->elem;\n        return num;\n    }\n\n    void addAtHead(int val) {\n        DList *newNode = new DList(val);\n        DList *next = sentinelNode->next;\n        newNode->prev = sentinelNode;\n        newNode->next = next;\n        size++;\n        sentinelNode->next = newNode;\n        next->prev = newNode;\n    }\n\n    void addAtTail(int val) {\n        DList *newNode = new DList(val);\n        DList *prev = sentinelNode->prev;\n        newNode->next = sentinelNode;\n        newNode->prev = prev;\n        size++;\n        sentinelNode->prev = newNode;\n        prev->next = newNode;\n    }\n\n    void addAtIndex(int index, int val) {\n        if (index > size) {\n            return;\n        }\n        if (index <= 0) {\n            addAtHead(val);\n            return;\n        }\n        int num;\n        int mid = size >> 1;\n        DList *curNode = sentinelNode;\n        if (index < mid) {\n            for (int i = 0; i < index; i++) {\n                curNode = curNode->next;\n            }\n            DList *temp = curNode->next;\n            DList *newNode = new DList(val);\n            curNode->next = newNode;\n            temp->prev = newNode;\n            newNode->next = temp;\n            newNode->prev = curNode;\n        } else {\n            for (int i = 0; i < size - index; i++) {\n                curNode = curNode->prev;\n            }\n            DList *temp = curNode->prev;\n            DList *newNode = new DList(val);\n            curNode->prev = newNode;\n            temp->next = newNode;\n            newNode->prev = temp;\n            newNode->next = curNode;\n        }\n        size++;\n    }\n\n    void deleteAtIndex(int index) {\n        if (index > (size - 1) || index < 0) {\n            return;\n        }\n        int num;\n        int mid = size >> 1;\n        DList *curNode = sentinelNode;\n        if (index < mid) {\n            for (int i = 0; i < index; i++) {\n                curNode = curNode->next;\n            }\n            DList *next = curNode->next->next;\n            curNode->next = next;\n            next->prev = curNode;\n        } else {\n            for (int i = 0; i < size - index - 1; i++) {\n                curNode = curNode->prev;\n            }\n            DList *prev = curNode->prev->prev;\n            curNode->prev = prev;\n            prev->next = curNode;\n        }\n        size--;\n    }\n\nprivate:\n    int size;\n    DList *sentinelNode;\n};",
          "description": "双链表实现"
        },
        {
          "language": "c",
          "code": "typedef struct Node {\n    int val;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    int size;\n    Node* data;\n} MyLinkedList;\n\nMyLinkedList* myLinkedListCreate() {\n    MyLinkedList* obj = (MyLinkedList*)malloc(sizeof(MyLinkedList));\n    Node* head = (Node*)malloc(sizeof(Node));\n    head->next = (void*)0;\n    obj->data = head;\n    obj->size = 0;\n    return obj;\n}\n\nint myLinkedListGet(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) return -1;\n\n    Node* cur = obj->data;\n    while (index-- >= 0) {\n        cur = cur->next;\n    }\n\n    return cur->val;\n}\n\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->val = val;\n\n    node->next = obj->data->next;\n    obj->data->next = node;\n    obj->size++;\n}\n\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\n    Node* cur = obj->data;\n    while (cur->next != ((void*)0)) {\n        cur = cur->next;\n    }\n\n    Node* tail = (Node*)malloc(sizeof(Node));\n    tail->val = val;\n    tail->next = (void*)0;\n    cur->next = tail;\n    obj->size++;\n}\n\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\n    if (index > obj->size) return;\n\n    Node* cur = obj->data;\n    while (index-- > 0) { \n        cur = cur->next;\n    }\n\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->val = val;\n    node->next = cur->next;\n    cur->next = node;\n    obj->size++;\n}\n\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) return;\n\n    Node* cur = obj->data;\n    while (index-- > 0) {\n        cur = cur->next;\n    }\n\n    Node* temp = cur->next;\n    cur->next = temp->next;\n    free(temp);\n    obj->size--;\n}\n\nvoid myLinkedListFree(MyLinkedList* obj) {\n    Node* tmp = obj->data;\n    while (tmp != NULL) {\n        Node* n = tmp;\n        tmp = tmp->next;\n        free(n);\n    }\n    free(obj);\n}",
          "description": "C语言实现"
        },
        {
          "language": "java",
          "code": "class MyLinkedList {\n\n    class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) {\n            this.val=val;\n        }\n    }\n    private int size;\n    private ListNode head;\n\n    public MyLinkedList() {\n        this.size = 0;\n        this.head = new ListNode(0);\n    }\n\n    public int get(int index) {\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        ListNode cur = head;\n        for (int i = 0; i <= index; i++) {\n            cur = cur.next;\n        }\n        return cur.val;\n    }\n\n    public void addAtHead(int val) {\n        ListNode newNode = new ListNode(val);\n        newNode.next = head.next;\n        head.next = newNode;\n        size++;\n    }\n\n    public void addAtTail(int val) {\n        ListNode newNode = new ListNode(val);\n        ListNode cur = head;\n        while (cur.next != null) {\n            cur = cur.next;\n        }\n        cur.next = newNode;\n        size++;\n    }\n\n    public void addAtIndex(int index, int val) {\n        if (index < 0 || index > size) {\n            return;\n        }\n\n        ListNode pre = head;\n        for (int i = 0; i < index; i++) {\n            pre = pre.next;\n        }\n        ListNode newNode = new ListNode(val);\n        newNode.next = pre.next;\n        pre.next = newNode;\n        size++;\n    }\n\n    public void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n\n        ListNode pre = head;\n        for (int i = 0; i < index ; i++) {\n            pre = pre.next;\n        }\n        pre.next = pre.next.next;\n        size--;\n    }\n}",
          "description": "Java单链表实现"
        },
        {
          "language": "java",
          "code": "class MyLinkedList {  \n\n    class ListNode{\n        int val;\n        ListNode next, prev;\n        ListNode(int val){\n            this.val = val;\n        }\n    }\n\n    private int size;\n    private ListNode head, tail;\n\n    public MyLinkedList() {\n        this.size = 0;\n        this.head = new ListNode(0);\n        this.tail = new ListNode(0);\n        this.head.next = tail;\n        this.tail.prev = head;\n    }\n\n    public int get(int index) {\n        if(index < 0 || index >= size){\n            return -1;\n        }\n        ListNode cur = head;\n        if(index >= size / 2){\n            cur = tail;\n            for(int i = 0; i < size - index; i++){\n                cur = cur.prev;\n            }\n        }else{\n            for(int i = 0; i <= index; i++){\n                cur = cur.next; \n            }\n        }\n        return cur.val;\n    }\n\n    public void addAtHead(int val) {\n        addAtIndex(0, val);\n    }\n\n    public void addAtTail(int val) {\n        addAtIndex(size, val);\n    }\n\n    public void addAtIndex(int index, int val) {\n        if(index < 0 || index > size){\n            return;\n        }\n\n        ListNode pre = head;\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        ListNode newNode = new ListNode(val);\n        newNode.next = pre.next;\n        pre.next.prev = newNode;\n        newNode.prev = pre;\n        pre.next = newNode;\n        size++;\n    }\n\n    public void deleteAtIndex(int index) {\n        if(index < 0 || index >= size){\n            return;\n        }\n\n        ListNode pre = head;\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        pre.next.next.prev = pre;\n        pre.next = pre.next.next;\n        size--;\n    }\n}",
          "description": "Java双链表实现"
        },
        {
          "language": "python",
          "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass MyLinkedList:\n    def __init__(self):\n        self.dummy_head = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n\n        current = self.dummy_head.next\n        for i in range(index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -> None:\n        self.dummy_head.next = ListNode(val, self.dummy_head.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        current = self.dummy_head\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n\n        current = self.dummy_head\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n\n        current = self.dummy_head\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1",
          "description": "Python单链表实现"
        },
        {
          "language": "python",
          "code": "class ListNode:\n    def __init__(self, val=0, prev=None, next=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n\nclass MyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n\n        if index < self.size // 2:\n            current = self.head\n            for i in range(index):\n                current = current.next\n        else:\n            current = self.tail\n            for i in range(self.size - index - 1):\n                current = current.prev\n\n        return current.val\n\n    def addAtHead(self, val: int) -> None:\n        new_node = ListNode(val, None, self.head)\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        new_node = ListNode(val, self.tail, None)\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n\n        if index == 0:\n            self.addAtHead(val)\n        elif index == self.size:\n            self.addAtTail(val)\n        else:\n            if index < self.size // 2:\n                current = self.head\n                for i in range(index - 1):\n                    current = current.next\n            else:\n                current = self.tail\n                for i in range(self.size - index):\n                    current = current.prev\n            new_node = ListNode(val, current, current.next)\n            current.next.prev = new_node\n            current.next = new_node\n            self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n\n        if index == 0:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n        elif index == self.size - 1:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n        else:\n            if index < self.size // 2:\n                current = self.head\n                for i in range(index):\n                    current = current.next\n            else:\n                current = self.tail\n                for i in range(self.size - index - 1):\n                    current = current.prev\n            current.prev.next = current.next\n            current.next.prev = current.prev\n        self.size -= 1",
          "description": "Python双链表实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#C++双链表法:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class MyLinkedList {\npublic:\n    struct LinkedNode {\n        int val;\n        LinkedNode* next;\n        LinkedNode(int val):val(val), next(nullptr){}\n    };\n\n    MyLinkedList() {\n        _dummyHead = new LinkedNode(0);\n        _size = 0;\n    }\n\n    int get(int index) {\n        if (index > (_size - 1) || index < 0) {\n            return -1;\n        }\n        LinkedNode* cur = _dummyHead->next;\n        while(index--){\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n\n    void addAtHead(int val) {\n        LinkedNode* newNode = new LinkedNode(val);\n        newNode->next = _dummyHead->next;\n        _dummyHead->next = newNode;\n        _size++;\n    }\n\n    void addAtTail(int val) {\n        LinkedNode* newNode = new LinkedNode(val);\n        LinkedNode* cur = _dummyHead;\n        while(cur->next != nullptr){\n            cur = cur->next;\n        }\n        cur->next = newNode;\n        _size++;\n    }\n\n    void addAtIndex(int index, int val) {\n        if(index > _size) return;\n        if(index < 0) index = 0;        \n        LinkedNode* newNode = new LinkedNode(val);\n        LinkedNode* cur = _dummyHead;\n        while(index--) {\n            cur = cur->next;\n        }\n        newNode->next = cur->next;\n        cur->next = newNode;\n        _size++;\n    }\n\n    void deleteAtIndex(int index) {\n        if (index >= _size || index < 0) {\n            return;\n        }\n        LinkedNode* cur = _dummyHead;\n        while(index--) {\n            cur = cur ->next;\n        }\n        LinkedNode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        tmp=nullptr;\n        _size--;\n    }\n\nprivate:\n    int _size;\n    LinkedNode* _dummyHead;\n};",
          "description": "C++单链表实现"
        },
        {
          "language": "cpp",
          "code": "class MyLinkedList {\npublic:\n    struct DList {\n        int elem;\n        DList *next;\n        DList *prev;\n        DList(int elem) : elem(elem), next(nullptr), prev(nullptr) {};\n    };\n\n    MyLinkedList() {\n        sentinelNode = new DList(0);\n        sentinelNode->next = sentinelNode;\n        sentinelNode->prev = sentinelNode;\n        size = 0;\n    }\n\n    int get(int index) {\n        if (index > (size - 1) || index < 0) {\n            return -1;\n        }\n        int num;\n        int mid = size >> 1;\n        DList *curNode = sentinelNode;\n        if (index < mid) {\n            for (int i = 0; i < index + 1; i++) {\n                curNode = curNode->next;\n            }\n        } else {\n            for (int i = 0; i < size - index; i++) {\n                curNode = curNode->prev;\n            }\n        }\n        num = curNode->elem;\n        return num;\n    }\n\n    void addAtHead(int val) {\n        DList *newNode = new DList(val);\n        DList *next = sentinelNode->next;\n        newNode->prev = sentinelNode;\n        newNode->next = next;\n        size++;\n        sentinelNode->next = newNode;\n        next->prev = newNode;\n    }\n\n    void addAtTail(int val) {\n        DList *newNode = new DList(val);\n        DList *prev = sentinelNode->prev;\n        newNode->next = sentinelNode;\n        newNode->prev = prev;\n        size++;\n        sentinelNode->prev = newNode;\n        prev->next = newNode;\n    }\n\n    void addAtIndex(int index, int val) {\n        if (index > size) {\n            return;\n        }\n        if (index <= 0) {\n            addAtHead(val);\n            return;\n        }\n        int num;\n        int mid = size >> 1;\n        DList *curNode = sentinelNode;\n        if (index < mid) {\n            for (int i = 0; i < index; i++) {\n                curNode = curNode->next;\n            }\n            DList *temp = curNode->next;\n            DList *newNode = new DList(val);\n            curNode->next = newNode;\n            temp->prev = newNode;\n            newNode->next = temp;\n            newNode->prev = curNode;\n        } else {\n            for (int i = 0; i < size - index; i++) {\n                curNode = curNode->prev;\n            }\n            DList *temp = curNode->prev;\n            DList *newNode = new DList(val);\n            curNode->prev = newNode;\n            temp->next = newNode;\n            newNode->prev = temp;\n            newNode->next = curNode;\n        }\n        size++;\n    }\n\n    void deleteAtIndex(int index) {\n        if (index > (size - 1) || index < 0) {\n            return;\n        }\n        int num;\n        int mid = size >> 1;\n        DList *curNode = sentinelNode;\n        if (index < mid) {\n            for (int i = 0; i < index; i++) {\n                curNode = curNode->next;\n            }\n            DList *next = curNode->next->next;\n            curNode->next = next;\n            next->prev = curNode;\n        } else {\n            for (int i = 0; i < size - index - 1; i++) {\n                curNode = curNode->prev;\n            }\n            DList *prev = curNode->prev->prev;\n            curNode->prev = prev;\n            prev->next = curNode;\n        }\n        size--;\n    }\n\nprivate:\n    int size;\n    DList *sentinelNode;\n};",
          "description": "C++双链表实现"
        },
        {
          "language": "c",
          "code": "typedef struct Node {\n    int val;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    int size;\n    Node* data;\n} MyLinkedList;\n\nMyLinkedList* myLinkedListCreate() {\n    MyLinkedList* obj = (MyLinkedList*)malloc(sizeof(MyLinkedList));\n    Node* head = (Node*)malloc(sizeof(Node));\n    head->next = (void*)0;\n    obj->data = head;\n    obj->size = 0;\n    return obj;\n}\n\nint myLinkedListGet(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) return -1;\n\n    Node* cur = obj->data;\n    while (index-- >= 0) {\n        cur = cur->next;\n    }\n\n    return cur->val;\n}\n\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->val = val;\n\n    node->next = obj->data->next;\n    obj->data->next = node;\n    obj->size++;\n}\n\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\n    Node* cur = obj->data;\n    while (cur->next != ((void*)0)) {\n        cur = cur->next;\n    }\n\n    Node* tail = (Node*)malloc(sizeof(Node));\n    tail->val = val;\n    tail->next = (void*)0;\n    cur->next = tail;\n    obj->size++;\n}\n\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\n    if (index > obj->size) return;\n\n    Node* cur = obj->data;\n    while (index-- > 0) { \n        cur = cur->next;\n    }\n\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->val = val;\n    node->next = cur->next;\n    cur->next = node;\n    obj->size++;\n}\n\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) return;\n\n    Node* cur = obj->data;\n    while (index-- > 0) {\n        cur = cur->next;\n    }\n\n    Node* temp = cur->next;\n    cur->next = temp->next;\n    free(temp);\n    obj->size--;\n}\n\nvoid myLinkedListFree(MyLinkedList* obj) {\n    Node* tmp = obj->data;\n    while (tmp != NULL) {\n        Node* n = tmp;\n        tmp = tmp->next;\n        free(n);\n    }\n    free(obj);\n}",
          "description": "C语言实现"
        },
        {
          "language": "java",
          "code": "class MyLinkedList {\n\n    class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) {\n            this.val=val;\n        }\n    }\n    private int size;\n    private ListNode head;\n\n    public MyLinkedList() {\n        this.size = 0;\n        this.head = new ListNode(0);\n    }\n\n    public int get(int index) {\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        ListNode cur = head;\n        for (int i = 0; i <= index; i++) {\n            cur = cur.next;\n        }\n        return cur.val;\n    }\n\n    public void addAtHead(int val) {\n        ListNode newNode = new ListNode(val);\n        newNode.next = head.next;\n        head.next = newNode;\n        size++;\n    }\n\n    public void addAtTail(int val) {\n        ListNode newNode = new ListNode(val);\n        ListNode cur = head;\n        while (cur.next != null) {\n            cur = cur.next;\n        }\n        cur.next = newNode;\n        size++;\n    }\n\n    public void addAtIndex(int index, int val) {\n        if (index < 0 || index > size) {\n            return;\n        }\n\n        ListNode pre = head;\n        for (int i = 0; i < index; i++) {\n            pre = pre.next;\n        }\n        ListNode newNode = new ListNode(val);\n        newNode.next = pre.next;\n        pre.next = newNode;\n        size++;\n    }\n\n    public void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n\n        ListNode pre = head;\n        for (int i = 0; i < index ; i++) {\n            pre = pre.next;\n        }\n        pre.next = pre.next.next;\n        size--;\n    }\n}",
          "description": "Java单链表实现"
        },
        {
          "language": "java",
          "code": "class MyLinkedList {  \n    class ListNode{\n        int val;\n        ListNode next, prev;\n        ListNode(int val){\n            this.val = val;\n        }\n    }\n\n    private int size;\n    private ListNode head, tail;\n    \n    public MyLinkedList() {\n        this.size = 0;\n        this.head = new ListNode(0);\n        this.tail = new ListNode(0);\n        this.head.next = tail;\n        this.tail.prev = head;\n    }\n    \n    public int get(int index) {\n        if(index < 0 || index >= size){\n            return -1;\n        }\n        ListNode cur = head;\n        if(index >= size / 2){\n            cur = tail;\n            for(int i = 0; i < size - index; i++){\n                cur = cur.prev;\n            }\n        }else{\n            for(int i = 0; i <= index; i++){\n                cur = cur.next; \n            }\n        }\n        return cur.val;\n    }\n    \n    public void addAtHead(int val) {\n        addAtIndex(0, val);\n    }\n    \n    public void addAtTail(int val) {\n        addAtIndex(size, val);\n    }\n    \n    public void addAtIndex(int index, int val) {\n        if(index < 0 || index > size){\n            return;\n        }\n\n        ListNode pre = head;\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        ListNode newNode = new ListNode(val);\n        newNode.next = pre.next;\n        pre.next.prev = newNode;\n        newNode.prev = pre;\n        pre.next = newNode;\n        size++;\n    }\n    \n    public void deleteAtIndex(int index) {\n        if(index < 0 || index >= size){\n            return;\n        }\n\n        ListNode pre = head;\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        pre.next.next.prev = pre;\n        pre.next = pre.next.next;\n        size--;\n    }\n}",
          "description": "Java双链表实现"
        },
        {
          "language": "python",
          "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass MyLinkedList:\n    def __init__(self):\n        self.dummy_head = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n\n        current = self.dummy_head.next\n        for i in range(index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -> None:\n        self.dummy_head.next = ListNode(val, self.dummy_head.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        current = self.dummy_head\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n\n        current = self.dummy_head\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n\n        current = self.dummy_head\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1",
          "description": "Python单链表实现"
        },
        {
          "language": "python",
          "code": "class ListNode:\n    def __init__(self, val=0, prev=None, next=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n\nclass MyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n\n        if index < self.size // 2:\n            current = self.head\n            for i in range(index):\n                current = current.next\n        else:\n            current = self.tail\n            for i in range(self.size - index - 1):\n                current = current.prev\n\n        return current.val\n\n    def addAtHead(self, val: int) -> None:\n        new_node = ListNode(val, None, self.head)\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        new_node = ListNode(val, self.tail, None)\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n\n        if index == 0:\n            self.addAtHead(val)\n        elif index == self.size:\n            self.addAtTail(val)\n        else:\n            if index < self.size // 2:\n                current = self.head\n                for i in range(index - 1):\n                    current = current.next\n            else:\n                current = self.tail\n                for i in range(self.size - index):\n                    current = current.prev\n            new_node = ListNode(val, current, current.next)\n            current.next.prev = new_node\n            current.next = new_node\n            self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n\n        if index == 0:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n        elif index == self.size - 1:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n        else:\n            if index < self.size // 2:\n                current = self.head\n                for i in range(index):\n                    current = current.next\n            else:\n                current = self.tail\n                for i in range(self.size - index - 1):\n                    current = current.prev\n            current.prev.next = current.next\n            current.next.prev = current.prev\n        self.size -= 1",
          "description": "Python双链表实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "C++双链表法:",
      "text": "//采用循环虚拟结点的双链表实现",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class MyLinkedList {\npublic:\n    struct LinkedNode {\n        int val;\n        LinkedNode* next;\n        LinkedNode(int val):val(val), next(nullptr){}\n    };\n\n    MyLinkedList() {\n        _dummyHead = new LinkedNode(0);\n        _size = 0;\n    }\n\n    int get(int index) {\n        if (index > (_size - 1) || index < 0) {\n            return -1;\n        }\n        LinkedNode* cur = _dummyHead->next;\n        while(index--){\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n\n    void addAtHead(int val) {\n        LinkedNode* newNode = new LinkedNode(val);\n        newNode->next = _dummyHead->next;\n        _dummyHead->next = newNode;\n        _size++;\n    }\n\n    void addAtTail(int val) {\n        LinkedNode* newNode = new LinkedNode(val);\n        LinkedNode* cur = _dummyHead;\n        while(cur->next != nullptr){\n            cur = cur->next;\n        }\n        cur->next = newNode;\n        _size++;\n    }\n\n    void addAtIndex(int index, int val) {\n        if(index > _size) return;\n        if(index < 0) index = 0;        \n        LinkedNode* newNode = new LinkedNode(val);\n        LinkedNode* cur = _dummyHead;\n        while(index--) {\n            cur = cur->next;\n        }\n        newNode->next = cur->next;\n        cur->next = newNode;\n        _size++;\n    }\n\n    void deleteAtIndex(int index) {\n        if (index >= _size || index < 0) {\n            return;\n        }\n        LinkedNode* cur = _dummyHead;\n        while(index--) {\n            cur = cur ->next;\n        }\n        LinkedNode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        tmp=nullptr;\n        _size--;\n    }\n\n    void printLinkedList() {\n        LinkedNode* cur = _dummyHead;\n        while (cur->next != nullptr) {\n            cout << cur->next->val << \" \";\n            cur = cur->next;\n        }\n        cout << endl;\n    }\nprivate:\n    int _size;\n    LinkedNode* _dummyHead;\n};",
          "description": "C++实现的单链表，支持获取、添加（头部/尾部/指定位置）、删除节点等操作。"
        },
        {
          "language": "cpp",
          "code": "class MyLinkedList {\npublic:\n    struct DList {\n        int elem;\n        DList *next, *prev;\n        DList(int elem) : elem(elem), next(nullptr), prev(nullptr) {}\n    };\n\n    MyLinkedList() {\n        sentinelNode = new DList(0);\n        sentinelNode->next = sentinelNode;\n        sentinelNode->prev = sentinelNode;\n        size = 0;\n    }\n\n    int get(int index) {\n        if (index > (size - 1) || index < 0) {\n            return -1;\n        }\n        int num;\n        int mid = size >> 1;\n        DList *curNode = sentinelNode;\n        if (index < mid) {\n            for (int i = 0; i < index + 1; i++) {\n                curNode = curNode->next;\n            }\n        } else {\n            for (int i = 0; i < size - index; i++) {\n                curNode = curNode->prev;\n            }\n        }\n        num = curNode->elem;\n        return num;\n    }\n\n    void addAtHead(int val) {\n        DList *newNode = new DList(val);\n        DList *next = sentinelNode->next;\n        newNode->prev = sentinelNode;\n        newNode->next = next;\n        size++;\n        sentinelNode->next = newNode;\n        next->prev = newNode;\n    }\n\n    void addAtTail(int val) {\n        DList *newNode = new DList(val);\n        DList *prev = sentinelNode->prev;\n        newNode->next = sentinelNode;\n        newNode->prev = prev;\n        size++;\n        sentinelNode->prev = newNode;\n        prev->next = newNode;\n    }\n\n    void addAtIndex(int index, int val) {\n        if (index > size) {\n            return;\n        }\n        if (index <= 0) {\n            addAtHead(val);\n            return;\n        }\n        int num;\n        int mid = size >> 1;\n        DList *curNode = sentinelNode;\n        if (index < mid) {\n            for (int i = 0; i < index; i++) {\n                curNode = curNode->next;\n            }\n            DList *temp = curNode->next;\n            DList *newNode = new DList(val);\n            curNode->next = newNode;\n            temp->prev = newNode;\n            newNode->next = temp;\n            newNode->prev = curNode;\n        } else {\n            for (int i = 0; i < size - index; i++) {\n                curNode = curNode->prev;\n            }\n            DList *temp = curNode->prev;\n            DList *newNode = new DList(val);\n            curNode->prev = newNode;\n            temp->next = newNode;\n            newNode->prev = temp;\n            newNode->next = curNode;\n        }\n        size++;\n    }\n\n    void deleteAtIndex(int index) {\n        if (index > (size - 1) || index < 0) {\n            return;\n        }\n        int num;\n        int mid = size >> 1;\n        DList *curNode = sentinelNode;\n        if (index < mid) {\n            for (int i = 0; i < index; i++) {\n                curNode = curNode->next;\n            }\n            DList *next = curNode->next->next;\n            curNode->next = next;\n            next->prev = curNode;\n        } else {\n            for (int i = 0; i < size - index - 1; i++) {\n                curNode = curNode->prev;\n            }\n            DList *prev = curNode->prev->prev;\n            curNode->prev = prev;\n            prev->next = curNode;\n        }\n        size--;\n    }\n\nprivate:\n    int size;\n    DList *sentinelNode;\n};",
          "description": "C++实现的双链表，使用循环虚拟结点，支持获取、添加（头部/尾部/指定位置）、删除节点等操作。"
        },
        {
          "language": "c",
          "code": "typedef struct Node {\n    int val;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    int size;\n    Node* data;\n} MyLinkedList;\n\nMyLinkedList* myLinkedListCreate() {\n    MyLinkedList* obj = (MyLinkedList*)malloc(sizeof(MyLinkedList));\n    Node* head = (Node*)malloc(sizeof(Node));\n    head->next = (void*)0;\n    obj->data = head;\n    obj->size = 0;\n    return obj;\n}\n\nint myLinkedListGet(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) return -1;\n\n    Node* cur = obj->data;\n    while (index-- >= 0) {\n        cur = cur->next;\n    }\n\n    return cur->val;\n}\n\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->val = val;\n\n    node->next = obj->data->next;\n    obj->data->next = node;\n    obj->size++;\n}\n\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\n    Node* cur = obj->data;\n    while (cur->next != ((void*)0)) {\n        cur = cur->next;\n    }\n\n    Node* tail = (Node*)malloc(sizeof(Node));\n    tail->val = val;\n    tail->next = (void*)0;\n    cur->next = tail;\n    obj->size++;\n}\n\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\n    if (index > obj->size) return;\n\n    Node* cur = obj->data;\n    while (index-- > 0) { \n        cur = cur->next;\n    }\n\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->val = val;\n    node->next = cur->next;\n    cur->next = node;\n    obj->size++;\n}\n\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) return;\n\n    Node* cur = obj->data;\n    while (index-- > 0) {\n        cur = cur->next;\n    }\n\n    Node* temp = cur->next;\n    cur->next = temp->next;\n    free(temp);\n    obj->size--;\n}\n\nvoid myLinkedListFree(MyLinkedList* obj) {\n    Node* tmp = obj->data;\n    while (tmp != NULL) {\n        Node* n = tmp;\n        tmp = tmp->next;\n        free(n);\n    }\n    free(obj);\n}",
          "description": "C语言实现的单链表，支持获取、添加（头部/尾部/指定位置）、删除节点等操作。"
        },
        {
          "language": "java",
          "code": "class MyLinkedList {\n\n    class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) {\n            this.val=val;\n        }\n    }\n    private int size;\n    private ListNode head;\n\n    public MyLinkedList() {\n        this.size = 0;\n        this.head = new ListNode(0);\n    }\n\n    public int get(int index) {\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        ListNode cur = head;\n        for (int i = 0; i <= index; i++) {\n            cur = cur.next;\n        }\n        return cur.val;\n    }\n\n    public void addAtHead(int val) {\n        ListNode newNode = new ListNode(val);\n        newNode.next = head.next;\n        head.next = newNode;\n        size++;\n    }\n\n    public void addAtTail(int val) {\n        ListNode newNode = new ListNode(val);\n        ListNode cur = head;\n        while (cur.next != null) {\n            cur = cur.next;\n        }\n        cur.next = newNode;\n        size++;\n    }\n\n    public void addAtIndex(int index, int val) {\n        if (index < 0 || index > size) {\n            return;\n        }\n        ListNode pre = head;\n        for (int i = 0; i < index; i++) {\n            pre = pre.next;\n        }\n        ListNode newNode = new ListNode(val);\n        newNode.next = pre.next;\n        pre.next = newNode;\n        size++;\n    }\n\n    public void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n        ListNode pre = head;\n        for (int i = 0; i < index ; i++) {\n            pre = pre.next;\n        }\n        pre.next = pre.next.next;\n        size--;\n    }\n}",
          "description": "Java实现的单链表，支持获取、添加（头部/尾部/指定位置）、删除节点等操作。"
        },
        {
          "language": "java",
          "code": "class MyLinkedList {  \n\n    class ListNode{\n        int val;\n        ListNode next, prev;\n        ListNode(int val){\n            this.val = val;\n        }\n    }\n\n    private int size;\n    private ListNode head, tail;\n\n    public MyLinkedList() {\n        this.size = 0;\n        this.head = new ListNode(0);\n        this.tail = new ListNode(0);\n        this.head.next = tail;\n        this.tail.prev = head;\n    }\n\n    public int get(int index) {\n        if(index < 0 || index >= size){\n            return -1;\n        }\n        ListNode cur = head;\n        if(index >= size / 2){\n            cur = tail;\n            for(int i = 0; i < size - index; i++){\n                cur = cur.prev;\n            }\n        }else{\n            for(int i = 0; i <= index; i++){\n                cur = cur.next; \n            }\n        }\n        return cur.val;\n    }\n\n    public void addAtHead(int val) {\n        addAtIndex(0, val);\n    }\n\n    public void addAtTail(int val) {\n        addAtIndex(size, val);\n    }\n\n    public void addAtIndex(int index, int val) {\n        if(index < 0 || index > size){\n            return;\n        }\n        ListNode pre = head;\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        ListNode newNode = new ListNode(val);\n        newNode.next = pre.next;\n        pre.next.prev = newNode;\n        newNode.prev = pre;\n        pre.next = newNode;\n        size++;\n    }\n\n    public void deleteAtIndex(int index) {\n        if(index < 0 || index >= size){\n            return;\n        }\n        ListNode pre = head;\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        pre.next.next.prev = pre;\n        pre.next = pre.next.next;\n        size--;\n    }\n}",
          "description": "Java实现的双链表，支持获取、添加（头部/尾部/指定位置）、删除节点等操作。"
        },
        {
          "language": "python",
          "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass MyLinkedList:\n    def __init__(self):\n        self.dummy_head = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n\n        current = self.dummy_head.next\n        for i in range(index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -> None:\n        self.dummy_head.next = ListNode(val, self.dummy_head.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        current = self.dummy_head\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n\n        current = self.dummy_head\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n\n        current = self.dummy_head\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1",
          "description": "Python实现的单链表，支持获取、添加（头部/尾部/指定位置）、删除节点等操作。"
        },
        {
          "language": "python",
          "code": "class ListNode:\n    def __init__(self, val=0, prev=None, next=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n\nclass MyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n\n        if index < self.size // 2:\n            current = self.head\n            for i in range(index):\n                current = current.next\n        else:\n            current = self.tail\n            for i in range(self.size - index - 1):\n                current = current.prev\n\n        return current.val\n\n    def addAtHead(self, val: int) -> None:\n        new_node = ListNode(val, None, self.head)\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        new_node = ListNode(val, self.tail, None)\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n\n        if index == 0:\n            self.addAtHead(val)\n        elif index == self.size:\n            self.addAtTail(val)\n        else:\n            if index < self.size // 2:\n                current = self.head\n                for i in range(index - 1):\n                    current = current.next\n            else:\n                current = self.tail\n                for i in range(self.size - index):\n                    current = current.prev\n            new_node = ListNode(val, current, current.next)\n            current.next.prev = new_node\n            current.next = new_node\n            self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n\n        if index == 0:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n        elif index == self.size - 1:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n        else:\n            if index < self.size // 2:\n                current = self.head\n                for i in range(index):\n                    current = current.next\n            else:\n                current = self.tail\n                for i in range(self.size - index - 1):\n                    current = current.prev\n            current.prev.next = current.next\n            current.next.prev = current.prev\n        self.size -= 1",
          "description": "Python实现的双链表，支持获取、添加（头部/尾部/指定位置）、删除节点等操作。"
        }
      ],
      "subsections": []
    },
    {
      "name": "C:",
      "text": "typedef struct Node {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "typedef struct Node {int val;struct Node* next;} Node;typedef struct {int size;Node* data;} MyLinkedList;MyLinkedList* myLinkedListCreate() {MyLinkedList* obj = (MyLinkedList*)malloc(sizeof(MyLinkedList));Node* head = (Node*)malloc(sizeof(Node));head->next = (void*)0;obj->data = head;obj->size = 0;return obj;}int myLinkedListGet(MyLinkedList* obj, int index) {if (index < 0 || index >= obj->size) return -1;Node* cur = obj->data;while (index-- >= 0) {cur = cur->next;}return cur->val;}void myLinkedListAddAtHead(MyLinkedList* obj, int val) {Node* node = (Node*)malloc(sizeof(Node));node->val = val;node->next = obj->data->next;obj->data->next = node;obj->size++;}void myLinkedListAddAtTail(MyLinkedList* obj, int val) {Node* cur = obj->data;while (cur->next != ((void*)0)) {cur = cur->next;}Node* tail = (Node*)malloc(sizeof(Node));tail->val = val;tail->next = (void*)0;cur->next = tail;obj->size++;}void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {if (index > obj->size) return;Node* cur = obj->data;while (index-- > 0) {cur = cur->next;}Node* node = (Node*)malloc(sizeof(Node));node->val = val;node->next = cur->next;cur->next = node;obj->size++;}void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {if (index < 0 || index >= obj->size) return;Node* cur = obj->data;while (index-- > 0) {cur = cur->next;}Node* temp = cur->next;cur->next = temp->next;free(temp);obj->size--;}void myLinkedListFree(MyLinkedList* obj) {Node* tmp = obj->data;while (tmp != NULL) {Node* n = tmp;tmp = tmp->next;free(n);}free(obj);}",
          "description": "C语言实现的单链表"
        },
        {
          "language": "java",
          "code": "class MyLinkedList {class ListNode {int val;ListNode next;ListNode(int val) {this.val=val;}}private int size;private ListNode head;public MyLinkedList() {this.size = 0;this.head = new ListNode(0);}public int get(int index) {if (index < 0 || index >= size) {return -1;}ListNode cur = head;for (int i = 0; i <= index; i++) {cur = cur.next;}return cur.val;}public void addAtHead(int val) {ListNode newNode = new ListNode(val);newNode.next = head.next;head.next = newNode;size++;}public void addAtTail(int val) {ListNode newNode = new ListNode(val);ListNode cur = head;while (cur.next != null) {cur = cur.next;}cur.next = newNode;size++;}public void addAtIndex(int index, int val) {if (index < 0 || index > size) {return;}ListNode pre = head;for (int i = 0; i < index; i++) {pre = pre.next;}ListNode newNode = new ListNode(val);newNode.next = pre.next;pre.next = newNode;size++;}public void deleteAtIndex(int index) {if (index < 0 || index >= size) {return;}ListNode pre = head;for (int i = 0; i < index ; i++) {pre = pre.next;}pre.next = pre.next.next;size--;}}",
          "description": "Java语言实现的单链表"
        },
        {
          "language": "python",
          "code": "class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = nextclass MyLinkedList: def __init__(self): self.dummy_head = ListNode() self.size = 0 def get(self, index: int) -> int: if index < 0 or index >= self.size: return -1 current = self.dummy_head.next for i in range(index): current = current.next return current.val def addAtHead(self, val: int) -> None: self.dummy_head.next = ListNode(val, self.dummy_head.next) self.size += 1 def addAtTail(self, val: int) -> None: current = self.dummy_head while current.next: current = current.next current.next = ListNode(val) self.size += 1 def addAtIndex(self, index: int, val: int) -> None: if index < 0 or index > self.size: return current = self.dummy_head for i in range(index): current = current.next current.next = ListNode(val, current.next) self.size += 1 def deleteAtIndex(self, index: int) -> None: if index < 0 or index >= self.size: return current = self.dummy_head for i in range(index): current = current.next current.next = current.next.next self.size -= 1",
          "description": "Python语言实现的单链表"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "//单链表",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class MyLinkedList { public: struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val):val(val), next(nullptr){} }; MyLinkedList() { _dummyHead = new LinkedNode(0); _size = 0; } int get(int index) { if (index > (_size - 1) || index < 0) { return -1; } LinkedNode* cur = _dummyHead->next; while(index--){ cur = cur->next; } return cur->val; } void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode->next = _dummyHead->next; _dummyHead->next = newNode; _size++; } void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(cur->next != nullptr){ cur = cur->next; } cur->next = newNode; _size++; } void addAtIndex(int index, int val) { if(index > _size) return; if(index < 0) index = 0; LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(index--) { cur = cur->next; } newNode->next = cur->next; cur->next = newNode; _size++; } void deleteAtIndex(int index) { if (index >= _size || index < 0) { return; } LinkedNode* cur = _dummyHead; while(index--) { cur = cur ->next; } LinkedNode* tmp = cur->next; cur->next = cur->next->next; delete tmp; tmp=nullptr; _size--; } private: int _size; LinkedNode* _dummyHead; };",
          "description": "单链表实现"
        },
        {
          "language": "cpp",
          "code": "class MyLinkedList { public: struct DList { int elem; DList *next; DList *prev; DList(int elem) : elem(elem), next(nullptr), prev(nullptr) {}; }; MyLinkedList() { sentinelNode = new DList(0); sentinelNode->next = sentinelNode; sentinelNode->prev = sentinelNode; size = 0; } int get(int index) { if (index > (size - 1) || index < 0) { return -1; } int num; int mid = size >> 1; DList *curNode = sentinelNode; if (index < mid) { for (int i = 0; i < index + 1; i++) { curNode = curNode->next; } } else { for (int i = 0; i < size - index; i++) { curNode = curNode->prev; } } num = curNode->elem; return num; } void addAtHead(int val) { DList *newNode = new DList(val); DList *next = sentinelNode->next; newNode->prev = sentinelNode; newNode->next = next; size++; sentinelNode->next = newNode; next->prev = newNode; } void addAtTail(int val) { DList *newNode = new DList(val); DList *prev = sentinelNode->prev; newNode->next = sentinelNode; newNode->prev = prev; size++; sentinelNode->prev = newNode; prev->next = newNode; } void addAtIndex(int index, int val) { if (index > size) { return; } if (index <= 0) { addAtHead(val); return; } int num; int mid = size >> 1; DList *curNode = sentinelNode; if (index < mid) { for (int i = 0; i < index; i++) { curNode = curNode->next; } DList *temp = curNode->next; DList *newNode = new DList(val); curNode->next = newNode; temp->prev = newNode; newNode->next = temp; newNode->prev = curNode; } else { for (int i = 0; i < size - index; i++) { curNode = curNode->prev; } DList *temp = curNode->prev; DList *newNode = new DList(val); curNode->prev = newNode; temp->next = newNode; newNode->prev = temp; newNode->next = curNode; } size++; } void deleteAtIndex(int index) { if (index > (size - 1) || index < 0) { return; } int num; int mid = size >> 1; DList *curNode = sentinelNode; if (index < mid) { for (int i = 0; i < index; i++) { curNode = curNode->next; } DList *next = curNode->next->next; curNode->next = next; next->prev = curNode; } else { for (int i = 0; i < size - index - 1; i++) { curNode = curNode->prev; } DList *prev = curNode->prev->prev; curNode->prev = prev; prev->next = curNode; } size--; } private: int size; DList *sentinelNode; };",
          "description": "双链表实现"
        },
        {
          "language": "c",
          "code": "typedef struct Node { int val; struct Node* next; } Node; typedef struct { int size; Node* data; } MyLinkedList; MyLinkedList* myLinkedListCreate() { MyLinkedList* obj = (MyLinkedList*)malloc(sizeof(MyLinkedList)); Node* head = (Node*)malloc(sizeof(Node)); head->next = (void*)0; obj->data = head; obj->size = 0; return obj; } int myLinkedListGet(MyLinkedList* obj, int index) { if (index < 0 || index >= obj->size) return -1; Node* cur = obj->data; while (index-- >= 0) { cur = cur->next; } return cur->val; } void myLinkedListAddAtHead(MyLinkedList* obj, int val) { Node* node = (Node*)malloc(sizeof(Node)); node->val = val; node->next = obj->data->next; obj->data->next = node; obj->size++; } void myLinkedListAddAtTail(MyLinkedList* obj, int val) { Node* cur = obj->data; while (cur->next != ((void*)0)) { cur = cur->next; } Node* tail = (Node*)malloc(sizeof(Node)); tail->val = val; tail->next = (void*)0; cur->next = tail; obj->size++; } void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) { if (index > obj->size) return; Node* cur = obj->data; while (index-- > 0) { cur = cur->next; } Node* node = (Node*)malloc(sizeof(Node)); node->val = val; node->next = cur->next; cur->next = node; obj->size++; } void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) { if (index < 0 || index >= obj->size) return; Node* cur = obj->data; while (index-- > 0) { cur = cur->next; } Node* temp = cur->next; cur->next = temp->next; free(temp); obj->size--; } void myLinkedListFree(MyLinkedList* obj) { Node* tmp = obj->data; while (tmp != NULL) { Node* n = tmp; tmp = tmp->next; free(n); } free(obj); }",
          "description": "C语言实现"
        },
        {
          "language": "java",
          "code": "class MyLinkedList { class ListNode { int val; ListNode next; ListNode(int val) { this.val=val; } } private int size; private ListNode head; public MyLinkedList() { this.size = 0; this.head = new ListNode(0); } public int get(int index) { if (index < 0 || index >= size) { return -1; } ListNode cur = head; for (int i = 0; i <= index; i++) { cur = cur.next; } return cur.val; } public void addAtHead(int val) { ListNode newNode = new ListNode(val); newNode.next = head.next; head.next = newNode; size++; } public void addAtTail(int val) { ListNode newNode = new ListNode(val); ListNode cur = head; while (cur.next != null) { cur = cur.next; } cur.next = newNode; size++; } public void addAtIndex(int index, int val) { if (index < 0 || index > size) { return; } ListNode pre = head; for (int i = 0; i < index; i++) { pre = pre.next; } ListNode newNode = new ListNode(val); newNode.next = pre.next; pre.next = newNode; size++; } public void deleteAtIndex(int index) { if (index < 0 || index >= size) { return; } ListNode pre = head; for (int i = 0; i < index ; i++) { pre = pre.next; } pre.next = pre.next.next; size--; } }",
          "description": "Java单链表实现"
        },
        {
          "language": "java",
          "code": "class MyLinkedList { class ListNode{ int val; ListNode next, prev; ListNode(int val){ this.val = val; } } private int size; private ListNode head, tail; public MyLinkedList() { this.size = 0; this.head = new ListNode(0); this.tail = new ListNode(0); this.head.next = tail; this.tail.prev = head; } public int get(int index) { if(index < 0 || index >= size){ return -1; } ListNode cur = head; if(index >= size / 2){ cur = tail; for(int i = 0; i < size - index; i++){ cur = cur.prev; } }else{ for(int i = 0; i <= index; i++){ cur = cur.next; } } return cur.val; } public void addAtHead(int val) { addAtIndex(0, val); } public void addAtTail(int val) { addAtIndex(size, val); } public void addAtIndex(int index, int val) { if(index < 0 || index > size){ return; } ListNode pre = head; for(int i = 0; i < index; i++){ pre = pre.next; } ListNode newNode = new ListNode(val); newNode.next = pre.next; pre.next.prev = newNode; newNode.prev = pre; pre.next = newNode; size++; } public void deleteAtIndex(int index) { if(index < 0 || index >= size){ return; } ListNode pre = head; for(int i = 0; i < index; i++){ pre = pre.next; } pre.next.next.prev = pre; pre.next = pre.next.next; size--; } }",
          "description": "Java双链表实现"
        },
        {
          "language": "python",
          "code": "class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class MyLinkedList: def __init__(self): self.dummy_head = ListNode() self.size = 0 def get(self, index: int) -> int: if index < 0 or index >= self.size: return -1 current = self.dummy_head.next for i in range(index): current = current.next return current.val def addAtHead(self, val: int) -> None: self.dummy_head.next = ListNode(val, self.dummy_head.next) self.size += 1 def addAtTail(self, val: int) -> None: current = self.dummy_head while current.next: current = current.next current.next = ListNode(val) self.size += 1 def addAtIndex(self, index: int, val: int) -> None: if index < 0 or index > self.size: return current = self.dummy_head for i in range(index): current = current.next current.next = ListNode(val, current.next) self.size += 1 def deleteAtIndex(self, index: int) -> None: if index < 0 or index >= self.size: return current = self.dummy_head for i in range(index): current = current.next current.next = current.next.next self.size -= 1",
          "description": "Python单链表实现"
        },
        {
          "language": "python",
          "code": "class ListNode: def __init__(self, val=0, prev=None, next=None): self.val = val self.prev = prev self.next = next class MyLinkedList: def __init__(self): self.head = None self.tail = None self.size = 0 def get(self, index: int) -> int: if index < 0 or index >= self.size: return -1 if index < self.size // 2: current = self.head for i in range(index): current = current.next else: current = self.tail for i in range(self.size - index - 1): current = current.prev return current.val def addAtHead(self, val: int) -> None: new_node = ListNode(val, None, self.head) if self.head: self.head.prev = new_node else: self.tail = new_node self.head = new_node self.size += 1 def addAtTail(self, val: int) -> None: new_node = ListNode(val, self.tail, None) if self.tail: self.tail.next = new_node else: self.head = new_node self.tail = new_node self.size += 1 def addAtIndex(self, index: int, val: int) -> None: if index < 0 or index > self.size: return if index == 0: self.addAtHead(val) elif index == self.size: self.addAtTail(val) else: if index < self.size // 2: current = self.head for i in range(index - 1): current = current.next else: current = self.tail for i in range(self.size - index): current = current.prev new_node = ListNode(val, current, current.next) current.next.prev = new_node current.next = new_node self.size += 1 def deleteAtIndex(self, index: int) -> None: if index < 0 or index >= self.size: return if index == 0: self.head = self.head.next if self.head: self.head.prev = None else: self.tail = None elif index == self.size - 1: self.tail = self.tail.prev if self.tail: self.tail.next = None else: self.head = None else: if index < self.size // 2: current = self.head for i in range(index): current = current.next else: current = self.tail for i in range(self.size - index - 1): current = current.prev current.prev.next = current.next current.next.prev = current.prev self.size -= 1",
          "description": "Python双链表实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "（版本一）单链表法",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class MyLinkedList {\npublic:\n    struct LinkedNode {\n        int val;\n        LinkedNode* next;\n        LinkedNode(int val):val(val), next(nullptr){}\n    };\n\n    MyLinkedList() {\n        _dummyHead = new LinkedNode(0);\n        _size = 0;\n    }\n\n    int get(int index) {\n        if (index > (_size - 1) || index < 0) {\n            return -1;\n        }\n        LinkedNode* cur = _dummyHead->next;\n        while(index--){\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n\n    void addAtHead(int val) {\n        LinkedNode* newNode = new LinkedNode(val);\n        newNode->next = _dummyHead->next;\n        _dummyHead->next = newNode;\n        _size++;\n    }\n\n    void addAtTail(int val) {\n        LinkedNode* newNode = new LinkedNode(val);\n        LinkedNode* cur = _dummyHead;\n        while(cur->next != nullptr){\n            cur = cur->next;\n        }\n        cur->next = newNode;\n        _size++;\n    }\n\n    void addAtIndex(int index, int val) {\n        if(index > _size) return;\n        if(index < 0) index = 0;        \n        LinkedNode* newNode = new LinkedNode(val);\n        LinkedNode* cur = _dummyHead;\n        while(index--) {\n            cur = cur->next;\n        }\n        newNode->next = cur->next;\n        cur->next = newNode;\n        _size++;\n    }\n\n    void deleteAtIndex(int index) {\n        if (index >= _size || index < 0) {\n            return;\n        }\n        LinkedNode* cur = _dummyHead;\n        while(index--) {\n            cur = cur ->next;\n        }\n        LinkedNode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        tmp=nullptr;\n        _size--;\n    }\n\nprivate:\n    int _size;\n    LinkedNode* _dummyHead;\n};",
          "description": "单链表实现"
        },
        {
          "language": "cpp",
          "code": "class MyLinkedList {\npublic:\n    struct DList {\n        int elem;\n        DList *next;\n        DList *prev;\n        DList(int elem) : elem(elem), next(nullptr), prev(nullptr) {};\n    };\n\n    MyLinkedList() {\n        sentinelNode = new DList(0);\n        sentinelNode->next = sentinelNode;\n        sentinelNode->prev = sentinelNode;\n        size = 0;\n    }\n\n    int get(int index) {\n        if (index > (size - 1) || index < 0) {\n            return -1;\n        }\n        int num;\n        int mid = size >> 1;\n        DList *curNode = sentinelNode;\n        if (index < mid) {\n            for (int i = 0; i < index + 1; i++) {\n                curNode = curNode->next;\n            }\n        } else {\n            for (int i = 0; i < size - index; i++) {\n                curNode = curNode->prev;\n            }\n        }\n        num = curNode->elem;\n        return num;\n    }\n\n    void addAtHead(int val) {\n        DList *newNode = new DList(val);\n        DList *next = sentinelNode->next;\n        newNode->prev = sentinelNode;\n        newNode->next = next;\n        size++;\n        sentinelNode->next = newNode;\n        next->prev = newNode;\n    }\n\n    void addAtTail(int val) {\n        DList *newNode = new DList(val);\n        DList *prev = sentinelNode->prev;\n        newNode->next = sentinelNode;\n        newNode->prev = prev;\n        size++;\n        sentinelNode->prev = newNode;\n        prev->next = newNode;\n    }\n\n    void addAtIndex(int index, int val) {\n        if (index > size) {\n            return;\n        }\n        if (index <= 0) {\n            addAtHead(val);\n            return;\n        }\n        int num;\n        int mid = size >> 1;\n        DList *curNode = sentinelNode;\n        if (index < mid) {\n            for (int i = 0; i < index; i++) {\n                curNode = curNode->next;\n            }\n            DList *temp = curNode->next;\n            DList *newNode = new DList(val);\n            curNode->next = newNode;\n            temp->prev = newNode;\n            newNode->next = temp;\n            newNode->prev = curNode;\n        } else {\n            for (int i = 0; i < size - index; i++) {\n                curNode = curNode->prev;\n            }\n            DList *temp = curNode->prev;\n            DList *newNode = new DList(val);\n            curNode->prev = newNode;\n            temp->next = newNode;\n            newNode->prev = temp;\n            newNode->next = curNode;\n        }\n        size++;\n    }\n\n    void deleteAtIndex(int index) {\n        if (index > (size - 1) || index < 0) {\n            return;\n        }\n        int num;\n        int mid = size >> 1;\n        DList *curNode = sentinelNode;\n        if (index < mid) {\n            for (int i = 0; i < index; i++) {\n                curNode = curNode->next;\n            }\n            DList *next = curNode->next->next;\n            curNode->next = next;\n            next->prev = curNode;\n        } else {\n            for (int i = 0; i < size - index - 1; i++) {\n                curNode = curNode->prev;\n            }\n            DList *prev = curNode->prev->prev;\n            curNode->prev = prev;\n            prev->next = curNode;\n        }\n        size--;\n    }\n\nprivate:\n    int size;\n    DList *sentinelNode;\n};",
          "description": "双链表实现"
        },
        {
          "language": "c",
          "code": "typedef struct Node {\n    int val;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    int size;\n    Node* data;\n} MyLinkedList;\n\nMyLinkedList* myLinkedListCreate() {\n    MyLinkedList* obj = (MyLinkedList*)malloc(sizeof(MyLinkedList));\n    Node* head = (Node*)malloc(sizeof(Node));\n    head->next = (void*)0;\n    obj->data = head;\n    obj->size = 0;\n    return obj;\n}\n\nint myLinkedListGet(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) return -1;\n\n    Node* cur = obj->data;\n    while (index-- >= 0) {\n        cur = cur->next;\n    }\n\n    return cur->val;\n}\n\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->val = val;\n\n    node->next = obj->data->next;\n    obj->data->next = node;\n    obj->size++;\n}\n\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\n    Node* cur = obj->data;\n    while (cur->next != ((void*)0)) {\n        cur = cur->next;\n    }\n\n    Node* tail = (Node*)malloc(sizeof(Node));\n    tail->val = val;\n    tail->next = (void*)0;\n    cur->next = tail;\n    obj->size++;\n}\n\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\n    if (index > obj->size) return;\n\n    Node* cur = obj->data;\n    while (index-- > 0) { \n        cur = cur->next;\n    }\n\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->val = val;\n    node->next = cur->next;\n    cur->next = node;\n    obj->size++;\n}\n\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\n    if (index < 0 || index >= obj->size) return;\n\n    Node* cur = obj->data;\n    while (index-- > 0) {\n        cur = cur->next;\n    }\n\n    Node* temp = cur->next;\n    cur->next = temp->next;\n    free(temp);\n    obj->size--;\n}\n\nvoid myLinkedListFree(MyLinkedList* obj) {\n    Node* tmp = obj->data;\n    while (tmp != NULL) {\n        Node* n = tmp;\n        tmp = tmp->next;\n        free(n);\n    }\n    free(obj);\n}",
          "description": "C语言实现"
        },
        {
          "language": "java",
          "code": "class MyLinkedList {\n    class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) {\n            this.val=val;\n        }\n    }\n    private int size;\n    private ListNode head;\n\n    public MyLinkedList() {\n        this.size = 0;\n        this.head = new ListNode(0);\n    }\n\n    public int get(int index) {\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        ListNode cur = head;\n        for (int i = 0; i <= index; i++) {\n            cur = cur.next;\n        }\n        return cur.val;\n    }\n\n    public void addAtHead(int val) {\n        ListNode newNode = new ListNode(val);\n        newNode.next = head.next;\n        head.next = newNode;\n        size++;\n    }\n\n    public void addAtTail(int val) {\n        ListNode newNode = new ListNode(val);\n        ListNode cur = head;\n        while (cur.next != null) {\n            cur = cur.next;\n        }\n        cur.next = newNode;\n        size++;\n    }\n\n    public void addAtIndex(int index, int val) {\n        if (index < 0 || index > size) {\n            return;\n        }\n        ListNode pre = head;\n        for (int i = 0; i < index; i++) {\n            pre = pre.next;\n        }\n        ListNode newNode = new ListNode(val);\n        newNode.next = pre.next;\n        pre.next = newNode;\n        size++;\n    }\n\n    public void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n        ListNode pre = head;\n        for (int i = 0; i < index ; i++) {\n            pre = pre.next;\n        }\n        pre.next = pre.next.next;\n        size--;\n    }\n}\nclass MyLinkedList {  \n    class ListNode{\n        int val;\n        ListNode next, prev;\n        ListNode(int val){\n            this.val = val;\n        }\n    }\n    private int size;\n    private ListNode head, tail;\n    public MyLinkedList() {\n        this.size = 0;\n        this.head = new ListNode(0);\n        this.tail = new ListNode(0);\n        this.head.next = tail;\n        this.tail.prev = head;\n    }\n    public int get(int index) {\n        if(index < 0 || index >= size){\n            return -1;\n        }\n        ListNode cur = head;\n        if(index >= size / 2){\n            cur = tail;\n            for(int i = 0; i < size - index; i++){\n                cur = cur.prev;\n            }\n        }else{\n            for(int i = 0; i <= index; i++){\n                cur = cur.next; \n            }\n        }\n        return cur.val;\n    }\n    public void addAtHead(int val) {\n        addAtIndex(0, val);\n    }\n    public void addAtTail(int val) {\n        addAtIndex(size, val);\n    }\n    public void addAtIndex(int index, int val) {\n        if(index < 0 || index > size){\n            return;\n        }\n        ListNode pre = head;\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        ListNode newNode = new ListNode(val);\n        newNode.next = pre.next;\n        pre.next.prev = newNode;\n        newNode.prev = pre;\n        pre.next = newNode;\n        size++;\n    }\n    public void deleteAtIndex(int index) {\n        if(index < 0 || index >= size){\n            return;\n        }\n        ListNode pre = head;\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        pre.next.next.prev = pre;\n        pre.next = pre.next.next;\n        size--;\n    }\n}",
          "description": "Java单链表与双链表实现"
        },
        {
          "language": "python",
          "code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass MyLinkedList:\n    def __init__(self):\n        self.dummy_head = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n\n        current = self.dummy_head.next\n        for i in range(index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -> None:\n        self.dummy_head.next = ListNode(val, self.dummy_head.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        current = self.dummy_head\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n\n        current = self.dummy_head\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n\n        current = self.dummy_head\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1",
          "description": "Python单链表实现"
        },
        {
          "language": "python",
          "code": "class ListNode:\n    def __init__(self, val=0, prev=None, next=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n\nclass MyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n\n        if index < self.size // 2:\n            current = self.head\n            for i in range(index):\n                current = current.next\n        else:\n            current = self.tail\n            for i in range(self.size - index - 1):\n                current = current.prev\n\n        return current.val\n\n    def addAtHead(self, val: int) -> None:\n        new_node = ListNode(val, None, self.head)\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        new_node = ListNode(val, self.tail, None)\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n\n        if index == 0:\n            self.addAtHead(val)\n        elif index == self.size:\n            self.addAtTail(val)\n        else:\n            if index < self.size // 2:\n                current = self.head\n                for i in range(index - 1):\n                    current = current.next\n            else:\n                current = self.tail\n                for i in range(self.size - index):\n                    current = current.prev\n            new_node = ListNode(val, current, current.next)\n            current.next.prev = new_node\n            current.next = new_node\n            self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n\n        if index == 0:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n        elif index == self.size - 1:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n        else:\n            if index < self.size // 2:\n                current = self.head\n                for i in range(index):\n                    current = current.next\n            else:\n                current = self.tail\n                for i in range(self.size - index - 1):\n                    current = current.prev\n            current.prev.next = current.next\n            current.next.prev = current.prev\n        self.size -= 1",
          "description": "Python双链表实现"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": null,
    "space_complexity": "O(n)",
    "explanation": "其余为 O(1)"
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class MyLinkedList {public: struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val):val(val), next(nullptr){}}; MyLinkedList() {_dummyHead = new LinkedNode(0); _size = 0;} int get(int index) { if (index > (_size - 1) || index < 0) { return -1; } LinkedNode* cur = _dummyHead->next; while(index--){ cur = cur->next; } return cur->val; } void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode->next = _dummyHead->next; _dummyHead->next = newNode; _size++; } void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(cur->next != nullptr){ cur = cur->next; } cur->next = newNode; _size++; } void addAtIndex(int index, int val) { if(index > _size) return; if(index < 0) index = 0; LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(index--) { cur = cur->next; } newNode->next = cur->next; cur->next = newNode; _size++; } void deleteAtIndex(int index) { if (index >= _size || index < 0) { return; } LinkedNode* cur = _dummyHead; while(index--) { cur = cur ->next; } LinkedNode* tmp = cur->next; cur->next = cur->next->next; delete tmp; tmp=nullptr; _size--; } void printLinkedList() { LinkedNode* cur = _dummyHead; while (cur->next != nullptr) { cout << cur->next->val << \" \"; cur = cur->next; } cout << endl; } private: int _size; LinkedNode* _dummyHead;};",
      "description": "单链表实现"
    },
    {
      "language": "cpp",
      "code": "class MyLinkedList {public: struct DList { int elem; DList *next, *prev; DList(int elem) : elem(elem), next(nullptr), prev(nullptr) {}; }; MyLinkedList() { sentinelNode = new DList(0); sentinelNode->next = sentinelNode; sentinelNode->prev = sentinelNode; size = 0; } int get(int index) { if (index > (size - 1) || index < 0) { return -1; } int num, mid = size >> 1; DList *curNode = sentinelNode; if (index < mid) { for (int i = 0; i < index + 1; i++) { curNode = curNode->next; } } else { for (int i = 0; i < size - index; i++) { curNode = curNode->prev; } } num = curNode->elem; return num; } void addAtHead(int val) { DList *newNode = new DList(val), *next = sentinelNode->next; newNode->prev = sentinelNode; newNode->next = next; size++; sentinelNode->next = newNode; next->prev = newNode; } void addAtTail(int val) { DList *newNode = new DList(val), *prev = sentinelNode->prev; newNode->next = sentinelNode; newNode->prev = prev; size++; sentinelNode->prev = newNode; prev->next = newNode; } void addAtIndex(int index, int val) { if (index > size) { return; } if (index <= 0) { addAtHead(val); return; } int num, mid = size >> 1; DList *curNode = sentinelNode; if (index < mid) { for (int i = 0; i < index; i++) { curNode = curNode->next; } DList *temp = curNode->next, *newNode = new DList(val); curNode->next = newNode; temp->prev = newNode; newNode->next = temp; newNode->prev = curNode; } else { for (int i = 0; i < size - index; i++) { curNode = curNode->prev; } DList *temp = curNode->prev, *newNode = new DList(val); curNode->prev = newNode; temp->next = newNode; newNode->prev = temp; newNode->next = curNode; } size++; } void deleteAtIndex(int index) { if (index > (size - 1) || index < 0) { return; } int num, mid = size >> 1; DList *curNode = sentinelNode; if (index < mid) { for (int i = 0; i < index; i++) { curNode = curNode->next; } DList *next = curNode->next->next; curNode->next = next; next->prev = curNode; } else { for (int i = 0; i < size - index - 1; i++) { curNode = curNode->prev; } DList *prev = curNode->prev->prev; curNode->prev = prev; prev->next = curNode; } size--; } private: int size; DList *sentinelNode;};",
      "description": "双链表实现"
    },
    {
      "language": "c",
      "code": "typedef struct Node { int val; struct Node* next; } Node; typedef struct { int size; Node* data; } MyLinkedList; MyLinkedList* myLinkedListCreate() { MyLinkedList* obj = (MyLinkedList*)malloc(sizeof(MyLinkedList)); Node* head = (Node*)malloc(sizeof(Node)); head->next = (void*)0; obj->data = head; obj->size = 0; return obj; } int myLinkedListGet(MyLinkedList* obj, int index) { if (index < 0 || index >= obj->size) return -1; Node* cur = obj->data; while (index-- >= 0) { cur = cur->next; } return cur->val; } void myLinkedListAddAtHead(MyLinkedList* obj, int val) { Node* node = (Node*)malloc(sizeof(Node)); node->val = val; node->next = obj->data->next; obj->data->next = node; obj->size++; } void myLinkedListAddAtTail(MyLinkedList* obj, int val) { Node* cur = obj->data; while (cur->next != ((void*)0)) { cur = cur->next; } Node* tail = (Node*)malloc(sizeof(Node)); tail->val = val; tail->next = (void*)0; cur->next = tail; obj->size++; } void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) { if (index > obj->size) return; Node* cur = obj->data; while (index-- > 0) { cur = cur->next; } Node* node = (Node*)malloc(sizeof(Node)); node->val = val; node->next = cur->next; cur->next = node; obj->size++; } void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) { if (index < 0 || index >= obj->size) return; Node* cur = obj->data; while (index-- > 0) { cur = cur->next; } Node* temp = cur->next; cur->next = temp->next; free(temp); obj->size--; } void myLinkedListFree(MyLinkedList* obj) { Node* tmp = obj->data; while (tmp != NULL) { Node* n = tmp; tmp = tmp->next; free(n); } free(obj); }",
      "description": "C语言实现"
    },
    {
      "language": "java",
      "code": "class MyLinkedList { class ListNode { int val; ListNode next; ListNode(int val) { this.val=val; } } private int size; private ListNode head; public MyLinkedList() { this.size = 0; this.head = new ListNode(0); } public int get(int index) { if (index < 0 || index >= size) { return -1; } ListNode cur = head; for (int i = 0; i <= index; i++) { cur = cur.next; } return cur.val; } public void addAtHead(int val) { ListNode newNode = new ListNode(val); newNode.next = head.next; head.next = newNode; size++; } public void addAtTail(int val) { ListNode newNode = new ListNode(val); ListNode cur = head; while (cur.next != null) { cur = cur.next; } cur.next = newNode; size++; } public void addAtIndex(int index, int val) { if (index < 0 || index > size) { return; } ListNode pre = head; for (int i = 0; i < index; i++) { pre = pre.next; } ListNode newNode = new ListNode(val); newNode.next = pre.next; pre.next = newNode; size++; } public void deleteAtIndex(int index) { if (index < 0 || index >= size) { return; } ListNode pre = head; for (int i = 0; i < index ; i++) { pre = pre.next; } pre.next = pre.next.next; size--; }}",
      "description": "Java单链表实现"
    },
    {
      "language": "java",
      "code": "class MyLinkedList { class ListNode{ int val; ListNode next, prev; ListNode(int val){ this.val = val; } } private int size; private ListNode head, tail; public MyLinkedList() { this.size = 0; this.head = new ListNode(0); this.tail = new ListNode(0); this.head.next = tail; this.tail.prev = head; } public int get(int index) { if(index < 0 || index >= size){ return -1; } ListNode cur = head; if(index >= size / 2){ cur = tail; for(int i = 0; i < size - index; i++){ cur = cur.prev; } }else{ for(int i = 0; i <= index; i++){ cur = cur.next; } } return cur.val; } public void addAtHead(int val) { addAtIndex(0, val); } public void addAtTail(int val) { addAtIndex(size, val); } public void addAtIndex(int index, int val) { if(index < 0 || index > size){ return; } ListNode pre = head; for(int i = 0; i < index; i++){ pre = pre.next; } ListNode newNode = new ListNode(val); newNode.next = pre.next; pre.next.prev = newNode; newNode.prev = pre; pre.next = newNode; size++; } public void deleteAtIndex(int index) { if(index < 0 || index >= size){ return; } ListNode pre = head; for(int i = 0; i < index; i++){ pre = pre.next; } pre.next.next.prev = pre; pre.next = pre.next.next; size--; }}",
      "description": "Java双链表实现"
    },
    {
      "language": "python",
      "code": "class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next class MyLinkedList: def __init__(self): self.dummy_head = ListNode() self.size = 0 def get(self, index: int) -> int: if index < 0 or index >= self.size: return -1 current = self.dummy_head.next for i in range(index): current = current.next return current.val def addAtHead(self, val: int) -> None: self.dummy_head.next = ListNode(val, self.dummy_head.next) self.size += 1 def addAtTail(self, val: int) -> None: current = self.dummy_head while current.next: current = current.next current.next = ListNode(val) self.size += 1 def addAtIndex(self, index: int, val: int) -> None: if index < 0 or index > self.size: return current = self.dummy_head for i in range(index): current = current.next current.next = ListNode(val, current.next) self.size += 1 def deleteAtIndex(self, index: int) -> None: if index < 0 or index >= self.size: return current = self.dummy_head for i in range(index): current = current.next current.next = current.next.next self.size -= 1",
      "description": "Python单链表实现"
    },
    {
      "language": "python",
      "code": "class ListNode: def __init__(self, val=0, prev=None, next=None): self.val = val self.prev = prev self.next = next class MyLinkedList: def __init__(self): self.head = None self.tail = None self.size = 0 def get(self, index: int) -> int: if index < 0 or index >= self.size: return -1 if index < self.size // 2: current = self.head for i in range(index): current = current.next else: current = self.tail for i in range(self.size - index - 1): current = current.prev return current.val def addAtHead(self, val: int) -> None: new_node = ListNode(val, None, self.head) if self.head: self.head.prev = new_node else: self.tail = new_node self.head = new_node self.size += 1 def addAtTail(self, val: int) -> None: new_node = ListNode(val, self.tail, None) if self.tail: self.tail.next = new_node else: self.head = new_node self.tail = new_node self.size += 1 def addAtIndex(self, index: int, val: int) -> None: if index < 0 or index > self.size: return if index == 0: self.addAtHead(val) elif index == self.size: self.addAtTail(val) else: if index < self.size // 2: current = self.head for i in range(index - 1): current = current.next else: current = self.tail for i in range(self.size - index): current = current.prev new_node = ListNode(val, current, current.next) current.next.prev = new_node current.next = new_node self.size += 1 def deleteAtIndex(self, index: int) -> None: if index < 0 or index >= self.size: return if index == 0: self.head = self.head.next if self.head: self.head.prev = None else: self.tail = None elif index == self.size - 1: self.tail = self.tail.prev if self.tail: self.tail.next = None else: self.head = None else: if index < self.size // 2: current = self.head for i in range(index): current = current.next else: current = self.tail for i in range(self.size - index - 1): current = current.prev current.prev.next = current.next current.next.prev = current.prev self.size -= 1",
      "description": "Python双链表实现"
    }
  ],
  "common_mistakes": [
    "未初始化链表长度变量导致后续操作中出现错误。",
    "忘记更新链表长度，在增删节点后没有相应地增加或减少链表大小。",
    "在循环中使用--index而不是index--来定位目标节点位置，可能导致死循环。",
    "删除节点时，仅断开链接而未释放内存，造成内存泄漏。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20200814200558953.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20200814200558953.png",
      "context": "该图片展示了如何通过addAtIndex方法在指定位置插入新节点以及如何使用deleteAtIndex方法删除链表中特定位置的节点的操作示意图。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20200806195114541.png",
      "description": "这张图片展示了一个单链表的结构，其中节点C和D之间的连接被删除，形成了从C直接指向E的链接。",
      "context": "此图片展示了删除链表节点的操作过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20200806195134331.png",
      "description": "这张图片展示了一个单链表的结构，其中节点C和D之间的连接被删除，并插入了一个新节点F，指向节点D。",
      "context": "该图片展示了在链表中添加节点的过程，是关于如何通过设置虚拟头结点来简化链表操作的一部分说明。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20200814200558953.png",
      "description": "GIF展示了链表中添加和删除节点的操作过程。",
      "context": "此GIF动画展示了如何通过addAtIndex方法在链表中指定位置插入新节点的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20200806195114541.png",
      "description": "GIF展示了链表中删除指定索引节点的过程。",
      "context": "该GIF动画展示了如何从链表中删除一个节点的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20200806195134331.png",
      "description": "GIF展示了在链表中插入新节点的过程。",
      "context": "GIF动画展示了在链表中添加节点的过程，帮助理解通过设置虚拟头结点来简化操作的方法。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\链表\\设计链表.txt",
  "extracted_at": "2025-07-22T21:40:41.450598",
  "raw_content": "设计链表\n力扣题目链接(https://leetcode.cn/problems/design-linked-list/)\n\n题意：\n\n在链表类中实现这些功能：\n\nget(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\naddAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\naddAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\naddAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\ndeleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\nhttps://file1.kamacoder.com/i/algo/20200814200558953.png\n\n\n#思路\n如果对链表的基础知识还不太懂，可以看这篇文章：关于链表，你该了解这些！(opens new window)\n\n如果对链表的虚拟头结点不清楚，可以看这篇文章：链表：听说用虚拟头节点会方便很多？(opens new window)\n\n删除链表节点： https://file1.kamacoder.com/i/algo/20200806195114541.png\n\n添加链表节点： https://file1.kamacoder.com/i/algo/20200806195134331.png\n\n这道题目设计链表的五个接口：\n\n获取链表第index个节点的数值\n在链表的最前面插入一个节点\n在链表的最后面插入一个节点\n在链表第index个节点前面插入一个节点\n删除链表的第index个节点\n可以说这五个接口，已经覆盖了链表的常见操作，是练习链表操作非常好的一道题目\n\n链表操作的两种方式：\n\n直接使用原来的链表来进行操作。\n设置一个虚拟头结点在进行操作。\n下面采用的设置一个虚拟头结点（这样更方便一些，大家看代码就会感受出来）。\n\nclass MyLinkedList {\npublic:\n    // 定义链表节点结构体\n    struct LinkedNode {\n        int val;\n        LinkedNode* next;\n        LinkedNode(int val):val(val), next(nullptr){}\n    };\n\n    // 初始化链表\n    MyLinkedList() {\n        _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点\n        _size = 0;\n    }\n\n    // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点\n    int get(int index) {\n        if (index > (_size - 1) || index < 0) {\n            return -1;\n        }\n        LinkedNode* cur = _dummyHead->next;\n        while(index--){ // 如果--index 就会陷入死循环\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n\n    // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点\n    void addAtHead(int val) {\n        LinkedNode* newNode = new LinkedNode(val);\n        newNode->next = _dummyHead->next;\n        _dummyHead->next = newNode;\n        _size++;\n    }\n\n    // 在链表最后面添加一个节点\n    void addAtTail(int val) {\n        LinkedNode* newNode = new LinkedNode(val);\n        LinkedNode* cur = _dummyHead;\n        while(cur->next != nullptr){\n            cur = cur->next;\n        }\n        cur->next = newNode;\n        _size++;\n    }\n\n    // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。\n    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点\n    // 如果index大于链表的长度，则返回空\n    // 如果index小于0，则在头部插入节点\n    void addAtIndex(int index, int val) {\n\n        if(index > _size) return;\n        if(index < 0) index = 0;        \n        LinkedNode* newNode = new LinkedNode(val);\n        LinkedNode* cur = _dummyHead;\n        while(index--) {\n            cur = cur->next;\n        }\n        newNode->next = cur->next;\n        cur->next = newNode;\n        _size++;\n    }\n\n    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的\n    void deleteAtIndex(int index) {\n        if (index >= _size || index < 0) {\n            return;\n        }\n        LinkedNode* cur = _dummyHead;\n        while(index--) {\n            cur = cur ->next;\n        }\n        LinkedNode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        //delete命令指示释放了tmp指针原本所指的那部分内存，\n        //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，\n        //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针\n        //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间\n        tmp=nullptr;\n        _size--;\n    }\n\n    // 打印链表\n    void printLinkedList() {\n        LinkedNode* cur = _dummyHead;\n        while (cur->next != nullptr) {\n            cout << cur->next->val << \" \";\n            cur = cur->next;\n        }\n        cout << endl;\n    }\nprivate:\n    int _size;\n    LinkedNode* _dummyHead;\n\n};\n时间复杂度: 涉及 index 的相关操作为 O(index), 其余为 O(1)\n空间复杂度: O(n)\n#其他语言版本\n#C++双链表法:\n//采用循环虚拟结点的双链表实现\nclass MyLinkedList {\npublic:\n    // 定义双向链表节点结构体\n    struct DList {\n        int elem; // 节点存储的元素\n        DList *next; // 指向下一个节点的指针\n        DList *prev; // 指向上一个节点的指针\n        // 构造函数，创建一个值为elem的新节点\n        DList(int elem) : elem(elem), next(nullptr), prev(nullptr) {};\n    };\n\n    // 构造函数，初始化链表\n    MyLinkedList() {\n        sentinelNode = new DList(0); // 创建哨兵节点，不存储有效数据\n        sentinelNode->next = sentinelNode; // 哨兵节点的下一个节点指向自身，形成循环\n        sentinelNode->prev = sentinelNode; // 哨兵节点的上一个节点指向自身，形成循环\n        size = 0; // 初始化链表大小为0\n    }\n\n    // 获取链表中第index个节点的值\n    int get(int index) {\n        if (index > (size - 1) || index < 0) { // 检查索引是否超出范围\n            return -1; // 如果超出范围，返回-1\n        }\n        int num;\n        int mid = size >> 1; // 计算链表中部位置\n        DList *curNode = sentinelNode; // 从哨兵节点开始\n        if (index < mid) { // 如果索引小于中部位置，从前往后遍历\n            for (int i = 0; i < index + 1; i++) {\n                curNode = curNode->next; // 移动到目标节点\n            }\n        } else { // 如果索引大于等于中部位置，从后往前遍历\n            for (int i = 0; i < size - index; i++) {\n                curNode = curNode->prev; // 移动到目标节点\n            }\n        }\n        num = curNode->elem; // 获取目标节点的值\n        return num; // 返回节点的值\n    }\n\n    // 在链表头部添加节点\n    void addAtHead(int val) {\n        DList *newNode = new DList(val); // 创建新节点\n        DList *next = sentinelNode->next; // 获取当前头节点的下一个节点\n        newNode->prev = sentinelNode; // 新节点的上一个节点指向哨兵节点\n        newNode->next = next; // 新节点的下一个节点指向原来的头节点\n        size++; // 链表大小加1\n        sentinelNode->next = newNode; // 哨兵节点的下一个节点指向新节点\n        next->prev = newNode; // 原来的头节点的上一个节点指向新节点\n    }\n\n    // 在链表尾部添加节点\n    void addAtTail(int val) {\n        DList *newNode = new DList(val); // 创建新节点\n        DList *prev = sentinelNode->prev; // 获取当前尾节点的上一个节点\n        newNode->next = sentinelNode; // 新节点的下一个节点指向哨兵节点\n        newNode->prev = prev; // 新节点的上一个节点指向原来的尾节点\n        size++; // 链表大小加1\n        sentinelNode->prev = newNode; // 哨兵节点的上一个节点指向新节点\n        prev->next = newNode; // 原来的尾节点的下一个节点指向新节点\n    }\n\n    // 在链表中的第index个节点之前添加值为val的节点\n    void addAtIndex(int index, int val) {\n        if (index > size) { // 检查索引是否超出范围\n            return; // 如果超出范围，直接返回\n        }\n        if (index <= 0) { // 如果索引为0或负数，在头部添加节点\n            addAtHead(val);\n            return;\n        }\n        int num;\n        int mid = size >> 1; // 计算链表中部位置\n        DList *curNode = sentinelNode; // 从哨兵节点开始\n        if (index < mid) { // 如果索引小于中部位置，从前往后遍历\n            for (int i = 0; i < index; i++) {\n                curNode = curNode->next; // 移动到目标位置的前一个节点\n            }\n            DList *temp = curNode->next; // 获取目标位置的节点\n            DList *newNode = new DList(val); // 创建新节点\n            curNode->next = newNode; // 在目标位置前添加新节点\n            temp->prev = newNode; // 目标位置的节点的前一个节点指向新节点\n            newNode->next = temp; // 新节点的下一个节点指向目标位置的结点\n            newNode->prev = curNode; // 新节点的上一个节点指向当前节点\n        } else { // 如果索引大于等于中部位置，从后往前遍历\n            for (int i = 0; i < size - index; i++) {\n                curNode = curNode->prev; // 移动到目标位置的后一个节点\n            }\n            DList *temp = curNode->prev; // 获取目标位置的节点\n            DList *newNode = new DList(val); // 创建新节点\n            curNode->prev = newNode; // 在目标位置后添加新节点\n            temp->next = newNode; // 目标位置的节点的下一个节点指向新节点\n            newNode->prev = temp; // 新节点的上一个节点指向目标位置的节点\n            newNode->next = curNode; // 新节点的下一个节点指向当前节点\n        }\n        size++; // 链表大小加1\n    }\n\n    // 删除链表中的第index个节点\n    void deleteAtIndex(int index) {\n        if (index > (size - 1) || index < 0) { // 检查索引是否超出范围\n            return; // 如果超出范围，直接返回\n        }\n        int num;\n        int mid = size >> 1; // 计算链表中部位置\n        DList *curNode = sentinelNode; // 从哨兵节点开始\n        if (index < mid) { // 如果索引小于中部位置，从前往后遍历\n            for (int i = 0; i < index; i++) {\n                curNode = curNode->next; // 移动到目标位置的前一个节点\n            }\n            DList *next = curNode->next->next; // 获取目标位置的下一个节点\n            curNode->next = next; // 删除目标位置的节点\n            next->prev = curNode; // 目标位置的下一个节点的前一个节点指向当前节点\n        } else { // 如果索引大于等于中部位置，从后往前遍历\n            for (int i = 0; i < size - index - 1; i++) {\n                curNode = curNode->prev; // 移动到目标位置的后一个节点\n            }\n            DList *prev = curNode->prev->prev; // 获取目标位置的下一个节点\n            curNode->prev = prev; // 删除目标位置的节点\n            prev->next = curNode; // 目标位置的下一个节点的下一个节点指向当前节点\n        }\n        size--; // 链表大小减1\n    }\n\nprivate:\n    int size; // 链表的大小\n    DList *sentinelNode; // 哨兵节点的指针\n};\n#C:\ntypedef struct Node {\n\tint val;\n\tstruct Node* next;\n} Node;\n\n\ntypedef struct {\n\tint size;\n\tNode* data;\n} MyLinkedList;\n\n/** Initialize your data structure here. */\n\nMyLinkedList* myLinkedListCreate() {\n\tMyLinkedList* obj = (MyLinkedList*)malloc(sizeof(MyLinkedList));\n    Node* head = (Node*)malloc(sizeof(Node));\n\thead->next = (void*)0;\n\tobj->data = head;\n    obj->size = 0;\n\treturn obj;\n}\n\n/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\nint myLinkedListGet(MyLinkedList* obj, int index) {\n\tif (index < 0 || index >= obj->size) return -1;\n\n\tNode* cur = obj->data;\n\twhile (index-- >= 0) {\n        cur = cur->next;\n    }\n\n\treturn cur->val;\n}\n\n/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\n\tNode* node = (Node*)malloc(sizeof(Node));\n\tnode->val = val;\n\n\tnode->next = obj->data->next;\n\tobj->data->next = node;\n\tobj->size++;\n}\n\n/** Append a node of value val to the last element of the linked list. */\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\n\tNode* cur = obj->data;\n\twhile (cur->next != ((void*)0)) {\n        cur = cur->next;\n    }\n\n\tNode* tail = (Node*)malloc(sizeof(Node));\n\ttail->val = val;\n\ttail->next = (void*)0;\n\tcur->next = tail;\n\tobj->size++;\n}\n\n/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\n\tif (index > obj->size) return;\n\n\tNode* cur = obj->data;\n\twhile (index-- > 0) { \n        cur = cur->next;\n    }\n\n\tNode* node = (Node*)malloc(sizeof(Node));\n\tnode->val = val;\n\tnode->next = cur->next;\n\tcur->next = node;\n\tobj->size++;\n}\n\n/** Delete the index-th node in the linked list, if the index is valid. */\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\n\tif (index < 0 || index >= obj->size) return;\n\n\tNode* cur = obj->data;\n\twhile (index-- > 0) {\n        cur = cur->next;\n    }\n\n\tNode* temp = cur->next;\n\tcur->next = temp->next;\n\tfree(temp);\n\tobj->size--;\n}\n\nvoid myLinkedListFree(MyLinkedList* obj) {\n\tNode* tmp = obj->data;\n\twhile (tmp != NULL) {\n\t\tNode* n = tmp;\n\t\ttmp = tmp->next;\n\t\tfree(n);\n\t}\n\tfree(obj);\n}\n\n/**\n * Your MyLinkedList struct will be instantiated and called as such:\n * MyLinkedList* obj = myLinkedListCreate();\n * int param_1 = myLinkedListGet(obj, index);\n \n * myLinkedListAddAtHead(obj, val);\n \n * myLinkedListAddAtTail(obj, val);\n \n * myLinkedListAddAtIndex(obj, index, val);\n \n * myLinkedListDeleteAtIndex(obj, index);\n \n * myLinkedListFree(obj);\n*/\n#Java：\n//单链表\nclass MyLinkedList {\n\n    class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val) {\n            this.val=val;\n        }\n    }\n    //size存储链表元素的个数\n    private int size;\n    //注意这里记录的是虚拟头结点\n    private ListNode head;\n\n    //初始化链表\n    public MyLinkedList() {\n        this.size = 0;\n        this.head = new ListNode(0);\n    }\n\n    //获取第index个节点的数值，注意index是从0开始的，第0个节点就是虚拟头结点\n    public int get(int index) {\n        //如果index非法，返回-1\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        ListNode cur = head;\n        //第0个节点是虚拟头节点，所以查找第 index+1 个节点\n        for (int i = 0; i <= index; i++) {\n            cur = cur.next;\n        }\n        return cur.val;\n    }\n\n    public void addAtHead(int val) {\n        ListNode newNode = new ListNode(val);\n        newNode.next = head.next;\n        head.next = newNode;\n        size++;\n\n        // 在链表最前面插入一个节点，等价于在第0个元素前添加\n        // addAtIndex(0, val);\n    }\n\n    \n    public void addAtTail(int val) {\n        ListNode newNode = new ListNode(val);\n        ListNode cur = head;\n        while (cur.next != null) {\n            cur = cur.next;\n        }\n        cur.next = newNode;\n        size++;\n\n        // 在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加\n        // addAtIndex(size, val);\n    }\n\n    // 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。\n    // 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点\n    // 如果 index 大于链表的长度，则返回空\n    public void addAtIndex(int index, int val) {\n        if (index < 0 || index > size) {\n            return;\n        }\n\n        //找到要插入节点的前驱\n        ListNode pre = head;\n        for (int i = 0; i < index; i++) {\n            pre = pre.next;\n        }\n        ListNode newNode = new ListNode(val);\n        newNode.next = pre.next;\n        pre.next = newNode;\n        size++;\n    }\n\n    public void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) {\n            return;\n        }\n        \n        //因为有虚拟头节点，所以不用对index=0的情况进行特殊处理\n        ListNode pre = head;\n        for (int i = 0; i < index ; i++) {\n            pre = pre.next;\n        }\n        pre.next = pre.next.next;\n        size--;\n    }\n}\n//双链表\nclass MyLinkedList {  \n\n    class ListNode{\n        int val;\n        ListNode next, prev;\n        ListNode(int val){\n            this.val = val;\n        }\n    }\n\n    //记录链表中元素的数量\n    private int size;\n    //记录链表的虚拟头结点和尾结点\n    private ListNode head, tail;\n    \n    public MyLinkedList() {\n        //初始化操作\n        this.size = 0;\n        this.head = new ListNode(0);\n        this.tail = new ListNode(0);\n        //这一步非常关键，否则在加入头结点的操作中会出现null.next的错误！！！\n        this.head.next = tail;\n        this.tail.prev = head;\n    }\n    \n    public int get(int index) {\n        //判断index是否有效\n        if(index < 0 || index >= size){\n            return -1;\n        }\n        ListNode cur = head;\n        //判断是哪一边遍历时间更短\n        if(index >= size / 2){\n            //tail开始\n            cur = tail;\n            for(int i = 0; i < size - index; i++){\n                cur = cur.prev;\n            }\n        }else{\n            for(int i = 0; i <= index; i++){\n                cur = cur.next; \n            }\n        }\n        return cur.val;\n    }\n    \n    public void addAtHead(int val) {\n        //等价于在第0个元素前添加\n        addAtIndex(0, val);\n    }\n    \n    public void addAtTail(int val) {\n        //等价于在最后一个元素(null)前添加\n        addAtIndex(size, val);\n    }\n    \n    public void addAtIndex(int index, int val) {\n        //判断index是否有效\n        if(index < 0 || index > size){\n            return;\n        }\n\n        //找到前驱\n        ListNode pre = head;\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        //新建结点\n        ListNode newNode = new ListNode(val);\n        newNode.next = pre.next;\n        pre.next.prev = newNode;\n        newNode.prev = pre;\n        pre.next = newNode;\n        size++;\n        \n    }\n    \n    public void deleteAtIndex(int index) {\n        //判断index是否有效\n        if(index < 0 || index >= size){\n            return;\n        }\n\n        //删除操作\n        ListNode pre = head;\n        for(int i = 0; i < index; i++){\n            pre = pre.next;\n        }\n        pre.next.next.prev = pre;\n        pre.next = pre.next.next;\n        size--;\n    }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList obj = new MyLinkedList();\n * int param_1 = obj.get(index);\n * obj.addAtHead(val);\n * obj.addAtTail(val);\n * obj.addAtIndex(index,val);\n * obj.deleteAtIndex(index);\n */\n#Python：\n（版本一）单链表法\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass MyLinkedList:\n    def __init__(self):\n        self.dummy_head = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n        \n        current = self.dummy_head.next\n        for i in range(index):\n            current = current.next\n            \n        return current.val\n\n    def addAtHead(self, val: int) -> None:\n        self.dummy_head.next = ListNode(val, self.dummy_head.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        current = self.dummy_head\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n        \n        current = self.dummy_head\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n        \n        current = self.dummy_head\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1\n\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)\n（版本二）双链表法\nclass ListNode:\n    def __init__(self, val=0, prev=None, next=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n\nclass MyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n        \n        if index < self.size // 2:\n            current = self.head\n            for i in range(index):\n                current = current.next\n        else:\n            current = self.tail\n            for i in range(self.size - index - 1):\n                current = current.prev\n                \n        return current.val\n\n    def addAtHead(self, val: int) -> None:\n        new_node = ListNode(val, None, self.head)\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        new_node = ListNode(val, self.tail, None)\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n        \n        if index == 0:\n            self.addAtHead(val)\n        elif index == self.size:\n            self.addAtTail(val)\n        else:\n            if index < self.size // 2:\n                current = self.head\n                for i in range(index - 1):\n                    current = current.next\n            else:\n                current = self.tail\n                for i in range(self.size - index):\n                    current = current.prev\n            new_node = ListNode(val, current, current.next)\n            current.next.prev = new_node\n            current.next = new_node\n            self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n        \n        if index == 0:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n        elif index == self.size - 1:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n        else:\n            if index < self.size // 2:\n                current = self.head\n                for i in range(index):\n                    current = current.next\n            else:\n                current = self.tail\n                for i in range(self.size - index - 1):\n                    current = current.prev\n            current.prev.next = current.next\n            current.next.prev = current.prev\n        self.size -= 1\n\n\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)"
}