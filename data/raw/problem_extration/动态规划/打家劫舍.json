{
  "id": "AP_78b00bc7",
  "title": "打家劫舍",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/house-robber/",
  "description": "一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "状态转移",
    "滚动数组"
  ],
  "difficulty": null,
  "solution_approach": "使用动态规划来解决打家劫舍问题。通过定义dp数组，其中dp[i]表示考虑下标i（包括i）以内的房屋时，最多可以偷窃的金额。根据是否偷第i个房间来更新dp值。",
  "key_insights": [
    {
      "content": "如果选择偷第i个房间，则最大收益为dp[i-2]+nums[i]；如果不偷，则为dp[i-1]。取两者中的较大者作为dp[i]的值。"
    },
    {
      "content": "dp[0]直接等于nums[0]，因为只有一间房可选；dp[1]则取前两间房中金额较大的一个。"
    },
    {
      "content": "当前房屋的最优解依赖于前两个房屋的状态，体现了动态规划中的状态转移思想。"
    },
    {
      "content": "可以通过滚动数组的思想优化空间复杂度，因为每次决策只需要参考前两个状态。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "大家如果刚接触这样的题目，会有点困惑，当前的状态我是偷还是不偷呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int rob(vector<int>& nums) {if (nums.size() == 0) return 0;if (nums.size() == 1) return nums[0];vector<int> dp(nums.size());dp[0] = nums[0];dp[1] = max(nums[0], nums[1]);for (int i = 2; i < nums.size(); i++) {dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);}return dp[nums.size() - 1];}};",
          "description": "C++实现打家劫舍问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int rob(int[] nums) {if (nums == null || nums.length == 0) return 0;if (nums.length == 1) return nums[0];int[] dp = new int[nums.length];dp[0] = nums[0];dp[1] = Math.max(dp[0], nums[1]);for (int i = 2; i < nums.length; i++) {dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);}return dp[nums.length - 1];}}",
          "description": "Java使用动态规划解决打家劫舍问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int rob(int[] nums) {int len = nums.length;if (len == 0) return 0;else if (len == 1) return nums[0];else if (len == 2) return Math.max(nums[0],nums[1]);int[] result = new int[3];result[0] = nums[0];result[1] = Math.max(nums[0],nums[1]);for(int i=2;i<len;i++){result[2] = Math.max(result[0]+nums[i],result[1]);result[0] = result[1];result[1] = result[2];}return result[2];}}",
          "description": "Java使用滚动数组思想优化空间复杂度的打家劫舍解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public int rob(int[] nums) {if (nums.length == 1)  {return nums[0];}int[] dp = new int[2];dp[0] = nums[0];dp[1] = Math.max(nums[0],nums[1]);int res = 0;for (int i = 2; i < nums.length; i++) {res = Math.max((dp[0] + nums[i]) , dp[1] );dp[0] = dp[1];dp[1] = res;}return dp[1];}}",
          "description": "进一步优化空间复杂度的Java版打家劫舍解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) return dp[-1]",
          "description": "Python版本的一维动态规划解法"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 n = len(nums) dp = [[0, 0] for _ in range(n)] dp[0][1] = nums[0] for i in range(1, n): dp[i][0] = max(dp[i-1][0], dp[i-1][1]) dp[i][1] = dp[i-1][0] + nums[i] return max(dp[n-1][0], dp[n-1][1])",
          "description": "二维动态规划的Python解法"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 prev_max = 0 curr_max = 0 for num in nums: temp = curr_max curr_max = max(prev_max + num, curr_max) prev_max = temp return curr_max",
          "description": "Python版本的空间优化解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "打家劫舍是DP解决的经典题目，这道题也是打家劫舍入门级题目，后面我们还会变种方式来打劫的。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int rob(vector<int>& nums) {if (nums.size() == 0) return 0;if (nums.size() == 1) return nums[0];vector<int> dp(nums.size());dp[0] = nums[0];dp[1] = max(nums[0], nums[1]);for (int i = 2; i < nums.size(); i++) {dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);}return dp[nums.size() - 1];}};",
          "description": "C++实现的打家劫舍问题"
        },
        {
          "language": "java",
          "code": "class Solution { public int rob(int[] nums) { if (nums == null || nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(dp[0], nums[1]); for (int i = 2; i < nums.length; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); } return dp[nums.length - 1]; }}",
          "description": "Java实现的打家劫舍问题"
        },
        {
          "language": "java",
          "code": "class Solution { public int rob(int[] nums) { int len = nums.length; if (len == 0) return 0; else if (len == 1) return nums[0]; else if (len == 2) return Math.max(nums[0],nums[1]); int[] result = new int[3]; result[0] = nums[0]; result[1] = Math.max(nums[0],nums[1]); for(int i=2;i<len;i++){ result[2] = Math.max(result[0]+nums[i],result[1]); result[0] = result[1]; result[1] = result[2]; } return result[2]; }}",
          "description": "使用滚动数组思想优化空间复杂度的Java实现"
        },
        {
          "language": "java",
          "code": "class Solution { public int rob(int[] nums) { if (nums.length == 1)  { return nums[0]; } int[] dp = new int[2]; dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]); int res = 0; for (int i = 2; i < nums.length; i++) { res = Math.max((dp[0] + nums[i]) , dp[1] ); dp[0] = dp[1]; dp[1] = res; } return dp[1]; }}",
          "description": "进一步对滚动数组的空间优化的Java实现"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) return dp[-1]",
          "description": "Python一维DP实现的打家劫舍问题"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 n = len(nums) dp = [[0, 0] for _ in range(n)] dp[0][1] = nums[0] for i in range(1, n): dp[i][0] = max(dp[i-1][0], dp[i-1][1]) dp[i][1] = dp[i-1][0] + nums[i] return max(dp[n-1][0], dp[n-1][1])",
          "description": "Python二维DP实现的打家劫舍问题"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 prev_max = 0 curr_max = 0 for num in nums: temp = curr_max curr_max = max(prev_max + num, curr_max) prev_max = temp return curr_max",
          "description": "Python优化版实现的打家劫舍问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution { public int rob(int[] nums) { if (nums == null || nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(dp[0], nums[1]); for (int i = 2; i < nums.length; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); } return dp[nums.length - 1]; }}",
          "description": "动态规划解决打家劫舍问题"
        },
        {
          "language": "java",
          "code": "class Solution { public int rob(int[] nums) { int len = nums.length; if (len == 0) return 0; else if (len == 1) return nums[0]; else if (len == 2) return Math.max(nums[0],nums[1]); int[] result = new int[3]; result[0] = nums[0]; result[1] = Math.max(nums[0],nums[1]); for(int i=2;i<len;i++){ result[2] = Math.max(result[0]+nums[i],result[1]); result[0] = result[1]; result[1] = result[2]; } return result[2]; }}",
          "description": "使用滚动数组思想优化空间复杂度的解决方案"
        },
        {
          "language": "java",
          "code": "class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } int[] dp = new int[2]; dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]); int res = 0; for (int i = 2; i < nums.length; i++) { res = Math.max((dp[0] + nums[i]), dp[1]); dp[0] = dp[1]; dp[1] = res; } return dp[1]; }}",
          "description": "进一步对滚动数组的空间进行优化"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) return dp[-1]",
          "description": "一维DP实现打家劫舍问题"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 n = len(nums) dp = [[0, 0] for _ in range(n)] dp[0][1] = nums[0] for i in range(1, n): dp[i][0] = max(dp[i-1][0], dp[i-1][1]) dp[i][1] = dp[i-1][0] + nums[i] return max(dp[n-1][0], dp[n-1][1])",
          "description": "二维DP方法解决打家劫舍问题"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 prev_max = 0 curr_max = 0 for num in nums: temp = curr_max curr_max = max(prev_max + num, curr_max) prev_max = temp return curr_max",
          "description": "优化版DP算法求解"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "// 动态规划",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int rob(vector<int>& nums) {if (nums.size() == 0) return 0;if (nums.size() == 1) return nums[0];vector<int> dp(nums.size());dp[0] = nums[0];dp[1] = max(nums[0], nums[1]);for (int i = 2; i < nums.size(); i++) {dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);}return dp[nums.size() - 1];}};",
          "description": "C++实现的打家劫舍问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int rob(int[] nums) {if (nums == null || nums.length == 0) return 0;if (nums.length == 1) return nums[0];int[] dp = new int[nums.length];dp[0] = nums[0];dp[1] = Math.max(dp[0], nums[1]);for (int i = 2; i < nums.length; i++) {dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);}return dp[nums.length - 1];}}",
          "description": "Java实现的打家劫舍问题"
        },
        {
          "language": "java",
          "code": "class Solution {public int rob(int[] nums) {int len = nums.length;if (len == 0) return 0;else if (len == 1) return nums[0];else if (len == 2) return Math.max(nums[0],nums[1]);int[] result = new int[3];result[0] = nums[0];result[1] = Math.max(nums[0],nums[1]);for(int i=2;i<len;i++){result[2] = Math.max(result[0]+nums[i],result[1]);result[0] = result[1];result[1] = result[2];}return result[2];}}",
          "description": "使用滚动数组思想优化空间的Java实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int rob(int[] nums) {if (nums.length == 1)  {return nums[0];}int[] dp = new int[2];dp[0] = nums[0];dp[1] = Math.max(nums[0],nums[1]);int res = 0;for (int i = 2; i < nums.length; i++) {res = Math.max((dp[0] + nums[i]) , dp[1] );dp[0] = dp[1];dp[1] = res;}return dp[1];}}",
          "description": "进一步对滚动数组的空间优化的Java实现"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) return dp[-1]",
          "description": "Python一维DP实现的打家劫舍问题"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 n = len(nums) dp = [[0, 0] for _ in range(n)] dp[0][1] = nums[0] for i in range(1, n): dp[i][0] = max(dp[i-1][0], dp[i-1][1]) dp[i][1] = dp[i-1][0] + nums[i] return max(dp[n-1][0], dp[n-1][1])",
          "description": "Python二维DP实现的打家劫舍问题"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 prev_max = 0 curr_max = 0 for num in nums: temp = curr_max curr_max = max(prev_max + num, curr_max) prev_max = temp return curr_max",
          "description": "Python优化版实现的打家劫舍问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "1维DP",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int rob(vector<int>& nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; vector<int> dp(nums.size()); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i < nums.size(); i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[nums.size() - 1]; }};",
          "description": "C++实现的打家劫舍问题解决方案"
        },
        {
          "language": "java",
          "code": "class Solution { public int rob(int[] nums) { if (nums == null || nums.length == 0) return 0; if (nums.length == 1) return nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(dp[0], nums[1]); for (int i = 2; i < nums.length; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); } return dp[nums.length - 1]; }}",
          "description": "Java实现的打家劫舍问题解决方案"
        },
        {
          "language": "java",
          "code": "class Solution { public int rob(int[] nums) { int len = nums.length; if (len == 0) return 0; else if (len == 1) return nums[0]; else if (len == 2) return Math.max(nums[0],nums[1]); int[] result = new int[3]; result[0] = nums[0]; result[1] = Math.max(nums[0],nums[1]); for(int i=2;i<len;i++){ result[2] = Math.max(result[0]+nums[i],result[1]); result[0] = result[1]; result[1] = result[2]; } return result[2]; }}",
          "description": "使用滚动数组思想优化空间的Java实现"
        },
        {
          "language": "java",
          "code": "class Solution { public int rob(int[] nums) { if (nums.length == 1) return nums[0]; int[] dp = new int[2]; dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]); int res = 0; for (int i = 2; i < nums.length; i++) { res = Math.max((dp[0] + nums[i]), dp[1]); dp[0] = dp[1]; dp[1] = res; } return dp[1]; }}",
          "description": "进一步优化空间复杂度的Java实现"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) return dp[-1]",
          "description": "Python实现的一维DP解法"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 n = len(nums) dp = [[0, 0] for _ in range(n)] dp[0][1] = nums[0] for i in range(1, n): dp[i][0] = max(dp[i-1][0], dp[i-1][1]) dp[i][1] = dp[i-1][0] + nums[i] return max(dp[n-1][0], dp[n-1][1])",
          "description": "Python实现的二维DP解法"
        },
        {
          "language": "python",
          "code": "class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 prev_max = 0 curr_max = 0 for num in nums: temp = curr_max curr_max = max(prev_max + num, curr_max) prev_max = temp return curr_max",
          "description": "Python实现的空间优化版解法"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int rob(vector<int>& nums) {if (nums.size() == 0) return 0;if (nums.size() == 1) return nums[0];vector<int> dp(nums.size());dp[0] = nums[0];dp[1] = max(nums[0], nums[1]);for (int i = 2; i < nums.size(); i++) {dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);}return dp[nums.size() - 1];}};",
      "description": "使用动态规划解决打家劫舍问题的C++实现"
    },
    {
      "language": "java",
      "code": "class Solution {public int rob(int[] nums) {if (nums == null || nums.length == 0) return 0;if (nums.length == 1) return nums[0];int[] dp = new int[nums.length];dp[0] = nums[0];dp[1] = Math.max(dp[0], nums[1]);for (int i = 2; i < nums.length; i++) {dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);}return dp[nums.length - 1];}}",
      "description": "使用动态规划解决打家劫舍问题的Java实现"
    },
    {
      "language": "java",
      "code": "class Solution {public int rob(int[] nums) {int len = nums.length;if (len == 0) return 0;else if (len == 1) return nums[0];else if (len == 2) return Math.max(nums[0],nums[1]);int[] result = new int[3];result[0] = nums[0];result[1] = Math.max(nums[0],nums[1]);for(int i=2;i<len;i++){result[2] = Math.max(result[0]+nums[i],result[1]);result[0] = result[1];result[1] = result[2];}return result[2];}}",
      "description": "使用滚动数组优化空间复杂度的Java实现"
    },
    {
      "language": "python",
      "code": "class Solution: def rob(self, nums: List[int]) -> int: if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) return dp[-1]",
      "description": "一维动态规划解决打家劫舍问题的Python实现"
    },
    {
      "language": "python",
      "code": "class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 n = len(nums) dp = [[0, 0] for _ in range(n)] dp[0][1] = nums[0] for i in range(1, n): dp[i][0] = max(dp[i-1][0], dp[i-1][1]) dp[i][1] = dp[i-1][0] + nums[i] return max(dp[n-1][0], dp[n-1][1])",
      "description": "二维动态规划解决打家劫舍问题的Python实现"
    },
    {
      "language": "python",
      "code": "class Solution: def rob(self, nums: List[int]) -> int: if not nums: return 0 prev_max = 0 curr_max = 0 for num in nums: temp = curr_max curr_max = max(prev_max + num, curr_max) prev_max = temp return curr_max",
      "description": "优化版动态规划解决打家劫舍问题的Python实现"
    }
  ],
  "common_mistakes": [
    "错误地认为dp[i]只依赖于dp[i-1]，而忽略了不偷当前房间情况下也可能需要考虑更前面的状态。",
    "在初始化dp数组时没有正确设置初始条件，特别是当输入数组长度小于2时的情况处理不当。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210221170954115.jpg",
      "description": "这张图片展示了动态规划（DP）算法的一个实例，输入数组为 [2,7,9,3,1]，dp 数组记录了每个位置的最大值，最终结果为 12。",
      "context": "该图片展示了以数组[2,7,9,3,1]为例推导dp数组的过程，红框标记了最终结果dp[nums.size() - 1]。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210221170954115.jpg",
      "description": "GIF展示了动态规划算法执行过程中dp数组值的变化情况。",
      "context": "GIF动画展示了如何通过动态规划数组dp逐步计算，最终得到以[2,7,9,3,1]为例的房屋盗窃问题的最大收益。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\打家劫舍.txt",
  "extracted_at": "2025-07-20T18:00:10.081134",
  "raw_content": "打家劫舍\n力扣题目链接(https://leetcode.cn/problems/house-robber/)\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n示例 1：\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。   偷窃到的最高金额 = 1 + 3 = 4 。\n\n示例 2：\n输入：[2,7,9,3,1]\n输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。   偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n提示：\n\n0 <= nums.length <= 100\n0 <= nums[i] <= 400\n\n\n#思路\n大家如果刚接触这样的题目，会有点困惑，当前的状态我是偷还是不偷呢？\n\n仔细一想，当前房屋偷与不偷取决于 前一个房屋和前两个房屋是否被偷了。\n\n所以这里就更感觉到，当前状态和前面状态会有一种依赖关系，那么这种依赖关系都是动规的递推公式。\n\n当然以上是大概思路，打家劫舍是dp解决的经典问题，接下来我们来动规五部曲分析如下：\n\n确定dp数组（dp table）以及下标的含义\ndp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。\n\n确定递推公式\n决定dp[i]的因素就是第i房间偷还是不偷。\n\n如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。\n\n如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点）\n\n然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\n\ndp数组如何初始化\n从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]\n\n从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);\n\n代码如下：\n\nvector<int> dp(nums.size());\ndp[0] = nums[0];\ndp[1] = max(nums[0], nums[1]);\n确定遍历顺序\ndp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！\n\n代码如下：\n\nfor (int i = 2; i < nums.size(); i++) {\n    dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\n}\n举例推导dp数组\n以示例二，输入[2,7,9,3,1]为例。\n\nhttps://file1.kamacoder.com/i/algo/20210221170954115.jpg\n\n红框dp[nums.size() - 1]为结果。\n\n以上分析完毕，C++代码如下：\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if (nums.size() == 0) return 0;\n        if (nums.size() == 1) return nums[0];\n        vector<int> dp(nums.size());\n        dp[0] = nums[0];\n        dp[1] = max(nums[0], nums[1]);\n        for (int i = 2; i < nums.size(); i++) {\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\n        }\n        return dp[nums.size() - 1];\n    }\n};\n时间复杂度: O(n)\n空间复杂度: O(n)\n#总结\n打家劫舍是DP解决的经典题目，这道题也是打家劫舍入门级题目，后面我们还会变种方式来打劫的。\n\n#其他语言版本\n#Java：\n// 动态规划\nclass Solution {\n\tpublic int rob(int[] nums) {\n\t\tif (nums == null || nums.length == 0) return 0;\n\t\tif (nums.length == 1) return nums[0];\n\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = nums[0];\n\t\tdp[1] = Math.max(dp[0], nums[1]);\n\t\tfor (int i = 2; i < nums.length; i++) {\n\t\t\tdp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n\t\t}\n\n\t\treturn dp[nums.length - 1];\n\t}\n}\n\n// 使用滚动数组思想，优化空间\n// 分析本题可以发现，所求结果仅依赖于前两种状态，此时可以使用滚动数组思想将空间复杂度降低为3个空间\nclass Solution {\n    public int rob(int[] nums) {\n        \n        int len = nums.length;\n\n        if (len == 0) return 0;\n        else if (len == 1) return nums[0];\n        else if (len == 2) return Math.max(nums[0],nums[1]);\n\n\n        int[] result = new int[3]; //存放选择的结果\n        result[0] = nums[0];\n        result[1] = Math.max(nums[0],nums[1]);\n        \n\n        for(int i=2;i<len;i++){\n\n            result[2] = Math.max(result[0]+nums[i],result[1]);\n\n            result[0] = result[1];\n            result[1] = result[2];\n        }\n        \n        return result[2];\n    }\n}\n\n// 进一步对滚动数组的空间优化 dp数组只存与计算相关的两次数据\nclass Solution {\n    public int rob(int[] nums) {\n        if (nums.length == 1)  {\n            return nums[0];\n        }\n        // 初始化dp数组\n        // 优化空间 dp数组只用2格空间 只记录与当前计算相关的前两个结果\n        int[] dp = new int[2];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0],nums[1]);\n        int res = 0;\n        // 遍历\n        for (int i = 2; i < nums.length; i++) {\n            res = Math.max((dp[0] + nums[i]) , dp[1] );\n            dp[0] = dp[1];\n            dp[1] = res;\n        }\n        // 输出结果\n        return dp[1];\n    }\n}\n#Python：\n1维DP\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 0:  # 如果没有房屋，返回0\n            return 0\n        if len(nums) == 1:  # 如果只有一个房屋，返回其金额\n            return nums[0]\n\n        # 创建一个动态规划数组，用于存储最大金额\n        dp = [0] * len(nums)\n        dp[0] = nums[0]  # 将dp的第一个元素设置为第一个房屋的金额\n        dp[1] = max(nums[0], nums[1])  # 将dp的第二个元素设置为第一二个房屋中的金额较大者\n\n        # 遍历剩余的房屋\n        for i in range(2, len(nums)):\n            # 对于每个房屋，选择抢劫当前房屋和抢劫前一个房屋的最大金额\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n\n        return dp[-1]  # 返回最后一个房屋中可抢劫的最大金额\n2维DP\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:  # 如果没有房屋，返回0\n            return 0\n\n        n = len(nums)\n        dp = [[0, 0] for _ in range(n)]  # 创建二维动态规划数组，dp[i][0]表示不抢劫第i个房屋的最大金额，dp[i][1]表示抢劫第i个房屋的最大金额\n\n        dp[0][1] = nums[0]  # 抢劫第一个房屋的最大金额为第一个房屋的金额\n\n        for i in range(1, n):\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1])  # 不抢劫第i个房屋，最大金额为前一个房屋抢劫和不抢劫的最大值\n            dp[i][1] = dp[i-1][0] + nums[i]  # 抢劫第i个房屋，最大金额为前一个房屋不抢劫的最大金额加上当前房屋的金额\n\n        return max(dp[n-1][0], dp[n-1][1])  # 返回最后一个房屋中可抢劫的最大金额\n\n优化版\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:  # 如果没有房屋，返回0\n            return 0\n\n        prev_max = 0  # 上一个房屋的最大金额\n        curr_max = 0  # 当前房屋的最大金额\n\n        for num in nums:\n            temp = curr_max  # 临时变量保存当前房屋的最大金额\n            curr_max = max(prev_max + num, curr_max)  # 更新当前房屋的最大金额\n            prev_max = temp  # 更新上一个房屋的最大金额\n\n        return curr_max  # 返回最后一个房屋中可抢劫的最大金额"
}