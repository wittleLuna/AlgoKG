{
  "id": "AP_fa35476b",
  "title": "两数之和",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/two-sum/",
  "description": "一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "哈希",
    "数组"
  ],
  "data_structure_tags": [
    "哈希表",
    "映射(map)"
  ],
  "technique_tags": [
    "一次遍历",
    "空间换时间",
    "哈希查找"
  ],
  "difficulty": null,
  "solution_approach": "使用哈希表（unordered_map）来存储遍历过的元素及其下标，从而在单次遍历中快速查找目标值减去当前元素的结果是否已存在于哈希表中。如果存在，则找到了两个数；否则，将当前元素及其下标存入哈希表。",
  "key_insights": [
    {
      "content": "当需要查询一个元素是否出现过或者一个元素是否在集合里时，应考虑使用哈希法。这里不仅要知道元素是否被遍历过，还需要知道其对应的下标，因此使用map的数据结构非常合适。"
    },
    {
      "content": "考虑到题目不需要键有序，并且需要高效地插入和查找操作，std::unordered_map由于其底层基于哈希表实现，提供了平均O(1)的时间复杂度，是最优选择。"
    },
    {
      "content": "通过一边遍历一边构建哈希表的方式，可以有效地减少查找的时间开销，从而将整体时间复杂度从暴力解法的O(n^2)降至O(n)。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> twoSum(vector<int>& nums, int target) { std::unordered_map <int,int> map; for(int i = 0; i < nums.size(); i++) { auto iter = map.find(target - nums[i]); if(iter != map.end()) { return {iter->second, i}; } map.insert(pair<int, int>(nums[i], i)); } return {}; }};",
          "description": "C++解决方案，使用unordered_map实现"
        },
        {
          "language": "java",
          "code": "public int[] twoSum(int[] nums, int target) { int[] res = new int[2]; if(nums == null || nums.length == 0){ return res; } Map<Integer, Integer> map = new HashMap<>(); for(int i = 0; i < nums.length; i++){ int temp = target - nums[i]; if(map.containsKey(temp)){ res[1] = i; res[0] = map.get(temp); break; } map.put(nums[i], i); } return res;}",
          "description": "Java解决方案，使用HashMap实现"
        },
        {
          "language": "java",
          "code": "public int[] twoSum(int[] nums, int target) { Map<Integer, Integer> indexMap = new HashMap<>(); for(int i = 0; i < nums.length; i++){ int balance = target - nums[i]; if(indexMap.containsKey(balance)){ return new int []{i, indexMap.get(balance)}; } else{ indexMap.put(nums[i], i); } } return null;}",
          "description": "Java解决方案，另一种使用HashMap的方法"
        },
        {
          "language": "java",
          "code": "public int[] twoSum(int[] nums, int target) { int m=0,n=0,k,board=0; int[] res=new int[2]; int[] tmp1=new int[nums.length]; System.arraycopy(nums,0,tmp1,0,nums.length); Arrays.sort(nums); for(int i=0,j=nums.length-1;i<j;){ if(nums[i]+nums[j]<target) i++; else if(nums[i]+nums[j]>target) j--; else if(nums[i]+nums[j]==target){ m=i; n=j; break; } } for(k=0;k<nums.length;k++){ if(tmp1[k]==nums[m]){ res[0]=k; break; } } for(int i=0;i<nums.length;i++){ if(tmp1[i]==nums[n]&&i!=k) res[1]=i; } return res;}",
          "description": "Java解决方案，使用双指针方法"
        },
        {
          "language": "python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: records = dict() for index, value in enumerate(nums): if target - value in records: return [records[target- value], index] records[value] = index return []",
          "description": "Python解决方案，使用字典实现"
        },
        {
          "language": "python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: seen = set() for i, num in enumerate(nums): complement = target - num if complement in seen: return [nums.index(complement), i] seen.add(num)",
          "description": "Python解决方案，使用集合实现"
        },
        {
          "language": "python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: nums_sorted = sorted(nums) left = 0 right = len(nums_sorted) - 1 while left < right: current_sum = nums_sorted[left] + nums_sorted[right] if current_sum == target: left_index = nums.index(nums_sorted[left]) right_index = nums.index(nums_sorted[right]) if left_index == right_index: right_index = nums[left_index+1:].index(nums_sorted[right]) + left_index + 1 return [left_index, right_index] elif current_sum < target: left += 1 else: right -= 1",
          "description": "Python解决方案，使用双指针方法"
        },
        {
          "language": "python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i,j]",
          "description": "Python解决方案，暴力解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "本题其实有四个重点：",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "class Solution {public: vector<int> twoSum(vector<int>& nums, int target) { std::unordered_map <int,int> map; for(int i = 0; i < nums.size(); i++) { auto iter = map.find(target - nums[i]); if(iter != map.end()) { return {iter->second, i}; } map.insert(pair<int, int>(nums[i], i)); } return {};}};",
          "description": "使用unordered_map实现哈希表，查找两数之和等于目标值的元素"
        },
        {
          "language": "Java",
          "code": "public int[] twoSum(int[] nums, int target) { int[] res = new int[2]; if(nums == null || nums.length == 0){ return res; } Map<Integer, Integer> map = new HashMap<>(); for(int i = 0; i < nums.length; i++){ int temp = target - nums[i]; if(map.containsKey(temp)){ res[1] = i; res[0] = map.get(temp); break; } map.put(nums[i], i); } return res;}",
          "description": "使用HashMap实现哈希表，查找两数之和等于目标值的元素"
        },
        {
          "language": "Java",
          "code": "public int[] twoSum(int[] nums, int target) { Map<Integer, Integer> indexMap = new HashMap<>(); for(int i = 0; i < nums.length; i++){ int balance = target - nums[i]; if(indexMap.containsKey(balance)){ return new int []{i, indexMap.get(balance)}; } else{ indexMap.put(nums[i], i); } } return null;}",
          "description": "另一种使用HashMap的方法，同样用于寻找两数之和等于目标值的情况"
        },
        {
          "language": "Java",
          "code": "public int[] twoSum(int[] nums, int target) { int m=0,n=0,k,board=0; int[] res=new int[2]; int[] tmp1=new int[nums.length]; System.arraycopy(nums,0,tmp1,0,nums.length); Arrays.sort(nums); for(int i=0,j=nums.length-1;i<j;){ if(nums[i]+nums[j]<target) i++; else if(nums[i]+nums[j]>target) j--; else if(nums[i]+nums[j]==target){ m=i; n=j; break; }} for(k=0;k<nums.length;k++){ if(tmp1[k]==nums[m]){ res[0]=k; break; }} for(int i=0;i<nums.length;i++){ if(tmp1[i]==nums[n]&&i!=k) res[1]=i; } return res;}",
          "description": "使用双指针方法结合排序来解决两数之和问题"
        },
        {
          "language": "Python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: records = dict() for index, value in enumerate(nums): if target - value in records: return [records[target- value], index] records[value] = index return []",
          "description": "Python版本，使用字典作为哈希表，以快速找到满足条件的两个数"
        },
        {
          "language": "Python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: seen = set() for i, num in enumerate(nums): complement = target - num if complement in seen: return [nums.index(complement), i] seen.add(num)",
          "description": "使用集合存储已访问过的数字，检查是否存在与当前元素相加等于目标值的另一个元素"
        },
        {
          "language": "Python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: nums_sorted = sorted(nums) left = 0 right = len(nums_sorted) - 1 while left < right: current_sum = nums_sorted[left] + nums_sorted[right] if current_sum == target: left_index = nums.index(nums_sorted[left]) right_index = nums.index(nums_sorted[right]) if left_index == right_index: right_index = nums[left_index+1:].index(nums_sorted[right]) + left_index + 1 return [left_index, right_index] elif current_sum < target: left += 1 else: right -= 1",
          "description": "通过排序数组后使用双指针技术来解决问题"
        },
        {
          "language": "Python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i,j]",
          "description": "暴力搜索法，遍历所有可能的数对组合"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> twoSum(vector<int>& nums, int target) { std::unordered_map <int,int> map; for(int i = 0; i < nums.size(); i++) { auto iter = map.find(target - nums[i]); if(iter != map.end()) { return {iter->second, i}; } map.insert(pair<int, int>(nums[i], i)); } return {}; }};",
          "description": "使用unordered_map来存储访问过的元素及其索引，查找目标值减去当前元素的差值是否存在于map中"
        },
        {
          "language": "java",
          "code": "public int[] twoSum(int[] nums, int target) { int[] res = new int[2]; if(nums == null || nums.length == 0){ return res; } Map<Integer, Integer> map = new HashMap<>(); for(int i = 0; i < nums.length; i++){ int temp = target - nums[i]; if(map.containsKey(temp)){ res[1] = i; res[0] = map.get(temp); break; } map.put(nums[i], i); } return res;}",
          "description": "使用HashMap来存储访问过的元素及其索引，查找目标值减去当前元素的差值是否存在于map中"
        },
        {
          "language": "java",
          "code": "public int[] twoSum(int[] nums, int target) { Map<Integer, Integer> indexMap = new HashMap<>(); for(int i = 0; i < nums.length; i++){ int balance = target - nums[i]; if(indexMap.containsKey(balance)){ return new int []{i, indexMap.get(balance)}; } else{ indexMap.put(nums[i], i); } } return null;}",
          "description": "另一种使用HashMap实现的方法，逻辑与上述Java版本相似"
        },
        {
          "language": "java",
          "code": "public int[] twoSum(int[] nums, int target) { int m=0,n=0,k,board=0; int[] res=new int[2]; int[] tmp1=new int[nums.length]; System.arraycopy(nums,0,tmp1,0,nums.length); Arrays.sort(nums); for(int i=0,j=nums.length-1;i<j;){ if(nums[i]+nums[j]<target) i++; else if(nums[i]+nums[j]>target) j--; else if(nums[i]+nums[j]==target){ m=i; n=j; break; } } for(k=0;k<nums.length;k++){ if(tmp1[k]==nums[m]){ res[0]=k; break; } } for(int i=0;i<nums.length;i++){ if(tmp1[i]==nums[n]&&i!=k) res[1]=i; } return res;}",
          "description": "使用双指针方法解决两数之和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: records = dict() for index, value in enumerate(nums): if target - value in records: return [records[target- value], index] records[value] = index return []",
          "description": "Python版本使用字典存储访问过的元素及其索引，查找目标值减去当前元素的差值是否存在于字典中"
        },
        {
          "language": "python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: seen = set() for i, num in enumerate(nums): complement = target - num if complement in seen: return [nums.index(complement), i] seen.add(num)",
          "description": "Python版本使用集合存储访问过的元素，查找目标值减去当前元素的差值是否存在于集合中"
        },
        {
          "language": "python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: nums_sorted = sorted(nums) left = 0 right = len(nums_sorted) - 1 while left < right: current_sum = nums_sorted[left] + nums_sorted[right] if current_sum == target: left_index = nums.index(nums_sorted[left]) right_index = nums.index(nums_sorted[right]) if left_index == right_index: right_index = nums[left_index+1:].index(nums_sorted[right]) + left_index + 1 return [left_index, right_index] elif current_sum < target: left += 1 else: right -= 1",
          "description": "Python版本使用双指针方法解决两数之和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i,j]",
          "description": "Python版本使用暴力法解决两数之和问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "//使用哈希表",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> twoSum(vector<int>& nums, int target) { std::unordered_map <int,int> map; for(int i = 0; i < nums.size(); i++) { auto iter = map.find(target - nums[i]); if(iter != map.end()) { return {iter->second, i}; } map.insert(pair<int, int>(nums[i], i)); } return {}; }};",
          "description": "C++使用哈希表解决两数之和问题"
        },
        {
          "language": "java",
          "code": "public int[] twoSum(int[] nums, int target) { int[] res = new int[2]; if(nums == null || nums.length == 0){ return res; } Map<Integer, Integer> map = new HashMap<>(); for(int i = 0; i < nums.length; i++){ int temp = target - nums[i]; if(map.containsKey(temp)){ res[1] = i; res[0] = map.get(temp); break; } map.put(nums[i], i); } return res;}",
          "description": "Java使用哈希表解决两数之和问题"
        },
        {
          "language": "java",
          "code": "public int[] twoSum(int[] nums, int target) { Map<Integer, Integer> indexMap = new HashMap<>(); for(int i = 0; i < nums.length; i++){ int balance = target - nums[i]; if(indexMap.containsKey(balance)){ return new int []{i, indexMap.get(balance)}; } else{ indexMap.put(nums[i], i); } } return null;}",
          "description": "Java另一种方式使用哈希表解决两数之和问题"
        },
        {
          "language": "java",
          "code": "public int[] twoSum(int[] nums, int target) { int m=0,n=0,k,board=0; int[] res=new int[2]; int[] tmp1=new int[nums.length]; System.arraycopy(nums,0,tmp1,0,nums.length); Arrays.sort(nums); for(int i=0,j=nums.length-1;i<j;){ if(nums[i]+nums[j]<target) i++; else if(nums[i]+nums[j]>target) j--; else if(nums[i]+nums[j]==target){ m=i; n=j; break; } } for(k=0;k<nums.length;k++){ if(tmp1[k]==nums[m]){ res[0]=k; break; } } for(int i=0;i<nums.length;i++){ if(tmp1[i]==nums[n]&&i!=k) res[1]=i; } return res;}",
          "description": "Java使用双指针解决两数之和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: records = dict() for index, value in enumerate(nums): if target - value in records: return [records[target- value], index] records[value] = index return []",
          "description": "Python使用字典解决两数之和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: seen = set() for i, num in enumerate(nums): complement = target - num if complement in seen: return [nums.index(complement), i] seen.add(num)",
          "description": "Python使用集合解决两数之和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: nums_sorted = sorted(nums) left = 0 right = len(nums_sorted) - 1 while left < right: current_sum = nums_sorted[left] + nums_sorted[right] if current_sum == target: left_index = nums.index(nums_sorted[left]) right_index = nums.index(nums_sorted[right]) if left_index == right_index: right_index = nums[left_index+1:].index(nums_sorted[right]) + left_index + 1 return [left_index, right_index] elif current_sum < target: left += 1 else: right -= 1",
          "description": "Python使用双指针解决两数之和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i,j]",
          "description": "Python暴力法解决两数之和问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "（版本一） 使用字典",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "class Solution {public: vector<int> twoSum(vector<int>& nums, int target) { std::unordered_map <int,int> map; for(int i = 0; i < nums.size(); i++) { auto iter = map.find(target - nums[i]); if(iter != map.end()) { return {iter->second, i}; } map.insert(pair<int, int>(nums[i], i)); } return {}; }};",
          "description": "使用哈希表解决两数之和问题"
        },
        {
          "language": "Java",
          "code": "public int[] twoSum(int[] nums, int target) { int[] res = new int[2]; if(nums == null || nums.length == 0){ return res; } Map<Integer, Integer> map = new HashMap<>(); for(int i = 0; i < nums.length; i++){ int temp = target - nums[i]; if(map.containsKey(temp)){ res[1] = i; res[0] = map.get(temp); break; } map.put(nums[i], i); } return res;}",
          "description": "使用哈希表解决两数之和问题"
        },
        {
          "language": "Java",
          "code": "public int[] twoSum(int[] nums, int target) { Map<Integer, Integer> indexMap = new HashMap<>(); for(int i = 0; i < nums.length; i++){ int balance = target - nums[i]; if(indexMap.containsKey(balance)){ return new int []{i, indexMap.get(balance)}; } else{ indexMap.put(nums[i], i); } } return null;}",
          "description": "使用哈希表方法2解决两数之和问题"
        },
        {
          "language": "Java",
          "code": "public int[] twoSum(int[] nums, int target) { int m=0,n=0,k,board=0; int[] res=new int[2]; int[] tmp1=new int[nums.length]; System.arraycopy(nums,0,tmp1,0,nums.length); Arrays.sort(nums); for(int i=0,j=nums.length-1;i<j;){ if(nums[i]+nums[j]<target) i++; else if(nums[i]+nums[j]>target) j--; else if(nums[i]+nums[j]==target){ m=i; n=j; break; } } for(k=0;k<nums.length;k++){ if(tmp1[k]==nums[m]){ res[0]=k; break; } } for(int i=0;i<nums.length;i++){ if(tmp1[i]==nums[n]&&i!=k) res[1]=i; } return res;}",
          "description": "使用双指针解决两数之和问题"
        },
        {
          "language": "Python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: records = dict() for index, value in enumerate(nums): if target - value in records: return [records[target- value], index] records[value] = index return []",
          "description": "使用字典解决两数之和问题"
        },
        {
          "language": "Python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: seen = set() for i, num in enumerate(nums): complement = target - num if complement in seen: return [nums.index(complement), i] seen.add(num)",
          "description": "使用集合解决两数之和问题"
        },
        {
          "language": "Python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: nums_sorted = sorted(nums) left = 0 right = len(nums_sorted) - 1 while left < right: current_sum = nums_sorted[left] + nums_sorted[right] if current_sum == target: left_index = nums.index(nums_sorted[left]) right_index = nums.index(nums_sorted[right]) if left_index == right_index: right_index = nums[left_index+1:].index(nums_sorted[right]) + left_index + 1 return [left_index, right_index] elif current_sum < target: left += 1 else: right -= 1",
          "description": "使用双指针解决两数之和问题"
        },
        {
          "language": "Python",
          "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i,j]",
          "description": "暴力法解决两数之和问题"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "explanation": "先做一下这两道"
  },
  "code_solutions": [
    {
      "language": "C++",
      "code": "class Solution {public: vector<int> twoSum(vector<int>& nums, int target) { std::unordered_map <int,int> map; for(int i = 0; i < nums.size(); i++) { auto iter = map.find(target - nums[i]); if(iter != map.end()) { return {iter->second, i}; } map.insert(pair<int, int>(nums[i], i)); } return {}; }};",
      "description": "使用哈希表来存储访问过的元素及其下标，以便在遍历时快速查找匹配的元素。"
    },
    {
      "language": "Java",
      "code": "public int[] twoSum(int[] nums, int target) { int[] res = new int[2]; if(nums == null || nums.length == 0){ return res; } Map<Integer, Integer> map = new HashMap<>(); for(int i = 0; i < nums.length; i++){ int temp = target - nums[i]; if(map.containsKey(temp)){ res[1] = i; res[0] = map.get(temp); break; } map.put(nums[i], i); } return res;}",
      "description": "利用HashMap存放已访问元素及其索引，通过检查目标值减去当前元素的结果是否存在于map中来寻找匹配对。"
    },
    {
      "language": "Python",
      "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: records = dict() for index, value in enumerate(nums): if target - value in records: return [records[target- value], index] records[value] = index return []",
      "description": "采用字典记录每个元素及其索引，在遍历过程中查找是否存在与当前元素相加等于目标值的另一个元素。"
    },
    {
      "language": "Python",
      "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: seen = set() for i, num in enumerate(nums): complement = target - num if complement in seen: return [nums.index(complement), i] seen.add(num)",
      "description": "使用集合存储已遇到的数值，当发现当前数值与集合中的某个数之和为目标值时，返回这两个数值的位置。"
    },
    {
      "language": "Python",
      "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: nums_sorted = sorted(nums) left = 0 right = len(nums_sorted) - 1 while left < right: current_sum = nums_sorted[left] + nums_sorted[right] if current_sum == target: left_index = nums.index(nums_sorted[left]) right_index = nums.index(nums_sorted[right]) if left_index == right_index: right_index = nums[left_index+1:].index(nums_sorted[right]) + left_index + 1 return [left_index, right_index] elif current_sum < target: left += 1 else: right -= 1",
      "description": "首先对数组进行排序，然后使用双指针从两端向中间移动以找到两个数之和为目标值的情况。"
    },
    {
      "language": "Python",
      "code": "class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i,j]",
      "description": "通过双重循环遍历所有可能的两数组合，找到第一个满足条件（两数之和等于目标值）的组合并立即返回其索引。"
    }
  ],
  "common_mistakes": [
    "忽略了对于特定问题选择最合适的数据结构的重要性，例如错误地选择了set或数组作为哈希表。",
    "未能理解为什么使用map而不仅仅是判断元素的存在性，还涉及到索引的记录。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20220711202638.png",
      "description": "这张图片展示了使用哈希表（map）解决“两数之和”问题的算法过程，目标是找到数组中两个数的和等于给定值（target=9）。",
      "context": "该图片展示了使用哈希表（map）来存储数组元素及其对应下标的过程，辅助理解如何通过一次遍历找到目标数值对。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20230220223536.png",
      "description": "这张图片展示了使用哈希表（map）解决“两数之和”问题的过程，目标值为9，通过查找map来匹配数组中的元素对（2, 7），其下标为（0, 1）。",
      "context": "该图片展示了使用哈希表（map）解决两数之和问题的具体步骤与流程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20220711202638.png",
      "description": "GIF展示了在遍历数组过程中，使用哈希表来查找与当前元素相加等于目标值的匹配元素的过程。",
      "context": "GIF动画展示了如何通过遍历数组并利用哈希表（map）来快速查找与当前元素相加等于目标值的另一个元素的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20230220223536.png",
      "description": "GIF展示了通过遍历数组并使用哈希表来查找两个数之和等于目标值的过程。",
      "context": "该GIF动画展示了在数组遍历过程中，如何利用哈希表来快速查找并确定两个数之和等于目标值的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\哈希表\\两数之和.txt",
  "extracted_at": "2025-07-21T03:26:39.051796",
  "raw_content": "两数之和\n力扣题目链接(https://leetcode.cn/problems/two-sum/)\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n\n示例:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n\n所以返回 [0, 1]\n\n\n#思路\n很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。\n\n建议大家做这道题目之前，先做一下这两道\n\n242. 有效的字母异位词(opens new window)\n349. 两个数组的交集(opens new window)\n242. 有效的字母异位词 (opens new window)这道题目是用数组作为哈希表来解决哈希问题，349. 两个数组的交集 (opens new window)这道题目是通过set作为哈希表来解决哈希问题。\n\n首先我再强调一下 什么时候使用哈希法，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。\n\n本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。\n\n那么我们就应该想到使用哈希法了。\n\n因为本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适。\n\n再来看一下使用数组和set来做哈希法的局限。\n\n数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。\nset是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。\n此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。\n\nC++中map，有三种类型：\n\n映射\t底层实现\t是否有序\t数值是否可以重复\t能否更改数值\t查询效率\t增删效率\nstd::map\t红黑树\tkey有序\tkey不可重复\tkey不可修改\tO(log n)\tO(log n)\nstd::multimap\t红黑树\tkey有序\tkey可重复\tkey不可修改\tO(log n)\tO(log n)\nstd::unordered_map\t哈希表\tkey无序\tkey不可重复\tkey不可修改\tO(1)\tO(1)\nstd::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。\n\n同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 更多哈希表的理论知识请看关于哈希表，你该了解这些！ (opens new window)。\n\n这道题目中并不需要key有序，选择std::unordered_map 效率更高！ 使用其他语言的录友注意了解一下自己所用语言的数据结构就行。\n\n接下来需要明确两点：\n\nmap用来做什么\nmap中key和value分别表示什么\nmap目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）\n\n接下来是map中key和value分别表示什么。\n\n这道题 我们需要 给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。\n\n那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。\n\n所以 map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。\n\n在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。\n\n过程如下：\n\nhttps://file1.kamacoder.com/i/algo/20220711202638.png\nhttps://file1.kamacoder.com/i/algo/20230220223536.png\n\nC++代码：\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        std::unordered_map <int,int> map;\n        for(int i = 0; i < nums.size(); i++) {\n            // 遍历当前元素，并在map中寻找是否有匹配的key\n            auto iter = map.find(target - nums[i]); \n            if(iter != map.end()) {\n                return {iter->second, i};\n            }\n            // 如果没找到匹配对，就把访问过的元素和下标加入到map中\n            map.insert(pair<int, int>(nums[i], i)); \n        }\n        return {};\n    }\n};\n时间复杂度: O(n)\n空间复杂度: O(n)\n#总结\n本题其实有四个重点：\n\n为什么会想到用哈希表\n哈希表为什么用map\n本题map是用来存什么的\nmap中的key和value用来存什么的\n把这四点想清楚了，本题才算是理解透彻了。\n\n很多录友把这道题目 通过了，但都没想清楚map是用来做什么的，以至于对代码的理解其实是 一知半解的。\n\n#其他语言版本\n#Java：\n//使用哈希表\npublic int[] twoSum(int[] nums, int target) {\n    int[] res = new int[2];\n    if(nums == null || nums.length == 0){\n        return res;\n    }\n    Map<Integer, Integer> map = new HashMap<>();\n    for(int i = 0; i < nums.length; i++){\n        int temp = target - nums[i];   // 遍历当前元素，并在map中寻找是否有匹配的key\n        if(map.containsKey(temp)){\n            res[1] = i;\n            res[0] = map.get(temp);\n            break;\n        }\n        map.put(nums[i], i);    // 如果没找到匹配对，就把访问过的元素和下标加入到map中\n    }\n    return res;\n}\n//使用哈希表方法2\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> indexMap = new HashMap<>();\n    \n    for(int i = 0; i < nums.length; i++){\n        int balance = target - nums[i];  // 记录当前的目标值的余数\n        if(indexMap.containsKey(balance)){  // 查找当前的map中是否有满足要求的值\n            return new int []{i, indexMap.get(balance)}; //  如果有，返回目标值\n        } else{\n            indexMap.put(nums[i], i); //  如果没有，把访问过的元素和下标加入map中\n        }\n    }\n    return null;\n}\n//使用双指针\npublic int[] twoSum(int[] nums, int target) {\n    int m=0,n=0,k,board=0;\n    int[] res=new int[2];\n    int[] tmp1=new int[nums.length];\n    //备份原本下标的nums数组\n    System.arraycopy(nums,0,tmp1,0,nums.length);\n    //将nums排序\n    Arrays.sort(nums);\n    //双指针\n    for(int i=0,j=nums.length-1;i<j;){\n        if(nums[i]+nums[j]<target)\n            i++;\n        else if(nums[i]+nums[j]>target)\n            j--;\n        else if(nums[i]+nums[j]==target){\n            m=i;\n            n=j;\n            break;\n        }\n    }\n    //找到nums[m]在tmp1数组中的下标\n    for(k=0;k<nums.length;k++){\n        if(tmp1[k]==nums[m]){\n            res[0]=k;\n            break;\n        }\n    }\n    //找到nums[n]在tmp1数组中的下标\n    for(int i=0;i<nums.length;i++){\n        if(tmp1[i]==nums[n]&&i!=k)\n            res[1]=i;\n    }\n    return res;\n}\n#Python：\n（版本一） 使用字典\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        records = dict()\n\n        for index, value in enumerate(nums):  \n            if target - value in records:   # 遍历当前元素，并在map中寻找是否有匹配的key\n                return [records[target- value], index]\n            records[value] = index    # 如果没找到匹配对，就把访问过的元素和下标加入到map中\n        return []\n（版本二）使用集合\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        #创建一个集合来存储我们目前看到的数字\n        seen = set()             \n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in seen:\n                return [nums.index(complement), i]\n            seen.add(num)\n（版本三）使用双指针\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        # 对输入列表进行排序\n        nums_sorted = sorted(nums)\n        \n        # 使用双指针\n        left = 0\n        right = len(nums_sorted) - 1\n        while left < right:\n            current_sum = nums_sorted[left] + nums_sorted[right]\n            if current_sum == target:\n                # 如果和等于目标数，则返回两个数的下标\n                left_index = nums.index(nums_sorted[left])\n                right_index = nums.index(nums_sorted[right])\n                if left_index == right_index:\n                    right_index = nums[left_index+1:].index(nums_sorted[right]) + left_index + 1\n                return [left_index, right_index]\n            elif current_sum < target:\n                # 如果总和小于目标，则将左侧指针向右移动\n                left += 1\n            else:\n                # 如果总和大于目标值，则将右指针向左移动\n                right -= 1\n（版本四）暴力法\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]"
}