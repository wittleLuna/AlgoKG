{
  "id": "AP_43fcdad7",
  "title": "N叉树的层序遍历",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/n-ary-tree-level-order-traversal/",
  "description": "给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。\n\n例如，给定一个 3叉树 :\n\nhttps://file1.kamacoder.com/i/algo/20210203151439168.png\n\n返回其层序遍历:\n\n[ [1], [3,2,4], [5,6] ]",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "广度优先搜索",
    "层次遍历"
  ],
  "data_structure_tags": [
    "队列",
    "列表"
  ],
  "technique_tags": [
    "迭代",
    "递归"
  ],
  "difficulty": null,
  "solution_approach": "使用广度优先搜索（BFS）策略来遍历N叉树。利用队列存储当前层的所有节点，然后逐个处理这些节点，并将它们的孩子节点加入队列中以供下一层处理。",
  "key_insights": [
    {
      "content": "通过维护一个队列来存储每一层的节点，可以确保按照从左到右、自上而下的顺序访问所有节点。"
    },
    {
      "content": "本题提供了基于队列的迭代方法和基于函数调用堆栈的递归方法两种解决方案，展示了不同风格但同样有效的编程实践。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "这道题依旧是模板题，只不过一个节点有多个孩子了",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<vector<int>> levelOrder(Node* root) { queue<Node*> que; if (root != NULL) que.push(root); vector<vector<int>> result; while (!que.empty()) { int size = que.size(); vector<int> vec; for (int i = 0; i < size; i++) { Node* node = que.front(); que.pop(); vec.push_back(node->val); for (int i = 0; i < node->children.size(); i++) { if (node->children[i]) que.push(node->children[i]); } } result.push_back(vec); } return result;}};",
          "description": "C++实现N叉树的层序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def levelOrder(self, root: 'Node') -> List[List[int]]: if not root: return [] result = [] queue = collections.deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) for child in node.children: queue.append(child) result.append(level) return result",
          "description": "Python实现N叉树的层序遍历（迭代法）"
        },
        {
          "language": "python",
          "code": "class Solution: def levelOrder(self, root: 'Node') -> List[List[int]]: if not root: return [] result=[] def traversal(root,depth): if len(result)==depth:result.append([]) result[depth].append(root.val) if root.children: for i in range(len(root.children)):traversal(root.children[i],depth+1) traversal(root,0) return result",
          "description": "Python实现N叉树的层序遍历（递归法）"
        },
        {
          "language": "java",
          "code": "public class N0429 { public List<List<Integer>> levelOrder(Node root) { List<List<Integer>> list = new ArrayList<>(); Deque<Node> que = new LinkedList<>(); if (root == null) { return list; } que.offerLast(root); while (!que.isEmpty()) { int levelSize = que.size(); List<Integer> levelList = new ArrayList<>(); for (int i = 0; i < levelSize; i++) { Node poll = que.pollFirst(); levelList.add(poll.val); List<Node> children = poll.children; if (children == null || children.size() == 0) { continue; } for (Node child : children) { if (child != null) { que.offerLast(child); } } } list.add(levelList); } return list; } class Node { public int val; public List<Node> children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List<Node> _children) { val = _val; children = _children; } }}",
          "description": "Java实现N叉树的层序遍历"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Python：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<vector<int>> levelOrder(Node* root) { queue<Node*> que; if (root != NULL) que.push(root); vector<vector<int>> result; while (!que.empty()) { int size = que.size(); vector<int> vec; for (int i = 0; i < size; i++) { Node* node = que.front(); que.pop(); vec.push_back(node->val); for (int i = 0; i < node->children.size(); i++) { if (node->children[i]) que.push(node->children[i]); } } result.push_back(vec); } return result; }};",
          "description": "C++实现N叉树层序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def levelOrder(self, root: 'Node') -> List[List[int]]: if not root: return [] result = [] queue = collections.deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) for child in node.children: queue.append(child) result.append(level) return result",
          "description": "Python实现N叉树层序遍历（迭代法）"
        },
        {
          "language": "python",
          "code": "class Solution: def levelOrder(self, root: 'Node') -> List[List[int]]: if not root: return [] result=[] def traversal(root,depth): if len(result)==depth:result.append([]) result[depth].append(root.val) if root.children: for i in range(len(root.children)):traversal(root.children[i],depth+1) traversal(root,0) return result",
          "description": "Python实现N叉树层序遍历（递归法）"
        },
        {
          "language": "java",
          "code": "public class N0429 { public List<List<Integer>> levelOrder(Node root) { List<List<Integer>> list = new ArrayList<>(); Deque<Node> que = new LinkedList<>(); if (root == null) { return list; } que.offerLast(root); while (!que.isEmpty()) { int levelSize = que.size(); List<Integer> levelList = new ArrayList<>(); for (int i = 0; i < levelSize; i++) { Node poll = que.pollFirst(); levelList.add(poll.val); List<Node> children = poll.children; if (children == null || children.size() == 0) { continue; } for (Node child : children) { if (child != null) { que.offerLast(child); } } } list.add(levelList); } return list; } class Node { public int val; public List<Node> children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List<Node> _children) { val = _val; children = _children; } }}",
          "description": "Java实现N叉树层序遍历"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "\"\"\"",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<vector<int>> levelOrder(Node* root) { queue<Node*> que; if (root != NULL) que.push(root); vector<vector<int>> result; while (!que.empty()) { int size = que.size(); vector<int> vec; for (int i = 0; i < size; i++) { Node* node = que.front(); que.pop(); vec.push_back(node->val); for (int i = 0; i < node->children.size(); i++) { if (node->children[i]) que.push(node->children[i]); } } result.push_back(vec); } return result; }};",
          "description": "C++实现N叉树的层序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def levelOrder(self, root: 'Node') -> List[List[int]]: if not root: return [] result = [] queue = collections.deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) for child in node.children: queue.append(child) result.append(level) return result",
          "description": "Python实现N叉树的层序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def levelOrder(self, root: 'Node') -> List[List[int]]: if not root: return [] result=[] def traversal(root,depth): if len(result)==depth:result.append([]) result[depth].append(root.val) if root.children: for i in range(len(root.children)):traversal(root.children[i],depth+1) traversal(root,0) return result",
          "description": "Python递归法实现N叉树的层序遍历"
        },
        {
          "language": "java",
          "code": "public class N0429 { public List<List<Integer>> levelOrder(Node root) { List<List<Integer>> list = new ArrayList<>(); Deque<Node> que = new LinkedList<>(); if (root == null) { return list; } que.offerLast(root); while (!que.isEmpty()) { int levelSize = que.size(); List<Integer> levelList = new ArrayList<>(); for (int i = 0; i < levelSize; i++) { Node poll = que.pollFirst(); levelList.add(poll.val); List<Node> children = poll.children; if (children == null || children.size() == 0) { continue; } for (Node child : children) { if (child != null) { que.offerLast(child); } } } list.add(levelList); } return list; } class Node { public int val; public List<Node> children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List<Node> _children) { val = _val; children = _children; } }}",
          "description": "Java实现N叉树的层序遍历"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java:",
      "text": "// 429. N 叉树的层序遍历",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<vector<int>> levelOrder(Node* root) { queue<Node*> que; if (root != NULL) que.push(root); vector<vector<int>> result; while (!que.empty()) { int size = que.size(); vector<int> vec; for (int i = 0; i < size; i++) { Node* node = que.front(); que.pop(); vec.push_back(node->val); for (int i = 0; i < node->children.size(); i++) { if (node->children[i]) que.push(node->children[i]); } } result.push_back(vec); } return result;}};",
          "description": "C++实现N叉树层序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def levelOrder(self, root: 'Node') -> List[List[int]]: if not root: return [] result = [] queue = collections.deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) for child in node.children: queue.append(child) result.append(level) return result",
          "description": "Python实现N叉树层序遍历（迭代法）"
        },
        {
          "language": "python",
          "code": "class Solution: def levelOrder(self, root: 'Node') -> List[List[int]]: if not root: return [] result=[] def traversal(root,depth): if len(result)==depth:result.append([]) result[depth].append(root.val) if root.children: for i in range(len(root.children)):traversal(root.children[i],depth+1) traversal(root,0) return result",
          "description": "Python实现N叉树层序遍历（递归法）"
        },
        {
          "language": "java",
          "code": "public class N0429 { public List<List<Integer>> levelOrder(Node root) { List<List<Integer>> list = new ArrayList<>(); Deque<Node> que = new LinkedList<>(); if (root == null) { return list; } que.offerLast(root); while (!que.isEmpty()) { int levelSize = que.size(); List<Integer> levelList = new ArrayList<>(); for (int i = 0; i < levelSize; i++) { Node poll = que.pollFirst(); levelList.add(poll.val); List<Node> children = poll.children; if (children == null || children.size() == 0) { continue; } for (Node child : children) { if (child != null) { que.offerLast(child); } } } list.add(levelList); } return list; } class Node { public int val; public List<Node> children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List<Node> _children) { val = _val; children = _children; } }}",
          "description": "Java实现N叉树层序遍历"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: vector<vector<int>> levelOrder(Node* root) { queue<Node*> que; if (root != NULL) que.push(root); vector<vector<int>> result; while (!que.empty()) { int size = que.size(); vector<int> vec; for (int i = 0; i < size; i++) { Node* node = que.front(); que.pop(); vec.push_back(node->val); for (int i = 0; i < node->children.size(); i++) { if (node->children[i]) que.push(node->children[i]); } } result.push_back(vec); } return result; }};",
      "description": "C++实现N叉树的层序遍历"
    },
    {
      "language": "python",
      "code": "class Solution: def levelOrder(self, root: 'Node') -> List[List[int]]: if not root: return [] result = [] queue = collections.deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) for child in node.children: queue.append(child) result.append(level) return result",
      "description": "Python实现N叉树的层序遍历（迭代法）"
    },
    {
      "language": "python",
      "code": "class Solution: def levelOrder(self, root: 'Node') -> List[List[int]]: if not root: return [] result=[] def traversal(root,depth): if len(result)==depth:result.append([]) result[depth].append(root.val) if root.children: for i in range(len(root.children)):traversal(root.children[i],depth+1) traversal(root,0) return result",
      "description": "Python实现N叉树的层序遍历（递归法）"
    },
    {
      "language": "java",
      "code": "public class N0429 { public List<List<Integer>> levelOrder(Node root) { List<List<Integer>> list = new ArrayList<>(); Deque<Node> que = new LinkedList<>(); if (root == null) { return list; } que.offerLast(root); while (!que.isEmpty()) { int levelSize = que.size(); List<Integer> levelList = new ArrayList<>(); for (int i = 0; i < levelSize; i++) { Node poll = que.pollFirst(); levelList.add(poll.val); List<Node> children = poll.children; if (children == null || children.size() == 0) { continue; } for (Node child : children) { if (child != null) { que.offerLast(child); } } } list.add(levelList); } return list; } class Node { public int val; public List<Node> children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List<Node> _children) { val = _val; children = _children; } }}",
      "description": "Java实现N叉树的层序遍历"
    }
  ],
  "common_mistakes": [
    "忘记检查根节点是否为空",
    "在处理每个节点时未正确添加其子节点至队列",
    "忽略了对结果列表的操作应在每层结束后执行而非每次添加节点后立即执行"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210203151439168.png",
      "description": "这是一棵二叉树的示意图，节点值分别为1、2、3、4、5、6，展示了树结构的基本形态。",
      "context": "该图片展示了一个具体的3叉树结构，用于说明题目中提到的N叉树层序遍历的具体例子。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210203151439168.png",
      "description": "GIF展示了N叉树层序遍历的过程，从根节点开始逐层访问每个节点，并将其值按层次顺序添加到结果列表中。",
      "context": "该GIF动画展示了如何对给定的3叉树进行层序遍历的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\二叉树\\二叉树的层序遍历\\N叉树的层序遍历.txt",
  "extracted_at": "2025-07-20T10:44:16.112885",
  "raw_content": "N叉树的层序遍历\n力扣题目链接(https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)\n\n给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。\n\n例如，给定一个 3叉树 :\n\nhttps://file1.kamacoder.com/i/algo/20210203151439168.png\n\n返回其层序遍历:\n\n[ [1], [3,2,4], [5,6] ]\n\n#思路\n这道题依旧是模板题，只不过一个节点有多个孩子了\n\nC++代码:\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(Node* root) {\n        queue<Node*> que;\n        if (root != NULL) que.push(root);\n        vector<vector<int>> result;\n        while (!que.empty()) {\n            int size = que.size();\n            vector<int> vec;\n            for (int i = 0; i < size; i++) {\n                Node* node = que.front();\n                que.pop();\n                vec.push_back(node->val);\n                for (int i = 0; i < node->children.size(); i++) { // 将节点孩子加入队列\n                    if (node->children[i]) que.push(node->children[i]);\n                }\n            }\n            result.push_back(vec);\n        }\n        return result;\n\n    }\n};\n#其他语言版本\n#Python：\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution:\n    def levelOrder(self, root: 'Node') -> List[List[int]]:\n        if not root:\n            return []\n\n        result = []\n        queue = collections.deque([root])\n\n        while queue:\n            level_size = len(queue)\n            level = []\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                level.append(node.val)\n\n                for child in node.children:\n                    queue.append(child)\n\n            result.append(level)\n\n        return result\n# LeetCode 429. N-ary Tree Level Order Traversal\n# 递归法\nclass Solution:\n    def levelOrder(self, root: 'Node') -> List[List[int]]:\n        if not root: return []\n        result=[]\n        def traversal(root,depth):\n            if len(result)==depth:result.append([])\n            result[depth].append(root.val)\n            if root.children:\n                for i in range(len(root.children)):traversal(root.children[i],depth+1)\n\n        traversal(root,0)\n        return result\n#Java:\n// 429. N 叉树的层序遍历\npublic class N0429 {\n    /**\n     * 解法1：队列，迭代。\n     */\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> list = new ArrayList<>();\n        Deque<Node> que = new LinkedList<>();\n\n        if (root == null) {\n            return list;\n        }\n\n        que.offerLast(root);\n        while (!que.isEmpty()) {\n            int levelSize = que.size();\n            List<Integer> levelList = new ArrayList<>();\n\n            for (int i = 0; i < levelSize; i++) {\n                Node poll = que.pollFirst();\n\n                levelList.add(poll.val);\n\n                List<Node> children = poll.children;\n                if (children == null || children.size() == 0) {\n                    continue;\n                }\n                for (Node child : children) {\n                    if (child != null) {\n                        que.offerLast(child);\n                    }\n                }\n            }\n            list.add(levelList);\n        }\n\n        return list;\n    }\n\n    class Node {\n        public int val;\n        public List<Node> children;\n\n        public Node() {}\n\n        public Node(int _val) {\n            val = _val;\n        }\n\n        public Node(int _val, List<Node> _children) {\n            val = _val;\n            children = _children;\n        }\n    }\n}"
}