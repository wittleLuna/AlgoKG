{
  "id": "AP_d04acf98",
  "title": "接雨水",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/trapping-rain-water/",
  "description": "n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "暴力搜索",
    "双指针",
    "单调栈"
  ],
  "data_structure_tags": [
    "数组",
    "栈"
  ],
  "technique_tags": [
    "空间换时间",
    "预处理",
    "双指针"
  ],
  "difficulty": null,
  "solution_approach": "通过计算每个柱子上方可以存储的雨水量来解决。首先确定每个柱子左右两边最高的柱子高度，然后根据这两个高度中的较小值减去当前柱子的高度得到该柱子上的雨水量。整个过程可以通过暴力解法、双指针优化和单调栈三种方法实现。",
  "key_insights": [
    {
      "content": "选择按列而非行来计算雨水量，因为每一列的宽度固定为1，只需关注高度即可。"
    },
    {
      "content": "每个位置能存多少水由它左边最高点和右边最高点中较矮的那个决定。"
    },
    {
      "content": "使用额外数组记录每个位置左侧和右侧的最大高度，以减少查找次数。"
    },
    {
      "content": "在单调栈方法中，当遇到比栈顶元素高的柱子时，可形成凹槽从而接住雨水。"
    },
    {
      "content": "相同高度的柱子，应更新栈内下标以确保计算宽度时使用的是最右边的柱子。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "接雨水问题在面试中还是常见题目的，有必要好好讲一讲。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) {int sum = 0;for (int i = 0; i < height.size(); i++) {if (i == 0 || i == height.size() - 1) continue;int rHeight = height[i]; // 记录右边柱子的最高高度int lHeight = height[i]; // 记录左边柱子的最高高度for (int r = i + 1; r < height.size(); r++) {if (height[r] > rHeight) rHeight = height[r];}for (int l = i - 1; l >= 0; l--) {if (height[l] > lHeight) lHeight = height[l];}int h = min(lHeight, rHeight) - height[i];if (h > 0) sum += h;}return sum;}};",
          "description": "暴力解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) {if (height.size() <= 2) return 0;vector<int> maxLeft(height.size(), 0);vector<int> maxRight(height.size(), 0);int size = maxRight.size();maxLeft[0] = height[0];for (int i = 1; i < size; i++) {maxLeft[i] = max(height[i], maxLeft[i - 1]);}maxRight[size - 1] = height[size - 1];for (int i = size - 2; i >= 0; i--) {maxRight[i] = max(height[i], maxRight[i + 1]);}int sum = 0;for (int i = 0; i < size; i++) {int count = min(maxLeft[i], maxRight[i]) - height[i];if (count > 0) sum += count;}return sum;}};",
          "description": "双指针优化"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) {if (height.size() <= 2) return 0;stack<int> st;st.push(0);int sum = 0;for (int i = 1; i < height.size(); i++) {while (!st.empty() && height[i] > height[st.top()]) {int mid = st.top();st.pop();if (!st.empty()) {int h = min(height[st.top()], height[i]) - height[mid];int w = i - st.top() - 1;sum += h * w;}}}st.push(i);}return sum;}};",
          "description": "单调栈解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {int sum = 0;for (int i = 0; i < height.length; i++) {if (i==0 || i== height.length - 1) continue;int rHeight = height[i];for (int r = i+1; r < height.length; r++) {if (height[r] > rHeight) rHeight = height[r];}for (int l = i-1; l >= 0; l--) {if(height[l] > lHeight) lHeight = height[l];}int h = Math.min(lHeight, rHeight) - height[i];if (h > 0) sum += h;}return sum;}}",
          "description": "暴力解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {int length = height.length;if (length <= 2) return 0;int[] maxLeft = new int[length];int[] maxRight = new int[length];maxLeft[0] = height[0];for (int i = 1; i< length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]);maxRight[length - 1] = height[length - 1];for(int i = length - 2; i >= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]);int sum = 0;for (int i = 0; i < length; i++) {int count = Math.min(maxLeft[i], maxRight[i]) - height[i];if (count > 0) sum += count;}return sum;}}",
          "description": "双指针"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {if (height.length <= 2) {return 0;}int maxLeft = height[0], maxRight = height[height.length - 1];int l = 1, r = height.length - 2;int res = 0;while (l <= r) {maxLeft = Math.max(maxLeft, height[l]);maxRight = Math.max(maxRight, height[r]);if (maxLeft < maxRight) {res += maxLeft - height[l ++];} else {res += maxRight - height[r --];}}return res;}}",
          "description": "双指针优化"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height){int size = height.length;if (size <= 2) return 0;Stack<Integer> stack = new Stack<Integer>();stack.push(0);int sum = 0;for (int index = 1; index < size; index++){int stackTop = stack.peek();if (height[index] < height[stackTop]){stack.push(index);}else if (height[index] == height[stackTop]){stack.pop();stack.push(index);}else{int heightAtIdx = height[index];while (!stack.isEmpty() && (heightAtIdx > height[stackTop])){int mid = stack.pop();if (!stack.isEmpty()){int left = stack.peek();int h = Math.min(height[left], height[index]) - height[mid];int w = index - left - 1;int hold = h * w;if (hold > 0) sum += hold;stackTop = stack.peek();}}}stack.push(index);}return sum;}}",
          "description": "单调栈法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: res = 0 for i in range(len(height)): if i == 0 or i == len(height)-1: continue lHight = height[i-1] rHight = height[i+1] for j in range(i-1): if height[j] > lHight: lHight = height[j] for k in range(i+2,len(height)): if height[k] > rHight: rHight = height[k] res1 = min(lHight,rHight) - height[i] if res1 > 0: res += res1 return res",
          "description": "暴力解法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: leftheight, rightheight = [0]*len(height), [0]*len(height) leftheight[0]=height[0] for i in range(1,len(height)): leftheight[i]=max(leftheight[i-1],height[i]) rightheight[-1]=height[-1] for i in range(len(height)-2,-1,-1): rightheight[i]=max(rightheight[i+1],height[i]) result = 0 for i in range(0,len(height)): summ = min(leftheight[i],rightheight[i])-height[i] result += summ return result",
          "description": "双指针"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: stack = [0] result = 0 for i in range(1, len(height)): while stack and height[i] > height[stack[-1]]: mid_height = stack.pop() if stack: h = min(height[stack[-1]], height[i]) - height[mid_height] w = i - stack[-1] - 1 result += h * w stack.append(i) return result",
          "description": "单调栈压缩版"
        }
      ],
      "subsections": []
    },
    {
      "name": "暴力解法",
      "text": "本题暴力解法也是也是使用双指针。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) { int sum = 0; for (int i = 0; i < height.size(); i++) { if (i == 0 || i == height.size() - 1) continue; int rHeight = height[i]; int lHeight = height[i]; for (int r = i + 1; r < height.size(); r++) { if (height[r] > rHeight) rHeight = height[r]; } for (int l = i - 1; l >= 0; l--) { if (height[l] > lHeight) lHeight = height[l]; } int h = min(lHeight, rHeight) - height[i]; if (h > 0) sum += h; } return sum;}};",
          "description": "暴力解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) { if (height.size() <= 2) return 0; vector<int> maxLeft(height.size(), 0); vector<int> maxRight(height.size(), 0); int size = maxRight.size(); maxLeft[0] = height[0]; for (int i = 1; i < size; i++) { maxLeft[i] = max(height[i], maxLeft[i - 1]); } maxRight[size - 1] = height[size - 1]; for (int i = size - 2; i >= 0; i--) { maxRight[i] = max(height[i], maxRight[i + 1]); } int sum = 0; for (int i = 0; i < size; i++) { int count = min(maxLeft[i], maxRight[i]) - height[i]; if (count > 0) sum += count; } return sum;}};",
          "description": "双指针优化"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) { if (height.size() <= 2) return 0; stack<int> st; st.push(0); int sum = 0; for (int i = 1; i < height.size(); i++) { while (!st.empty() && height[i] > height[st.top()]) { int mid = st.top(); st.pop(); if (!st.empty()) { int h = min(height[st.top()], height[i]) - height[mid]; int w = i - st.top() - 1; sum += h * w; } } st.push(i); } return sum;}};",
          "description": "单调栈解法"
        },
        {
          "language": "java",
          "code": "class Solution { public int trap(int[] height) { int sum = 0; for (int i = 0; i < height.length; i++) { if (i==0 || i== height.length - 1) continue; int rHeight = height[i]; int lHeight = height[i]; for (int r = i+1; r < height.length; r++) { if (height[r] > rHeight) rHeight = height[r]; } for (int l = i-1; l >= 0; l--) { if(height[l] > lHeight) lHeight = height[l]; } int h = Math.min(lHeight, rHeight) - height[i]; if (h > 0) sum += h; } return sum; }}",
          "description": "暴力解法"
        },
        {
          "language": "java",
          "code": "class Solution { public int trap(int[] height) { int length = height.length; if (length <= 2) return 0; int[] maxLeft = new int[length]; int[] maxRight = new int[length]; maxLeft[0] = height[0]; for (int i = 1; i< length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]); maxRight[length - 1] = height[length - 1]; for(int i = length - 2; i >= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]); int sum = 0; for (int i = 0; i < length; i++) { int count = Math.min(maxLeft[i], maxRight[i]) - height[i]; if (count > 0) sum += count; } return sum; }}",
          "description": "双指针"
        },
        {
          "language": "java",
          "code": "class Solution { public int trap(int[] height) { if (height.length <= 2) { return 0; } int maxLeft = height[0], maxRight = height[height.length - 1]; int l = 1, r = height.length - 2; int res = 0; while (l <= r) { maxLeft = Math.max(maxLeft, height[l]); maxRight = Math.max(maxRight, height[r]); if (maxLeft < maxRight) { res += maxLeft - height[l ++]; } else { res += maxRight - height[r --]; } } return res; }}",
          "description": "双指针优化"
        },
        {
          "language": "java",
          "code": "class Solution { public int trap(int[] height){ int size = height.length; if (size <= 2) return 0; Stack<Integer> stack = new Stack<Integer>(); stack.push(0); int sum = 0; for (int index = 1; index < size; index++){ int stackTop = stack.peek(); if (height[index] < height[stackTop]){ stack.push(index); }else if (height[index] == height[stackTop]){ stack.pop(); stack.push(index); }else{ int heightAtIdx = height[index]; while (!stack.isEmpty() && (heightAtIdx > height[stackTop])){ int mid = stack.pop(); if (!stack.isEmpty()){ int left = stack.peek(); int h = Math.min(height[left], height[index]) - height[mid]; int w = index - left - 1; int hold = h * w; if (hold > 0) sum += hold; stackTop = stack.peek(); } } stack.push(index); } } return sum; }}",
          "description": "单调栈法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: res = 0 for i in range(len(height)): if i == 0 or i == len(height)-1: continue lHight = height[i-1] rHight = height[i+1] for j in range(i-1): if height[j] > lHight: lHight = height[j] for k in range(i+2,len(height)): if height[k] > rHight: rHight = height[k] res1 = min(lHight,rHight) - height[i] if res1 > 0: res += res1 return res",
          "description": "暴力解法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: leftheight, rightheight = [0]*len(height), [0]*len(height) leftheight[0]=height[0] for i in range(1,len(height)): leftheight[i]=max(leftheight[i-1],height[i]) rightheight[-1]=height[-1] for i in range(len(height)-2,-1,-1): rightheight[i]=max(rightheight[i+1],height[i]) result = 0 for i in range(0,len(height)): summ = min(leftheight[i],rightheight[i])-height[i] result += summ return result",
          "description": "双指针"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: stack = [0] result = 0 for i in range(1, len(height)): if height[i] < height[stack[-1]]: stack.append(i) elif height[i] == height[stack[-1]]: stack.pop() stack.append(i) else: while stack and height[i] > height[stack[-1]]: mid_height = height[stack[-1]] stack.pop() if stack: right_height = height[i] left_height = height[stack[-1]] h = min(right_height, left_height) - mid_height w = i - stack[-1] - 1 result += h * w stack.append(i) return result",
          "description": "单调栈"
        }
      ],
      "subsections": []
    },
    {
      "name": "双指针优化",
      "text": "在暴力解法中，我们可以看到只要记录左边柱子的最高高度 和 右边柱子的最高高度，就可以计算当前位置的雨水面积，这就是通过列来计算。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) { int sum = 0; for (int i = 0; i < height.size(); i++) { if (i == 0 || i == height.size() - 1) continue; int rHeight = height[i]; int lHeight = height[i]; for (int r = i + 1; r < height.size(); r++) { if (height[r] > rHeight) rHeight = height[r]; } for (int l = i - 1; l >= 0; l--) { if (height[l] > lHeight) lHeight = height[l]; } int h = min(lHeight, rHeight) - height[i]; if (h > 0) sum += h; } return sum; }};",
          "description": "暴力解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) { if (height.size() <= 2) return 0; vector<int> maxLeft(height.size(), 0); vector<int> maxRight(height.size(), 0); int size = maxRight.size(); maxLeft[0] = height[0]; for (int i = 1; i < size; i++) { maxLeft[i] = max(height[i], maxLeft[i - 1]); } maxRight[size - 1] = height[size - 1]; for (int i = size - 2; i >= 0; i--) { maxRight[i] = max(height[i], maxRight[i + 1]); } int sum = 0; for (int i = 0; i < size; i++) { int count = min(maxLeft[i], maxRight[i]) - height[i]; if (count > 0) sum += count; } return sum; }};",
          "description": "双指针优化"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) { if (height.size() <= 2) return 0; stack<int> st; st.push(0); int sum = 0; for (int i = 1; i < height.size(); i++) { while (!st.empty() && height[i] > height[st.top()]) { int mid = st.top(); st.pop(); if (!st.empty()) { int h = min(height[st.top()], height[i]) - height[mid]; int w = i - st.top() - 1; sum += h * w; } } st.push(i); } return sum; }};",
          "description": "单调栈解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {int sum = 0;for (int i = 0; i < height.length; i++) {if (i==0 || i== height.length - 1) continue;int rHeight = height[i];int lHeight = height[i];for (int r = i+1; r < height.length; r++) {if (height[r] > rHeight) rHeight = height[r];}for (int l = i-1; l >= 0; l--) {if(height[l] > lHeight) lHeight = height[l];}int h = Math.min(lHeight, rHeight) - height[i];if (h > 0) sum += h;}return sum;}}",
          "description": "暴力解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {int length = height.length;if (length <= 2) return 0;int[] maxLeft = new int[length];int[] maxRight = new int[length];maxLeft[0] = height[0];for (int i = 1; i< length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]);maxRight[length - 1] = height[length - 1];for(int i = length - 2; i >= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]);int sum = 0;for (int i = 0; i < length; i++) {int count = Math.min(maxLeft[i], maxRight[i]) - height[i];if (count > 0) sum += count;}return sum;}}",
          "description": "双指针"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {if (height.length <= 2) {return 0;}int maxLeft = height[0], maxRight = height[height.length - 1];int l = 1, r = height.length - 2;int res = 0;while (l <= r) {maxLeft = Math.max(maxLeft, height[l]);maxRight = Math.max(maxRight, height[r]);if (maxLeft < maxRight) {res += maxLeft - height[l ++];} else {res += maxRight - height[r --];}}return res;}}",
          "description": "双指针优化"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height){int size = height.length;if (size <= 2) return 0;Stack<Integer> stack = new Stack<Integer>();stack.push(0);int sum = 0;for (int index = 1; index < size; index++){int stackTop = stack.peek();if (height[index] < height[stackTop]){stack.push(index);}else if (height[index] == height[stackTop]){stack.pop();stack.push(index);}else{int heightAtIdx = height[index];while (!stack.isEmpty() && (heightAtIdx > height[stackTop])){int mid = stack.pop();if (!stack.isEmpty()){int left = stack.peek();int h = Math.min(height[left], height[index]) - height[mid];int w = index - left - 1;int hold = h * w;if (hold > 0) sum += hold;stackTop = stack.peek();}}stack.push(index);}}return sum;}}",
          "description": "单调栈法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: res = 0 for i in range(len(height)): if i == 0 or i == len(height)-1: continue lHight = height[i-1] rHight = height[i+1] for j in range(i-1): if height[j] > lHight: lHight = height[j] for k in range(i+2,len(height)): if height[k] > rHight: rHight = height[k] res1 = min(lHight,rHight) - height[i] if res1 > 0: res += res1 return res",
          "description": "暴力解法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: leftheight, rightheight = [0]*len(height), [0]*len(height) leftheight[0]=height[0] for i in range(1,len(height)): leftheight[i]=max(leftheight[i-1],height[i]) rightheight[-1]=height[-1] for i in range(len(height)-2,-1,-1): rightheight[i]=max(rightheight[i+1],height[i]) result = 0 for i in range(0,len(height)): summ = min(leftheight[i],rightheight[i])-height[i] result += summ return result",
          "description": "双指针"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: stack = [0] result = 0 for i in range(1, len(height)): while stack and height[i] > height[stack[-1]]: mid_height = stack.pop() if stack: h = min(height[stack[-1]], height[i]) - height[mid_height] w = i - stack[-1] - 1 result += h * w stack.append(i) return result",
          "description": "单调栈压缩版"
        }
      ],
      "subsections": []
    },
    {
      "name": "单调栈解法",
      "text": "关于单调栈的理论基础，单调栈适合解决什么问题，单调栈的工作过程，大家可以先看这题讲解 739. 每日温度 (https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html)。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) { int sum = 0; for (int i = 0; i < height.size(); i++) { if (i == 0 || i == height.size() - 1) continue; int rHeight = height[i]; int lHeight = height[i]; for (int r = i + 1; r < height.size(); r++) { if (height[r] > rHeight) rHeight = height[r]; } for (int l = i - 1; l >= 0; l--) { if (height[l] > lHeight) lHeight = height[l]; } int h = min(lHeight, rHeight) - height[i]; if (h > 0) sum += h; } return sum; }};",
          "description": "暴力解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) { if (height.size() <= 2) return 0; vector<int> maxLeft(height.size(), 0); vector<int> maxRight(height.size(), 0); int size = maxRight.size(); maxLeft[0] = height[0]; for (int i = 1; i < size; i++) { maxLeft[i] = max(height[i], maxLeft[i - 1]); } maxRight[size - 1] = height[size - 1]; for (int i = size - 2; i >= 0; i--) { maxRight[i] = max(height[i], maxRight[i + 1]); } int sum = 0; for (int i = 0; i < size; i++) { int count = min(maxLeft[i], maxRight[i]) - height[i]; if (count > 0) sum += count; } return sum; }};",
          "description": "双指针优化"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) { if (height.size() <= 2) return 0; stack<int> st; st.push(0); int sum = 0; for (int i = 1; i < height.size(); i++) { while (!st.empty() && height[i] > height[st.top()]) { int mid = st.top(); st.pop(); if (!st.empty()) { int h = min(height[st.top()], height[i]) - height[mid]; int w = i - st.top() - 1; sum += h * w; } } st.push(i); } return sum; }};",
          "description": "单调栈解法"
        },
        {
          "language": "java",
          "code": "class Solution { public int trap(int[] height) { int sum = 0; for (int i = 0; i < height.length; i++) { if (i==0 || i== height.length - 1) continue; int rHeight = height[i]; int lHeight = height[i]; for (int r = i+1; r < height.length; r++) { if (height[r] > rHeight) rHeight = height[r]; } for (int l = i-1; l >= 0; l--) { if(height[l] > lHeight) lHeight = height[l]; } int h = Math.min(lHeight, rHeight) - height[i]; if (h > 0) sum += h; } return sum; }}",
          "description": "暴力解法"
        },
        {
          "language": "java",
          "code": "class Solution { public int trap(int[] height) { int length = height.length; if (length <= 2) return 0; int[] maxLeft = new int[length]; int[] maxRight = new int[length]; maxLeft[0] = height[0]; for (int i = 1; i< length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]); maxRight[length - 1] = height[length - 1]; for(int i = length - 2; i >= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]); int sum = 0; for (int i = 0; i < length; i++) { int count = Math.min(maxLeft[i], maxRight[i]) - height[i]; if (count > 0) sum += count; } return sum; }}",
          "description": "双指针"
        },
        {
          "language": "java",
          "code": "class Solution { public int trap(int[] height) { if (height.length <= 2) { return 0; } int maxLeft = height[0], maxRight = height[height.length - 1]; int l = 1, r = height.length - 2; int res = 0; while (l <= r) { maxLeft = Math.max(maxLeft, height[l]); maxRight = Math.max(maxRight, height[r]); if (maxLeft < maxRight) { res += maxLeft - height[l ++]; } else { res += maxRight - height[r --]; } } return res; }}",
          "description": "双指针优化"
        },
        {
          "language": "java",
          "code": "class Solution { public int trap(int[] height){ int size = height.length; if (size <= 2) return 0; Stack<Integer> stack = new Stack<Integer>(); stack.push(0); int sum = 0; for (int index = 1; index < size; index++){ int stackTop = stack.peek(); if (height[index] < height[stackTop]){ stack.push(index); }else if (height[index] == height[stackTop]){ stack.pop(); stack.push(index); }else{ int heightAtIdx = height[index]; while (!stack.isEmpty() && (heightAtIdx > height[stackTop])){ int mid = stack.pop(); if (!stack.isEmpty()){ int left = stack.peek(); int h = Math.min(height[left], height[index]) - height[mid]; int w = index - left - 1; int hold = h * w; if (hold > 0) sum += hold; stackTop = stack.peek(); } } stack.push(index); } } return sum; }}",
          "description": "单调栈法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: res = 0 for i in range(len(height)): if i == 0 or i == len(height)-1: continue lHight = height[i-1] rHight = height[i+1] for j in range(i-1): if height[j] > lHight: lHight = height[j] for k in range(i+2,len(height)): if height[k] > rHight: rHight = height[k] res1 = min(lHight,rHight) - height[i] if res1 > 0: res += res1 return res",
          "description": "暴力解法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: leftheight, rightheight = [0]*len(height), [0]*len(height) leftheight[0]=height[0] for i in range(1,len(height)): leftheight[i]=max(leftheight[i-1],height[i]) rightheight[-1]=height[-1] for i in range(len(height)-2,-1,-1): rightheight[i]=max(rightheight[i+1],height[i]) result = 0 for i in range(0,len(height)): summ = min(leftheight[i],rightheight[i])-height[i] result += summ return result",
          "description": "双指针"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: stack = [0] result = 0 for i in range(1, len(height)): if height[i] < height[stack[-1]]: stack.append(i) elif height[i] == height[stack[-1]]: stack.pop() stack.append(i) else: while stack and height[i] > height[stack[-1]]: mid_height = height[stack[-1]] stack.pop() if stack: right_height = height[i] left_height = height[stack[-1]] h = min(right_height, left_height) - mid_height w = i - stack[-1] - 1 result += h * w stack.append(i) return result",
          "description": "单调栈"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: stack = [0] result = 0 for i in range(1, len(height)): while stack and height[i] > height[stack[-1]]: mid_height = stack.pop() if stack: h = min(height[stack[-1]], height[i]) - height[mid_height] w = i - stack[-1] - 1 result += h * w stack.append(i) return result",
          "description": "单调栈压缩版"
        }
      ],
      "subsections": []
    },
    {
      "name": "准备工作",
      "text": "那么本题使用单调栈有如下几个问题：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) {int sum = 0;for (int i = 0; i < height.size(); i++) {if (i == 0 || i == height.size() - 1) continue;int rHeight = height[i]; // 记录右边柱子的最高高度int lHeight = height[i]; // 记录左边柱子的最高高度for (int r = i + 1; r < height.size(); r++) {if (height[r] > rHeight) rHeight = height[r];}for (int l = i - 1; l >= 0; l--) {if (height[l] > lHeight) lHeight = height[l];}int h = min(lHeight, rHeight) - height[i];if (h > 0) sum += h;}return sum;}};",
          "description": "暴力解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) {if (height.size() <= 2) return 0;vector<int> maxLeft(height.size(), 0);vector<int> maxRight(height.size(), 0);int size = maxRight.size();maxLeft[0] = height[0];for (int i = 1; i < size; i++) {maxLeft[i] = max(height[i], maxLeft[i - 1]);}maxRight[size - 1] = height[size - 1];for (int i = size - 2; i >= 0; i--) {maxRight[i] = max(height[i], maxRight[i + 1]);}int sum = 0;for (int i = 0; i < size; i++) {int count = min(maxLeft[i], maxRight[i]) - height[i];if (count > 0) sum += count;}return sum;}};",
          "description": "双指针优化"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) {if (height.size() <= 2) return 0;stack<int> st;st.push(0);int sum = 0;for (int i = 1; i < height.size(); i++) {while (!st.empty() && height[i] > height[st.top()]) {int mid = st.top();st.pop();if (!st.empty()) {int h = min(height[st.top()], height[i]) - height[mid];int w = i - st.top() - 1;sum += h * w;}}}st.push(i);}return sum;}};",
          "description": "单调栈解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {int sum = 0;for (int i = 0; i < height.length; i++) {if (i==0 || i== height.length - 1) continue;int rHeight = height[i];int lHeight = height[i];for (int r = i+1; r < height.length; r++) {if (height[r] > rHeight) rHeight = height[r];}for (int l = i-1; l >= 0; l--) {if(height[l] > lHeight) lHeight = height[l];}int h = Math.min(lHeight, rHeight) - height[i];if (h > 0) sum += h;}return sum;}}",
          "description": "暴力解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {int length = height.length;if (length <= 2) return 0;int[] maxLeft = new int[length];int[] maxRight = new int[length];maxLeft[0] = height[0];for (int i = 1; i< length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]);maxRight[length - 1] = height[length - 1];for(int i = length - 2; i >= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]);int sum = 0;for (int i = 0; i < length; i++) {int count = Math.min(maxLeft[i], maxRight[i]) - height[i];if (count > 0) sum += count;}return sum;}}",
          "description": "双指针"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {if (height.length <= 2) {return 0;}int maxLeft = height[0], maxRight = height[height.length - 1];int l = 1, r = height.length - 2;int res = 0;while (l <= r) {maxLeft = Math.max(maxLeft, height[l]);maxRight = Math.max(maxRight, height[r]);if (maxLeft < maxRight) {res += maxLeft - height[l ++];} else {res += maxRight - height[r --];}}return res;}}",
          "description": "双指针优化"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height){int size = height.length;if (size <= 2) return 0;Stack<Integer> stack = new Stack<Integer>();stack.push(0);int sum = 0;for (int index = 1; index < size; index++){int stackTop = stack.peek();if (height[index] < height[stackTop]){stack.push(index);}else if (height[index] == height[stackTop]){stack.pop();stack.push(index);}else{int heightAtIdx = height[index];while (!stack.isEmpty() && (heightAtIdx > height[stackTop])){int mid = stack.pop();if (!stack.isEmpty()){int left = stack.peek();int h = Math.min(height[left], height[index]) - height[mid];int w = index - left - 1;int hold = h * w;if (hold > 0) sum += hold;stackTop = stack.peek();}}stack.push(index);}}return sum;}}",
          "description": "单调栈法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: res = 0 for i in range(len(height)): if i == 0 or i == len(height)-1: continue lHight = height[i-1] rHight = height[i+1] for j in range(i-1): if height[j] > lHight: lHight = height[j] for k in range(i+2,len(height)): if height[k] > rHight: rHight = height[k] res1 = min(lHight,rHight) - height[i] if res1 > 0: res += res1 return res",
          "description": "暴力解法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: leftheight, rightheight = [0]*len(height), [0]*len(height) leftheight[0]=height[0] for i in range(1,len(height)): leftheight[i]=max(leftheight[i-1],height[i]) rightheight[-1]=height[-1] for i in range(len(height)-2,-1,-1): rightheight[i]=max(rightheight[i+1],height[i]) result = 0 for i in range(0,len(height)): summ = min(leftheight[i],rightheight[i])-height[i] result += summ return result",
          "description": "双指针"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: stack = [0] result = 0 for i in range(1, len(height)): while stack and height[i] > height[stack[-1]]: mid_height = stack.pop() if stack: h = min(height[stack[-1]], height[i]) - height[mid_height] w = i - stack[-1] - 1 result += h * w stack.append(i) return result",
          "description": "单调栈压缩版"
        }
      ],
      "subsections": []
    },
    {
      "name": "单调栈处理逻辑",
      "text": "以下操作过程其实和 739. 每日温度 (https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html)也是一样的，建议先做 739. 每日温度 (https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html)。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) {int sum = 0;for (int i = 0; i < height.size(); i++) {if (i == 0 || i == height.size() - 1) continue;int rHeight = height[i]; // 记录右边柱子的最高高度int lHeight = height[i]; // 记录左边柱子的最高高度for (int r = i + 1; r < height.size(); r++) {if (height[r] > rHeight) rHeight = height[r];}for (int l = i - 1; l >= 0; l--) {if (height[l] > lHeight) lHeight = height[l];}int h = min(lHeight, rHeight) - height[i];if (h > 0) sum += h;}return sum;}};",
          "description": "暴力解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) {if (height.size() <= 2) return 0;vector<int> maxLeft(height.size(), 0);vector<int> maxRight(height.size(), 0);int size = maxRight.size();maxLeft[0] = height[0];for (int i = 1; i < size; i++) {maxLeft[i] = max(height[i], maxLeft[i - 1]);}maxRight[size - 1] = height[size - 1];for (int i = size - 2; i >= 0; i--) {maxRight[i] = max(height[i], maxRight[i + 1]);}int sum = 0;for (int i = 0; i < size; i++) {int count = min(maxLeft[i], maxRight[i]) - height[i];if (count > 0) sum += count;}return sum;}};",
          "description": "双指针优化"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) {if (height.size() <= 2) return 0;stack<int> st;st.push(0);int sum = 0;for (int i = 1; i < height.size(); i++) {while (!st.empty() && height[i] > height[st.top()]) {int mid = st.top();st.pop();if (!st.empty()) {int h = min(height[st.top()], height[i]) - height[mid];int w = i - st.top() - 1;sum += h * w;}}}st.push(i);}return sum;}};",
          "description": "单调栈解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {int sum = 0;for (int i = 0; i < height.length; i++) {if (i==0 || i== height.length - 1) continue;int rHeight = height[i];int lHeight = height[i];for (int r = i+1; r < height.length; r++) {if (height[r] > rHeight) rHeight = height[r];}for (int l = i-1; l >= 0; l--) {if(height[l] > lHeight) lHeight = height[l];}int h = Math.min(lHeight, rHeight) - height[i];if (h > 0) sum += h;}return sum;}}",
          "description": "暴力解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {int length = height.length;if (length <= 2) return 0;int[] maxLeft = new int[length];int[] maxRight = new int[length];maxLeft[0] = height[0];for (int i = 1; i< length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]);maxRight[length - 1] = height[length - 1];for(int i = length - 2; i >= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]);int sum = 0;for (int i = 0; i < length; i++) {int count = Math.min(maxLeft[i], maxRight[i]) - height[i];if (count > 0) sum += count;}return sum;}}",
          "description": "双指针"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {if (height.length <= 2) {return 0;}int maxLeft = height[0], maxRight = height[height.length - 1];int l = 1, r = height.length - 2;int res = 0;while (l <= r) {maxLeft = Math.max(maxLeft, height[l]);maxRight = Math.max(maxRight, height[r]);if (maxLeft < maxRight) {res += maxLeft - height[l ++];} else {res += maxRight - height[r --];}}return res;}}",
          "description": "双指针优化"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height){int size = height.length;if (size <= 2) return 0;Stack<Integer> stack = new Stack<Integer>();stack.push(0);int sum = 0;for (int index = 1; index < size; index++){int stackTop = stack.peek();if (height[index] < height[stackTop]){stack.push(index);}else if (height[index] == height[stackTop]){stack.pop();stack.push(index);}else{int heightAtIdx = height[index];while (!stack.isEmpty() && (heightAtIdx > height[stackTop])){int mid = stack.pop();if (!stack.isEmpty()){int left = stack.peek();int h = Math.min(height[left], height[index]) - height[mid];int w = index - left - 1;int hold = h * w;if (hold > 0) sum += hold;stackTop = stack.peek();}}stack.push(index);}}return sum;}}",
          "description": "单调栈法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: res = 0 for i in range(len(height)): if i == 0 or i == len(height)-1: continue lHight = height[i-1] rHight = height[i+1] for j in range(i-1): if height[j] > lHight: lHight = height[j] for k in range(i+2,len(height)): if height[k] > rHight: rHight = height[k] res1 = min(lHight,rHight) - height[i] if res1 > 0: res += res1 return res",
          "description": "暴力解法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: leftheight, rightheight = [0]*len(height), [0]*len(height) leftheight[0]=height[0] for i in range(1,len(height)): leftheight[i]=max(leftheight[i-1],height[i]) rightheight[-1]=height[-1] for i in range(len(height)-2,-1,-1): rightheight[i]=max(rightheight[i+1],height[i]) result = 0 for i in range(0,len(height)): summ = min(leftheight[i],rightheight[i])-height[i] result += summ return result",
          "description": "双指针"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: stack = [0] result = 0 for i in range(1, len(height)): while stack and height[i] > height[stack[-1]]: mid_height = stack.pop() if stack: h = min(height[stack[-1]], height[i]) - height[mid_height] w = i - stack[-1] - 1 result += h * w stack.append(i) return result",
          "description": "单调栈压缩版"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java:",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution {\n    public int trap(int[] height) {\n        int sum = 0;\n        for (int i = 0; i < height.length; i++) {\n            if (i==0 || i== height.length - 1) continue;\n\n            int rHeight = height[i];\n            int lHeight = height[i];\n            for (int r = i+1; r < height.length; r++) {\n                if (height[r] > rHeight) rHeight = height[r];\n            }\n            for (int l = i-1; l >= 0; l--) {\n                if(height[l] > lHeight) lHeight = height[l];\n            }\n            int h = Math.min(lHeight, rHeight) - height[i];\n            if (h > 0) sum += h;\n        }\n        return sum;\n    }\n}",
          "description": "暴力解法"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int trap(int[] height) {\n        int length = height.length;\n        if (length <= 2) return 0;\n        int[] maxLeft = new int[length];\n        int[] maxRight = new int[length];\n\n        maxLeft[0] = height[0];\n        for (int i = 1; i< length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]);\n\n        maxRight[length - 1] = height[length - 1];\n        for(int i = length - 2; i >= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]);\n\n        int sum = 0;\n        for (int i = 0; i < length; i++) {\n            int count = Math.min(maxLeft[i], maxRight[i]) - height[i];\n            if (count > 0) sum += count;\n        }\n        return sum;\n    }\n}",
          "description": "双指针"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int trap(int[] height) {\n        if (height.length <= 2) {\n            return 0;\n        }\n        int maxLeft = height[0], maxRight = height[height.length - 1];\n        int l = 1, r = height.length - 2;\n        int res = 0;\n        while (l <= r) {\n            maxLeft = Math.max(maxLeft, height[l]);\n            maxRight = Math.max(maxRight, height[r]);\n            if (maxLeft < maxRight) {\n                res += maxLeft - height[l ++];\n            } else {\n                res += maxRight - height[r --];\n            }\n        }\n        return res;\n    }\n}",
          "description": "双指针优化"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public int trap(int[] height){\n        int size = height.length;\n\n        if (size <= 2) return 0;\n\n        Stack<Integer> stack = new Stack<Integer>();\n        stack.push(0);\n\n        int sum = 0;\n        for (int index = 1; index < size; index++){\n            int stackTop = stack.peek();\n            if (height[index] < height[stackTop]){\n                stack.push(index);\n            }else if (height[index] == height[stackTop]){\n                stack.pop();\n                stack.push(index);\n            }else{\n                int heightAtIdx = height[index];\n                while (!stack.isEmpty() && (heightAtIdx > height[stackTop])){\n                    int mid = stack.pop();\n\n                    if (!stack.isEmpty()){\n                        int left = stack.peek();\n\n                        int h = Math.min(height[left], height[index]) - height[mid];\n                        int w = index - left - 1;\n                        int hold = h * w;\n                        if (hold > 0) sum += hold;\n                        stackTop = stack.peek();\n                    }\n                }\n                stack.push(index);\n            }\n        }\n\n        return sum;\n    }\n}",
          "description": "单调栈法"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        res = 0\n        for i in range(len(height)):\n            if i == 0 or i == len(height)-1: continue\n            lHight = height[i-1]\n            rHight = height[i+1]\n            for j in range(i-1):\n                if height[j] > lHight:\n                    lHight = height[j]\n            for k in range(i+2,len(height)):\n                if height[k] > rHight:\n                    rHight = height[k]\n            res1 = min(lHight,rHight) - height[i]\n            if res1 > 0:\n                res += res1\n        return res",
          "description": "暴力解法"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        leftheight, rightheight = [0]*len(height), [0]*len(height)\n\n        leftheight[0]=height[0]\n        for i in range(1,len(height)):\n            leftheight[i]=max(leftheight[i-1],height[i])\n        rightheight[-1]=height[-1]\n        for i in range(len(height)-2,-1,-1):\n            rightheight[i]=max(rightheight[i+1],height[i])\n\n        result = 0\n        for i in range(0,len(height)):\n            summ = min(leftheight[i],rightheight[i])-height[i]\n            result += summ\n        return result",
          "description": "双指针"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        stack = [0]\n        result = 0\n        for i in range(1, len(height)):\n            while stack and height[i] > height[stack[-1]]:\n                mid_height = stack.pop()\n                if stack:\n                    h = min(height[stack[-1]], height[i]) - height[mid_height]\n                    w = i - stack[-1] - 1\n                    result += h * w\n            stack.append(i)\n        return result",
          "description": "单调栈压缩版"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java:",
      "text": "暴力解法：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) {int sum = 0; for (int i = 0; i < height.size(); i++) {if (i == 0 || i == height.size() - 1) continue;int rHeight = height[i]; // 记录右边柱子的最高高度int lHeight = height[i]; // 记录左边柱子的最高高度for (int r = i + 1; r < height.size(); r++) {if (height[r] > rHeight) rHeight = height[r];}for (int l = i - 1; l >= 0; l--) {if (height[l] > lHeight) lHeight = height[l];}int h = min(lHeight, rHeight) - height[i];if (h > 0) sum += h;}return sum;}};",
          "description": "暴力解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int trap(int[] height) {int sum = 0; for (int i = 0; i < height.length; i++) {if (i==0 || i== height.length - 1) continue;int rHeight = height[i]; // 记录右边柱子的最高高度int lHeight = height[i]; // 记录左边柱子的最高高度for (int r = i+1; r < height.length; r++) {if (height[r] > rHeight) rHeight = height[r];}for (int l = i-1; l >= 0; l--) {if(height[l] > lHeight) lHeight = height[l];}int h = Math.min(lHeight, rHeight) - height[i];if (h > 0) sum += h;}return sum;}}",
          "description": "暴力解法"
        },
        {
          "language": "python",
          "code": "class Solution: def trap(self, height: List[int]) -> int: res = 0 for i in range(len(height)): if i == 0 or i == len(height)-1: continue lHight = height[i-1] rHight = height[i+1] for j in range(i-1): if height[j] > lHight: lHight = height[j] for k in range(i+2,len(height)): if height[k] > rHight: rHight = height[k] res1 = min(lHight,rHight) - height[i] if res1 > 0: res += res1 return res",
          "description": "暴力解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python:",
      "text": "暴力解法：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) { int sum = 0; for (int i = 0; i < height.size(); i++) { if (i == 0 || i == height.size() - 1) continue; int rHeight = height[i]; int lHeight = height[i]; for (int r = i + 1; r < height.size(); r++) { if (height[r] > rHeight) rHeight = height[r]; } for (int l = i - 1; l >= 0; l--) { if (height[l] > lHeight) lHeight = height[l]; } int h = min(lHeight, rHeight) - height[i]; if (h > 0) sum += h; } return sum;}};",
          "description": "暴力解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) { if (height.size() <= 2) return 0; vector<int> maxLeft(height.size(), 0); vector<int> maxRight(height.size(), 0); int size = maxRight.size(); maxLeft[0] = height[0]; for (int i = 1; i < size; i++) { maxLeft[i] = max(height[i], maxLeft[i - 1]); } maxRight[size - 1] = height[size - 1]; for (int i = size - 2; i >= 0; i--) { maxRight[i] = max(height[i], maxRight[i + 1]); } int sum = 0; for (int i = 0; i < size; i++) { int count = min(maxLeft[i], maxRight[i]) - height[i]; if (count > 0) sum += count; } return sum;}};",
          "description": "双指针优化"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int trap(vector<int>& height) { if (height.size() <= 2) return 0; stack<int> st; st.push(0); int sum = 0; for (int i = 1; i < height.size(); i++) { while (!st.empty() && height[i] > height[st.top()]) { int mid = st.top(); st.pop(); if (!st.empty()) { int h = min(height[st.top()], height[i]) - height[mid]; int w = i - st.top() - 1; sum += h * w; } } st.push(i); } return sum;}};",
          "description": "单调栈解法"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int trap(vector<int>& height) {int sum = 0; for (int i = 0; i < height.size(); i++) {if (i == 0 || i == height.size() - 1) continue; int rHeight = height[i]; int lHeight = height[i]; for (int r = i + 1; r < height.size(); r++) {if (height[r] > rHeight) rHeight = height[r];} for (int l = i - 1; l >= 0; l--) {if (height[l] > lHeight) lHeight = height[l];} int h = min(lHeight, rHeight) - height[i]; if (h > 0) sum += h;} return sum;}};",
      "description": "暴力解法"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int trap(vector<int>& height) {if (height.size() <= 2) return 0; vector<int> maxLeft(height.size(), 0); vector<int> maxRight(height.size(), 0); int size = maxRight.size(); maxLeft[0] = height[0]; for (int i = 1; i < size; i++) {maxLeft[i] = max(height[i], maxLeft[i - 1]);} maxRight[size - 1] = height[size - 1]; for (int i = size - 2; i >= 0; i--) {maxRight[i] = max(height[i], maxRight[i + 1]);} int sum = 0; for (int i = 0; i < size; i++) {int count = min(maxLeft[i], maxRight[i]) - height[i]; if (count > 0) sum += count;} return sum;}};",
      "description": "双指针优化"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: int trap(vector<int>& height) {if (height.size() <= 2) return 0; stack<int> st; st.push(0); int sum = 0; for (int i = 1; i < height.size(); i++) {while (!st.empty() && height[i] > height[st.top()]) {int mid = st.top(); st.pop(); if (!st.empty()) {int h = min(height[st.top()], height[i]) - height[mid]; int w = i - st.top() - 1; sum += h * w;}}} st.push(i);} return sum;}};",
      "description": "单调栈解法"
    },
    {
      "language": "java",
      "code": "class Solution {public int trap(int[] height) {int sum = 0; for (int i = 0; i < height.length; i++) {if (i==0 || i== height.length - 1) continue; int rHeight = height[i]; int lHeight = height[i]; for (int r = i+1; r < height.length; r++) {if (height[r] > rHeight) rHeight = height[r];} for (int l = i-1; l >= 0; l--) {if(height[l] > lHeight) lHeight = height[l];} int h = Math.min(lHeight, rHeight) - height[i]; if (h > 0) sum += h;} return sum;}}",
      "description": "暴力解法"
    },
    {
      "language": "java",
      "code": "class Solution {public int trap(int[] height) {int length = height.length; if (length <= 2) return 0; int[] maxLeft = new int[length]; int[] maxRight = new int[length]; maxLeft[0] = height[0]; for (int i = 1; i< length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]); maxRight[length - 1] = height[length - 1]; for(int i = length - 2; i >= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]); int sum = 0; for (int i = 0; i < length; i++) {int count = Math.min(maxLeft[i], maxRight[i]) - height[i]; if (count > 0) sum += count;} return sum;}}",
      "description": "双指针"
    },
    {
      "language": "java",
      "code": "class Solution {public int trap(int[] height) {if (height.length <= 2) {return 0;} int maxLeft = height[0], maxRight = height[height.length - 1]; int l = 1, r = height.length - 2; int res = 0; while (l <= r) {maxLeft = Math.max(maxLeft, height[l]); maxRight = Math.max(maxRight, height[r]); if (maxLeft < maxRight) {res += maxLeft - height[l ++];} else {res += maxRight - height[r --];}} return res;}}",
      "description": "双指针优化"
    },
    {
      "language": "java",
      "code": "class Solution {public int trap(int[] height){int size = height.length; if (size <= 2) return 0; Stack<Integer> stack = new Stack<Integer>(); stack.push(0); int sum = 0; for (int index = 1; index < size; index++){int stackTop = stack.peek(); if (height[index] < height[stackTop]){stack.push(index);}else if (height[index] == height[stackTop]){stack.pop(); stack.push(index);}else{int heightAtIdx = height[index]; while (!stack.isEmpty() && (heightAtIdx > height[stackTop])){int mid = stack.pop(); if (!stack.isEmpty()){int left = stack.peek(); int h = Math.min(height[left], height[index]) - height[mid]; int w = index - left - 1; int hold = h * w; if (hold > 0) sum += hold; stackTop = stack.peek();}} stack.push(index);}} return sum;}}",
      "description": "单调栈法"
    },
    {
      "language": "python",
      "code": "class Solution: def trap(self, height: List[int]) -> int: res = 0 for i in range(len(height)): if i == 0 or i == len(height)-1: continue lHight = height[i-1] rHight = height[i+1] for j in range(i-1): if height[j] > lHight: lHight = height[j] for k in range(i+2,len(height)): if height[k] > rHight: rHight = height[k] res1 = min(lHight,rHight) - height[i] if res1 > 0: res += res1 return res",
      "description": "暴力解法"
    },
    {
      "language": "python",
      "code": "class Solution: def trap(self, height: List[int]) -> int: leftheight, rightheight = [0]*len(height), [0]*len(height) leftheight[0]=height[0] for i in range(1,len(height)): leftheight[i]=max(leftheight[i-1],height[i]) rightheight[-1]=height[-1] for i in range(len(height)-2,-1,-1): rightheight[i]=max(rightheight[i+1],height[i]) result = 0 for i in range(0,len(height)): summ = min(leftheight[i],rightheight[i])-height[i] result += summ return result",
      "description": "双指针"
    },
    {
      "language": "python",
      "code": "class Solution: def trap(self, height: List[int]) -> int: stack = [0] result = 0 for i in range(1, len(height)): while stack and height[i] > height[stack[-1]]: mid_height = stack.pop() if stack: h = min(height[stack[-1]], height[i]) - height[mid_height] w = i - stack[-1] - 1 result += h * w stack.append(i) return result",
      "description": "单调栈压缩版"
    }
  ],
  "common_mistakes": [
    "在遍历过程中混淆了按行与按列的逻辑。",
    "未能正确更新或维护左侧/右侧最大高度导致错误的结果。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210402091118927.png",
      "description": "这张图片展示了利用单调栈算法解决接雨水问题的过程，蓝色区域表示可以接住的雨水量。",
      "context": "该图片展示了按照行来计算能够接住的雨水量的方法，帮助理解如何通过给定的高度图计算可容纳的雨水总量。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210402091208445.png",
      "description": "这张图片展示了利用单调栈算法解决接雨水问题的示意图，红色箭头指示了雨水存储的位置。",
      "context": "该图片展示了按照列来计算接雨水问题的方法，帮助理解每一列的雨水高度是如何由其左侧和右侧最高柱子中较矮的那个决定的。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210223092732301.png",
      "description": "该图展示了在柱状图中寻找最大矩形面积的算法过程，具体为在列4两侧寻找高度最大的列以确定矩形边界。",
      "context": "该图示例说明了如何通过比较列4左侧和右侧最高柱子的高度来计算列4上可以积聚的雨水量。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210223092629946.png",
      "description": "该图展示了通过数组 `[0,1,0,2,1,0,1,3,2,1,2,1]` 计算接雨水问题的解法，蓝色区域表示可接住的雨水量，共6个单位。",
      "context": "该图展示了如何按照行方向使用单调栈来计算能接住的雨水量，帮助理解通过维护从栈头到栈底递增顺序的柱子高度来识别形成凹槽的位置。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/2021022309321229.png",
      "description": "这张图片展示了使用栈来解决接雨水问题的算法过程，具体为计算柱状图中能接住的雨水量。",
      "context": "该图片展示了通过单调栈方法识别柱状图中凹槽结构的过程，帮助理解为何栈内元素需保持从小到大的顺序。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210223094619398.png",
      "description": "该图展示了使用栈来解决接雨水问题的算法过程，具体为当遇到较矮柱子时，利用右侧柱子计算积水面积。",
      "context": "该图展示了如何处理相同高度柱子的情况以及在计算宽度时使用最右侧柱子的方法，辅助说明了单调栈中更新相同元素下标的过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/2021022309321229-20230310123027977.png",
      "description": "这张图片展示了使用栈来解决接雨水问题的过程，通过栈内元素的高度计算柱子间能接住的雨水量。",
      "context": "该图片展示了当遇到高度大于栈顶元素的柱子时形成的凹槽结构，用以说明如何确定凹槽底部、左侧以及右侧的位置与对应的高度。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210402091118927.png",
      "description": "GIF展示了按照行来计算接雨水量的过程，通过移动指针遍历每一行并累加可接的雨水单位。",
      "context": "该GIF动画展示了按照行来计算可以接住的雨水量的方法，帮助理解在给定高度图下雨水是如何被两侧较高位置“拦住”的。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210402091208445.png",
      "description": "GIF展示了按照列计算时，每一列可接收雨水量的确定过程，通过比较每列左右两侧最高柱子来决定当前列的雨水高度。",
      "context": "GIF动画展示了按照列计算时，如何通过比较每列左右两侧最高柱子来确定该列能接住的雨水量的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210223092732301.png",
      "description": "GIF展示了按照列计算雨水收集量的过程，通过比较每列左右两侧最高柱子来确定该列的雨水高度。",
      "context": "该GIF动画展示了如何通过比较列4左侧和右侧最高柱子的高度来计算列4上能够积聚的雨水量，直观地解释了按照列计算雨水收集量的方法。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210223092629946.png",
      "description": "GIF展示了利用单调栈按行方向计算雨水收集过程，其中通过柱子高度的变化来确定凹槽位置并计算可收集的雨水量。",
      "context": "该GIF动画展示了如何按照行方向利用单调栈来计算接雨水问题中每一行能够接到的雨水量，形象地解释了当新柱子高度大于栈顶元素时形成凹槽的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/2021022309321229.png",
      "description": "GIF展示了使用单调栈算法计算柱状图中雨水收集面积的过程，特别是当新加入的柱子高度大于栈顶元素时形成凹槽并计算该凹槽可收集雨水量的情景。",
      "context": "GIF动画展示了在处理柱状图时，如何通过维护一个从栈头到栈底顺序为从小到大的单调栈来识别形成凹槽的过程，从而帮助理解算法中关键步骤的可视化表示。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210223094619398.png",
      "description": "GIF展示了使用单调栈算法处理柱状图中最大矩形问题的过程，特别强调了当遇到相同高度的柱子时如何更新栈内下标。",
      "context": "GIF动画展示了在处理相同高度柱子时，如何通过更新栈内下标来确保使用最右边的柱子计算宽度的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/2021022309321229-20230310123027977.png",
      "description": "GIF展示了在遍历柱子高度数组时，遇到较高柱子形成凹槽并计算可接水量的过程。",
      "context": "GIF动画展示了当遍历到的柱子高度大于栈顶柱子高度时，如何通过弹出栈顶元素来确定凹槽底部及其左右边界的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\单调栈\\接雨水.txt",
  "extracted_at": "2025-07-21T00:58:49.237026",
  "raw_content": "接雨水\n力扣题目链接(https://leetcode.cn/problems/trapping-rain-water/)\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n示例 1：\n\nimage\n\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n示例 2：\n\n输入：height = [4,2,0,3,2,5]\n输出：9\n\n\n#思路\n接雨水问题在面试中还是常见题目的，有必要好好讲一讲。\n\n本文深度讲解如下三种方法：\n\n暴力解法\n双指针优化\n单调栈\n#暴力解法\n本题暴力解法也是也是使用双指针。\n\n首先要明确，要按照行来计算，还是按照列来计算。\n\n按照行来计算如图： https://file1.kamacoder.com/i/algo/20210402091118927.png\n\n按照列来计算如图： https://file1.kamacoder.com/i/algo/20210402091208445.png\n\n一些同学在实现的时候，很容易一会按照行来计算一会按照列来计算，这样就会越写越乱。\n\n我个人倾向于按照列来计算，比较容易理解，接下来看一下按照列如何计算。\n\n首先，如果按照列来计算的话，宽度一定是1了，我们再把每一列的雨水的高度求出来就可以了。\n\n可以看出每一列雨水的高度，取决于，该列 左侧最高的柱子和右侧最高的柱子中最矮的那个柱子的高度。\n\n这句话可以有点绕，来举一个理解，例如求列4的雨水高度，如图：\n\nhttps://file1.kamacoder.com/i/algo/20210223092732301.png\n\n列4 左侧最高的柱子是列3，高度为2（以下用lHeight表示）。\n\n列4 右侧最高的柱子是列7，高度为3（以下用rHeight表示）。\n\n列4 柱子的高度为1（以下用height表示）\n\n那么列4的雨水高度为 列3和列7的高度最小值减列4高度，即： min(lHeight, rHeight) - height。\n\n列4的雨水高度求出来了，宽度为1，相乘就是列4的雨水体积了。\n\n此时求出了列4的雨水体积。\n\n一样的方法，只要从头遍历一遍所有的列，然后求出每一列雨水的体积，相加之后就是总雨水的体积了。\n\n首先从头遍历所有的列，并且要注意第一个柱子和最后一个柱子不接雨水，代码如下：\n\nfor (int i = 0; i < height.size(); i++) {\n    // 第一个柱子和最后一个柱子不接雨水\n    if (i == 0 || i == height.size() - 1) continue;\n}\n在for循环中求左右两边最高柱子，代码如下：\n\nint rHeight = height[i]; // 记录右边柱子的最高高度\nint lHeight = height[i]; // 记录左边柱子的最高高度\nfor (int r = i + 1; r < height.size(); r++) {\n    if (height[r] > rHeight) rHeight = height[r];\n}\nfor (int l = i - 1; l >= 0; l--) {\n    if (height[l] > lHeight) lHeight = height[l];\n}\n最后，计算该列的雨水高度，代码如下：\n\nint h = min(lHeight, rHeight) - height[i];\nif (h > 0) sum += h; // 注意只有h大于零的时候，在统计到总和中\n整体代码如下：\n\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int sum = 0;\n        for (int i = 0; i < height.size(); i++) {\n            // 第一个柱子和最后一个柱子不接雨水\n            if (i == 0 || i == height.size() - 1) continue;\n\n            int rHeight = height[i]; // 记录右边柱子的最高高度\n            int lHeight = height[i]; // 记录左边柱子的最高高度\n            for (int r = i + 1; r < height.size(); r++) {\n                if (height[r] > rHeight) rHeight = height[r];\n            }\n            for (int l = i - 1; l >= 0; l--) {\n                if (height[l] > lHeight) lHeight = height[l];\n            }\n            int h = min(lHeight, rHeight) - height[i];\n            if (h > 0) sum += h;\n        }\n        return sum;\n    }\n};\n因为每次遍历列的时候，还要向两边寻找最高的列，所以时间复杂度为O(n^2)，空间复杂度为O(1)。\n\n力扣后面修改了后台测试数据，所以以上暴力解法超时了。\n\n#双指针优化\n在暴力解法中，我们可以看到只要记录左边柱子的最高高度 和 右边柱子的最高高度，就可以计算当前位置的雨水面积，这就是通过列来计算。\n\n当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。\n\n为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight），这样就避免了重复计算。\n\n当前位置，左边的最高高度是前一个位置的左边最高高度和本高度的最大值。\n\n即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);\n\n从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);\n\n代码如下：\n\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        if (height.size() <= 2) return 0;\n        vector<int> maxLeft(height.size(), 0);\n        vector<int> maxRight(height.size(), 0);\n        int size = maxRight.size();\n\n        // 记录每个柱子左边柱子最大高度\n        maxLeft[0] = height[0];\n        for (int i = 1; i < size; i++) {\n            maxLeft[i] = max(height[i], maxLeft[i - 1]);\n        }\n        // 记录每个柱子右边柱子最大高度\n        maxRight[size - 1] = height[size - 1];\n        for (int i = size - 2; i >= 0; i--) {\n            maxRight[i] = max(height[i], maxRight[i + 1]);\n        }\n        // 求和\n        int sum = 0;\n        for (int i = 0; i < size; i++) {\n            int count = min(maxLeft[i], maxRight[i]) - height[i];\n            if (count > 0) sum += count;\n        }\n        return sum;\n    }\n};\n#单调栈解法\n关于单调栈的理论基础，单调栈适合解决什么问题，单调栈的工作过程，大家可以先看这题讲解 739. 每日温度 (https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html)。\n\n单调栈就是保持栈内元素有序。和栈与队列：单调队列 (https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html)一样，需要我们自己维持顺序，没有现成的容器可以用。\n\n通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。\n\n而接雨水这道题目，我们正需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。\n\n#准备工作\n那么本题使用单调栈有如下几个问题：\n\n首先单调栈是按照行方向来计算雨水，如图：\nhttps://file1.kamacoder.com/i/algo/20210223092629946.png\n\n知道这一点，后面的就可以理解了。\n\n使用单调栈内元素的顺序\n从大到小还是从小到大呢？\n\n从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。\n\n因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。\n\n如图：\n\nhttps://file1.kamacoder.com/i/algo/2021022309321229.png\n\n关于单调栈的顺序给大家一个总结： 739. 每日温度 (https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html)中求一个元素右边第一个更大元素，单调栈就是递增的，84.柱状图中最大的矩形 (https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html)求一个元素右边第一个更小元素，单调栈就是递减的。\n\n遇到相同高度的柱子怎么办。\n遇到相同的元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。\n\n例如 5 5 1 3 这种情况。如果添加第二个5的时候就应该将第一个5的下标弹出，把第二个5添加到栈中。\n\n因为我们要求宽度的时候 如果遇到相同高度的柱子，需要使用最右边的柱子来计算宽度。\n\n如图所示：\n\nhttps://file1.kamacoder.com/i/algo/20210223094619398.png\n\n栈里要保存什么数值\n使用单调栈，也是通过 长 * 宽 来计算雨水面积的。\n\n长就是通过柱子的高度来计算，宽是通过柱子之间的下标来计算，\n\n那么栈里有没有必要存一个pair<int, int>类型的元素，保存柱子的高度和下标呢。\n\n其实不用，栈里就存放下标就行，想要知道对应的高度，通过height[stack.top()] 就知道弹出的下标对应的高度了。\n\n所以栈的定义如下：\n\nstack<int> st; // 存着下标，计算的时候用下标对应的柱子高度\n明确了如上几点，我们再来看处理逻辑。\n\n#单调栈处理逻辑\n以下操作过程其实和 739. 每日温度 (https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html)也是一样的，建议先做 739. 每日温度 (https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html)。\n\n以下逻辑主要就是三种情况\n\n情况一：当前遍历的元素（柱子）高度小于栈顶元素的高度 height[i] < height[st.top()]\n情况二：当前遍历的元素（柱子）高度等于栈顶元素的高度 height[i] == height[st.top()]\n情况三：当前遍历的元素（柱子）高度大于栈顶元素的高度 height[i] > height[st.top()]\n先将下标0的柱子加入到栈中，st.push(0);。 栈中存放我们遍历过的元素，所以先将下标0加进来。\n\n然后开始从下标1开始遍历所有的柱子，for (int i = 1; i < height.size(); i++)。\n\n如果当前遍历的元素（柱子）高度小于栈顶元素的高度，就把这个元素加入栈中，因为栈里本来就要保持从小到大的顺序（从栈头到栈底）。\n\n代码如下：\n\nif (height[i] < height[st.top()])  st.push(i);\n如果当前遍历的元素（柱子）高度等于栈顶元素的高度，要跟更新栈顶元素，因为遇到相相同高度的柱子，需要使用最右边的柱子来计算宽度。\n\n代码如下：\n\nif (height[i] == height[st.top()]) { // 例如 5 5 1 7 这种情况\n  st.pop();\n  st.push(i);\n}\n如果当前遍历的元素（柱子）高度大于栈顶元素的高度，此时就出现凹槽了，如图所示：\n\nhttps://file1.kamacoder.com/i/algo/2021022309321229-20230310123027977.png\n\n取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为mid，对应的高度为height[mid]（就是图中的高度1）。\n\n此时的栈顶元素st.top()，就是凹槽的左边位置，下标为st.top()，对应的高度为height[st.top()]（就是图中的高度2）。\n\n当前遍历的元素i，就是凹槽右边的位置，下标为i，对应的高度为height[i]（就是图中的高度3）。\n\n此时大家应该可以发现其实就是栈顶和栈顶的下一个元素以及要入栈的元素，三个元素来接水！\n\n那么雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度，代码为：int h = min(height[st.top()], height[i]) - height[mid];\n\n雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度），代码为：int w = i - st.top() - 1 ;\n\n当前凹槽雨水的体积就是：h * w。\n\n求当前凹槽雨水的体积代码如下：\n\nwhile (!st.empty() && height[i] > height[st.top()]) { // 注意这里是while，持续跟新栈顶元素\n    int mid = st.top();\n    st.pop();\n    if (!st.empty()) {\n        int h = min(height[st.top()], height[i]) - height[mid];\n        int w = i - st.top() - 1; // 注意减一，只求中间宽度\n        sum += h * w;\n    }\n}\n关键部分讲完了，整体代码如下：\n\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        if (height.size() <= 2) return 0; // 可以不加\n        stack<int> st; // 存着下标，计算的时候用下标对应的柱子高度\n        st.push(0);\n        int sum = 0;\n        for (int i = 1; i < height.size(); i++) {\n            if (height[i] < height[st.top()]) {     // 情况一\n                st.push(i);\n            } if (height[i] == height[st.top()]) {  // 情况二\n                st.pop(); // 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。\n                st.push(i);\n            } else {                                // 情况三\n                while (!st.empty() && height[i] > height[st.top()]) { // 注意这里是while\n                    int mid = st.top();\n                    st.pop();\n                    if (!st.empty()) {\n                        int h = min(height[st.top()], height[i]) - height[mid];\n                        int w = i - st.top() - 1; // 注意减一，只求中间宽度\n                        sum += h * w;\n                    }\n                }\n                st.push(i);\n            }\n        }\n        return sum;\n    }\n};\n以上代码冗余了一些，但是思路是清晰的，下面我将代码精简一下，如下：\n\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        stack<int> st;\n        st.push(0);\n        int sum = 0;\n        for (int i = 1; i < height.size(); i++) {\n            while (!st.empty() && height[i] > height[st.top()]) {\n                int mid = st.top();\n                st.pop();\n                if (!st.empty()) {\n                    int h = min(height[st.top()], height[i]) - height[mid];\n                    int w = i - st.top() - 1;\n                    sum += h * w;\n                }\n            }\n            st.push(i);\n        }\n        return sum;\n    }\n};\n精简之后的代码，大家就看不出去三种情况的处理了，貌似好像只处理的情况三，其实是把情况一和情况二融合了。 这样的代码不太利于理解。\n\n#其他语言版本\n#Java:\n暴力解法：\n\nclass Solution {\n    public int trap(int[] height) {\n        int sum = 0;\n        for (int i = 0; i < height.length; i++) {\n            // 第一个柱子和最后一个柱子不接雨水\n            if (i==0 || i== height.length - 1) continue;\n\n            int rHeight = height[i]; // 记录右边柱子的最高高度\n            int lHeight = height[i]; // 记录左边柱子的最高高度\n            for (int r = i+1; r < height.length; r++) {\n                if (height[r] > rHeight) rHeight = height[r];\n            }\n            for (int l = i-1; l >= 0; l--) {\n                if(height[l] > lHeight) lHeight = height[l];\n            }\n            int h = Math.min(lHeight, rHeight) - height[i];\n            if (h > 0) sum += h;\n        }\n        return sum;\n\n    }\n}\n双指针：\n\nclass Solution {\n    public int trap(int[] height) {\n        int length = height.length;\n        if (length <= 2) return 0;\n        int[] maxLeft = new int[length];\n        int[] maxRight = new int[length];\n\n        // 记录每个柱子左边柱子最大高度\n        maxLeft[0] = height[0];\n        for (int i = 1; i< length; i++) maxLeft[i] = Math.max(height[i], maxLeft[i-1]);\n\n        // 记录每个柱子右边柱子最大高度\n        maxRight[length - 1] = height[length - 1];\n        for(int i = length - 2; i >= 0; i--) maxRight[i] = Math.max(height[i], maxRight[i+1]);\n\n        // 求和\n        int sum = 0;\n        for (int i = 0; i < length; i++) {\n            int count = Math.min(maxLeft[i], maxRight[i]) - height[i];\n            if (count > 0) sum += count;\n        }\n        return sum;\n    }\n}\n双指针优化\n\nclass Solution {\n    public int trap(int[] height) {\n        if (height.length <= 2) {\n            return 0;\n        }\n        // 从两边向中间寻找最值\n        int maxLeft = height[0], maxRight = height[height.length - 1];\n        int l = 1, r = height.length - 2;\n        int res = 0;\n        while (l <= r) {\n            // 不确定上一轮是左边移动还是右边移动，所以两边都需更新最值\n            maxLeft = Math.max(maxLeft, height[l]);\n            maxRight = Math.max(maxRight, height[r]);\n            // 最值较小的一边所能装的水量已定，所以移动较小的一边。\n            if (maxLeft < maxRight) {\n                res += maxLeft - height[l ++];\n            } else {\n                res += maxRight - height[r --];\n            }\n        }\n        return res;\n    }\n}\n单调栈法\n\nclass Solution {\n    public int trap(int[] height){\n        int size = height.length;\n\n        if (size <= 2) return 0;\n\n        // in the stack, we push the index of array\n        // using height[] to access the real height\n        Stack<Integer> stack = new Stack<Integer>();\n        stack.push(0);\n\n        int sum = 0;\n        for (int index = 1; index < size; index++){\n            int stackTop = stack.peek();\n            if (height[index] < height[stackTop]){\n                stack.push(index);\n            }else if (height[index] == height[stackTop]){\n                // 因为相等的相邻墙，左边一个是不可能存放雨水的，所以pop左边的index, push当前的index\n                stack.pop();\n                stack.push(index);\n            }else{\n                //pop up all lower value\n                int heightAtIdx = height[index];\n                while (!stack.isEmpty() && (heightAtIdx > height[stackTop])){\n                    int mid = stack.pop();\n\n                    if (!stack.isEmpty()){\n                        int left = stack.peek();\n\n                        int h = Math.min(height[left], height[index]) - height[mid];\n                        int w = index - left - 1;\n                        int hold = h * w;\n                        if (hold > 0) sum += hold;\n                        stackTop = stack.peek();\n                    }\n                }\n                stack.push(index);\n            }\n        }\n\n        return sum;\n    }\n}\n#Python:\n暴力解法：\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        res = 0\n        for i in range(len(height)):\n            if i == 0 or i == len(height)-1: continue\n            lHight = height[i-1]\n            rHight = height[i+1]\n            for j in range(i-1):\n                if height[j] > lHight:\n                    lHight = height[j]\n            for k in range(i+2,len(height)):\n                if height[k] > rHight:\n                    rHight = height[k]\n            res1 = min(lHight,rHight) - height[i]\n            if res1 > 0:\n                res += res1\n        return res\n双指针：\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        leftheight, rightheight = [0]*len(height), [0]*len(height)\n\n        leftheight[0]=height[0]\n        for i in range(1,len(height)):\n            leftheight[i]=max(leftheight[i-1],height[i])\n        rightheight[-1]=height[-1]\n        for i in range(len(height)-2,-1,-1):\n            rightheight[i]=max(rightheight[i+1],height[i])\n\n        result = 0\n        for i in range(0,len(height)):\n            summ = min(leftheight[i],rightheight[i])-height[i]\n            result += summ\n        return result\n单调栈\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        # 单调栈\n        '''\n        单调栈是按照 行 的方向来计算雨水\n        从栈顶到栈底的顺序：从小到大\n        通过三个元素来接水：栈顶，栈顶的下一个元素，以及即将入栈的元素\n        雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度\n        雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度）\n        '''\n        # stack储存index，用于计算对应的柱子高度\n        stack = [0]\n        result = 0\n        for i in range(1, len(height)):\n            # 情况一\n            if height[i] < height[stack[-1]]:\n                stack.append(i)\n\n            # 情况二\n            # 当当前柱子高度和栈顶一致时，左边的一个是不可能存放雨水的，所以保留右侧新柱子\n            # 需要使用最右边的柱子来计算宽度\n            elif height[i] == height[stack[-1]]:\n                stack.pop()\n                stack.append(i)\n\n            # 情况三\n            else:\n                # 抛出所有较低的柱子\n                while stack and height[i] > height[stack[-1]]:\n                    # 栈顶就是中间的柱子：储水槽，就是凹槽的地步\n                    mid_height = height[stack[-1]]\n                    stack.pop()\n                    if stack:\n                        right_height = height[i]\n                        left_height = height[stack[-1]]\n                        # 两侧的较矮一方的高度 - 凹槽底部高度\n                        h = min(right_height, left_height) - mid_height\n                        # 凹槽右侧下标 - 凹槽左侧下标 - 1: 只求中间宽度\n                        w = i - stack[-1] - 1\n                        # 体积：高乘宽\n                        result += h * w\n                stack.append(i)\n        return result\n\n# 单调栈压缩版\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        stack = [0]\n        result = 0\n        for i in range(1, len(height)):\n            while stack and height[i] > height[stack[-1]]:\n                mid_height = stack.pop()\n                if stack:\n                    # 雨水高度是 min(凹槽左侧高度, 凹槽右侧高度) - 凹槽底部高度\n                    h = min(height[stack[-1]], height[i]) - height[mid_height]\n                    # 雨水宽度是 凹槽右侧的下标 - 凹槽左侧的下标 - 1\n                    w = i - stack[-1] - 1\n                    # 累计总雨水体积\n                    result += h * w\n            stack.append(i)\n        return result"
}