{
  "id": "AP_53c17fc8",
  "title": "最大子序和",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/maximum-subarray/",
  "description": "一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "Dynamic Programming",
    "Greedy"
  ],
  "data_structure_tags": [
    "Array"
  ],
  "technique_tags": [
    "Memoization",
    "Optimization"
  ],
  "difficulty": null,
  "solution_approach": "使用动态规划来解决最大子序和问题。定义dp[i]为以第i个元素结尾的最大连续子序列和。通过比较当前元素nums[i]加入前一个子序列（dp[i-1]+nums[i]）还是作为新子序列开始(nums[i])来更新dp数组，并在遍历过程中追踪最大值。",
  "key_insights": [
    {
      "content": "每次迭代中，都需要决定是将当前元素添加到现有子序列中，还是从当前元素开始一个新的子序列。这确保了最终得到的是最大可能的子序列和。"
    },
    {
      "content": "dp[i] = max(dp[i - 1] + nums[i], nums[i]) 的设定使得算法能够有效地利用之前计算的结果，同时保证了局部最优解向全局最优解推进。"
    },
    {
      "content": "尽管可以使用贪心算法求解此题，但动态规划提供了一个更直观的方法来理解问题并构建解决方案。"
    },
    {
      "content": "注意到最后返回的结果是所有dp[i]中的最大值，而不是最后一个dp[nums.size() - 1]。这是因为最大子序列可能并不一定包含最后一个元素。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "这道题之前我们在讲解贪心专题的时候用贪心算法解决过一次，贪心算法：最大子序和 (https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html)。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxSubArray(vector<int>& nums) { if (nums.size() == 0) return 0; vector<int> dp(nums.size()); dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i < nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); if (dp[i] > result) result = dp[i]; } return result; }};",
          "description": "C++实现的最大子序和"
        },
        {
          "language": "java",
          "code": "public static int maxSubArray(int[] nums) { if (nums.length == 0) { return 0; } int res = nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; for (int i = 1; i < nums.length; i++) { dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); res = res > dp[i] ? res : dp[i]; } return res;}",
          "description": "Java实现的最大子序和"
        },
        {
          "language": "java",
          "code": "public int maxSubArray(int[] nums) { int res = nums[0]; int pre = nums[0]; for(int i = 1; i < nums.length; i++) { pre = Math.max(pre + nums[i], nums[i]); res = Math.max(res, pre); } return res;}",
          "description": "优化后的Java版本最大子序和"
        },
        {
          "language": "python",
          "code": "class Solution: def maxSubArray(self, nums: List[int]) -> int: dp = [0] * len(nums) dp[0] = nums[0] result = dp[0] for i in range(1, len(nums)): dp[i] = max(dp[i-1] + nums[i], nums[i]) result = max(result, dp[i]) return result",
          "description": "Python实现的最大子序和"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "这道题目用贪心也很巧妙，但有一点绕，需要仔细想一想，如果想回顾一下贪心就看这里吧：贪心算法：最大子序和(https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html)",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxSubArray(vector<int>& nums) { if (nums.size() == 0) return 0; vector<int> dp(nums.size()); dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i < nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); if (dp[i] > result) result = dp[i]; } return result; }};",
          "description": "C++实现的动态规划解法，用于寻找数组中具有最大和的连续子数组。"
        },
        {
          "language": "java",
          "code": "public static int maxSubArray(int[] nums) { if (nums.length == 0) { return 0; } int res = nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; for (int i = 1; i < nums.length; i++) { dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); res = res > dp[i] ? res : dp[i]; } return res;}",
          "description": "Java实现的动态规划解法，用于寻找数组中具有最大和的连续子数组。"
        },
        {
          "language": "java",
          "code": "public int maxSubArray(int[] nums) { int res = nums[0]; int pre = nums[0]; for(int i = 1; i < nums.length; i++) { pre = Math.max(pre + nums[i], nums[i]); res = Math.max(res, pre); } return res;}",
          "description": "改进后的Java实现，使用单个变量替代dp数组以减少空间复杂度。"
        },
        {
          "language": "python",
          "code": "class Solution: def maxSubArray(self, nums: List[int]) -> int: dp = [0] * len(nums) dp[0] = nums[0] result = dp[0] for i in range(1, len(nums)): dp[i] = max(dp[i-1] + nums[i], nums[i]) result = max(result, dp[i]) return result",
          "description": "Python实现的动态规划解法，用于寻找数组中具有最大和的连续子数组。"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java:",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "public static int maxSubArray(int[] nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n\n    int res = nums[0];\n    int[] dp = new int[nums.length];\n    dp[0] = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);\n        res = res > dp[i] ? res : dp[i];\n    }\n    return res;\n}",
          "description": "Java版本的动态规划解法"
        },
        {
          "language": "java",
          "code": "public int maxSubArray(int[] nums) {\n    int res = nums[0];\n    int pre = nums[0];\n    for(int i = 1; i < nums.length; i++) {\n        pre = Math.max(pre + nums[i], nums[i]);\n        res = Math.max(res, pre);\n    }\n    return res;\n}",
          "description": "Java版本使用单个变量代替dp数组以节省空间"
        },
        {
          "language": "python",
          "code": "def maxSubArray(self, nums: List[int]) -> int:\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    result = dp[0]\n    for i in range(1, len(nums)):\n        dp[i] = max(dp[i-1] + nums[i], nums[i])\n        result = max(result, dp[i])\n    return result",
          "description": "Python版本的动态规划解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java:",
      "text": "/**",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxSubArray(vector<int>& nums) { if (nums.size() == 0) return 0; vector<int> dp(nums.size()); dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i < nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); if (dp[i] > result) result = dp[i]; } return result; }};",
          "description": "C++实现最大子序和问题的动态规划解法"
        },
        {
          "language": "java",
          "code": "public static int maxSubArray(int[] nums) { if (nums.length == 0) { return 0; } int res = nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; for (int i = 1; i < nums.length; i++) { dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); res = res > dp[i] ? res : dp[i]; } return res;}",
          "description": "Java实现最大子序和问题的动态规划解法，使用了数组存储中间结果"
        },
        {
          "language": "java",
          "code": "public int maxSubArray(int[] nums) { int res = nums[0]; int pre = nums[0]; for(int i = 1; i < nums.length; i++) { pre = Math.max(pre + nums[i], nums[i]); res = Math.max(res, pre); } return res;}",
          "description": "优化后的Java实现，空间复杂度为O(1)"
        },
        {
          "language": "python",
          "code": "class Solution: def maxSubArray(self, nums: List[int]) -> int: dp = [0] * len(nums) dp[0] = nums[0] result = dp[0] for i in range(1, len(nums)): dp[i] = max(dp[i-1] + nums[i], nums[i]) result = max(result, dp[i]) return result",
          "description": "Python实现最大子序和问题的动态规划解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "class Solution:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxSubArray(vector<int>& nums) { if (nums.size() == 0) return 0; vector<int> dp(nums.size()); dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i < nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); if (dp[i] > result) result = dp[i]; } return result; }};",
          "description": "C++实现的动态规划求解最大子序和问题"
        },
        {
          "language": "java",
          "code": "public static int maxSubArray(int[] nums) { if (nums.length == 0) { return 0; } int res = nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; for (int i = 1; i < nums.length; i++) { dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); res = res > dp[i] ? res : dp[i]; } return res;}",
          "description": "Java实现的动态规划求解最大子序和问题，使用数组存储中间状态"
        },
        {
          "language": "java",
          "code": "public int maxSubArray(int[] nums) { int res = nums[0]; int pre = nums[0]; for(int i = 1; i < nums.length; i++) { pre = Math.max(pre + nums[i], nums[i]); res = Math.max(res, pre); } return res;}",
          "description": "Java实现的优化空间复杂度版本的最大子序和问题"
        },
        {
          "language": "python",
          "code": "class Solution: def maxSubArray(self, nums: List[int]) -> int: dp = [0] * len(nums) dp[0] = nums[0] result = dp[0] for i in range(1, len(nums)): dp[i] = max(dp[i-1] + nums[i], nums[i]) result = max(result, dp[i]) return result",
          "description": "Python实现的动态规划求解最大子序和问题"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n)",
    "space_complexity": "O(n)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int maxSubArray(vector<int>& nums) { if (nums.size() == 0) return 0; vector<int> dp(nums.size()); dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i < nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); if (dp[i] > result) result = dp[i]; } return result; }};",
      "description": "使用动态规划解决最大子序和问题的C++实现"
    },
    {
      "language": "java",
      "code": "public static int maxSubArray(int[] nums) { if (nums.length == 0) { return 0; } int res = nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; for (int i = 1; i < nums.length; i++) { dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); res = res > dp[i] ? res : dp[i]; } return res;}",
      "description": "使用动态规划解决最大子序和问题的Java实现"
    },
    {
      "language": "java",
      "code": "public int maxSubArray(int[] nums) { int res = nums[0]; int pre = nums[0]; for(int i = 1; i < nums.length; i++) { pre = Math.max(pre + nums[i], nums[i]); res = Math.max(res, pre); } return res;}",
      "description": "空间优化后的Java实现，用于解决最大子序和问题"
    },
    {
      "language": "python",
      "code": "class Solution: def maxSubArray(self, nums: List[int]) -> int: dp = [0] * len(nums) dp[0] = nums[0] result = dp[0] for i in range(1, len(nums)): dp[i] = max(dp[i-1] + nums[i], nums[i]) result = max(result, dp[i]) return result",
      "description": "使用动态规划解决最大子序和问题的Python实现"
    }
  ],
  "common_mistakes": [
    "忽略初始化条件，特别是对于dp[0]的设置。",
    "没有正确处理边界情况如空数组。",
    "误认为最后的结果一定是dp[nums.size() - 1]，而实际上应该是在所有dp[i]中选取最大值。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210303104129101.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20210303104129101.png",
      "context": "该图片展示了使用动态规划方法解决最大子序和问题时，对于给定数组[-2,1,-3,4,-1,2,1,-5,4]，对应dp数组状态的变化过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210303104129101.png",
      "description": "GIF展示了动态规划求解最大子序列和过程中dp数组的变化。",
      "context": "GIF动画展示了如何通过动态规划方法逐步计算数组[-2,1,-3,4,-1,2,1,-5,4]中每个位置的最大连续子序列和，直至找到整个数组的最大子序和。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\最大子序和.txt",
  "extracted_at": "2025-07-20T20:49:13.373657",
  "raw_content": "最大子序和\n力扣题目链接(https://leetcode.cn/problems/maximum-subarray/)\n\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n示例:\n\n输入: [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n\n#思路\n这道题之前我们在讲解贪心专题的时候用贪心算法解决过一次，贪心算法：最大子序和 (https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html)。\n\n这次我们用动态规划的思路再来分析一次。\n\n动规五部曲如下：\n\n确定dp数组（dp table）以及下标的含义\ndp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。\n\n确定递推公式\ndp[i]只有两个方向可以推出来：\n\ndp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和\nnums[i]，即：从头开始计算当前连续子序列和\n一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i]);\n\ndp数组如何初始化\n从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。\n\ndp[0]应该是多少呢?\n\n根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] = nums[0]。\n\n确定遍历顺序\n递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。\n\n举例推导dp数组\n以示例一为例，输入：nums = [-2,1,-3,4,-1,2,1,-5,4]，对应的dp状态如下： 53.最大子序和（动态规划）\nhttps://file1.kamacoder.com/i/algo/20210303104129101.png\n\n注意最后的结果可不是dp[nums.size() - 1]！ ，而是dp[6]。\n\n在回顾一下dp[i]的定义：包括下标i之前的最大连续子序列和为dp[i]。\n\n那么我们要找最大的连续子序列，就应该找每一个i为终点的连续最大子序列。\n\n所以在递推公式的时候，可以直接选出最大的dp[i]。\n\n以上动规五部曲分析完毕，完整代码如下：\n\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        if (nums.size() == 0) return 0;\n        vector<int> dp(nums.size());\n        dp[0] = nums[0];\n        int result = dp[0];\n        for (int i = 1; i < nums.size(); i++) {\n            dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移公式\n            if (dp[i] > result) result = dp[i]; // result 保存dp[i]的最大值\n        }\n        return result;\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(n)\n#总结\n这道题目用贪心也很巧妙，但有一点绕，需要仔细想一想，如果想回顾一下贪心就看这里吧：贪心算法：最大子序和(https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html)\n\n动规的解法还是很直接的。\n\n#其他语言版本\n#Java:\n   /**\n     * 1.dp[i]代表当前下标对应的最大值\n     * 2.递推公式 dp[i] = max (dp[i-1]+nums[i],nums[i]) res = max(res,dp[i])\n     * 3.初始化 都为 0\n     * 4.遍历方向，从前往后\n     * 5.举例推导结果。。。\n     *\n     * @param nums\n     * @return\n     */\n    public static int maxSubArray(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n\n        int res = nums[0];\n        int[] dp = new int[nums.length];\n        dp[0] = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);\n            res = res > dp[i] ? res : dp[i];\n        }\n        return res;\n    }\n//因为dp[i]的递推公式只与前一个值有关，所以可以用一个变量代替dp数组，空间复杂度为O(1)\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int res = nums[0];\n        int pre = nums[0];\n        for(int i = 1; i < nums.length; i++) {\n            pre = Math.max(pre + nums[i], nums[i]);\n            res = Math.max(res, pre);\n        }\n        return res;\n    }\n}\n#Python：\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        result = dp[0]\n        for i in range(1, len(nums)):\n            dp[i] = max(dp[i-1] + nums[i], nums[i]) #状态转移公式\n            result = max(result, dp[i]) #result 保存dp[i]的最大值\n        return result"
}