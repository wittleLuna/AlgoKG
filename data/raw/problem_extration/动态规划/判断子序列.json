{
  "id": "AP_f27c162b",
  "title": "判断子序列",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/is-subsequence/",
  "description": "字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划",
    "编辑距离"
  ],
  "data_structure_tags": [
    "数组",
    "二维数组"
  ],
  "technique_tags": [
    "双指针（可选）",
    "状态转移"
  ],
  "difficulty": null,
  "solution_approach": "使用动态规划方法解决判断子序列问题。通过构建一个二维dp数组来记录两个字符串间最长匹配子序列长度，并以此来判断s是否为t的子序列。",
  "key_insights": [
    {
      "content": "dp[i][j] 表示以i-1为结尾的s和以j-1为结尾的t之间相同子序列的最大长度。这种定义方式便于初始化以及后续递推公式的应用。"
    },
    {
      "content": "当s[i-1]==t[j-1]时，dp[i][j]=dp[i-1][j-1]+1；否则，dp[i][j]=dp[i][j-1]。这反映了在匹配过程中遇到相等字符时增加计数，不相等则保持当前最大匹配长度不变的原则。"
    },
    {
      "content": "通过对dp数组的初始化及遍历顺序的设计，可以简化问题处理过程并保证正确性。"
    },
    {
      "content": "最终结果取决于dp[s.size()][t.size()]是否等于s的长度，如果相等则说明s是t的一个子序列。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "（这道题也可以用双指针的思路来实现，时间复杂度也是O(n)）",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSubsequence(string s, string t) {vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0)); for (int i = 1; i <= s.size(); i++) {for (int j = 1; j <= t.size(); j++) {if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = dp[i][j - 1];}} if (dp[s.size()][t.size()] == s.size()) return true; return false;}};",
          "description": "使用动态规划判断字符串s是否为t的子序列"
        },
        {
          "language": "java",
          "code": "class Solution { public boolean isSubsequence(String s, String t) { int length1 = s.length(); int length2 = t.length(); int[][] dp = new int[length1+1][length2+1]; for(int i = 1; i <= length1; i++){ for(int j = 1; j <= length2; j++){ if(s.charAt(i-1) == t.charAt(j-1)){ dp[i][j] = dp[i-1][j-1] + 1; }else{ dp[i][j] = dp[i][j-1]; } } } if(dp[length1][length2] == length1){ return true; }else{ return false; } }}",
          "description": "Java实现，使用动态规划判断字符串s是否为t的子序列"
        },
        {
          "language": "java",
          "code": "class Solution { public boolean isSubsequence(String s, String t) { int[][] dp = new int[t.length() + 1][s.length() + 1]; for (int i = 1; i < dp.length; i++) { for (int j = 1; j < dp[i].length; j++) { if (t.charAt(i - 1) == s.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = dp[i - 1][j]; } } System.out.println(Arrays.toString(dp[i])); } return dp[t.length()][s.length()] == s.length(); }}",
          "description": "Java版本，修改遍历顺序后利用滚动数组压缩DP表"
        },
        {
          "language": "java",
          "code": "class Solution { public boolean isSubsequence(String s, String t) { int[] dp = new int[s.length() + 1]; for (int i = 0; i < t.length(); i ++) { for (int j = dp.length - 1; j > 0; j --) { if (t.charAt(i) == s.charAt(j - 1)) { dp[j] = dp[j - 1] + 1; } } } return dp[s.length()] == s.length(); }}",
          "description": "进一步状态压缩的Java实现"
        },
        {
          "language": "java",
          "code": "class Solution { public boolean isSubsequence(String s, String t) { boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for (int i = 0; i < t.length(); i ++) { for (int j = dp.length - 1; j > 0; j --) { if (t.charAt(i) == s.charAt(j - 1)) { dp[j] = dp[j - 1]; } } } return dp[dp.length - 1]; }}",
          "description": "直接使用布尔类型表示子序列关系的Java实现"
        },
        {
          "language": "python",
          "code": "class Solution: def isSubsequence(self, s: str, t: str) -> bool: dp = [[0] * (len(t)+1) for _ in range(len(s)+1)] for i in range(1, len(s)+1): for j in range(1, len(t)+1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = dp[i][j-1] if dp[-1][-1] == len(s): return True return False",
          "description": "Python版本，采用动态规划方法来判断s是否为t的一个子序列"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "这道题目算是编辑距离的入门题目（毕竟这里只是涉及到减法），也是动态规划解决的经典题型。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSubsequence(string s, string t) {vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0)); for (int i = 1; i <= s.size(); i++) {for (int j = 1; j <= t.size(); j++) {if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = dp[i][j - 1];}} if (dp[s.size()][t.size()] == s.size()) return true; return false;}};",
          "description": "C++版本的解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public boolean isSubsequence(String s, String t) {int length1 = s.length(); int length2 = t.length(); int[][] dp = new int[length1+1][length2+1]; for(int i = 1; i <= length1; i++){for(int j = 1; j <= length2; j++){if(s.charAt(i-1) == t.charAt(j-1)){dp[i][j] = dp[i-1][j-1] + 1;}else{dp[i][j] = dp[i][j-1];}}} if(dp[length1][length2] == length1){return true;}else{return false;}}}",
          "description": "Java版本的解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public boolean isSubsequence(String s, String t) {int[][] dp = new int[t.length() + 1][s.length() + 1]; for (int i = 1; i < dp.length; i++) {for (int j = 1; j < dp[i].length; j++) {if (t.charAt(i - 1) == s.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1] + 1;} else {dp[i][j] = dp[i - 1][j];}}} return dp[t.length()][s.length()] == s.length();}}",
          "description": "修改遍历顺序并压缩dp数组的Java版本"
        },
        {
          "language": "java",
          "code": "class Solution {public boolean isSubsequence(String s, String t) {int[] dp = new int[s.length() + 1]; for (int i = 0; i < t.length(); i ++) {for (int j = dp.length - 1; j > 0; j --) {if (t.charAt(i) == s.charAt(j - 1)) {dp[j] = dp[j - 1] + 1;}}}} return dp[s.length()] == s.length();}}",
          "description": "使用状态压缩技术的Java版本"
        },
        {
          "language": "java",
          "code": "class Solution {public boolean isSubsequence(String s, String t) {boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for (int i = 0; i < t.length(); i ++) {for (int j = dp.length - 1; j > 0; j --) {if (t.charAt(i) == s.charAt(j - 1)) {dp[j] = dp[j - 1];}}}} return dp[dp.length - 1];}}",
          "description": "将dp定义为布尔类型的Java版本"
        },
        {
          "language": "python",
          "code": "class Solution: def isSubsequence(self, s: str, t: str) -> bool: dp = [[0] * (len(t)+1) for _ in range(len(s)+1)] for i in range(1, len(s)+1): for j in range(1, len(t)+1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = dp[i][j-1] if dp[-1][-1] == len(s): return True return False",
          "description": "Python版本的解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java:",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        int length1 = s.length(); int length2 = t.length();\n        int[][] dp = new int[length1+1][length2+1];\n        for(int i = 1; i <= length1; i++){\n            for(int j = 1; j <= length2; j++){\n                if(s.charAt(i-1) == t.charAt(j-1)){\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                }else{\n                    dp[i][j] = dp[i][j-1];\n                }\n            }\n        }\n        if(dp[length1][length2] == length1){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}",
          "description": "使用动态规划判断s是否为t的子序列"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        int[][] dp = new int[t.length() + 1][s.length() + 1];\n        for (int i = 1; i < dp.length; i++) {\n            for (int j = 1; j < dp[i].length; j++) {\n                if (t.charAt(i - 1) == s.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[t.length()][s.length()] == s.length();\n    }\n}",
          "description": "通过修改遍历顺序利用滚动数组压缩dp数组，判断s是否为t的子序列"
        },
        {
          "language": "java",
          "code": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        int[] dp = new int[s.length() + 1];\n        for (int i = 0; i < t.length(); i++) {\n            for (int j = dp.length - 1; j > 0; j--) {\n                if (t.charAt(i) == s.charAt(j - 1)) {\n                    dp[j] = dp[j - 1] + 1;\n                }\n            }\n        }\n        return dp[s.length()] == s.length();\n    }\n}",
          "description": "状态压缩后的版本，减少空间复杂度来判断s是否为t的子序列"
        },
        {
          "language": "java",
          "code": "class Solution { \n    public boolean isSubsequence(String s, String t) {\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        for (int i = 0; i < t.length(); i++) {\n            for (int j = dp.length - 1; j > 0; j--) {\n                if (t.charAt(i) == s.charAt(j - 1)) {\n                    dp[j] = dp[j - 1];\n                }\n            }\n        }\n        return dp[dp.length - 1];\n    }\n}",
          "description": "将dp定义为布尔类型，直接表示s的前缀是否为t的子序列"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]\n        for i in range(1, len(s)+1):\n            for j in range(1, len(t)+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = dp[i][j-1]\n        if dp[-1][-1] == len(s):\n            return True\n        return False",
          "description": "Python版本的动态规划解法，用于判断s是否为t的子序列"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java:",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSubsequence(string s, string t) {vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0)); for (int i = 1; i <= s.size(); i++) {for (int j = 1; j <= t.size(); j++) {if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = dp[i][j - 1];}} if (dp[s.size()][t.size()] == s.size()) return true; return false;}};",
          "description": "使用动态规划判断s是否为t的子序列"
        },
        {
          "language": "java",
          "code": "class Solution {public boolean isSubsequence(String s, String t) {int length1 = s.length(); int length2 = t.length(); int[][] dp = new int[length1+1][length2+1]; for(int i = 1; i <= length1; i++){for(int j = 1; j <= length2; j++){if(s.charAt(i-1) == t.charAt(j-1)){dp[i][j] = dp[i-1][j-1] + 1;}else{dp[i][j] = dp[i][j-1];}}} if(dp[length1][length2] == length1){return true;}else{return false;}}}",
          "description": "Java实现，使用动态规划判断s是否为t的子序列"
        },
        {
          "language": "java",
          "code": "class Solution {public boolean isSubsequence(String s, String t) {int[][] dp = new int[t.length() + 1][s.length() + 1]; for (int i = 1; i < dp.length; i++) {for (int j = 1; j < dp[i].length; j++) {if (t.charAt(i - 1) == s.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1] + 1;} else {dp[i][j] = dp[i - 1][j];}}} return dp[t.length()][s.length()] == s.length();}}",
          "description": "修改遍历顺序后，利用滚动数组压缩DP表"
        },
        {
          "language": "java",
          "code": "class Solution {public boolean isSubsequence(String s, String t) {int[] dp = new int[s.length() + 1]; for (int i = 0; i < t.length(); i ++) {for (int j = dp.length - 1; j > 0; j --) {if (t.charAt(i) == s.charAt(j - 1)) {dp[j] = dp[j - 1] + 1;}}}} return dp[s.length()] == s.length();}}",
          "description": "状态压缩后的Java实现"
        },
        {
          "language": "java",
          "code": "class Solution {public boolean isSubsequence(String s, String t) {boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for (int i = 0; i < t.length(); i ++) {for (int j = dp.length - 1; j > 0; j --) {if (t.charAt(i) == s.charAt(j - 1)) {dp[j] = dp[j - 1];}}}} return dp[dp.length - 1];}}",
          "description": "将dp定义为boolean类型的Java实现"
        },
        {
          "language": "python",
          "code": "class Solution: def isSubsequence(self, s: str, t: str) -> bool: dp = [[0] * (len(t)+1) for _ in range(len(s)+1)] for i in range(1, len(s)+1): for j in range(1, len(t)+1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = dp[i][j-1] if dp[-1][-1] == len(s): return True return False",
          "description": "Python版本的动态规划解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "class Solution:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: bool isSubsequence(string s, string t) {vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0)); for (int i = 1; i <= s.size(); i++) {for (int j = 1; j <= t.size(); j++) {if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = dp[i][j - 1];}} if (dp[s.size()][t.size()] == s.size()) return true; return false;}};",
          "description": "C++版本的解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public boolean isSubsequence(String s, String t) {int length1 = s.length(); int length2 = t.length(); int[][] dp = new int[length1+1][length2+1]; for(int i = 1; i <= length1; i++){for(int j = 1; j <= length2; j++){if(s.charAt(i-1) == t.charAt(j-1)){dp[i][j] = dp[i-1][j-1] + 1;}else{dp[i][j] = dp[i][j-1];}}} if(dp[length1][length2] == length1){return true;}else{return false;}}}",
          "description": "Java版本的解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public boolean isSubsequence(String s, String t) {int[][] dp = new int[t.length() + 1][s.length() + 1]; for (int i = 1; i < dp.length; i++) {for (int j = 1; j < dp[i].length; j++) {if (t.charAt(i - 1) == s.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1] + 1;} else {dp[i][j] = dp[i - 1][j];}}} return dp[t.length()][s.length()] == s.length();}}",
          "description": "修改遍历顺序后的Java版本解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public boolean isSubsequence(String s, String t) {int[] dp = new int[s.length() + 1]; for (int i = 0; i < t.length(); i ++) {for (int j = dp.length - 1; j > 0; j --) {if (t.charAt(i) == s.charAt(j - 1)) {dp[j] = dp[j - 1] + 1;}}}} return dp[s.length()] == s.length();}",
          "description": "状态压缩后的Java版本解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public boolean isSubsequence(String s, String t) {boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for (int i = 0; i < t.length(); i ++) {for (int j = dp.length - 1; j > 0; j --) {if (t.charAt(i) == s.charAt(j - 1)) {dp[j] = dp[j - 1];}}}} return dp[dp.length - 1];}",
          "description": "布尔类型DP数组的Java版本解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def isSubsequence(self, s: str, t: str) -> bool: dp = [[0] * (len(t)+1) for _ in range(len(s)+1)] for i in range(1, len(s)+1): for j in range(1, len(t)+1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = dp[i][j-1] if dp[-1][-1] == len(s): return True return False",
          "description": "Python版本的解决方案"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n × m)",
    "space_complexity": "O(n × m)",
    "explanation": "因为从题意中我们也可以发现，只需要计算删除的情况，不用考虑增加和替换的情况。"
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: bool isSubsequence(string s, string t) {vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0)); for (int i = 1; i <= s.size(); i++) {for (int j = 1; j <= t.size(); j++) {if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = dp[i][j - 1];}} if (dp[s.size()][t.size()] == s.size()) return true; return false;}};",
      "description": "使用动态规划判断一个字符串是否为另一个字符串的子序列"
    },
    {
      "language": "java",
      "code": "class Solution {public boolean isSubsequence(String s, String t) {int length1 = s.length(); int length2 = t.length(); int[][] dp = new int[length1+1][length2+1]; for(int i = 1; i <= length1; i++){for(int j = 1; j <= length2; j++){if(s.charAt(i-1) == t.charAt(j-1)){dp[i][j] = dp[i-1][j-1] + 1;}else{dp[i][j] = dp[i][j-1];}}} if(dp[length1][length2] == length1){return true;}else{return false;}}}",
      "description": "Java实现，使用动态规划方法来判断子序列"
    },
    {
      "language": "java",
      "code": "class Solution {public boolean isSubsequence(String s, String t) {int[][] dp = new int[t.length() + 1][s.length() + 1]; for (int i = 1; i < dp.length; i++) {for (int j = 1; j < dp[i].length; j++) {if (t.charAt(i - 1) == s.charAt(j - 1)) {dp[i][j] = dp[i - 1][j - 1] + 1;} else {dp[i][j] = dp[i - 1][j];}}} return dp[t.length()][s.length()] == s.length();}}",
      "description": "通过修改遍历顺序并利用滚动数组压缩空间复杂度"
    },
    {
      "language": "java",
      "code": "class Solution {public boolean isSubsequence(String s, String t) {int[] dp = new int[s.length() + 1]; for (int i = 0; i < t.length(); i ++) {for (int j = dp.length - 1; j > 0; j --) {if (t.charAt(i) == s.charAt(j - 1)) {dp[j] = dp[j - 1] + 1;}}}} return dp[s.length()] == s.length();}}",
      "description": "进一步优化存储空间至一维数组"
    },
    {
      "language": "java",
      "code": "class Solution {public boolean isSubsequence(String s, String t) {boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for (int i = 0; i < t.length(); i ++) {for (int j = dp.length - 1; j > 0; j --) {if (t.charAt(i) == s.charAt(j - 1)) {dp[j] = dp[j - 1];}}}} return dp[dp.length - 1];}}",
      "description": "将dp数组定义为布尔类型以简化逻辑"
    },
    {
      "language": "python",
      "code": "class Solution: def isSubsequence(self, s: str, t: str) -> bool: dp = [[0] * (len(t)+1) for _ in range(len(s)+1)] for i in range(1, len(s)+1): for j in range(1, len(t)+1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = dp[i][j-1] if dp[-1][-1] == len(s): return True return False",
      "description": "Python版本，同样采用动态规划方式"
    }
  ],
  "common_mistakes": [
    "忽视了dp数组边界条件的正确设置，如dp[0][0]及第一行/列的值应该初始化为0。",
    "混淆了dp[i][j]所表示的具体含义，可能导致递推关系理解错误。",
    "没有注意到最终结果需要比较dp[s.size()][t.size()]与s的实际长度以确认s是否完全作为t的一个子序列存在。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210303173115966.png",
      "description": "这张图片展示了使用动态规划算法解决子序列匹配问题的过程，具体为字符串 \"abc\" 在 \"ahbgdc\" 中的匹配情况。",
      "context": "该图展示了如何通过定义dp[i][j]来表示以下标i-1为结尾的字符串s与以下标j-1为结尾的字符串t之间的最长相同子序列长度，从而简化初始化过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210303172354155.jpg",
      "description": "这张图片展示了动态规划（DP）表格中状态转移的方向，箭头指示了从 `dp[i-1][j-1]`、`dp[i-1][j]` 和 `dp[i][j-1]` 到 `dp[i][j]` 的更新路径。",
      "context": "该图展示了动态规划数组dp的初始化设置及遍历顺序，帮助理解如何通过比较字符串s和t来计算最长公共子序列长度。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/2021030317364166.jpg",
      "description": "这张图片展示了使用动态规划算法解决子序列匹配问题的过程，具体为字符串 \"ahbgdc\" 和 \"abc\" 的最长公共子序列长度计算。",
      "context": "该图展示了当输入为s=\"abc\", t=\"ahbgdc\"时，根据动态规划方法计算得到的dp数组状态转移过程，用以说明如何通过比较dp[s.size()][t.size()]与字符串s长度来判断s是否为t的子序列。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210303173115966.png",
      "description": "GIF展示了动态规划算法中dp数组的填充过程，按照从上到下、从左到右的顺序进行。",
      "context": "GIF动画展示了如何通过初始化dp[0][0]和dp[i][0]来构建二维矩阵，以便于解决字符串最长公共子序列问题。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210303172354155.jpg",
      "description": "GIF展示了动态规划算法中dp数组填充的过程，逐步计算字符串s是否为t的子序列。",
      "context": "该GIF动画展示了如何通过动态规划方法填充二维数组dp来解决最长公共子序列问题的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/2021030317364166.jpg",
      "description": "GIF展示了通过动态规划方法计算字符串s是否为t的子序列的过程，逐步填充dp数组直至完成状态转移。",
      "context": "该GIF动画展示了如何通过动态规划方法逐步填充dp数组来判断字符串s是否为t的子序列的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\判断子序列.txt",
  "extracted_at": "2025-07-20T16:55:50.125327",
  "raw_content": "判断子序列\n力扣题目链接(https://leetcode.cn/problems/is-subsequence/)\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。\n\n示例 1：\n\n输入：s = \"abc\", t = \"ahbgdc\"\n输出：true\n示例 2：\n\n输入：s = \"axc\", t = \"ahbgdc\"\n输出：false\n提示：\n\n0 <= s.length <= 100\n0 <= t.length <= 10^4\n两个字符串都只由小写字符组成。\n\n\n\n#思路\n（这道题也可以用双指针的思路来实现，时间复杂度也是O(n)）\n\n这道题应该算是编辑距离的入门题目，因为从题意中我们也可以发现，只需要计算删除的情况，不用考虑增加和替换的情况。\n\n所以掌握本题的动态规划解法是对后面要讲解的编辑距离的题目打下基础。\n\n动态规划五部曲分析如下：\n\n确定dp数组（dp table）以及下标的含义\ndp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。\n\n注意这里是判断s是否为t的子序列。即t的长度是大于等于s的。\n\n有同学问了，为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？\n\n为什么这么定义我在 718. 最长重复子数组 (https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html)中做了详细的讲解。\n\n其实用i来表示也可以！\n\n但我统一以下标i-1为结尾的字符串来计算，这样在下面的递归公式中会容易理解一些，如果还有疑惑，可以继续往下看。\n\n确定递推公式\n在确定递推公式的时候，首先要考虑如下两种操作，整理如下：\n\nif (s[i - 1] == t[j - 1])\nt中找到了一个字符在s中也出现了\nif (s[i - 1] != t[j - 1])\n相当于t要删除元素，继续匹配\nif (s[i - 1] == t[j - 1])，那么dp[i][j] = dp[i - 1][j - 1] + 1;，因为找到了一个相同的字符，相同子序列长度自然要在dp[i-1][j-1]的基础上加1（如果不理解，在回看一下dp[i][j]的定义）\n\nif (s[i - 1] != t[j - 1])，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i][j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i][j] = dp[i][j - 1];\n\n其实这里 大家可以发现和 1143.最长公共子序列 (https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html)的递推公式基本那就是一样的，区别就是 本题 如果删元素一定是字符串t，而 1143.最长公共子序列 是两个字符串都可以删元素。\n\ndp数组如何初始化\n从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，所以dp[0][0]和dp[i][0]是一定要初始化的。\n\n这里大家已经可以发现，在定义dp[i][j]含义的时候为什么要表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。\n\n因为这样的定义在dp二维矩阵中可以留出初始化的区间，如图：\n\nhttps://file1.kamacoder.com/i/algo/20210303173115966.png\n\n如果要是定义的dp[i][j]是以下标i为结尾的字符串s和以下标j为结尾的字符串t，初始化就比较麻烦了。\n\ndp[i][0] 表示以下标i-1为结尾的字符串，与空字符串的相同子序列长度，所以为0. dp[0][j]同理。\n\nvector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));\n确定遍历顺序\n同理从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，那么遍历顺序也应该是从上到下，从左到右\n\n如图所示：\n\nhttps://file1.kamacoder.com/i/algo/20210303172354155.jpg\n\n举例推导dp数组\n以示例一为例，输入：s = \"abc\", t = \"ahbgdc\"，dp状态转移图如下：\n\nhttps://file1.kamacoder.com/i/algo/2021030317364166.jpg\n\ndp[i][j]表示以下标i-1为结尾的字符串s和以下标j-1为结尾的字符串t 相同子序列的长度，所以如果dp[s.size()][t.size()] 与 字符串s的长度相同说明：s与t的最长相同子序列就是s，那么s 就是 t 的子序列。\n\n图中dp[s.size()][t.size()] = 3， 而s.size() 也为3。所以s是t 的子序列，返回true。\n\n动规五部曲分析完毕，C++代码如下：\n\nclass Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));\n        for (int i = 1; i <= s.size(); i++) {\n            for (int j = 1; j <= t.size(); j++) {\n                if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;\n                else dp[i][j] = dp[i][j - 1];\n            }\n        }\n        if (dp[s.size()][t.size()] == s.size()) return true;\n        return false;\n    }\n};\n时间复杂度：O(n × m)\n空间复杂度：O(n × m)\n#总结\n这道题目算是编辑距离的入门题目（毕竟这里只是涉及到减法），也是动态规划解决的经典题型。\n\n这一类题都是题目读上去感觉很复杂，模拟一下也发现很复杂，用动规分析完了也感觉很复杂，但是最终代码却很简短。\n\n在之前的题目讲解中，我们讲了 1143.最长公共子序列 (https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html)，大家会发现 本题和 1143.最长公共子序列 的相似之处。\n\n编辑距离的题目最能体现出动规精髓和巧妙之处，大家可以好好体会一下。\n\n#其他语言版本\n#Java:\nclass Solution {\n    public boolean isSubsequence(String s, String t) {\n        int length1 = s.length(); int length2 = t.length();\n        int[][] dp = new int[length1+1][length2+1];\n        for(int i = 1; i <= length1; i++){\n            for(int j = 1; j <= length2; j++){\n                if(s.charAt(i-1) == t.charAt(j-1)){\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                }else{\n                    dp[i][j] = dp[i][j-1];\n                }\n            }\n        }\n        if(dp[length1][length2] == length1){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n修改遍历顺序后，可以利用滚动数组，对dp数组进行压缩\n\nclass Solution {\n    public boolean isSubsequence(String s, String t) {\n        // 修改遍历顺序，外圈遍历t，内圈遍历s。使得dp的推算只依赖正上方和左上方，方便压缩。\n        int[][] dp = new int[t.length() + 1][s.length() + 1];\n        for (int i = 1; i < dp.length; i++) { // 遍历t字符串\n            for (int j = 1; j < dp[i].length; j++) { // 遍历s字符串\n                if (t.charAt(i - 1) == s.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n            System.out.println(Arrays.toString(dp[i]));\n        }\n        return dp[t.length()][s.length()] == s.length();\n    }\n}\n状态压缩\n\nclass Solution {\n    public boolean isSubsequence(String s, String t) {\n        int[] dp = new int[s.length() + 1];\n        for (int i = 0; i < t.length(); i ++) {\n            // 需要使用上一轮的dp[j - 1]，所以使用倒序遍历\n            for (int j = dp.length - 1; j > 0; j --) {\n                // i遍历的是t字符串，j遍历的是dp数组，dp数组的长度比s的大1，因此需要减1。\n                if (t.charAt(i) == s.charAt(j - 1)) {\n                    dp[j] = dp[j - 1] + 1;\n                }\n            }\n        }\n        return dp[s.length()] == s.length();\n    }\n}\n将dp定义为boolean类型，dp[i]直接表示s.substring(0, i)是否为t的子序列\n\nclass Solution { \n    public boolean isSubsequence(String s, String t) {\n        boolean[] dp = new boolean[s.length() + 1];\n        // 表示 “” 是t的子序列\n        dp[0] = true;\n        for (int i = 0; i < t.length(); i ++) {\n            for (int j = dp.length - 1; j > 0; j --) {\n                if (t.charAt(i) == s.charAt(j - 1)) {\n                    dp[j] = dp[j - 1];\n                }\n            }\n        }\n        return dp[dp.length - 1];\n    }\n}\n#Python：\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]\n        for i in range(1, len(s)+1):\n            for j in range(1, len(t)+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = dp[i][j-1]\n        if dp[-1][-1] == len(s):\n            return True\n        return False"
}