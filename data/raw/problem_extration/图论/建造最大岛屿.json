{
  "id": "AP_690af5a6",
  "title": "建造最大岛屿",
  "alternative_titles": [],
  "platform": "kamacoder",
  "url": "https://kamacoder.com/problempage.php?pid=1176",
  "description": "一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。\n\n岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。\n\n输入描述：\n\n第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。\n\n输出描述：\n\n输出一个整数，表示最大的岛屿面积。\n\n输入",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "深度优先搜索",
    "图论"
  ],
  "data_structure_tags": [
    "二维数组",
    "哈希表"
  ],
  "technique_tags": [
    "递归",
    "连通性检测"
  ],
  "difficulty": null,
  "solution_approach": "首先遍历地图标记每个岛屿，并记录其面积。然后再次遍历地图中的每个0（水），计算如果将这个0变为1后与之相邻的所有岛屿合并后的总面积，从而找到最大可能的岛屿面积。",
  "key_insights": [
    {
      "content": "通过一次深度优先搜索(DFS)预先计算并存储每个岛屿的面积，而不是在每次尝试改变一个0为1时重新计算整个地图的最大岛屿面积，可以显著减少计算量。"
    },
    {
      "content": "使用不同的整数标记来区分不同岛屿，这不仅帮助识别独立的岛屿，也允许我们省略visited数组，因为一旦访问过某块陆地，它的值就被更新为岛屿编号了。"
    },
    {
      "content": "在处理每个0位置时，利用集合避免重复添加同一岛屿的面积，确保正确计算最大可能的岛屿面积。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "本题的一个暴力想法，应该是遍历地图尝试 将每一个 0 改成1，然后去搜索地图中的最大的岛屿面积。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\nint n, m;\nint count;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; \nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) {\n    if (visited[x][y] || grid[x][y] == 0) return; \n    visited[x][y] = true; \n    grid[x][y] = mark; \n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;  \n        dfs(grid, visited, nextx, nexty, mark);\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false)); \n    unordered_map<int ,int> gridNum;\n    int mark = 2; \n    bool isAllGrid = true; \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 0) isAllGrid = false;\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j, mark); \n                gridNum[mark] = count; \n                mark++;\n            }\n        }\n    }\n    if (isAllGrid) {\n        cout << n * m << endl; \n        return 0; \n    }\n\n    int result = 0; \n    unordered_set<int> visitedGrid; \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            count = 1; \n            visitedGrid.clear(); \n            if (grid[i][j] == 0) {\n                for (int k = 0; k < 4; k++) {\n                    int neari = i + dir[k][1]; \n                    int nearj = j + dir[k][0];\n                    if (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue;\n                    if (visitedGrid.count(grid[neari][nearj])) continue; \n                    count += gridNum[grid[neari][nearj]];\n                    visitedGrid.insert(grid[neari][nearj]); \n                }\n            }\n            result = max(result, count);\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的解决方案，使用DFS遍历地图，并记录每个岛屿的面积。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static int count;\n    static int mark;\n    static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    public static void dfs(int[][] grid, int x, int y, boolean[][] visited) {\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return;\n        if (visited[x][y] || grid[x][y] == 0) return;\n\n        visited[x][y] = true;\n        count++;\n        grid[x][y] = mark;\n\n        dfs(grid, x, y + 1, visited);\n        dfs(grid, x, y - 1, visited);\n        dfs(grid, x + 1, y, visited);\n        dfs(grid, x - 1, y, visited);\n    }\n\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n\n        mark = 2;\n        boolean[][] visited = new boolean[m][n];\n        HashMap<Integer, Integer> getSize = new HashMap<>();\n        HashSet<Integer> set = new HashSet<>();\n        boolean isAllIsland = true;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) isAllIsland = false;\n                if (grid[i][j] == 1) {\n                    count = 0;\n                    dfs(grid, i, j, visited);\n                    getSize.put(mark, count);\n                    mark++;\n                }\n            }\n        }\n\n        int result = 0;\n        if (isAllIsland) result =  m * n;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    set.clear();\n                    int curSize = 1;\n\n                    for (int[] dir : dirs) {\n                        int curRow = i + dir[0];\n                        int curCol = j + dir[1];\n\n                        if (curRow < 0 || curRow >= m || curCol < 0 || curCol >= n) continue;\n                        int curMark = grid[curRow][curCol];\n                        if (set.contains(curMark) || !getSize.containsKey(curMark)) continue;\n                        set.add(curMark);\n                        curSize += getSize.get(curMark);\n                    }\n\n                    result = Math.max(result, curSize);\n                }\n            }\n        }\n\n        System.out.println(result);\n    }\n}",
          "description": "Java版本的解决方案，同样采用DFS来标记岛屿并计算面积。"
        },
        {
          "language": "python",
          "code": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self):\n        self.direction = [(1,0),(-1,0),(0,1),(0,-1)]\n        self.res = 0\n        self.count = 0\n        self.idx = 1\n        self.count_area = defaultdict(int)\n\n    def max_area_island(self, grid: List[List[int]]) -> int:\n        if not grid or len(grid) == 0 or len(grid[0]) == 0:\n            return 0\n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    self.count = 0\n                    self.idx += 1\n                    self.dfs(grid,i,j)\n        self.check_area(grid)\n        if self.check_largest_connect_island(grid=grid):\n            return self.res + 1\n        return max(self.count_area.values())\n\n    def dfs(self,grid,row,col):\n        grid[row][col] = self.idx\n        self.count += 1\n        for dr,dc in self.direction:\n            _row = dr + row \n            _col = dc + col \n            if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] == 1:\n                self.dfs(grid,_row,_col)\n        return\n\n    def check_area(self,grid):\n        m, n = len(grid), len(grid[0])\n        for row in range(m):\n            for col in range(n):\n                  self.count_area[grid[row][col]] = self.count_area.get(grid[row][col],0) + 1\n        return\n\n    def check_largest_connect_island(self,grid):\n        m, n = len(grid), len(grid[0])\n        has_connect = False\n        for row in range(m):\n            for col in range(n):\n                if grid[row][col] == 0:\n                    has_connect = True\n                    area = 0\n                    visited = set()\n                    for dr, dc in self.direction:\n                        _row = row + dr \n                        _col = col + dc\n                        if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] != 0 and grid[_row][_col] not in visited:\n                            visited.add(grid[_row][_col])\n                            area += self.count_area[grid[_row][_col]]\n                            self.res = max(self.res, area)\n        return has_connect\n\n\ndef main():\n    m, n = map(int, input().split())\n    grid = []\n\n    for i in range(m):\n        grid.append(list(map(int,input().split())))\n\n    sol = Solution()\n    print(sol.max_area_island(grid))\n\nif __name__ == '__main__':\n    main()",
          "description": "Python版本的解决方案，通过DFS标记并计算岛屿面积，最后找到最大可能的岛屿面积。"
        }
      ],
      "subsections": []
    },
    {
      "name": "优化思路",
      "text": "其实每次深搜遍历计算最大岛屿面积，我们都做了很多重复的工作。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) {\\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\\n    visited[x][y] = true; // 标记访问过\\n    grid[x][y] = mark; // 给陆地标记新标签\\n    count++;\\n    for (int i = 0; i < 4; i++) {\\n        int nextx = x + dir[i][0];\\n        int nexty = y + dir[i][1];\\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;  // 越界了，直接跳过\\n        dfs(grid, visited, nextx, nexty, mark);\\n    }\\n}\\n\\nint main() {\\n    cin >> n >> m;\\n    vector<vector<int>> grid(n, vector<int>(m, 0));\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            cin >> grid[i][j];\\n        }\\n    }\\n    vector<vector<bool>> visited(n, vector<bool>(m, false)); // 标记访问过的点\\n    unordered_map<int ,int> gridNum;\\n    int mark = 2; // 记录每个岛屿的编号\\n    bool isAllGrid = true; // 标记是否整个地图都是陆地\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (grid[i][j] == 0) isAllGrid = false;\\n            if (!visited[i][j] && grid[i][j] == 1) {\\n                count = 0;\\n                dfs(grid, visited, i, j, mark); // 将与其链接的陆地都标记上 true\\n                gridNum[mark] = count; // 记录每一个岛屿的面积\\n                mark++; // 记录下一个岛屿编号\\n            }\\n        }\\n    }\\n    if (isAllGrid) {\\n        cout << n * m << endl; // 如果都是陆地，返回全面积\\n        return 0; // 结束程序\\n    }\\n\\n    // 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和\\n    int result = 0; // 记录最后结果\\n    unordered_set<int> visitedGrid; // 标记访问过的岛屿\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            count = 1; // 记录连接之后的岛屿数量\\n            visitedGrid.clear(); // 每次使用时，清空\\n            if (grid[i][j] == 0) {\\n                for (int k = 0; k < 4; k++) {\\n                    int neari = i + dir[k][1]; // 计算相邻坐标\\n                    int nearj = j + dir[k][0];\\n                    if (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue;\\n                    if (visitedGrid.count(grid[neari][nearj])) continue; // 添加过的岛屿不要重复添加\\n                    // 把相邻四面的岛屿数量加起来\\n                    count += gridNum[grid[neari][nearj]];\\n                    visitedGrid.insert(grid[neari][nearj]); // 标记该岛屿已经添加过\\n                }\\n            }\\n            result = max(result, count);\\n        }\\n    }\\n    cout << result << endl;\\n}",
          "description": "C++代码实现寻找最大岛屿面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\\nclass Main {\\n    static int count;\\n    static int mark;\\n    static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public static void dfs(int[][] grid, int x, int y, boolean[][] visited) {\\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return;\\n        if (visited[x][y] || grid[x][y] == 0) return;\\n        visited[x][y] = true;\\n        count++;\\n        grid[x][y] = mark;\\n        dfs(grid, x, y + 1, visited);\\n        dfs(grid, x, y - 1, visited);\\n        dfs(grid, x + 1, y, visited);\\n        dfs(grid, x - 1, y, visited);\\n    }\\n    public static void main (String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        int m = sc.nextInt();\\n        int n = sc.nextInt();\\n        int[][] grid = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                grid[i][j] = sc.nextInt();\\n            }\\n        }\\n        mark = 2;\\n        boolean[][] visited = new boolean[m][n];\\n        HashMap<Integer, Integer> getSize = new HashMap<>();\\n        HashSet<Integer> set = new HashSet<>();\\n        boolean isAllIsland = true;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) isAllIsland = false;\\n                if (grid[i][j] == 1) {\\n                    count = 0;\\n                    dfs(grid, i, j, visited);\\n                    getSize.put(mark, count);\\n                    mark++;\\n                }\\n            }\\n        }\\n        int result = 0;\\n        if (isAllIsland) result =  m * n;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) {\\n                    set.clear();\\n                    int curSize = 1;\\n                    for (int[] dir : dirs) {\\n                        int curRow = i + dir[0];\\n                        int curCol = j + dir[1];\\n                        if (curRow < 0 || curRow >= m || curCol < 0 || curCol >= n) continue;\\n                        int curMark = grid[curRow][curCol];\\n                        if (set.contains(curMark) || !getSize.containsKey(curMark)) continue;\\n                        set.add(curMark);\\n                        curSize += getSize.get(curMark);\\n                    }\\n                    result = Math.max(result, curSize);\\n                }\\n            }\\n        }\\n        System.out.println(result);\\n    }\\n}",
          "description": "Java代码实现寻找最大岛屿面积"
        },
        {
          "language": "python",
          "code": "from typing import List\\nfrom collections import defaultdict\\nclass Solution: \\n    def __init__(self):\\n        self.direction = [(1,0),(-1,0),(0,1),(0,-1)]\\n        self.res = 0\\n        self.count = 0\\n        self.idx = 1\\n        self.count_area = defaultdict(int)\\n    def max_area_island(self, grid: List[List[int]]) -> int:\\n        if not grid or len(grid) == 0 or len(grid[0]) == 0:\\n            return 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    self.count = 0\\n                    self.idx += 1\\n                    self.dfs(grid,i,j)\\n        self.check_area(grid)\\n        if self.check_largest_connect_island(grid=grid):\\n            return self.res + 1\\n        return max(self.count_area.values())\\n    def dfs(self,grid,row,col):\\n        grid[row][col] = self.idx\\n        self.count += 1\\n        for dr,dc in self.direction:\\n            _row = dr + row \\n            _col = dc + col \\n            if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] == 1:\\n                self.dfs(grid,_row,_col)\\n        return\\n    def check_area(self,grid):\\n        m, n = len(grid), len(grid[0])\\n        for row in range(m):\\n            for col in range(n):\\n                  self.count_area[grid[row][col]] = self.count_area.get(grid[row][col],0) + 1\\n        return\\n    def check_largest_connect_island(self,grid):\\n        m, n = len(grid), len(grid[0])\\n        has_connect = False\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == 0:\\n                    has_connect = True\\n                    area = 0\\n                    visited = set()\\n                    for dr, dc in self.direction:\\n                        _row = row + dr \\n                        _col = col + dc\\n                        if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] != 0 and grid[_row][_col] not in visited:\\n                            visited.add(grid[_row][_col])\\n                            area += self.count_area[grid[_row][_col]]\\n                            self.res = max(self.res, area)\\n        return has_connect\\ndef main():\\n    m, n = map(int, input().split())\\n    grid = []\\n    for i in range(m):\\n        grid.append(list(map(int,input().split())))\\n    sol = Solution()\\n    print(sol.max_area_island(grid))\\nif __name__ == '__main__':\\n    main()",
          "description": "Python代码实现寻找最大岛屿面积"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\nint n, m;\nint count;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    grid[x][y] = mark; // 给陆地标记新标签\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty, mark);\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false)); // 标记访问过的点\n    unordered_map<int ,int> gridNum;\n    int mark = 2; // 记录每个岛屿的编号\n    bool isAllGrid = true; // 标记是否整个地图都是陆地\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 0) isAllGrid = false;\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j, mark); // 将与其链接的陆地都标记上 true\n                gridNum[mark] = count; // 记录每一个岛屿的面积\n                mark++; // 记录下一个岛屿编号\n            }\n        }\n    }\n    if (isAllGrid) {\n        cout << n * m << endl; // 如果都是陆地，返回全面积\n        return 0; // 结束程序\n    }\n\n    // 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和\n    int result = 0; // 记录最后结果\n    unordered_set<int> visitedGrid; // 标记访问过的岛屿\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            count = 1; // 记录连接之后的岛屿数量\n            visitedGrid.clear(); // 每次使用时，清空\n            if (grid[i][j] == 0) {\n                for (int k = 0; k < 4; k++) {\n                    int neari = i + dir[k][1]; // 计算相邻坐标\n                    int nearj = j + dir[k][0];\n                    if (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue;\n                    if (visitedGrid.count(grid[neari][nearj])) continue; // 添加过的岛屿不要重复添加\n                    // 把相邻四面的岛屿数量加起来\n                    count += gridNum[grid[neari][nearj]];\n                    visitedGrid.insert(grid[neari][nearj]); // 标记该岛屿已经添加过\n                }\n            }\n            result = max(result, count);\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++代码实现求解最大岛屿面积问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    static int count;\n    static int mark;\n    static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    public static void dfs(int[][] grid, int x, int y, boolean[][] visited) {\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return;\n        if (visited[x][y] || grid[x][y] == 0) return;\n\n        visited[x][y] = true;\n        count++;\n        grid[x][y] = mark;\n\n        dfs(grid, x, y + 1, visited);\n        dfs(grid, x, y - 1, visited);\n        dfs(grid, x + 1, y, visited);\n        dfs(grid, x - 1, y, visited);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n\n        mark = 2;\n        boolean[][] visited = new boolean[m][n];\n        HashMap<Integer, Integer> getSize = new HashMap<>();\n        HashSet<Integer> set = new HashSet<>();\n        boolean isAllIsland = true;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) isAllIsland = false;\n                if (grid[i][j] == 1) {\n                    count = 0;\n                    dfs(grid, i, j, visited);\n                    getSize.put(mark, count);\n                    mark++;\n                }\n            }\n        }\n\n        int result = 0;\n        if (isAllIsland) result =  m * n;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    set.clear();\n                    int curSize = 1;\n\n                    for (int[] dir : dirs) {\n                        int curRow = i + dir[0];\n                        int curCol = j + dir[1];\n\n                        if (curRow < 0 || curRow >= m || curCol < 0 || curCol >= n) continue;\n                        int curMark = grid[curRow][curCol];\n                        if (set.contains(curMark) || !getSize.containsKey(curMark)) continue;\n                        set.add(curMark);\n                        curSize += getSize.get(curMark);\n                    }\n\n                    result = Math.max(result, curSize);\n                }\n            }\n        }\n\n        System.out.println(result);\n    }\n}",
          "description": "Java代码实现求解最大岛屿面积问题"
        },
        {
          "language": "python",
          "code": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self):\n        self.direction = [(1,0),(-1,0),(0,1),(0,-1)]\n        self.res = 0\n        self.count = 0\n        self.idx = 1\n        self.count_area = defaultdict(int)\n\n    def max_area_island(self, grid: List[List[int]]) -> int:\n        if not grid or len(grid) == 0 or len(grid[0]) == 0:\n            return 0\n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    self.count = 0\n                    self.idx += 1\n                    self.dfs(grid,i,j)\n        self.check_area(grid)\n\n        if self.check_largest_connect_island(grid=grid):\n            return self.res + 1\n        return max(self.count_area.values())\n\n    def dfs(self,grid,row,col):\n        grid[row][col] = self.idx\n        self.count += 1\n        for dr,dc in self.direction:\n            _row = dr + row \n            _col = dc + col \n            if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] == 1:\n                self.dfs(grid,_row,_col)\n        return\n\n    def check_area(self,grid):\n        m, n = len(grid), len(grid[0])\n        for row in range(m):\n            for col in range(n):\n                  self.count_area[grid[row][col]] = self.count_area.get(grid[row][col],0) + 1\n        return\n\n    def check_largest_connect_island(self,grid):\n        m, n = len(grid), len(grid[0])\n        has_connect = False\n        for row in range(m):\n            for col in range(n):\n                if grid[row][col] == 0:\n                    has_connect = True\n                    area = 0\n                    visited = set()\n                    for dr, dc in self.direction:\n                        _row = row + dr \n                        _col = col + dc\n                        if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] != 0 and grid[_row][_col] not in visited:\n                            visited.add(grid[_row][_col])\n                            area += self.count_area[grid[_row][_col]]\n                            self.res = max(self.res, area)\n        return has_connect\n\n\ndef main():\n    m, n = map(int, input().split())\n    grid = []\n\n    for i in range(m):\n        grid.append(list(map(int,input().split())))\n\n    sol = Solution()\n    print(sol.max_area_island(grid))\n\nif __name__ == '__main__':\n    main()",
          "description": "Python代码实现求解最大岛屿面积问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <unordered_set>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\nint n, m;\nint count;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    grid[x][y] = mark; // 给陆地标记新标签\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty, mark);\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false)); // 标记访问过的点\n    unordered_map<int ,int> gridNum;\n    int mark = 2; // 记录每个岛屿的编号\n    bool isAllGrid = true; // 标记是否整个地图都是陆地\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 0) isAllGrid = false;\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j, mark); // 将与其链接的陆地都标记上 true\n                gridNum[mark] = count; // 记录每一个岛屿的面积\n                mark++; // 记录下一个岛屿编号\n            }\n        }\n    }\n    if (isAllGrid) {\n        cout << n * m << endl; // 如果都是陆地，返回全面积\n        return 0; // 结束程序\n    }\n\n    // 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和\n    int result = 0; // 记录最后结果\n    unordered_set<int> visitedGrid; // 标记访问过的岛屿\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            count = 1; // 记录连接之后的岛屿数量\n            visitedGrid.clear(); // 每次使用时，清空\n            if (grid[i][j] == 0) {\n                for (int k = 0; k < 4; k++) {\n                    int neari = i + dir[k][1]; // 计算相邻坐标\n                    int nearj = j + dir[k][0];\n                    if (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue;\n                    if (visitedGrid.count(grid[neari][nearj])) continue; // 添加过的岛屿不要重复添加\n                    // 把相邻四面的岛屿数量加起来\n                    count += gridNum[grid[neari][nearj]];\n                    visitedGrid.insert(grid[neari][nearj]); // 标记该岛屿已经添加过\n                }\n            }\n            result = max(result, count);\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++代码实现寻找最大岛屿问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    static int count;\n    static int mark;\n    static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    public static void dfs(int[][] grid, int x, int y, boolean[][] visited) {\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return;\n        if (visited[x][y] || grid[x][y] == 0) return;\n\n        visited[x][y] = true;\n        count++;\n        grid[x][y] = mark;\n\n        dfs(grid, x, y + 1, visited);\n        dfs(grid, x, y - 1, visited);\n        dfs(grid, x + 1, y, visited);\n        dfs(grid, x - 1, y, visited);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n\n        mark = 2;\n        boolean[][] visited = new boolean[m][n];\n        HashMap<Integer, Integer> getSize = new HashMap<>();\n        HashSet<Integer> set = new HashSet<>();\n        boolean isAllIsland = true;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) isAllIsland = false;\n                if (grid[i][j] == 1) {\n                    count = 0;\n                    dfs(grid, i, j, visited);\n                    getSize.put(mark, count);\n                    mark++;\n                }\n            }\n        }\n\n        int result = 0;\n        if (isAllIsland) result = m * n;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    set.clear();\n                    int curSize = 1;\n\n                    for (int[] dir : dirs) {\n                        int curRow = i + dir[0];\n                        int curCol = j + dir[1];\n\n                        if (curRow < 0 || curRow >= m || curCol < 0 || curCol >= n) continue;\n                        int curMark = grid[curRow][curCol];\n                        if (set.contains(curMark) || !getSize.containsKey(curMark)) continue;\n                        set.add(curMark);\n                        curSize += getSize.get(curMark);\n                    }\n\n                    result = Math.max(result, curSize);\n                }\n            }\n        }\n\n        System.out.println(result);\n    }\n}",
          "description": "Java代码实现寻找最大岛屿问题"
        },
        {
          "language": "python",
          "code": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self):\n        self.direction = [(1,0),(-1,0),(0,1),(0,-1)]\n        self.res = 0\n        self.count = 0\n        self.idx = 1\n        self.count_area = defaultdict(int)\n\n    def max_area_island(self, grid: List[List[int]]) -> int:\n        if not grid or len(grid) == 0 or len(grid[0]) == 0:\n            return 0\n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    self.count = 0\n                    self.idx += 1\n                    self.dfs(grid,i,j)\n        self.check_area(grid)\n\n        if self.check_largest_connect_island(grid=grid):\n            return self.res + 1\n        return max(self.count_area.values())\n\n    def dfs(self,grid,row,col):\n        grid[row][col] = self.idx\n        self.count += 1\n        for dr,dc in self.direction:\n            _row = dr + row \n            _col = dc + col \n            if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] == 1:\n                self.dfs(grid,_row,_col)\n        return\n\n    def check_area(self,grid):\n        m, n = len(grid), len(grid[0])\n        for row in range(m):\n            for col in range(n):\n                  self.count_area[grid[row][col]] = self.count_area.get(grid[row][col],0) + 1\n        return\n\n    def check_largest_connect_island(self,grid):\n        m, n = len(grid), len(grid[0])\n        has_connect = False\n        for row in range(m):\n            for col in range(n):\n                if grid[row][col] == 0:\n                    has_connect = True\n                    area = 0\n                    visited = set()\n                    for dr, dc in self.direction:\n                        _row = row + dr \n                        _col = col + dc\n                        if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] != 0 and grid[_row][_col] not in visited:\n                            visited.add(grid[_row][_col])\n                            area += self.count_area[grid[_row][_col]]\n                            self.res = max(self.res, area)\n        return has_connect\n\n\ndef main():\n    m, n = map(int, input().split())\n    grid = []\n\n    for i in range(m):\n        grid.append(list(map(int,input().split())))\n\n    sol = Solution()\n    print(sol.max_area_island(grid))\n\nif __name__ == '__main__':\n    main()",
          "description": "Python代码实现寻找最大岛屿问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <unordered_set>",
      "text": "#include <unordered_map>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\nint n, m;\nint count;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    grid[x][y] = mark; // 给陆地标记新标签\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty, mark);\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false)); // 标记访问过的点\n    unordered_map<int ,int> gridNum;\n    int mark = 2; // 记录每个岛屿的编号\n    bool isAllGrid = true; // 标记是否整个地图都是陆地\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 0) isAllGrid = false;\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j, mark); // 将与其链接的陆地都标记上 true\n                gridNum[mark] = count; // 记录每一个岛屿的面积\n                mark++; // 记录下一个岛屿编号\n            }\n        }\n    }\n    if (isAllGrid) {\n        cout << n * m << endl; // 如果都是陆地，返回全面积\n        return 0; // 结束程序\n    }\n\n    // 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和\n    int result = 0; // 记录最后结果\n    unordered_set<int> visitedGrid; // 标记访问过的岛屿\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            count = 1; // 记录连接之后的岛屿数量\n            visitedGrid.clear(); // 每次使用时，清空\n            if (grid[i][j] == 0) {\n                for (int k = 0; k < 4; k++) {\n                    int neari = i + dir[k][1]; // 计算相邻坐标\n                    int nearj = j + dir[k][0];\n                    if (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue;\n                    if (visitedGrid.count(grid[neari][nearj])) continue; // 添加过的岛屿不要重复添加\n                    // 把相邻四面的岛屿数量加起来\n                    count += gridNum[grid[neari][nearj]];\n                    visitedGrid.insert(grid[neari][nearj]); // 标记该岛屿已经添加过\n                }\n            }\n            result = max(result, count);\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++实现最大岛屿问题"
        },
        {
          "language": "java",
          "code": "public class Main {\n    // 该方法采用 DFS\n    // 定义全局变量\n    // 记录每次每个岛屿的面积\n    static int count;\n    // 对每个岛屿进行标记\n    static int mark;\n    // 定义二维数组表示四个方位\n    static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    // DFS 进行搜索，将每个岛屿标记为不同的数字\n    public static void dfs(int[][] grid, int x, int y, boolean[][] visited) {\n        // 当遇到边界，直接return\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return;\n        // 遇到已经访问过的或者遇到海水，直接返回\n        if (visited[x][y] || grid[x][y] == 0) return;\n\n        visited[x][y] = true;\n        count++;\n        grid[x][y] = mark;\n\n        // 继续向下层搜索\n        dfs(grid, x, y + 1, visited);\n        dfs(grid, x, y - 1, visited);\n        dfs(grid, x + 1, y, visited);\n        dfs(grid, x - 1, y, visited);\n    }\n\n    public static void main (String[] args) {\n        // 接收输入\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n\n        // 初始化mark变量，从2开始（区别于0水，1岛屿）\n        mark = 2;\n\n        // 定义二位boolean数组记录该位置是否被访问\n        boolean[][] visited = new boolean[m][n];\n\n        // 定义一个HashMap，记录某片岛屿的标记号和面积\n        HashMap<Integer, Integer> getSize = new HashMap<>();\n\n        // 定义一个HashSet，用来判断某一位置水四周是否存在不同标记编号的岛屿\n        HashSet<Integer> set = new HashSet<>();\n\n        // 定义一个boolean变量，看看DFS之后，是否全是岛屿\n        boolean isAllIsland = true;\n\n        // 遍历二维数组进行DFS搜索，标记每片岛屿的编号，记录对应的面积\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) isAllIsland = false;\n                if (grid[i][j] == 1) {\n                    count = 0;\n                    dfs(grid, i, j, visited);\n                    getSize.put(mark, count);\n                    mark++;\n                }\n            }\n        }\n\n        int result = 0;\n        if (isAllIsland) result =  m * n;\n\n        // 对标记完的grid继续遍历，判断每个水位置四周是否有岛屿，并记录下四周不同相邻岛屿面积之和\n        // 每次计算完一个水位置周围可能存在的岛屿面积之和，更新下result变量\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    set.clear();\n                    // 当前水位置变更为岛屿，所以初始化为1\n                    int curSize = 1;\n\n                    for (int[] dir : dirs) {\n                        int curRow = i + dir[0];\n                        int curCol = j + dir[1];\n\n                        if (curRow < 0 || curRow >= m || curCol < 0 || curCol >= n) continue;\n                        int curMark = grid[curRow][curCol];\n                        // 如果当前相邻的岛屿已经遍历过或者HashMap中不存在这个编号，继续搜索\n                        if (set.contains(curMark) || !getSize.containsKey(curMark)) continue;\n                        set.add(curMark);\n                        curSize += getSize.get(curMark);\n                    }\n\n                    result = Math.max(result, curSize);\n                }\n            }\n        }\n\n        // 打印结果\n        System.out.println(result);\n    }\n}",
          "description": "Java实现最大岛屿问题"
        },
        {
          "language": "python",
          "code": "from typing import List\nfrom collections import defaultdict\nclass Solution:\n    def __init__(self):\n        self.direction = [(1,0),(-1,0),(0,1),(0,-1)]\n        self.res = 0\n        self.count = 0\n        self.idx = 1\n        self.count_area = defaultdict(int)\n\n    def max_area_island(self, grid: List[List[int]]) -> int:\n        if not grid or len(grid) == 0 or len(grid[0]) == 0:\n            return 0\n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    self.count = 0\n                    self.idx += 1\n                    self.dfs(grid,i,j)\n        # print(grid)\n        self.check_area(grid)\n        # print(self.count_area)\n        \n        if self.check_largest_connect_island(grid=grid):\n            return self.res + 1\n        return max(self.count_area.values())\n    \n    def dfs(self,grid,row,col):\n        grid[row][col] = self.idx\n        self.count += 1\n        for dr,dc in self.direction:\n            _row = dr + row \n            _col = dc + col \n            if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] == 1:\n                self.dfs(grid,_row,_col)\n        return\n\n    def check_area(self,grid):\n        m, n = len(grid), len(grid[0])\n        for row in range(m):\n            for col in range(n):\n                  self.count_area[grid[row][col]] = self.count_area.get(grid[row][col],0) + 1\n        return\n\n    def check_largest_connect_island(self,grid):\n        m, n = len(grid), len(grid[0])\n        has_connect = False\n        for row in range(m):\n            for col in range(n):\n                if grid[row][col] == 0:\n                    has_connect = True\n                    area = 0\n                    visited = set()\n                    for dr, dc in self.direction:\n                        _row = row + dr \n                        _col = col + dc\n                        if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] != 0 and grid[_row][_col] not in visited:\n                            visited.add(grid[_row][_col])\n                            area += self.count_area[grid[_row][_col]]\n                            self.res = max(self.res, area)\n                            \n        return has_connect\n\n\ndef main():\n    m, n = map(int, input().split())\n    grid = []\n\n    for i in range(m):\n        grid.append(list(map(int,input().split())))\n    \n\n    sol = Solution()\n    print(sol.max_area_island(grid))\n\nif __name__ == '__main__':\n    main()",
          "description": "Python实现最大岛屿问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <unordered_map>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) { if (visited[x][y] || grid[x][y] == 0) return; visited[x][y] = true; grid[x][y] = mark; count++; for (int i = 0; i < 4; i++) { int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;  dfs(grid, visited, nextx, nexty, mark); } }\nint main() { cin >> n >> m; vector<vector<int>> grid(n, vector<int>(m, 0)); for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { cin >> grid[i][j]; } } vector<vector<bool>> visited(n, vector<bool>(m, false)); unordered_map<int ,int> gridNum; int mark = 2; bool isAllGrid = true; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { if (grid[i][j] == 0) isAllGrid = false; if (!visited[i][j] && grid[i][j] == 1) { count = 0; dfs(grid, visited, i, j, mark); gridNum[mark] = count; mark++; } } } if (isAllGrid) { cout << n * m << endl; return 0; } int result = 0; unordered_set<int> visitedGrid; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { count = 1; visitedGrid.clear(); if (grid[i][j] == 0) { for (int k = 0; k < 4; k++) { int neari = i + dir[k][1]; int nearj = j + dir[k][0]; if (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue; if (visitedGrid.count(grid[neari][nearj])) continue; count += gridNum[grid[neari][nearj]]; visitedGrid.insert(grid[neari][nearj]); } } result = max(result, count); } } cout << result << endl; }",
          "description": "C++代码实现寻找最大岛屿面积"
        },
        {
          "language": "java",
          "code": "public class Main { static int count; static int mark; static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; public static void dfs(int[][] grid, int x, int y, boolean[][] visited) { if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return; if (visited[x][y] || grid[x][y] == 0) return; visited[x][y] = true; count++; grid[x][y] = mark; dfs(grid, x, y + 1, visited); dfs(grid, x, y - 1, visited); dfs(grid, x + 1, y, visited); dfs(grid, x - 1, y, visited); } public static void main (String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); int[][] grid = new int[m][n]; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { grid[i][j] = sc.nextInt(); } } mark = 2; boolean[][] visited = new boolean[m][n]; HashMap<Integer, Integer> getSize = new HashMap<>(); HashSet<Integer> set = new HashSet<>(); boolean isAllIsland = true; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == 0) isAllIsland = false; if (grid[i][j] == 1) { count = 0; dfs(grid, i, j, visited); getSize.put(mark, count); mark++; } } } int result = 0; if (isAllIsland) result = m * n; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == 0) { set.clear(); int curSize = 1; for (int[] dir : dirs) { int curRow = i + dir[0]; int curCol = j + dir[1]; if (curRow < 0 || curRow >= m || curCol < 0 || curCol >= n) continue; int curMark = grid[curRow][curCol]; if (set.contains(curMark) || !getSize.containsKey(curMark)) continue; set.add(curMark); curSize += getSize.get(curMark); } result = Math.max(result, curSize); } } } System.out.println(result); } }",
          "description": "Java代码实现寻找最大岛屿面积"
        },
        {
          "language": "python",
          "code": "from typing import List from collections import defaultdict\nclass Solution: def __init__(self): self.direction = [(1,0),(-1,0),(0,1),(0,-1)] self.res = 0 self.count = 0 self.idx = 1 self.count_area = defaultdict(int)\ndef max_area_island(self, grid: List[List[int]]) -> int: if not grid or len(grid) == 0 or len(grid[0]) == 0: return 0\nfor i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: self.count = 0 self.idx += 1 self.dfs(grid,i,j) self.check_area(grid) if self.check_largest_connect_island(grid=grid): return self.res + 1 return max(self.count_area.values())\ndef dfs(self,grid,row,col): grid[row][col] = self.idx self.count += 1 for dr,dc in self.direction: _row = dr + row _col = dc + col if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] == 1: self.dfs(grid,_row,_col) return\ndef check_area(self,grid): m, n = len(grid), len(grid[0]) for row in range(m): for col in range(n): self.count_area[grid[row][col]] = self.count_area.get(grid[row][col],0) + 1 return\ndef check_largest_connect_island(self,grid): m, n = len(grid), len(grid[0]) has_connect = False for row in range(m): for col in range(n): if grid[row][col] == 0: has_connect = True area = 0 visited = set() for dr, dc in self.direction: _row = row + dr _col = col + dc if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] != 0 and grid[_row][_col] not in visited: visited.add(grid[_row][_col]) area += self.count_area[grid[_row][_col]] self.res = max(self.res, area) return has_connect\ndef main(): m, n = map(int, input().split()) grid = [] for i in range(m): grid.append(list(map(int,input().split()))) sol = Solution() print(sol.max_area_island(grid))\nif __name__ == '__main__': main()",
          "description": "Python代码实现寻找最大岛屿面积"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "public class Main {\nstatic int count;\nstatic int mark;\nstatic int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\npublic static void dfs(int[][] grid, int x, int y, boolean[][] visited) {\nif (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return;\nif (visited[x][y] || grid[x][y] == 0) return;\nvisited[x][y] = true;\ncount++;\ngrid[x][y] = mark;\ndfs(grid, x, y + 1, visited);\ndfs(grid, x, y - 1, visited);\ndfs(grid, x + 1, y, visited);\ndfs(grid, x - 1, y, visited);\n}\npublic static void main (String[] args) {\nScanner sc = new Scanner(System.in);\nint m = sc.nextInt();\nint n = sc.nextInt();\nint[][] grid = new int[m][n];\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\ngrid[i][j] = sc.nextInt();\n}\n}\nmark = 2;\nboolean[][] visited = new boolean[m][n];\nHashMap<Integer, Integer> getSize = new HashMap<>();\nHashSet<Integer> set = new HashSet<>();\nboolean isAllIsland = true;\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nif (grid[i][j] == 0) isAllIsland = false;\nif (grid[i][j] == 1) {\ncount = 0;\ndfs(grid, i, j, visited);\ngetSize.put(mark, count);\nmark++;\n}\n}\n}\nint result = 0;\nif (isAllIsland) result =  m * n;\nfor (int i = 0; i < m; i++) {\nfor (int j = 0; j < n; j++) {\nif (grid[i][j] == 0) {\nset.clear();\nint curSize = 1;\nfor (int[] dir : dirs) {\nint curRow = i + dir[0];\nint curCol = j + dir[1];\nif (curRow < 0 || curRow >= m || curCol < 0 || curCol >= n) continue;\nint curMark = grid[curRow][curCol];\nif (set.contains(curMark) || !getSize.containsKey(curMark)) continue;\nset.add(curMark);\ncurSize += getSize.get(curMark);\n}\nresult = Math.max(result, curSize);\n}\n}\n}\nSystem.out.println(result);\n}\n}",
          "description": "Java代码实现寻找最大岛屿面积"
        },
        {
          "language": "python",
          "code": "from typing import List\nfrom collections import defaultdict\nclass Solution:\ndef __init__(self):\nself.direction = [(1,0),(-1,0),(0,1),(0,-1)]\nself.res = 0\nself.count = 0\nself.idx = 1\nself.count_area = defaultdict(int)\ndef max_area_island(self, grid: List[List[int]]) -> int:\nif not grid or len(grid) == 0 or len(grid[0]) == 0:\nreturn 0\nfor i in range(len(grid)):\nfor j in range(len(grid[0])):\nif grid[i][j] == 1:\nself.count = 0\nself.idx += 1\nself.dfs(grid,i,j)\nself.check_area(grid)\nif self.check_largest_connect_island(grid=grid):\nreturn self.res + 1\nreturn max(self.count_area.values())\ndef dfs(self,grid,row,col):\ngrid[row][col] = self.idx\nself.count += 1\nfor dr,dc in self.direction:\n_row = dr + row \n_col = dc + col \nif 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] == 1:\nself.dfs(grid,_row,_col)\nreturn\ndef check_area(self,grid):\nm, n = len(grid), len(grid[0])\nfor row in range(m):\nfor col in range(n):\nself.count_area[grid[row][col]] = self.count_area.get(grid[row][col],0) + 1\nreturn\ndef check_largest_connect_island(self,grid):\nm, n = len(grid), len(grid[0])\nhas_connect = False\nfor row in range(m):\nfor col in range(n):\nif grid[row][col] == 0:\nhas_connect = True\narea = 0\nvisited = set()\nfor dr, dc in self.direction:\n_row = row + dr \n_col = col + dc\nif 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] != 0 and grid[_row][_col] not in visited:\nvisited.add(grid[_row][_col])\narea += self.count_area[grid[_row][_col]]\nself.res = max(self.res, area)\nreturn has_connect\ndef main():\nm, n = map(int, input().split())\ngrid = []\nfor i in range(m):\ngrid.append(list(map(int,input().split())))\nsol = Solution()\nprint(sol.max_area_island(grid))\nif __name__ == '__main__':\nmain()",
          "description": "Python代码实现寻找最大岛屿面积"
        },
        {
          "language": "c++",
          "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\nint n, m;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) {\nif (visited[x][y] || grid[x][y] == 0) return;\nvisited[x][y] = true;\ngrid[x][y] = mark;\ncount++;\nfor (int i = 0; i < 4; i++) {\nint nextx = x + dir[i][0];\nint nexty = y + dir[i][1];\nif (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;\ndfs(grid, visited, nextx, nexty, mark);\n}\n}\nint main() {\ncin >> n >> m;\nvector<vector<int>> grid(n, vector<int>(m, 0));\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ncin >> grid[i][j];\n}\n}\nvector<vector<bool>> visited(n, vector<bool>(m, false));\nunordered_map<int ,int> gridNum;\nint mark = 2;\nbool isAllGrid = true;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nif (grid[i][j] == 0) isAllGrid = false;\nif (!visited[i][j] && grid[i][j] == 1) {\ncount = 0;\ndfs(grid, visited, i, j, mark);\ngridNum[mark] = count;\nmark++;\n}\n}\n}\nif (isAllGrid) {\ncout << n * m << endl;\nreturn 0;\n}\nint result = 0;\nunordered_set<int> visitedGrid;\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\ncount = 1;\nvisitedGrid.clear();\nif (grid[i][j] == 0) {\nfor (int k = 0; k < 4; k++) {\nint neari = i + dir[k][1];\nint nearj = j + dir[k][0];\nif (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue;\nif (visitedGrid.count(grid[neari][nearj])) continue;\ncount += gridNum[grid[neari][nearj]];\nvisitedGrid.insert(grid[neari][nearj]);\n}\n}\nresult = max(result, count);\n}\n}\ncout << result << endl;\n}",
          "description": "C++代码实现寻找最大岛屿面积"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "public class Main {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) { if (visited[x][y] || grid[x][y] == 0) return; visited[x][y] = true; grid[x][y] = mark; count++; for (int i = 0; i < 4; i++) { int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue; dfs(grid, visited, nextx, nexty, mark); } } int main() { cin >> n >> m; vector<vector<int>> grid(n, vector<int>(m, 0)); for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { cin >> grid[i][j]; } } vector<vector<bool>> visited(n, vector<bool>(m, false)); unordered_map<int ,int> gridNum; int mark = 2; bool isAllGrid = true; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { if (grid[i][j] == 0) isAllGrid = false; if (!visited[i][j] && grid[i][j] == 1) { count = 0; dfs(grid, visited, i, j, mark); gridNum[mark] = count; mark++; } } } if (isAllGrid) { cout << n * m << endl; return 0; } int result = 0; unordered_set<int> visitedGrid; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { count = 1; visitedGrid.clear(); if (grid[i][j] == 0) { for (int k = 0; k < 4; k++) { int neari = i + dir[k][1]; int nearj = j + dir[k][0]; if (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue; if (visitedGrid.count(grid[neari][nearj])) continue; count += gridNum[grid[neari][nearj]]; visitedGrid.insert(grid[neari][nearj]); } } result = max(result, count); } } cout << result << endl; }",
          "description": "C++代码实现最大岛屿问题"
        },
        {
          "language": "java",
          "code": "public class Main { static int count; static int mark; static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; public static void dfs(int[][] grid, int x, int y, boolean[][] visited) { if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return; if (visited[x][y] || grid[x][y] == 0) return; visited[x][y] = true; count++; grid[x][y] = mark; dfs(grid, x, y + 1, visited); dfs(grid, x, y - 1, visited); dfs(grid, x + 1, y, visited); dfs(grid, x - 1, y, visited); } public static void main (String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); int[][] grid = new int[m][n]; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { grid[i][j] = sc.nextInt(); } } mark = 2; boolean[][] visited = new boolean[m][n]; HashMap<Integer, Integer> getSize = new HashMap<>(); HashSet<Integer> set = new HashSet<>(); boolean isAllIsland = true; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == 0) isAllIsland = false; if (grid[i][j] == 1) { count = 0; dfs(grid, i, j, visited); getSize.put(mark, count); mark++; } } } int result = 0; if (isAllIsland) result =  m * n; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == 0) { set.clear(); int curSize = 1; for (int[] dir : dirs) { int curRow = i + dir[0]; int curCol = j + dir[1]; if (curRow < 0 || curRow >= m || curCol < 0 || curCol >= n) continue; int curMark = grid[curRow][curCol]; if (set.contains(curMark) || !getSize.containsKey(curMark)) continue; set.add(curMark); curSize += getSize.get(curMark); } result = Math.max(result, curSize); } } } System.out.println(result); } }",
          "description": "Java代码实现最大岛屿问题"
        },
        {
          "language": "python",
          "code": "from typing import List from collections import defaultdict class Solution: def __init__(self): self.direction = [(1,0),(-1,0),(0,1),(0,-1)] self.res = 0 self.count = 0 self.idx = 1 self.count_area = defaultdict(int) def max_area_island(self, grid: List[List[int]]) -> int: if not grid or len(grid) == 0 or len(grid[0]) == 0: return 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: self.count = 0 self.idx += 1 self.dfs(grid,i,j) self.check_area(grid) if self.check_largest_connect_island(grid=grid): return self.res + 1 return max(self.count_area.values()) def dfs(self,grid,row,col): grid[row][col] = self.idx self.count += 1 for dr,dc in self.direction: _row = dr + row _col = dc + col if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] == 1: self.dfs(grid,_row,_col) return def check_area(self,grid): m, n = len(grid), len(grid[0]) for row in range(m): for col in range(n): self.count_area[grid[row][col]] = self.count_area.get(grid[row][col],0) + 1 return def check_largest_connect_island(self,grid): m, n = len(grid), len(grid[0]) has_connect = False for row in range(m): for col in range(n): if grid[row][col] == 0: has_connect = True area = 0 visited = set() for dr, dc in self.direction: _row = row + dr _col = col + dc if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] != 0 and grid[_row][_col] not in visited: visited.add(grid[_row][_col]) area += self.count_area[grid[_row][_col]] self.res = max(self.res, area) return has_connect def main(): m, n = map(int, input().split()) grid = [] for i in range(m): grid.append(list(map(int,input().split()))) sol = Solution() print(sol.max_area_island(grid)) if __name__ == '__main__': main()",
          "description": "Python代码实现最大岛屿问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "#BFS",
      "resources": [],
      "code_snippets": [
        {
          "language": "c++",
          "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\nint n, m;\nint count;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    grid[x][y] = mark; // 给陆地标记新标签\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty, mark);\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false)); // 标记访问过的点\n    unordered_map<int ,int> gridNum;\n    int mark = 2; // 记录每个岛屿的编号\n    bool isAllGrid = true; // 标记是否整个地图都是陆地\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 0) isAllGrid = false;\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j, mark); // 将与其链接的陆地都标记上 true\n                gridNum[mark] = count; // 记录每一个岛屿的面积\n                mark++; // 记录下一个岛屿编号\n            }\n        }\n    }\n    if (isAllGrid) {\n        cout << n * m << endl; // 如果都是陆地，返回全面积\n        return 0; // 结束程序\n    }\n\n    // 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和\n    int result = 0; // 记录最后结果\n    unordered_set<int> visitedGrid; // 标记访问过的岛屿\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            count = 1; // 记录连接之后的岛屿数量\n            visitedGrid.clear(); // 每次使用时，清空\n            if (grid[i][j] == 0) {\n                for (int k = 0; k < 4; k++) {\n                    int neari = i + dir[k][1]; // 计算相邻坐标\n                    int nearj = j + dir[k][0];\n                    if (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue;\n                    if (visitedGrid.count(grid[neari][nearj])) continue; // 添加过的岛屿不要重复添加\n                    // 把相邻四面的岛屿数量加起来\n                    count += gridNum[grid[neari][nearj]];\n                    visitedGrid.insert(grid[neari][nearj]); // 标记该岛屿已经添加过\n                }\n            }\n            result = max(result, count);\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++代码实现寻找最大岛屿面积的问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static int count;\n    static int mark;\n    static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    public static void dfs(int[][] grid, int x, int y, boolean[][] visited) {\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return;\n        if (visited[x][y] || grid[x][y] == 0) return;\n\n        visited[x][y] = true;\n        count++;\n        grid[x][y] = mark;\n\n        dfs(grid, x, y + 1, visited);\n        dfs(grid, x, y - 1, visited);\n        dfs(grid, x + 1, y, visited);\n        dfs(grid, x - 1, y, visited);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n\n        mark = 2;\n        boolean[][] visited = new boolean[m][n];\n        HashMap<Integer, Integer> getSize = new HashMap<>();\n        HashSet<Integer> set = new HashSet<>();\n        boolean isAllIsland = true;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) isAllIsland = false;\n                if (grid[i][j] == 1) {\n                    count = 0;\n                    dfs(grid, i, j, visited);\n                    getSize.put(mark, count);\n                    mark++;\n                }\n            }\n        }\n\n        int result = 0;\n        if (isAllIsland) result = m * n;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    set.clear();\n                    int curSize = 1;\n\n                    for (int[] dir : dirs) {\n                        int curRow = i + dir[0];\n                        int curCol = j + dir[1];\n\n                        if (curRow < 0 || curRow >= m || curCol < 0 || curCol >= n) continue;\n                        int curMark = grid[curRow][curCol];\n                        if (set.contains(curMark) || !getSize.containsKey(curMark)) continue;\n                        set.add(curMark);\n                        curSize += getSize.get(curMark);\n                    }\n\n                    result = Math.max(result, curSize);\n                }\n            }\n        }\n\n        System.out.println(result);\n    }\n}",
          "description": "Java代码实现寻找最大岛屿面积的问题。"
        },
        {
          "language": "python",
          "code": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self):\n        self.direction = [(1,0),(-1,0),(0,1),(0,-1)]\n        self.res = 0\n        self.count = 0\n        self.idx = 1\n        self.count_area = defaultdict(int)\n\n    def max_area_island(self, grid: List[List[int]]) -> int:\n        if not grid or len(grid) == 0 or len(grid[0]) == 0:\n            return 0\n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    self.count = 0\n                    self.idx += 1\n                    self.dfs(grid,i,j)\n        self.check_area(grid)\n        if self.check_largest_connect_island(grid=grid):\n            return self.res + 1\n        return max(self.count_area.values())\n\n    def dfs(self,grid,row,col):\n        grid[row][col] = self.idx\n        self.count += 1\n        for dr,dc in self.direction:\n            _row = dr + row \n            _col = dc + col \n            if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] == 1:\n                self.dfs(grid,_row,_col)\n        return\n\n    def check_area(self,grid):\n        m, n = len(grid), len(grid[0])\n        for row in range(m):\n            for col in range(n):\n                  self.count_area[grid[row][col]] = self.count_area.get(grid[row][col],0) + 1\n        return\n\n    def check_largest_connect_island(self,grid):\n        m, n = len(grid), len(grid[0])\n        has_connect = False\n        for row in range(m):\n            for col in range(n):\n                if grid[row][col] == 0:\n                    has_connect = True\n                    area = 0\n                    visited = set()\n                    for dr, dc in self.direction:\n                        _row = row + dr \n                        _col = col + dc\n                        if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] != 0 and grid[_row][_col] not in visited:\n                            visited.add(grid[_row][_col])\n                            area += self.count_area[grid[_row][_col]]\n                            self.res = max(self.res, area)\n        return has_connect\n\n\ndef main():\n    m, n = map(int, input().split())\n    grid = []\n\n    for i in range(m):\n        grid.append(list(map(int,input().split())))\n\n    sol = Solution()\n    print(sol.max_area_island(grid))\n\nif __name__ == '__main__':\n    main()",
          "description": "Python代码实现寻找最大岛屿面积的问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "BFS",
      "text": "from typing import List",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) { if (visited[x][y] || grid[x][y] == 0) return; visited[x][y] = true; grid[x][y] = mark; count++; for (int i = 0; i < 4; i++) { int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue; dfs(grid, visited, nextx, nexty, mark); } } int main() { cin >> n >> m; vector<vector<int>> grid(n, vector<int>(m, 0)); for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { cin >> grid[i][j]; } } vector<vector<bool>> visited(n, vector<bool>(m, false)); unordered_map<int, int> gridNum; int mark = 2; bool isAllGrid = true; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { if (grid[i][j] == 0) isAllGrid = false; if (!visited[i][j] && grid[i][j] == 1) { count = 0; dfs(grid, visited, i, j, mark); gridNum[mark] = count; mark++; } } } if (isAllGrid) { cout << n * m << endl; return 0; } int result = 0; unordered_set<int> visitedGrid; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { count = 1; visitedGrid.clear(); if (grid[i][j] == 0) { for (int k = 0; k < 4; k++) { int neari = i + dir[k][1]; int nearj = j + dir[k][0]; if (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue; if (visitedGrid.count(grid[neari][nearj])) continue; count += gridNum[grid[neari][nearj]]; visitedGrid.insert(grid[neari][nearj]); } } result = max(result, count); } } cout << result << endl; }",
          "description": "C++代码实现"
        },
        {
          "language": "java",
          "code": "static int count; static int mark; static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; public static void dfs(int[][] grid, int x, int y, boolean[][] visited) { if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return; if (visited[x][y] || grid[x][y] == 0) return; visited[x][y] = true; count++; grid[x][y] = mark; dfs(grid, x, y + 1, visited); dfs(grid, x, y - 1, visited); dfs(grid, x + 1, y, visited); dfs(grid, x - 1, y, visited); } public static void main (String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); int[][] grid = new int[m][n]; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { grid[i][j] = sc.nextInt(); } } mark = 2; boolean[][] visited = new boolean[m][n]; HashMap<Integer, Integer> getSize = new HashMap<>(); HashSet<Integer> set = new HashSet<>(); boolean isAllIsland = true; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == 0) isAllIsland = false; if (grid[i][j] == 1) { count = 0; dfs(grid, i, j, visited); getSize.put(mark, count); mark++; } } } int result = 0; if (isAllIsland) result = m * n; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == 0) { set.clear(); int curSize = 1; for (int[] dir : dirs) { int curRow = i + dir[0]; int curCol = j + dir[1]; if (curRow < 0 || curRow >= m || curCol < 0 || curCol >= n) continue; int curMark = grid[curRow][curCol]; if (set.contains(curMark) || !getSize.containsKey(curMark)) continue; set.add(curMark); curSize += getSize.get(curMark); } result = Math.max(result, curSize); } } } System.out.println(result); }",
          "description": "Java代码实现"
        },
        {
          "language": "python",
          "code": "from typing import List from collections import defaultdict class Solution: def __init__(self): self.direction = [(1,0),(-1,0),(0,1),(0,-1)] self.res = 0 self.count = 0 self.idx = 1 self.count_area = defaultdict(int) def max_area_island(self, grid: List[List[int]]) -> int: if not grid or len(grid) == 0 or len(grid[0]) == 0: return 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: self.count = 0 self.idx += 1 self.dfs(grid,i,j) self.check_area(grid) if self.check_largest_connect_island(grid=grid): return self.res + 1 return max(self.count_area.values()) def dfs(self,grid,row,col): grid[row][col] = self.idx self.count += 1 for dr,dc in self.direction: _row = dr + row _col = dc + col if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] == 1: self.dfs(grid,_row,_col) return def check_area(self,grid): m, n = len(grid), len(grid[0]) for row in range(m): for col in range(n): self.count_area[grid[row][col]] = self.count_area.get(grid[row][col],0) + 1 return def check_largest_connect_island(self,grid): m, n = len(grid), len(grid[0]) has_connect = False for row in range(m): for col in range(n): if grid[row][col] == 0: has_connect = True area = 0 visited = set() for dr, dc in self.direction: _row = row + dr _col = col + dc if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] != 0 and grid[_row][_col] not in visited: visited.add(grid[_row][_col]) area += self.count_area[grid[_row][_col]] self.res = max(self.res, area) return has_connect def main(): m, n = map(int, input().split()) grid = [] for i in range(m): grid.append(list(map(int,input().split()))) sol = Solution() print(sol.max_area_island(grid)) if __name__ == '__main__': main()",
          "description": "Python代码实现"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) { if (visited[x][y] || grid[x][y] == 0) return; visited[x][y] = true; grid[x][y] = mark; count++; for (int i = 0; i < 4; i++) { int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue; dfs(grid, visited, nextx, nexty, mark); } } int main() { cin >> n >> m; vector<vector<int>> grid(n, vector<int>(m, 0)); for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { cin >> grid[i][j]; } } vector<vector<bool>> visited(n, vector<bool>(m, false)); unordered_map<int ,int> gridNum; int mark = 2; bool isAllGrid = true; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { if (grid[i][j] == 0) isAllGrid = false; if (!visited[i][j] && grid[i][j] == 1) { count = 0; dfs(grid, visited, i, j, mark); gridNum[mark] = count; mark++; } } } if (isAllGrid) { cout << n * m << endl; return 0; } int result = 0; unordered_set<int> visitedGrid; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { count = 1; visitedGrid.clear(); if (grid[i][j] == 0) { for (int k = 0; k < 4; k++) { int neari = i + dir[k][1]; int nearj = j + dir[k][0]; if (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue; if (visitedGrid.count(grid[neari][nearj])) continue; count += gridNum[grid[neari][nearj]]; visitedGrid.insert(grid[neari][nearj]); } } result = max(result, count); } } cout << result << endl; }",
      "description": "C++实现的解决方案，使用DFS遍历岛屿并计算最大面积。"
    },
    {
      "language": "java",
      "code": "public class Main { static int count; static int mark; static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; public static void dfs(int[][] grid, int x, int y, boolean[][] visited) { if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return; if (visited[x][y] || grid[x][y] == 0) return; visited[x][y] = true; count++; grid[x][y] = mark; dfs(grid, x, y + 1, visited); dfs(grid, x, y - 1, visited); dfs(grid, x + 1, y, visited); dfs(grid, x - 1, y, visited); } public static void main (String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); int[][] grid = new int[m][n]; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { grid[i][j] = sc.nextInt(); } } mark = 2; boolean[][] visited = new boolean[m][n]; HashMap<Integer, Integer> getSize = new HashMap<>(); HashSet<Integer> set = new HashSet<>(); boolean isAllIsland = true; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == 0) isAllIsland = false; if (grid[i][j] == 1) { count = 0; dfs(grid, i, j, visited); getSize.put(mark, count); mark++; } } } int result = 0; if (isAllIsland) result = m * n; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == 0) { set.clear(); int curSize = 1; for (int[] dir : dirs) { int curRow = i + dir[0]; int curCol = j + dir[1]; if (curRow < 0 || curRow >= m || curCol < 0 || curCol >= n) continue; int curMark = grid[curRow][curCol]; if (set.contains(curMark) || !getSize.containsKey(curMark)) continue; set.add(curMark); curSize += getSize.get(curMark); } result = Math.max(result, curSize); } } } System.out.println(result); } }",
      "description": "Java实现的解决方案，同样使用DFS来标记和计算岛屿的最大面积。"
    },
    {
      "language": "python",
      "code": "from typing import List from collections import defaultdict class Solution: def __init__(self): self.direction = [(1,0),(-1,0),(0,1),(0,-1)] self.res = 0 self.count = 0 self.idx = 1 self.count_area = defaultdict(int) def max_area_island(self, grid: List[List[int]]) -> int: if not grid or len(grid) == 0 or len(grid[0]) == 0: return 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: self.count = 0 self.idx += 1 self.dfs(grid,i,j) self.check_area(grid) if self.check_largest_connect_island(grid=grid): return self.res + 1 return max(self.count_area.values()) def dfs(self,grid,row,col): grid[row][col] = self.idx self.count += 1 for dr,dc in self.direction: _row = dr + row _col = dc + col if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] == 1: self.dfs(grid,_row,_col) return def check_area(self,grid): m, n = len(grid), len(grid[0]) for row in range(m): for col in range(n): self.count_area[grid[row][col]] = self.count_area.get(grid[row][col],0) + 1 return def check_largest_connect_island(self,grid): m, n = len(grid), len(grid[0]) has_connect = False for row in range(m): for col in range(n): if grid[row][col] == 0: has_connect = True area = 0 visited = set() for dr, dc in self.direction: _row = row + dr _col = col + dc if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] != 0 and grid[_row][_col] not in visited: visited.add(grid[_row][_col]) area += self.count_area[grid[_row][_col]] self.res = max(self.res, area) return has_connect def main(): m, n = map(int, input().split()) grid = [] for i in range(m): grid.append(list(map(int,input().split()))) sol = Solution() print(sol.max_area_island(grid)) if __name__ == '__main__': main()",
      "description": "Python实现的解决方案，采用DFS方法遍历地图并计算岛屿的最大可能面积。"
    }
  ],
  "common_mistakes": [
    "忘记处理边界条件，特别是当尝试访问越界索引时。",
    "没有正确更新岛屿面积或岛屿编号，导致后续计算错误。",
    "忽略了一些特殊情况，比如整个地图都是水域或者全部是陆地的情况。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240522154055.png",
      "description": "这张图片展示了一个4x5的二维数组，其中包含两个分离的“1”区域，可用于图像分割或连通分量分析算法。",
      "context": "这张图片展示了给定的岛屿矩阵示例，帮助理解如何通过改变某些0为1来找到可能的最大岛屿面积。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240522154110.png",
      "description": "该图片展示了两个二维数组（矩阵），每个矩阵中的元素为0或1，黄色高亮部分可能表示特定算法（如图像处理或模式识别）中关注的区域或数据结构的变化。",
      "context": "该图片展示了通过将某些0变为1后形成的具有最大面积岛屿的布局情况。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20220829104834.png",
      "description": "这张图片展示了一个二维数组中的岛屿问题，其中“1”表示陆地，“0”（空白）表示水域，用于算法题中寻找岛屿数量或面积的场景。",
      "context": "这张图片展示了原始地图上的岛屿分布情况，用作示例来解释如何通过遍历地图计算每个岛屿的面积并进行编号。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20220829105644.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20220829105644.png",
      "context": "该图片展示了遍历地图时，如何将岛屿进行编号并统计每个岛屿面积的过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20220829105249.png",
      "description": "这张图片展示了通过将一个0变为1来合并多个岛屿（用不同编号表示），并计算合并后最大岛屿面积的算法过程。",
      "context": "该图展示了遍历每个0方格并统计其相邻岛屿面积的过程，帮助理解如何计算可能的最大人工岛面积。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240522154055.png",
      "description": "GIF展示了将矩阵中的一个0变为1后，通过深度优先搜索计算最大岛屿面积的过程。",
      "context": "GIF动画展示了通过改变地图上的某个0为1来寻找并计算最大岛屿面积的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240522154110.png",
      "description": "GIF展示了通过改变0为1来连接或扩展岛屿，并计算最大岛屿面积的过程。",
      "context": "GIF动画展示了通过将某个0变为1后，地图上形成的最大岛屿面积变化过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20220829104834.png",
      "description": "GIF展示了通过一次遍历地图来标记并计算各个岛屿面积的过程。",
      "context": "该GIF动画展示了地图上各个岛屿被编号并计算面积的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20220829105644.png",
      "description": "GIF展示了通过深度优先搜索算法遍历地图并标记每个岛屿及其面积的过程。",
      "context": "GIF动画展示了遍历地图并统计每个岛屿编号及其面积的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20220829105249.png",
      "description": "GIF展示了通过深度优先搜索（DFS）遍历网格地图，标记并计算每个岛屿面积的过程。",
      "context": "该GIF动画展示了算法中遍历每一个0的方格，并统计其相邻岛屿面积的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\图论\\建造最大岛屿.txt",
  "extracted_at": "2025-07-21T16:47:33.066092",
  "raw_content": "建造最大岛屿\n卡码网题目链接（ACM模式）(https://kamacoder.com/problempage.php?pid=1176)\n\n题目描述：\n\n给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。\n\n岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。\n\n输入描述：\n\n第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。\n\n输出描述：\n\n输出一个整数，表示最大的岛屿面积。\n\n输入示例：\n\n4 5\n1 1 0 0 0\n1 1 0 0 0\n0 0 1 0 0\n0 0 0 1 1\n输出示例\n\n6\n\n提示信息\n\nhttps://file1.kamacoder.com/i/algo/20240522154055.png\n\n对于上面的案例，有两个位置可将 0 变成 1，使得岛屿的面积最大，即 6。\n\nhttps://file1.kamacoder.com/i/algo/20240522154110.png\n\n数据范围：\n\n1 <= M, N <= 50。\n\n#思路\n\n本题的一个暴力想法，应该是遍历地图尝试 将每一个 0 改成1，然后去搜索地图中的最大的岛屿面积。\n\n计算地图的最大面积：遍历地图 + 深搜岛屿，时间复杂度为 n * n。\n\n（其实使用深搜还是广搜都是可以的，其目的就是遍历岛屿做一个标记，相当于染色，那么使用哪个遍历方式都行，以下我用深搜来讲解）\n\n每改变一个0的方格，都需要重新计算一个地图的最大面积，所以 整体时间复杂度为：n^4。\n\n#优化思路\n其实每次深搜遍历计算最大岛屿面积，我们都做了很多重复的工作。\n\n只要用一次深搜把每个岛屿的面积记录下来就好。\n\n第一步：一次遍历地图，得出各个岛屿的面积，并做编号记录。可以使用map记录，key为岛屿编号，value为岛屿面积\n\n第二步：再遍历地图，遍历0的方格（因为要将0变成1），并统计该1（由0变成的1）周边岛屿面积，将其相邻面积相加在一起，遍历所有 0 之后，就可以得出 选一个0变成1 之后的最大面积。\n\n拿如下地图的岛屿情况来举例： （1为陆地）\n\nhttps://file1.kamacoder.com/i/algo/20220829104834.png\n\n第一步，则遍历地图，并将岛屿的编号和面积都统计好，过程如图所示：\n\nhttps://file1.kamacoder.com/i/algo/20220829105644.png\n\n本过程代码如下：\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    grid[x][y] = mark; // 给陆地标记新标签\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty, mark);\n    }\n}\n\nint largestIsland(vector<vector<int>>& grid) {\n    int n = grid.size(), m = grid[0].size();\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false)); // 标记访问过的点\n    unordered_map<int ,int> gridNum;\n    int mark = 2; // 记录每个岛屿的编号\n    bool isAllGrid = true; // 标记是否整个地图都是陆地\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 0) isAllGrid = false;\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j, mark); // 将与其链接的陆地都标记上 true\n                gridNum[mark] = count; // 记录每一个岛屿的面积\n                mark++; // 记录下一个岛屿编号\n            }\n        }\n    }\n}\n这个过程时间复杂度 n * n 。可能有录友想：分明是两个for循环下面套这一个dfs，时间复杂度怎么回事 n * n呢？\n\n其实大家可以仔细看一下代码，n * n这个方格地图中，每个节点我们就遍历一次，并不会重复遍历。\n\n第二步过程如图所示：\n\nhttps://file1.kamacoder.com/i/algo/20220829105249.png\n\n也就是遍历每一个0的方格，并统计其相邻岛屿面积，最后取一个最大值。\n\n这个过程的时间复杂度也为 n * n。\n\n所以整个解法的时间复杂度，为 n * n + n * n 也就是 n^2。\n\n当然这里还有一个优化的点，就是 可以不用 visited数组，因为有mark来标记，所以遍历过的grid[i][j]是不等于1的。\n\n代码如下：\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(vector<vector<int>>& grid, int x, int y, int mark) {\n    if (grid[x][y] != 1 || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    grid[x][y] = mark; // 给陆地标记新标签\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;  // 越界了，直接跳过\n        dfs(grid, nextx, nexty, mark);\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    unordered_map<int ,int> gridNum;\n    int mark = 2; // 记录每个岛屿的编号\n    bool isAllGrid = true; // 标记是否整个地图都是陆地\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 0) isAllGrid = false;\n            if (grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, i, j, mark); // 将与其链接的陆地都标记上 true\n                gridNum[mark] = count; // 记录每一个岛屿的面积\n                mark++; // 记录下一个岛屿编号\n            }\n        }\n    }\n不过为了让各个变量各司其事，代码清晰一些，完整代码还是使用visited数组来标记。\n\n最后，整体代码如下：\n\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\nint n, m;\nint count;\n\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    grid[x][y] = mark; // 给陆地标记新标签\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty, mark);\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false)); // 标记访问过的点\n    unordered_map<int ,int> gridNum;\n    int mark = 2; // 记录每个岛屿的编号\n    bool isAllGrid = true; // 标记是否整个地图都是陆地\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 0) isAllGrid = false;\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j, mark); // 将与其链接的陆地都标记上 true\n                gridNum[mark] = count; // 记录每一个岛屿的面积\n                mark++; // 记录下一个岛屿编号\n            }\n        }\n    }\n    if (isAllGrid) {\n        cout << n * m << endl; // 如果都是陆地，返回全面积\n        return 0; // 结束程序\n    }\n\n    // 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和\n    int result = 0; // 记录最后结果\n    unordered_set<int> visitedGrid; // 标记访问过的岛屿\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            count = 1; // 记录连接之后的岛屿数量\n            visitedGrid.clear(); // 每次使用时，清空\n            if (grid[i][j] == 0) {\n                for (int k = 0; k < 4; k++) {\n                    int neari = i + dir[k][1]; // 计算相邻坐标\n                    int nearj = j + dir[k][0];\n                    if (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue;\n                    if (visitedGrid.count(grid[neari][nearj])) continue; // 添加过的岛屿不要重复添加\n                    // 把相邻四面的岛屿数量加起来\n                    count += gridNum[grid[neari][nearj]];\n                    visitedGrid.insert(grid[neari][nearj]); // 标记该岛屿已经添加过\n                }\n            }\n            result = max(result, count);\n        }\n    }\n    cout << result << endl;\n\n}\n#其他语言版本\n#Java\npublic class Main {\n    // 该方法采用 DFS\n    // 定义全局变量\n    // 记录每次每个岛屿的面积\n    static int count;\n    // 对每个岛屿进行标记\n    static int mark;\n    // 定义二维数组表示四个方位\n    static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    // DFS 进行搜索，将每个岛屿标记为不同的数字\n    public static void dfs(int[][] grid, int x, int y, boolean[][] visited) {\n        // 当遇到边界，直接return\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length) return;\n        // 遇到已经访问过的或者遇到海水，直接返回\n        if (visited[x][y] || grid[x][y] == 0) return;\n\n        visited[x][y] = true;\n        count++;\n        grid[x][y] = mark;\n\n        // 继续向下层搜索\n        dfs(grid, x, y + 1, visited);\n        dfs(grid, x, y - 1, visited);\n        dfs(grid, x + 1, y, visited);\n        dfs(grid, x - 1, y, visited);\n    }\n\n    public static void main (String[] args) {\n        // 接收输入\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n\n        int[][] grid = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n\n        // 初始化mark变量，从2开始（区别于0水，1岛屿）\n        mark = 2;\n\n        // 定义二位boolean数组记录该位置是否被访问\n        boolean[][] visited = new boolean[m][n];\n\n        // 定义一个HashMap，记录某片岛屿的标记号和面积\n        HashMap<Integer, Integer> getSize = new HashMap<>();\n\n        // 定义一个HashSet，用来判断某一位置水四周是否存在不同标记编号的岛屿\n        HashSet<Integer> set = new HashSet<>();\n\n        // 定义一个boolean变量，看看DFS之后，是否全是岛屿\n        boolean isAllIsland = true;\n\n        // 遍历二维数组进行DFS搜索，标记每片岛屿的编号，记录对应的面积\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) isAllIsland = false;\n                if (grid[i][j] == 1) {\n                    count = 0;\n                    dfs(grid, i, j, visited);\n                    getSize.put(mark, count);\n                    mark++;\n                }\n            }\n        }\n\n        int result = 0;\n        if (isAllIsland) result =  m * n;\n\n        // 对标记完的grid继续遍历，判断每个水位置四周是否有岛屿，并记录下四周不同相邻岛屿面积之和\n        // 每次计算完一个水位置周围可能存在的岛屿面积之和，更新下result变量\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    set.clear();\n                    // 当前水位置变更为岛屿，所以初始化为1\n                    int curSize = 1;\n\n                    for (int[] dir : dirs) {\n                        int curRow = i + dir[0];\n                        int curCol = j + dir[1];\n\n                        if (curRow < 0 || curRow >= m || curCol < 0 || curCol >= n) continue;\n                        int curMark = grid[curRow][curCol];\n                        // 如果当前相邻的岛屿已经遍历过或者HashMap中不存在这个编号，继续搜索\n                        if (set.contains(curMark) || !getSize.containsKey(curMark)) continue;\n                        set.add(curMark);\n                        curSize += getSize.get(curMark);\n                    }\n\n                    result = Math.max(result, curSize);\n                }\n            }\n        }\n\n        // 打印结果\n        System.out.println(result);\n    }\n}\n\n#Python\n#BFS\nfrom typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self):\n        self.direction = [(1,0),(-1,0),(0,1),(0,-1)]\n        self.res = 0\n        self.count = 0\n        self.idx = 1\n        self.count_area = defaultdict(int)\n\n    def max_area_island(self, grid: List[List[int]]) -> int:\n        if not grid or len(grid) == 0 or len(grid[0]) == 0:\n            return 0\n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    self.count = 0\n                    self.idx += 1\n                    self.dfs(grid,i,j)\n        # print(grid)\n        self.check_area(grid)\n        # print(self.count_area)\n        \n        if self.check_largest_connect_island(grid=grid):\n            return self.res + 1\n        return max(self.count_area.values())\n    \n    def dfs(self,grid,row,col):\n        grid[row][col] = self.idx\n        self.count += 1\n        for dr,dc in self.direction:\n            _row = dr + row \n            _col = dc + col \n            if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] == 1:\n                self.dfs(grid,_row,_col)\n        return\n\n    def check_area(self,grid):\n        m, n = len(grid), len(grid[0])\n        for row in range(m):\n            for col in range(n):\n                  self.count_area[grid[row][col]] = self.count_area.get(grid[row][col],0) + 1\n        return\n\n    def check_largest_connect_island(self,grid):\n        m, n = len(grid), len(grid[0])\n        has_connect = False\n        for row in range(m):\n            for col in range(n):\n                if grid[row][col] == 0:\n                    has_connect = True\n                    area = 0\n                    visited = set()\n                    for dr, dc in self.direction:\n                        _row = row + dr \n                        _col = col + dc\n                        if 0<=_row<len(grid) and 0<=_col<len(grid[0]) and grid[_row][_col] != 0 and grid[_row][_col] not in visited:\n                            visited.add(grid[_row][_col])\n                            area += self.count_area[grid[_row][_col]]\n                            self.res = max(self.res, area)\n                            \n        return has_connect\n\n\n\n\ndef main():\n    m, n = map(int, input().split())\n    grid = []\n\n    for i in range(m):\n        grid.append(list(map(int,input().split())))\n\n    \n    sol = Solution()\n    print(sol.max_area_island(grid))\n\nif __name__ == '__main__':\n    main()\nimport collections\n\ndirections = [[-1, 0], [0, 1], [0, -1], [1, 0]]\narea = 0\n\ndef dfs(i, j, grid, visited, num):\n    global area\n    \n    if visited[i][j]:\n        return\n\n    visited[i][j] = True\n    grid[i][j] = num  # 标记岛屿号码\n    area += 1\n    \n    for x, y in directions:\n        new_x = i + x\n        new_y = j + y\n        if (\n            0 <= new_x < len(grid)\n            and 0 <= new_y < len(grid[0])\n            and grid[new_x][new_y] == \"1\"\n        ):\n            dfs(new_x, new_y, grid, visited, num)\n    \n\ndef main():\n    global area\n    \n    N, M = map(int, input().strip().split())\n    grid = []\n    for i in range(N):\n        grid.append(input().strip().split())\n    visited = [[False] * M for _ in range(N)]\n    rec = collections.defaultdict(int)\n    \n    cnt = 2\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == \"1\":\n                area = 0\n                dfs(i, j, grid, visited, cnt)\n                rec[cnt] = area  # 纪录岛屿面积\n                cnt += 1\n    \n    res = 0\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == \"0\":\n                max_island = 1  # 将水变为陆地，故从1开始计数\n                v = set()\n                for x, y in directions:\n                    new_x = i + x\n                    new_y = j + y\n                    if (\n                        0 <= new_x < len(grid)\n                        and 0 <= new_y < len(grid[0])\n                        and grid[new_x][new_y] != \"0\"\n                        and grid[new_x][new_y] not in v  # 岛屿不可重复\n                    ):\n                        max_island += rec[grid[new_x][new_y]]\n                        v.add(grid[new_x][new_y])\n                res = max(res, max_island)\n\n    if res == 0:\n        return max(rec.values())  # 无水的情况\n    return res\n    \nif __name__ == \"__main__\":\n    print(main())"
}