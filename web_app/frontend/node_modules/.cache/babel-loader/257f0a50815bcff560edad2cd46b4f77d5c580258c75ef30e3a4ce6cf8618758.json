{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport { getPtg } from './useSizes';\n/**\n * Handle user drag resize logic.\n */\nexport default function useResize(items, resizableInfos, percentSizes, containerSize, updateSizes, isRTL) {\n  const limitSizes = items.map(item => [item.min, item.max]);\n  const mergedContainerSize = containerSize || 0;\n  const ptg2px = ptg => ptg * mergedContainerSize;\n  // ======================== Resize ========================\n  function getLimitSize(str, defaultLimit) {\n    if (typeof str === 'string') {\n      return ptg2px(getPtg(str));\n    }\n    return str !== null && str !== void 0 ? str : defaultLimit;\n  }\n  // Real px sizes\n  const [cacheSizes, setCacheSizes] = React.useState([]);\n  const cacheCollapsedSize = React.useRef([]);\n  /**\n   * When start drag, check the direct is `start` or `end`.\n   * This will handle when 2 splitter bar are in the same position.\n   */\n  const [movingIndex, setMovingIndex] = React.useState(null);\n  const getPxSizes = () => percentSizes.map(ptg2px);\n  const onOffsetStart = index => {\n    setCacheSizes(getPxSizes());\n    setMovingIndex({\n      index,\n      confirmed: false\n    });\n  };\n  const onOffsetUpdate = (index, offset) => {\n    var _a;\n    // First time trigger move index update is not sync in the state\n    let confirmedIndex = null;\n    // We need to know what the real index is.\n    if ((!movingIndex || !movingIndex.confirmed) && offset !== 0) {\n      // Search for the real index\n      if (offset > 0) {\n        confirmedIndex = index;\n        setMovingIndex({\n          index,\n          confirmed: true\n        });\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cacheSizes[i] > 0 && resizableInfos[i].resizable) {\n            confirmedIndex = i;\n            setMovingIndex({\n              index: i,\n              confirmed: true\n            });\n            break;\n          }\n        }\n      }\n    }\n    const mergedIndex = (_a = confirmedIndex !== null && confirmedIndex !== void 0 ? confirmedIndex : movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index) !== null && _a !== void 0 ? _a : index;\n    const numSizes = _toConsumableArray(cacheSizes);\n    const nextIndex = mergedIndex + 1;\n    // Get boundary\n    const startMinSize = getLimitSize(limitSizes[mergedIndex][0], 0);\n    const endMinSize = getLimitSize(limitSizes[nextIndex][0], 0);\n    const startMaxSize = getLimitSize(limitSizes[mergedIndex][1], mergedContainerSize);\n    const endMaxSize = getLimitSize(limitSizes[nextIndex][1], mergedContainerSize);\n    let mergedOffset = offset;\n    // Align with the boundary\n    if (numSizes[mergedIndex] + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex] - endMinSize;\n    }\n    if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex] - endMaxSize;\n    }\n    // Do offset\n    numSizes[mergedIndex] += mergedOffset;\n    numSizes[nextIndex] -= mergedOffset;\n    updateSizes(numSizes);\n    return numSizes;\n  };\n  const onOffsetEnd = () => {\n    setMovingIndex(null);\n  };\n  // ======================= Collapse =======================\n  const onCollapse = (index, type) => {\n    const currentSizes = getPxSizes();\n    const adjustedType = isRTL ? type === 'start' ? 'end' : 'start' : type;\n    const currentIndex = adjustedType === 'start' ? index : index + 1;\n    const targetIndex = adjustedType === 'start' ? index + 1 : index;\n    const currentSize = currentSizes[currentIndex];\n    const targetSize = currentSizes[targetIndex];\n    if (currentSize !== 0 && targetSize !== 0) {\n      // Collapse directly\n      currentSizes[currentIndex] = 0;\n      currentSizes[targetIndex] += currentSize;\n      cacheCollapsedSize.current[index] = currentSize;\n    } else {\n      const totalSize = currentSize + targetSize;\n      const currentSizeMin = getLimitSize(limitSizes[currentIndex][0], 0);\n      const currentSizeMax = getLimitSize(limitSizes[currentIndex][1], mergedContainerSize);\n      const targetSizeMin = getLimitSize(limitSizes[targetIndex][0], 0);\n      const targetSizeMax = getLimitSize(limitSizes[targetIndex][1], mergedContainerSize);\n      const limitStart = Math.max(currentSizeMin, totalSize - targetSizeMax);\n      const limitEnd = Math.min(currentSizeMax, totalSize - targetSizeMin);\n      const halfOffset = targetSizeMin || (limitEnd - limitStart) / 2;\n      const targetCacheCollapsedSize = cacheCollapsedSize.current[index];\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;\n      const shouldUseCache = targetCacheCollapsedSize && targetCacheCollapsedSize <= targetSizeMax && targetCacheCollapsedSize >= targetSizeMin && currentCacheCollapsedSize <= currentSizeMax && currentCacheCollapsedSize >= currentSizeMin;\n      if (shouldUseCache) {\n        currentSizes[targetIndex] = targetCacheCollapsedSize;\n        currentSizes[currentIndex] = currentCacheCollapsedSize;\n      } else {\n        currentSizes[currentIndex] -= halfOffset;\n        currentSizes[targetIndex] += halfOffset;\n      }\n    }\n    updateSizes(currentSizes);\n    return currentSizes;\n  };\n  return [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index];\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}