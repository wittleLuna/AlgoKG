{
  "id": "AP_b55842fd",
  "title": "岛屿的最大面积",
  "alternative_titles": [],
  "platform": "kamacoder",
  "url": "https://kamacoder.com/problempage.php?pid=1172",
  "description": "一个由 1（陆地）和 0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。\n\n输入描述\n\n第一行包含两个整数 N, M，表示矩阵的行数和列数。后续 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。\n\n输出描述\n\n输出一个整数，表示岛屿的最大面积。如果不存在岛屿，则输出 0。\n\n输入",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "深度优先搜索",
    "广度优先搜索"
  ],
  "data_structure_tags": [
    "二维数组",
    "布尔数组"
  ],
  "technique_tags": [
    "图的遍历",
    "递归",
    "队列"
  ],
  "difficulty": null,
  "solution_approach": "通过深度优先搜索(DFS)或广度优先搜索(BFS)遍历矩阵中的每个岛屿，计算每个岛屿的面积，并记录最大值。当遇到陆地（值为1）时，使用DFS或BFS来标记所有相连的陆地并计算其总面积。",
  "key_insights": [
    {
      "content": "岛屿由水平方向或垂直方向上相邻的陆地连接而成，这意味着在探索过程中只需考虑上下左右四个方向。"
    },
    {
      "content": "无论是DFS还是BFS都可以用来解决这个问题，选择哪种方法取决于具体实现和个人偏好。这两种方法都能有效地遍历整个岛屿并且不会重复访问同一个位置。"
    },
    {
      "content": "第一种是在主函数中遇到陆地就先计数为1，然后递归处理相邻的陆地；第二种则是在进入DFS前将计数设为0，在DFS内部开始计数。两者都能正确解决问题，但逻辑略有不同。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "注意题目中每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            count++;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 1;\n                visited[i][j] = true;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的DFS算法，用于计算岛屿的最大面积。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "另一种C++版本的DFS算法实现，同样用于查找矩阵中岛屿的最大面积。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main{\n\nstatic final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};\nstatic int result=0;\nstatic int count=0;\n\npublic static void main(String[] args){\n    Scanner scanner = new Scanner(System.in);\n    int n = scanner.nextInt();\n    int m = scanner.nextInt();\n    int[][] map = new int[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            map[i][j]=scanner.nextInt();\n        }\n    }\n    boolean[][] visited = new boolean[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if(!visited[i][j]&&map[i][j]==1){\n                count=0;\n                dfs(map,visited,i,j);\n                result= Math.max(count, result);\n            }\n        }\n    }\n    System.out.println(result);\n}\n\nstatic void dfs(int[][] map,boolean[][] visited,int x,int y){\n            count++;\n            visited[x][y]=true;\n            for (int i = 0; i < 4; i++) {\n                int nextX=x+dir[i][0];\n                int nextY=y+dir[i][1];\n                if(nextX<0||nextY<0||nextX>=map.length||nextY>=map[0].length||visited[nextX][nextY]||map[nextX][nextY]==0)continue;\n                \n                dfs(map,visited,nextX,nextY);\n            }\n        }\n}",
          "description": "Java语言下的DFS方法实现，用于求解给定矩阵内最大岛屿面积。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main {\n    static class Node {\n        int x;\n        int y;\n\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    static int result = 0;\n    static int count = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j] = scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && map[i][j] == 1) {\n                    count = 0;\n                    bfs(map, visited, i, j);\n                    result = Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void bfs(int[][] map, boolean[][] visited, int x, int y) {\n        Queue<Node> q = new LinkedList<>();\n        q.add(new Node(x, y));\n        visited[x][y] = true;\n        count++;\n        while (!q.isEmpty()) {\n            Node node = q.remove();\n            for (int i = 0; i < 4; i++) {\n                int nextX = node.x + dir[i][0];\n                int nextY = node.y + dir[i][1];\n                if (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)\n                    continue;\n                q.add(new Node(nextX, nextY));\n                visited[nextX][nextY] = true;\n                count++;\n            }\n        }\n    }\n}",
          "description": "使用Java编写的BFS算法来解决寻找矩阵中最大岛屿面积的问题。"
        },
        {
          "language": "python",
          "code": "position = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef dfs(grid, visited, x, y):\n    global count\n    for i, j in position:\n        cur_x = x + i\n        cur_y = y + j\n        if cur_x < 0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]):\n            continue\n        if not visited[cur_x][cur_y] and grid[cur_x][cur_y] == 1:\n            visited[cur_x][cur_y] = True\n            count += 1\n            dfs(grid, visited, cur_x, cur_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            dfs(grid, visited, i, j)\n            result = max(count, result)\nprint(result)",
          "description": "Python语言实现的DFS算法，用来找出二维矩阵中最大的连通陆地块（岛屿）的面积。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef bfs(grid, visited, x, y):\n    global count\n    que = deque()\n    que.append([x, y])\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in position:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n                continue\n            if grid[next_x][next_y] == 1 and not visited[next_x][next_y]:\n                visited[next_x][next_y] = True\n                count += 1\n                que.append([next_x, next_y])\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            bfs(grid, visited, i, j)\n            res = max(result, count)\nprint(result)",
          "description": "利用Python中的队列实现BFS算法，用于计算给定矩阵中最大岛屿的面积。"
        }
      ],
      "subsections": []
    },
    {
      "name": "DFS",
      "text": "很多同学写dfs其实也是凭感觉来的，有的时候dfs函数中写终止条件才能过，有的时候 dfs函数不写终止添加也能过！",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            count++;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 1;\n                visited[i][j] = true;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "使用DFS计算岛屿的最大面积"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "使用另一种写法的DFS计算岛屿的最大面积"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    int count;\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n    void bfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n        queue<int> que;\n        que.push(x);\n        que.push(y);\n        visited[x][y] = true;\n        count++;\n        while(!que.empty()) {\n            int xx = que.front();que.pop();\n            int yy = que.front();que.pop();\n            for (int i = 0 ;i < 4; i++) {\n                int nextx = xx + dir[i][0];\n                int nexty = yy + dir[i][1];\n                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n                if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                    visited[nextx][nexty] = true;\n                    count++;\n                    que.push(nextx);\n                    que.push(nexty);\n                }\n            }\n        }\n    }\n\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    count = 0;\n                    bfs(grid, visited, i, j);\n                    result = max(result, count);\n                }\n            }\n        }\n        return result;\n    }\n};",
          "description": "使用BFS计算岛屿的最大面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main{\n\n    static final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};\n    static int result=0;\n    static int count=0;\n\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j]=scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if(!visited[i][j]&&map[i][j]==1){\n                    count=0;\n                    dfs(map,visited,i,j);\n                    result= Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void dfs(int[][] map,boolean[][] visited,int x,int y){\n                count++;\n                visited[x][y]=true;\n                for (int i = 0; i < 4; i++) {\n                    int nextX=x+dir[i][0];\n                    int nextY=y+dir[i][1];\n                    if(nextX<0||nextY<0\n                    ||nextX>=map.length||nextY>=map[0].length\n                    ||visited[nextX][nextY]||map[nextX][nextY]==0)continue;\n\n                    dfs(map,visited,nextX,nextY);\n                }\n            }\n}",
          "description": "Java版本使用DFS计算岛屿的最大面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main {\n    static class Node {\n        int x;\n        int y;\n\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    static int result = 0;\n    static int count = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j] = scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && map[i][j] == 1) {\n                    count = 0;\n                    bfs(map, visited, i, j);\n                    result = Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void bfs(int[][] map, boolean[][] visited, int x, int y) {\n        Queue<Node> q = new LinkedList<>();\n        q.add(new Node(x, y));\n        visited[x][y] = true;\n        count++;\n        while (!q.isEmpty()) {\n            Node node = q.remove();\n            for (int i = 0; i < 4; i++) {\n                int nextX = node.x + dir[i][0];\n                int nextY = node.y + dir[i][1];\n                if (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)\n                    continue;\n                q.add(new Node(nextX, nextY));\n                visited[nextX][nextY] = true;\n                count++;\n            }\n        }\n    }\n}",
          "description": "Java版本使用BFS计算岛屿的最大面积"
        },
        {
          "language": "python",
          "code": "position = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef dfs(grid, visited, x, y):\n    global count\n    for i, j in position:\n        cur_x = x + i\n        cur_y = y + j\n        if cur_x < 0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]):\n            continue\n        if not visited[cur_x][cur_y] and grid[cur_x][cur_y] == 1:\n            visited[cur_x][cur_y] = True\n            count += 1\n            dfs(grid, visited, cur_x, cur_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            dfs(grid, visited, i, j)\n            result = max(count, result)\nprint(result)",
          "description": "Python版本使用DFS计算岛屿的最大面积"
        },
        {
          "language": "python",
          "code": "from collections import deque\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef bfs(grid, visited, x, y):\n    global count\n    que = deque()\n    que.append([x, y])\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in position:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n                continue\n            if grid[next_x][next_y] == 1 and not visited[next_x][next_y]:\n                visited[next_x][next_y] = True\n                count += 1\n                que.append([next_x, next_y])\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            bfs(grid, visited, i, j)\n            res = max(result, count)\nprint(result)",
          "description": "Python版本使用BFS计算岛屿的最大面积"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            count++;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 1;\n                visited[i][j] = true;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++ DFS实现，计算岛屿的最大面积"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++ 另一种DFS实现，计算岛屿的最大面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\npublic class Main{\n    static final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};\n    static int result=0;\n    static int count=0;\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j]=scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if(!visited[i][j]&&map[i][j]==1){\n                    count=0;\n                    dfs(map,visited,i,j);\n                    result= Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n    static void dfs(int[][] map,boolean[][] visited,int x,int y){\n        count++;\n        visited[x][y]=true;\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextX<0||nextY<0||nextX>=map.length||nextY>=map[0].length||visited[nextX][nextY]||map[nextX][nextY]==0)continue;\n            dfs(map,visited,nextX,nextY);\n        }\n    }\n}",
          "description": "Java DFS实现，计算岛屿的最大面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\npublic class Main {\n    static class Node {\n        int x;\n        int y;\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    static int result = 0;\n    static int count = 0;\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j] = scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && map[i][j] == 1) {\n                    count = 0;\n                    bfs(map, visited, i, j);\n                    result = Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n    static void bfs(int[][] map, boolean[][] visited, int x, int y) {\n        Queue<Node> q = new LinkedList<>();\n        q.add(new Node(x, y));\n        visited[x][y] = true;\n        count++;\n        while (!q.isEmpty()) {\n            Node node = q.remove();\n            for (int i = 0; i < 4; i++) {\n                int nextX = node.x + dir[i][0];\n                int nextY = node.y + dir[i][1];\n                if (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)\n                    continue;\n                q.add(new Node(nextX, nextY));\n                visited[nextX][nextY] = true;\n                count++;\n            }\n        }\n    }\n}",
          "description": "Java BFS实现，计算岛屿的最大面积"
        },
        {
          "language": "python",
          "code": "position = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef dfs(grid, visited, x, y):\n    global count\n    for i, j in position:\n        cur_x = x + i\n        cur_y = y + j\n        if cur_x < 0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]):\n            continue\n        if not visited[cur_x][cur_y] and grid[cur_x][cur_y] == 1:\n            visited[cur_x][cur_y] = True\n            count += 1\n            dfs(grid, visited, cur_x, cur_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            dfs(grid, visited, i, j)\n            result = max(count, result)\nprint(result)",
          "description": "Python DFS实现，计算岛屿的最大面积"
        },
        {
          "language": "python",
          "code": "from collections import deque\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef bfs(grid, visited, x, y):\n    global count\n    que = deque()\n    que.append([x, y])\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in position:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n                continue\n            if grid[next_x][next_y] == 1 and not visited[next_x][next_y]:\n                visited[next_x][next_y] = True\n                count += 1\n                que.append([next_x, next_y])\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            bfs(grid, visited, i, j)\n            res = max(result, count)\nprint(result)",
          "description": "Python BFS实现，计算岛屿的最大面积"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            count++;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 1;\n                visited[i][j] = true;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的DFS算法解决岛屿最大面积问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的另一种DFS算法解决岛屿最大面积问题"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    int count;\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n    void bfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n        queue<int> que;\n        que.push(x);\n        que.push(y);\n        visited[x][y] = true;\n        count++;\n        while(!que.empty()) {\n            int xx = que.front();que.pop();\n            int yy = que.front();que.pop();\n            for (int i = 0 ;i < 4; i++) {\n                int nextx = xx + dir[i][0];\n                int nexty = yy + dir[i][1];\n                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n                if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                    visited[nextx][nexty] = true;\n                    count++;\n                    que.push(nextx);\n                    que.push(nexty);\n                }\n            }\n        }\n    }\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    count = 0;\n                    bfs(grid, visited, i, j);\n                    result = max(result, count);\n                }\n            }\n        }\n        return result;\n    }\n};",
          "description": "C++版本的BFS算法解决岛屿最大面积问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\npublic class Main{\n    static final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};\n    static int result=0;\n    static int count=0;\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j]=scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if(!visited[i][j]&&map[i][j]==1){\n                    count=0;\n                    dfs(map,visited,i,j);\n                    result= Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n    static void dfs(int[][] map,boolean[][] visited,int x,int y){\n        count++;\n        visited[x][y]=true;\n        for (int i = 0; i < 4; i++) {\n            int nextX=x+dir[i][0];\n            int nextY=y+dir[i][1];\n            if(nextX<0||nextY<0||nextX>=map.length||nextY>=map[0].length||visited[nextX][nextY]||map[nextX][nextY]==0)continue;\n            dfs(map,visited,nextX,nextY);\n        }\n    }\n}",
          "description": "Java版本的DFS算法解决岛屿最大面积问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\npublic class Main {\n    static class Node {\n        int x;\n        int y;\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    static int result = 0;\n    static int count = 0;\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j] = scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && map[i][j] == 1) {\n                    count = 0;\n                    bfs(map, visited, i, j);\n                    result = Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n    static void bfs(int[][] map, boolean[][] visited, int x, int y) {\n        Queue<Node> q = new LinkedList<>();\n        q.add(new Node(x, y));\n        visited[x][y] = true;\n        count++;\n        while (!q.isEmpty()) {\n            Node node = q.remove();\n            for (int i = 0; i < 4; i++) {\n                int nextX = node.x + dir[i][0];\n                int nextY = node.y + dir[i][1];\n                if (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)\n                    continue;\n                q.add(new Node(nextX, nextY));\n                visited[nextX][nextY] = true;\n                count++;\n            }\n        }\n    }\n}",
          "description": "Java版本的BFS算法解决岛屿最大面积问题"
        },
        {
          "language": "python",
          "code": "position = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef dfs(grid, visited, x, y):\n    global count\n    for i, j in position:\n        cur_x = x + i\n        cur_y = y + j\n        if cur_x < 0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]):\n            continue\n        if not visited[cur_x][cur_y] and grid[cur_x][cur_y] == 1:\n            visited[cur_x][cur_y] = True\n            count += 1\n            dfs(grid, visited, cur_x, cur_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            dfs(grid, visited, i, j)\n            result = max(count, result)\nprint(result)",
          "description": "Python版本的DFS算法解决岛屿最大面积问题"
        },
        {
          "language": "python",
          "code": "from collections import deque\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef bfs(grid, visited, x, y):\n    global count\n    que = deque()\n    que.append([x, y])\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in position:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n                continue\n            if grid[next_x][next_y] == 1 and not visited[next_x][next_y]:\n                visited[next_x][next_y] = True\n                count += 1\n                que.append([next_x, next_y])\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            bfs(grid, visited, i, j)\n            res = max(result, count)\nprint(result)",
          "description": "Python版本的BFS算法解决岛屿最大面积问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 没有访问过的 同时 是陆地的\n            visited[nextx][nexty] = true;\n            count++;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 1;  // 因为dfs处理下一个节点，所以这里遇到陆地了就先计数，dfs处理接下来的相邻陆地\n                visited[i][j] = true;\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本一：DFS处理当前节点的相邻节点"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0; // 因为dfs处理当前节点，所以遇到陆地计数为0，进dfs之后在开始从1计数\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本二：DFS处理当前节点"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\n/**\n * DFS版\n */\npublic class Main{\n\n    static final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};\n    static int result=0;\n    static int count=0;\n\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j]=scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if(!visited[i][j]&&map[i][j]==1){\n                    count=0;\n                    dfs(map,visited,i,j);\n                    result= Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void dfs(int[][] map,boolean[][] visited,int x,int y){\n                count++;\n                visited[x][y]=true;\n                for (int i = 0; i < 4; i++) {\n                    int nextX=x+dir[i][0];\n                    int nextY=y+dir[i][1];\n                    //水或者已经访问过的跳过\n                    if(nextX<0||nextY<0\n                    ||nextX>=map.length||nextY>=map[0].length\n                    ||visited[nextX][nextY]||map[nextX][nextY]==0)continue;\n                    \n                    dfs(map,visited,nextX,nextY);\n                }\n            }\n}",
          "description": "Java版本：DFS实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\n/**\n * BFS版\n */\npublic class Main {\n    static class Node {\n        int x;\n        int y;\n\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    static int result = 0;\n    static int count = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j] = scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && map[i][j] == 1) {\n                    count = 0;\n                    bfs(map, visited, i, j);\n                    result = Math.max(count, result);\n\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void bfs(int[][] map, boolean[][] visited, int x, int y) {\n        Queue<Node> q = new LinkedList<>();\n        q.add(new Node(x, y));\n        visited[x][y] = true;\n        count++;\n        while (!q.isEmpty()) {\n            Node node = q.remove();\n            for (int i = 0; i < 4; i++) {\n                int nextX = node.x + dir[i][0];\n                int nextY = node.y + dir[i][1];\n                if (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)\n                    continue;\n                q.add(new Node(nextX, nextY));\n                visited[nextX][nextY] = true;\n                count++;\n            }\n        }\n    }\n}",
          "description": "Java版本：BFS实现"
        },
        {
          "language": "python",
          "code": "position = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef dfs(grid, visited, x, y):\n    global count\n    for i, j in position:\n        cur_x = x + i\n        cur_y = y + j\n        if cur_x < 0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]):\n            continue\n        if not visited[cur_x][cur_y] and grid[cur_x][cur_y] == 1:\n            visited[cur_x][cur_y] = True\n            count += 1\n            dfs(grid, visited, cur_x, cur_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            dfs(grid, visited, i, j)\n            result = max(count, result)\nprint(result)",
          "description": "Python版本：DFS实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef bfs(grid, visited, x, y):\n    global count\n    que = deque()\n    que.append([x, y])\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in position:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n                continue\n            if grid[next_x][next_y] == 1 and not visited[next_x][next_y]:\n                visited[next_x][next_y] = True\n                count += 1\n                que.append([next_x, next_y])\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            bfs(grid, visited, i, j)\n            res = max(result, count)\nprint(result)",
          "description": "Python版本：BFS实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            count++;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 1;\n                visited[i][j] = true;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++ DFS实现岛屿最大面积计算"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++ 另一种DFS实现岛屿最大面积计算"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    int count;\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n    void bfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n        queue<int> que;\n        que.push(x);\n        que.push(y);\n        visited[x][y] = true;\n        count++;\n        while(!que.empty()) {\n            int xx = que.front();que.pop();\n            int yy = que.front();que.pop();\n            for (int i = 0 ;i < 4; i++) {\n                int nextx = xx + dir[i][0];\n                int nexty = yy + dir[i][1];\n                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n                if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                    visited[nextx][nexty] = true;\n                    count++;\n                    que.push(nextx);\n                    que.push(nexty);\n                }\n            }\n        }\n    }\n\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    count = 0;\n                    bfs(grid, visited, i, j);\n                    result = max(result, count);\n                }\n            }\n        }\n        return result;\n    }\n};",
          "description": "C++ BFS实现岛屿最大面积计算"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main{\n\n    static final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};\n    static int result=0;\n    static int count=0;\n\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j]=scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if(!visited[i][j]&&map[i][j]==1){\n                    count=0;\n                    dfs(map,visited,i,j);\n                    result= Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void dfs(int[][] map,boolean[][] visited,int x,int y){\n                count++;\n                visited[x][y]=true;\n                for (int i = 0; i < 4; i++) {\n                    int nextX=x+dir[i][0];\n                    int nextY=y+dir[i][1];\n                    if(nextX<0||nextY<0||nextX>=map.length||nextY>=map[0].length||visited[nextX][nextY]||map[nextX][nextY]==0)continue;\n                    dfs(map,visited,nextX,nextY);\n                }\n            }\n}",
          "description": "Java DFS实现岛屿最大面积计算"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main {\n    static class Node {\n        int x;\n        int y;\n\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    static int result = 0;\n    static int count = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j] = scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && map[i][j] == 1) {\n                    count = 0;\n                    bfs(map, visited, i, j);\n                    result = Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void bfs(int[][] map, boolean[][] visited, int x, int y) {\n        Queue<Node> q = new LinkedList<>();\n        q.add(new Node(x, y));\n        visited[x][y] = true;\n        count++;\n        while (!q.isEmpty()) {\n            Node node = q.remove();\n            for (int i = 0; i < 4; i++) {\n                int nextX = node.x + dir[i][0];\n                int nextY = node.y + dir[i][1];\n                if (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)\n                    continue;\n                q.add(new Node(nextX, nextY));\n                visited[nextX][nextY] = true;\n                count++;\n            }\n        }\n    }\n}",
          "description": "Java BFS实现岛屿最大面积计算"
        },
        {
          "language": "python",
          "code": "position = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef dfs(grid, visited, x, y):\n    global count\n    for i, j in position:\n        cur_x = x + i\n        cur_y = y + j\n        if cur_x < 0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]):\n            continue\n        if not visited[cur_x][cur_y] and grid[cur_x][cur_y] == 1:\n            visited[cur_x][cur_y] = True\n            count += 1\n            dfs(grid, visited, cur_x, cur_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            dfs(grid, visited, i, j)\n            result = max(count, result)\nprint(result)",
          "description": "Python DFS实现岛屿最大面积计算"
        },
        {
          "language": "python",
          "code": "from collections import deque\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef bfs(grid, visited, x, y):\n    global count\n    que = deque()\n    que.append([x, y])\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in position:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n                continue\n            if grid[next_x][next_y] == 1 and not visited[next_x][next_y]:\n                visited[next_x][next_y] = True\n                count += 1\n                que.append([next_x, next_y])\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            bfs(grid, visited, i, j)\n            res = max(result, count)\nprint(result)",
          "description": "Python BFS实现岛屿最大面积计算"
        }
      ],
      "subsections": []
    },
    {
      "name": "BFS",
      "text": "关于广度优先搜索，如果大家还不了解的话，看这里：广度优先搜索精讲 https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%BF%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            count++;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 1;\n                visited[i][j] = true;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的DFS求解岛屿最大面积"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的另一种DFS实现求解岛屿最大面积"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    int count;\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n    void bfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n        queue<int> que;\n        que.push(x);\n        que.push(y);\n        visited[x][y] = true;\n        count++;\n        while(!que.empty()) {\n            int xx = que.front();que.pop();\n            int yy = que.front();que.pop();\n            for (int i = 0 ;i < 4; i++) {\n                int nextx = xx + dir[i][0];\n                int nexty = yy + dir[i][1];\n                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n                if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                    visited[nextx][nexty] = true;\n                    count++;\n                    que.push(nextx);\n                    que.push(nexty);\n                }\n            }\n        }\n    }\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    count = 0;\n                    bfs(grid, visited, i, j);\n                    result = max(result, count);\n                }\n            }\n        }\n        return result;\n    }\n};",
          "description": "C++版本的BFS求解岛屿最大面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main{\n\nstatic final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};\nstatic int result=0;\nstatic int count=0;\n\npublic static void main(String[] args){\n    Scanner scanner = new Scanner(System.in);\n    int n = scanner.nextInt();\n    int m = scanner.nextInt();\n    int[][] map = new int[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            map[i][j]=scanner.nextInt();\n        }\n    }\n    boolean[][] visited = new boolean[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if(!visited[i][j]&&map[i][j]==1){\n                count=0;\n                dfs(map,visited,i,j);\n                result= Math.max(count, result);\n            }\n        }\n    }\n    System.out.println(result);\n}\n\nstatic void dfs(int[][] map,boolean[][] visited,int x,int y){\n            count++;\n            visited[x][y]=true;\n            for (int i = 0; i < 4; i++) {\n                int nextX=x+dir[i][0];\n                int nextY=y+dir[i][1];\n                if(nextX<0||nextY<0||nextX>=map.length||nextY>=map[0].length||visited[nextX][nextY]||map[nextX][nextY]==0)continue;\n                \n                dfs(map,visited,nextX,nextY);\n            }\n        }\n}",
          "description": "Java版本的DFS求解岛屿最大面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main {\n    static class Node {\n        int x;\n        int y;\n\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    static int result = 0;\n    static int count = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j] = scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && map[i][j] == 1) {\n                    count = 0;\n                    bfs(map, visited, i, j);\n                    result = Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void bfs(int[][] map, boolean[][] visited, int x, int y) {\n        Queue<Node> q = new LinkedList<>();\n        q.add(new Node(x, y));\n        visited[x][y] = true;\n        count++;\n        while (!q.isEmpty()) {\n            Node node = q.remove();\n            for (int i = 0; i < 4; i++) {\n                int nextX = node.x + dir[i][0];\n                int nextY = node.y + dir[i][1];\n                if (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)\n                    continue;\n                q.add(new Node(nextX, nextY));\n                visited[nextX][nextY] = true;\n                count++;\n            }\n        }\n    }\n}",
          "description": "Java版本的BFS求解岛屿最大面积"
        },
        {
          "language": "python",
          "code": "position = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef dfs(grid, visited, x, y):\n    global count\n    for i, j in position:\n        cur_x = x + i\n        cur_y = y + j\n        if cur_x < 0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]):\n            continue\n        if not visited[cur_x][cur_y] and grid[cur_x][cur_y] == 1:\n            visited[cur_x][cur_y] = True\n            count += 1\n            dfs(grid, visited, cur_x, cur_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            dfs(grid, visited, i, j)\n            result = max(count, result)\nprint(result)",
          "description": "Python版本的DFS求解岛屿最大面积"
        },
        {
          "language": "python",
          "code": "from collections import deque\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef bfs(grid, visited, x, y):\n    global count\n    que = deque()\n    que.append([x, y])\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in position:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n                continue\n            if grid[next_x][next_y] == 1 and not visited[next_x][next_y]:\n                visited[next_x][next_y] = True\n                count += 1\n                que.append([next_x, next_y])\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            bfs(grid, visited, i, j)\n            res = max(result, count)\nprint(result)",
          "description": "Python版本的BFS求解岛屿最大面积"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            count++;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 1;\n                visited[i][j] = true;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++ DFS版本一"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++ DFS版本二"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main{\n\nstatic final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};\nstatic int result=0;\nstatic int count=0;\n\npublic static void main(String[] args){\n    Scanner scanner = new Scanner(System.in);\n    int n = scanner.nextInt();\n    int m = scanner.nextInt();\n    int[][] map = new int[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            map[i][j]=scanner.nextInt();\n        }\n    }\n    boolean[][] visited = new boolean[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if(!visited[i][j]&&map[i][j]==1){\n                count=0;\n                dfs(map,visited,i,j);\n                result= Math.max(count, result);\n            }\n        }\n    }\n    System.out.println(result);\n}\n\nstatic void dfs(int[][] map,boolean[][] visited,int x,int y){\n            count++;\n            visited[x][y]=true;\n            for (int i = 0; i < 4; i++) {\n                int nextX=x+dir[i][0];\n                int nextY=y+dir[i][1];\n                //水或者已经访问过的跳过\n                if(nextX<0||nextY<0\n                ||nextX>=map.length||nextY>=map[0].length\n                ||visited[nextX][nextY]||map[nextX][nextY]==0)continue;\n                \n                dfs(map,visited,nextX,nextY);\n            }\n        }\n}",
          "description": "Java DFS版本"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main {\n    static class Node {\n        int x;\n        int y;\n\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    static int result = 0;\n    static int count = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j] = scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && map[i][j] == 1) {\n                    count = 0;\n                    bfs(map, visited, i, j);\n                    result = Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void bfs(int[][] map, boolean[][] visited, int x, int y) {\n        Queue<Node> q = new LinkedList<>();\n        q.add(new Node(x, y));\n        visited[x][y] = true;\n        count++;\n        while (!q.isEmpty()) {\n            Node node = q.remove();\n            for (int i = 0; i < 4; i++) {\n                int nextX = node.x + dir[i][0];\n                int nextY = node.y + dir[i][1];\n                if (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)\n                    continue;\n                q.add(new Node(nextX, nextY));\n                visited[nextX][nextY] = true;\n                count++;\n            }\n        }\n    }\n}",
          "description": "Java BFS版本"
        },
        {
          "language": "python",
          "code": "position = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef dfs(grid, visited, x, y):\n    global count\n    for i, j in position:\n        cur_x = x + i\n        cur_y = y + j\n        if cur_x < 0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]):\n            continue\n        if not visited[cur_x][cur_y] and grid[cur_x][cur_y] == 1:\n            visited[cur_x][cur_y] = True\n            count += 1\n            dfs(grid, visited, cur_x, cur_y)\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n)]\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            dfs(grid, visited, i, j)\n            result = max(count, result)\nprint(result)",
          "description": "Python DFS版本"
        },
        {
          "language": "python",
          "code": "from collections import deque\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef bfs(grid, visited, x, y):\n    global count\n    que = deque()\n    que.append([x, y])\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in position:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n                continue\n            if grid[next_x][next_y] == 1 and not visited[next_x][next_y]:\n                visited[next_x][next_y] = True\n                count += 1\n                que.append([next_x, next_y])\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n)]\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            bfs(grid, visited, i, j)\n            result = max(result, count)\nprint(result)",
          "description": "Python BFS版本"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "import java.util.*;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            count++;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 1;\n                visited[i][j] = true;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的DFS算法实现求解岛屿的最大面积"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "C++版本的另一种DFS算法实现求解岛屿的最大面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\npublic class Main{\nstatic final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};\nstatic int result=0;\nstatic int count=0;\npublic static void main(String[] args){\nScanner scanner = new Scanner(System.in);\nint n = scanner.nextInt();\nint m = scanner.nextInt();\nint[][] map = new int[n][m];\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nmap[i][j]=scanner.nextInt();\n}\n}\nboolean[][] visited = new boolean[n][m];\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nif(!visited[i][j]&&map[i][j]==1){\ncount=0;\ndfs(map,visited,i,j);\nresult= Math.max(count, result);\n}\n}\n}\nSystem.out.println(result);\n}\nstatic void dfs(int[][] map,boolean[][] visited,int x,int y){\ncount++;\nvisited[x][y]=true;\nfor (int i = 0; i < 4; i++) {\nint nextX=x+dir[i][0];\nint nextY=y+dir[i][1];\nif(nextX<0||nextY<0||nextX>=map.length||nextY>=map[0].length||visited[nextX][nextY]||map[nextX][nextY]==0)continue;\ndfs(map,visited,nextX,nextY);\n}\n}\n}",
          "description": "Java版本的DFS算法实现求解岛屿的最大面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\npublic class Main {\nstatic class Node {\nint x;\nint y;\npublic Node(int x, int y) {\nthis.x = x;\nthis.y = y;\n}\n}\nstatic final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nstatic int result = 0;\nstatic int count = 0;\npublic static void main(String[] args) {\nScanner scanner = new Scanner(System.in);\nint n = scanner.nextInt();\nint m = scanner.nextInt();\nint[][] map = new int[n][m];\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nmap[i][j] = scanner.nextInt();\n}\n}\nboolean[][] visited = new boolean[n][m];\nfor (int i = 0; i < n; i++) {\nfor (int j = 0; j < m; j++) {\nif (!visited[i][j] && map[i][j] == 1) {\ncount = 0;\nbfs(map, visited, i, j);\nresult = Math.max(count, result);\n}\n}\n}\nSystem.out.println(result);\n}\nstatic void bfs(int[][] map, boolean[][] visited, int x, int y) {\nQueue<Node> q = new LinkedList<>();\nq.add(new Node(x, y));\nvisited[x][y] = true;\ncount++;\nwhile (!q.isEmpty()) {\nNode node = q.remove();\nfor (int i = 0; i < 4; i++) {\nint nextX = node.x + dir[i][0];\nint nextY = node.y + dir[i][1];\nif (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)\ncontinue;\nq.add(new Node(nextX, nextY));\nvisited[nextX][nextY] = true;\ncount++;\n}\n}\n}\n}",
          "description": "Java版本的BFS算法实现求解岛屿的最大面积"
        },
        {
          "language": "python",
          "code": "position = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef dfs(grid, visited, x, y):\nglobal count\nfor i, j in position:\ncur_x = x + i\ncur_y = y + j\nif cur_x < 0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]):\ncontinue\nif not visited[cur_x][cur_y] and grid[cur_x][cur_y] == 1:\nvisited[cur_x][cur_y] = True\ncount += 1\ndfs(grid, visited, cur_x, cur_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\ngrid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\nfor j in range(m):\nif grid[i][j] == 1 and not visited[i][j]:\ncount = 1\nvisited[i][j] = True\ndfs(grid, visited, i, j)\nresult = max(count, result)\nprint(result)",
          "description": "Python版本的DFS算法实现求解岛屿的最大面积"
        },
        {
          "language": "python",
          "code": "from collections import deque\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef bfs(grid, visited, x, y):\nglobal count\nque = deque()\nque.append([x, y])\nwhile que:\ncur_x, cur_y = que.popleft()\nfor i, j in position:\nnext_x = cur_x + i\nnext_y = cur_y + j\nif next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\ncontinue\nif grid[next_x][next_y] == 1 and not visited[next_x][next_y]:\nvisited[next_x][next_y] = True\ncount += 1\nque.append([next_x, next_y])\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\ngrid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\nfor j in range(m):\nif grid[i][j] == 1 and not visited[i][j]:\ncount = 1\nvisited[i][j] = True\nbfs(grid, visited, i, j)\nres = max(result, count)\nprint(result)",
          "description": "Python版本的BFS算法实现求解岛屿的最大面积"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "DFS",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            count++;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 1;\n                visited[i][j] = true;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "使用DFS计算岛屿的最大面积"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
          "description": "另一种使用DFS计算岛屿最大面积的方法"
        },
        {
          "language": "cpp",
          "code": "class Solution {\nprivate:\n    int count;\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n    void bfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n        queue<int> que;\n        que.push(x);\n        que.push(y);\n        visited[x][y] = true;\n        count++;\n        while(!que.empty()) {\n            int xx = que.front();que.pop();\n            int yy = que.front();que.pop();\n            for (int i = 0 ;i < 4; i++) {\n                int nextx = xx + dir[i][0];\n                int nexty = yy + dir[i][1];\n                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n                if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                    visited[nextx][nexty] = true;\n                    count++;\n                    que.push(nextx);\n                    que.push(nexty);\n                }\n            }\n        }\n    }\n\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    count = 0;\n                    bfs(grid, visited, i, j);\n                    result = max(result, count);\n                }\n            }\n        }\n        return result;\n    }\n};",
          "description": "使用BFS计算岛屿的最大面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main{\n\n    static final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};\n    static int result=0;\n    static int count=0;\n\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j]=scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if(!visited[i][j]&&map[i][j]==1){\n                    count=0;\n                    dfs(map,visited,i,j);\n                    result= Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void dfs(int[][] map,boolean[][] visited,int x,int y){\n                count++;\n                visited[x][y]=true;\n                for (int i = 0; i < 4; i++) {\n                    int nextX=x+dir[i][0];\n                    int nextY=y+dir[i][1];\n                    if(nextX<0||nextY<0||nextX>=map.length||nextY>=map[0].length||visited[nextX][nextY]||map[nextX][nextY]==0)continue;\n                    dfs(map,visited,nextX,nextY);\n                }\n            }\n}",
          "description": "Java版本的DFS实现来计算岛屿的最大面积"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main {\n    static class Node {\n        int x;\n        int y;\n\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    static int result = 0;\n    static int count = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j] = scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && map[i][j] == 1) {\n                    count = 0;\n                    bfs(map, visited, i, j);\n                    result = Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void bfs(int[][] map, boolean[][] visited, int x, int y) {\n        Queue<Node> q = new LinkedList<>();\n        q.add(new Node(x, y));\n        visited[x][y] = true;\n        count++;\n        while (!q.isEmpty()) {\n            Node node = q.remove();\n            for (int i = 0; i < 4; i++) {\n                int nextX = node.x + dir[i][0];\n                int nextY = node.y + dir[i][1];\n                if (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)\n                    continue;\n                q.add(new Node(nextX, nextY));\n                visited[nextX][nextY] = true;\n                count++;\n            }\n        }\n    }\n}",
          "description": "Java版本的BFS实现来计算岛屿的最大面积"
        },
        {
          "language": "python",
          "code": "position = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef dfs(grid, visited, x, y):\n    global count\n    for i, j in position:\n        cur_x = x + i\n        cur_y = y + j\n        if cur_x < 0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]):\n            continue\n        if not visited[cur_x][cur_y] and grid[cur_x][cur_y] == 1:\n            visited[cur_x][cur_y] = True\n            count += 1\n            dfs(grid, visited, cur_x, cur_y)\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n)]\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            dfs(grid, visited, i, j)\n            result = max(count, result)\nprint(result)",
          "description": "Python版本的DFS实现来计算岛屿的最大面积"
        },
        {
          "language": "python",
          "code": "from collections import deque\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef bfs(grid, visited, x, y):\n    global count\n    que = deque()\n    que.append([x, y])\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in position:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n                continue\n            if grid[next_x][next_y] == 1 and not visited[next_x][next_y]:\n                visited[next_x][next_y] = True\n                count += 1\n                que.append([next_x, next_y])\nn, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n)]\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            bfs(grid, visited, i, j)\n            res = max(result, count)\nprint(result)",
          "description": "Python版本的BFS实现来计算岛屿的最大面积"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n            visited[nextx][nexty] = true;\n            count++;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 1;\n                visited[i][j] = true;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
      "description": "C++版本的DFS实现，用于计算岛屿的最大面积。"
    },
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return;\n    visited[x][y] = true;\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0;\n                dfs(grid, visited, i, j);\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}",
      "description": "C++版本的另一种DFS实现，用于计算岛屿的最大面积。"
    },
    {
      "language": "cpp",
      "code": "class Solution {\nprivate:\n    int count;\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n    void bfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n        queue<int> que;\n        que.push(x);\n        que.push(y);\n        visited[x][y] = true;\n        count++;\n        while(!que.empty()) {\n            int xx = que.front();que.pop();\n            int yy = que.front();que.pop();\n            for (int i = 0 ;i < 4; i++) {\n                int nextx = xx + dir[i][0];\n                int nexty = yy + dir[i][1];\n                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;\n                if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {\n                    visited[nextx][nexty] = true;\n                    count++;\n                    que.push(nextx);\n                    que.push(nexty);\n                }\n            }\n        }\n    }\n\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    count = 0;\n                    bfs(grid, visited, i, j);\n                    result = max(result, count);\n                }\n            }\n        }\n        return result;\n    }\n};",
      "description": "C++版本的BFS实现，用于计算岛屿的最大面积。"
    },
    {
      "language": "java",
      "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main{\n    static final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};\n    static int result=0;\n    static int count=0;\n\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j]=scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if(!visited[i][j]&&map[i][j]==1){\n                    count=0;\n                    dfs(map,visited,i,j);\n                    result= Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void dfs(int[][] map,boolean[][] visited,int x,int y){\n                count++;\n                visited[x][y]=true;\n                for (int i = 0; i < 4; i++) {\n                    int nextX=x+dir[i][0];\n                    int nextY=y+dir[i][1];\n                    if(nextX<0||nextY<0||nextX>=map.length||nextY>=map[0].length||visited[nextX][nextY]||map[nextX][nextY]==0)continue;\n                    dfs(map,visited,nextX,nextY);\n                }\n            }\n}",
      "description": "Java版本的DFS实现，用于计算岛屿的最大面积。"
    },
    {
      "language": "java",
      "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main {\n    static class Node {\n        int x;\n        int y;\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    static int result = 0;\n    static int count = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j] = scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && map[i][j] == 1) {\n                    count = 0;\n                    bfs(map, visited, i, j);\n                    result = Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void bfs(int[][] map, boolean[][] visited, int x, int y) {\n        Queue<Node> q = new LinkedList<>();\n        q.add(new Node(x, y));\n        visited[x][y] = true;\n        count++;\n        while (!q.isEmpty()) {\n            Node node = q.remove();\n            for (int i = 0; i < 4; i++) {\n                int nextX = node.x + dir[i][0];\n                int nextY = node.y + dir[i][1];\n                if (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)\n                    continue;\n                q.add(new Node(nextX, nextY));\n                visited[nextX][nextY] = true;\n                count++;\n            }\n        }\n    }\n}",
      "description": "Java版本的BFS实现，用于计算岛屿的最大面积。"
    },
    {
      "language": "python",
      "code": "position = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef dfs(grid, visited, x, y):\n    global count\n    for i, j in position:\n        cur_x = x + i\n        cur_y = y + j\n        if cur_x < 0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]):\n            continue\n        if not visited[cur_x][cur_y] and grid[cur_x][cur_y] == 1:\n            visited[cur_x][cur_y] = True\n            count += 1\n            dfs(grid, visited, cur_x, cur_y)\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            dfs(grid, visited, i, j)\n            result = max(count, result)\nprint(result)",
      "description": "Python版本的DFS实现，用于计算岛屿的最大面积。"
    },
    {
      "language": "python",
      "code": "from collections import deque\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\ndef bfs(grid, visited, x, y):\n    global count\n    que = deque()\n    que.append([x, y])\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in position:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n                continue\n            if grid[next_x][next_y] == 1 and not visited[next_x][next_y]:\n                visited[next_x][next_y] = True\n                count += 1\n                que.append([next_x, next_y])\nn, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]\nresult = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            bfs(grid, visited, i, j)\n            res = max(result, count)\nprint(result)",
      "description": "Python版本的BFS实现，用于计算岛屿的最大面积。"
    }
  ],
  "common_mistakes": [
    "忘记初始化visited数组，导致无限循环。",
    "没有正确处理边界条件，如数组越界问题。",
    "在DFS/BFS中未正确更新计数器，可能导致结果不准确。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240517103410.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20240517103410.png",
      "context": "该图片展示了样例输入中矩阵的可视化表示，帮助理解岛屿分布及其面积计算。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20220726094200.png",
      "description": "这张图片展示了一个二维数组（矩阵）的示例，其中包含多个“1”形成的岛屿，用于解释或解决与岛屿数量相关的算法问题。",
      "context": "该图片展示了样例二中三个独立岛屿的布局情况，用以说明斜向连接不被视为同一岛屿的一部分。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240517103410.png",
      "description": "GIF展示了通过深度优先搜索(DFS)或广度优先搜索(BFS)遍历矩阵来计算每个岛屿面积的过程。",
      "context": "GIF动画展示了如何通过搜索算法（如DFS或BFS）遍历矩阵，以计算并标记每个岛屿的面积，直至找到最大面积的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20220726094200.png",
      "description": "GIF展示了通过DFS或BFS算法搜索二维网格中每个岛屿的过程，标记访问过的陆地单元格，并计算每座岛屿的面积。",
      "context": "该GIF动画展示了如何在给定的网格中识别出三个独立的岛屿，强调了只有水平或垂直方向相邻的陆地才能形成同一岛屿的原则。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\图论\\岛屿的最大面积.txt",
  "extracted_at": "2025-07-21T16:20:01.062745",
  "raw_content": "岛屿的最大面积\n卡码网题目链接（ACM模式）(https://kamacoder.com/problempage.php?pid=1172)\n\n题目描述\n\n给定一个由 1（陆地）和 0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。\n\n输入描述\n\n第一行包含两个整数 N, M，表示矩阵的行数和列数。后续 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。\n\n输出描述\n\n输出一个整数，表示岛屿的最大面积。如果不存在岛屿，则输出 0。\n\n输入示例\n\n4 5\n1 1 0 0 0\n1 1 0 0 0\n0 0 1 0 0\n0 0 0 1 1\n输出示例\n\n4\n\n提示信息\nhttps://file1.kamacoder.com/i/algo/20240517103410.png\n\n\n样例输入中，岛屿的最大面积为 4。\n\n数据范围：\n\n1 <= M, N <= 50。\n#思路\n\n注意题目中每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n\n也就是说斜角度链接是不算了， 例如示例二，是三个岛屿，如图：\n\nhttps://file1.kamacoder.com/i/algo/20220726094200.png\n\n这道题目也是 dfs bfs基础类题目，就是搜索每个岛屿上“1”的数量，然后取一个最大的。\n\n本题思路上比较简单，难点其实都是 dfs 和 bfs的理论基础，关于理论基础我在这里都有详细讲解 ：\n\nDFS理论基础(https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)\nBFS理论基础(https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%BF%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)\n#DFS\n很多同学写dfs其实也是凭感觉来的，有的时候dfs函数中写终止条件才能过，有的时候 dfs函数不写终止添加也能过！\n\n这里其实涉及到dfs的两种写法。\n\n写法一，dfs处理当前节点的相邻节点，即在主函数遇到岛屿就计数为1，dfs处理接下来的相邻陆地\n\n// 版本一\n#include <iostream>\n#include <vector>\nusing namespace std;\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 没有访问过的 同时 是陆地的\n            visited[nextx][nexty] = true;\n            count++;\n            dfs(grid, visited, nextx, nexty);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 1;  // 因为dfs处理下一个节点，所以这里遇到陆地了就先计数，dfs处理接下来的相邻陆地\n                visited[i][j] = true;\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n\n}\n写法二，dfs处理当前节点，即在主函数遇到岛屿就计数为0，dfs处理接下来的全部陆地\n\ndfs\n\n// 版本二\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint count;\nint dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\nvoid dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水\n    visited[x][y] = true; // 标记访问过\n    count++;\n    for (int i = 0; i < 4; i++) {\n        int nextx = x + dir[i][0];\n        int nexty = y + dir[i][1];\n        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n        dfs(grid, visited, nextx, nexty);\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> grid(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && grid[i][j] == 1) {\n                count = 0; // 因为dfs处理当前节点，所以遇到陆地计数为0，进dfs之后在开始从1计数\n                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n                result = max(result, count);\n            }\n        }\n    }\n    cout << result << endl;\n}\n大家通过注释可以发现，两种写法，版本一，在主函数遇到陆地就计数为1，接下来的相邻陆地都在dfs中计算。\n\n版本二 在主函数遇到陆地 计数为0，也就是不计数，陆地数量都去dfs里做计算。\n\n这也是为什么大家看了很多 dfs的写法 ，发现写法怎么都不一样呢？ 其实这就是根本原因。\n\n#BFS\n关于广度优先搜索，如果大家还不了解的话，看这里：广度优先搜索精讲 https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%BF%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html\n\n本题BFS代码如下：\n\nclass Solution {\nprivate:\n    int count;\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\n    void bfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n        queue<int> que;\n        que.push(x);\n        que.push(y);\n        visited[x][y] = true; // 加入队列就意味节点是陆地可到达的点\n        count++;\n        while(!que.empty()) {\n            int xx = que.front();que.pop();\n            int yy = que.front();que.pop();\n            for (int i = 0 ;i < 4; i++) {\n                int nextx = xx + dir[i][0];\n                int nexty = yy + dir[i][1];\n                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue; // 越界\n                if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 节点没有被访问过且是陆地\n                    visited[nextx][nexty] = true;\n                    count++;\n                    que.push(nextx);\n                    que.push(nexty);\n                }\n            }\n        }\n    }\n\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    count = 0;\n                    bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n                    result = max(result, count);\n                }\n            }\n        }\n        return result;\n    }\n};\n\n#其他语言版本\n#Java\nimport java.util.*;\nimport java.math.*;\n\n/**\n * DFS版\n */\npublic class Main{\n\n    static final int[][] dir={{0,1},{1,0},{0,-1},{-1,0}};\n    static int result=0;\n    static int count=0;\n\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j]=scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if(!visited[i][j]&&map[i][j]==1){\n                    count=0;\n                    dfs(map,visited,i,j);\n                    result= Math.max(count, result);\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void dfs(int[][] map,boolean[][] visited,int x,int y){\n                count++;\n                visited[x][y]=true;\n                for (int i = 0; i < 4; i++) {\n                    int nextX=x+dir[i][0];\n                    int nextY=y+dir[i][1];\n                    //水或者已经访问过的跳过\n                    if(nextX<0||nextY<0\n                    ||nextX>=map.length||nextY>=map[0].length\n                    ||visited[nextX][nextY]||map[nextX][nextY]==0)continue;\n                    \n                    dfs(map,visited,nextX,nextY);\n                }\n            }\n}\nimport java.util.*;\nimport java.math.*;\n\n/**\n * BFS版\n */\npublic class Main {\n    static class Node {\n        int x;\n        int y;\n\n        public Node(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    static int result = 0;\n    static int count = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] map = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                map[i][j] = scanner.nextInt();\n            }\n        }\n        boolean[][] visited = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && map[i][j] == 1) {\n                    count = 0;\n                    bfs(map, visited, i, j);\n                    result = Math.max(count, result);\n\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static void bfs(int[][] map, boolean[][] visited, int x, int y) {\n        Queue<Node> q = new LinkedList<>();\n        q.add(new Node(x, y));\n        visited[x][y] = true;\n        count++;\n        while (!q.isEmpty()) {\n            Node node = q.remove();\n            for (int i = 0; i < 4; i++) {\n                int nextX = node.x + dir[i][0];\n                int nextY = node.y + dir[i][1];\n                if (nextX < 0 || nextY < 0 || nextX >= map.length || nextY >= map[0].length || visited[nextX][nextY] || map[nextX][nextY] == 0)\n                    continue;\n                q.add(new Node(nextX, nextY));\n                visited[nextX][nextY] = true;\n                count++;\n            }\n        }\n    }\n}\n\n#Python\nDFS\n\n# 四个方向\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]\ncount = 0\n\n\ndef dfs(grid, visited, x, y):\n    \"\"\"\n    深度优先搜索，对一整块陆地进行标记\n    \"\"\"\n    global count  # 定义全局变量，便于传递count值\n    for i, j in position:\n        cur_x = x + i\n        cur_y = y + j\n        # 下标越界，跳过\n        if cur_x < 0 or cur_x >= len(grid) or cur_y < 0 or cur_y >= len(grid[0]):\n            continue\n        if not visited[cur_x][cur_y] and grid[cur_x][cur_y] == 1:\n            visited[cur_x][cur_y] = True\n            count += 1\n            dfs(grid, visited, cur_x, cur_y)\n\n\nn, m = map(int, input().split())\n# 邻接矩阵\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n# 访问表\nvisited = [[False] * m for _ in range(n)]\n\nresult = 0  # 记录最终结果\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            dfs(grid, visited, i, j)\n            result = max(count, result)\n\nprint(result)\nBFS\n\nfrom collections import deque\n\nposition = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # 四个方向\ncount = 0\n\n\ndef bfs(grid, visited, x, y):\n    \"\"\"\n    广度优先搜索对陆地进行标记\n    \"\"\"\n    global count  # 声明全局变量\n    que = deque()\n    que.append([x, y])\n    while que:\n        cur_x, cur_y = que.popleft()\n        for i, j in position:\n            next_x = cur_x + i\n            next_y = cur_y + j\n            # 下标越界，跳过\n            if next_x < 0 or next_x >= len(grid) or next_y < 0 or next_y >= len(grid[0]):\n                continue\n            if grid[next_x][next_y] == 1 and not visited[next_x][next_y]:\n                visited[next_x][next_y] = True\n                count += 1\n                que.append([next_x, next_y])\n\n\nn, m = map(int, input().split())\n# 邻接矩阵\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\nvisited = [[False] * m for _ in range(n)]  # 访问表\n\nresult = 0  # 记录最终结果\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count = 1\n            visited[i][j] = True\n            bfs(grid, visited, i, j)\n            res = max(result, count)\n\nprint(result)"
}