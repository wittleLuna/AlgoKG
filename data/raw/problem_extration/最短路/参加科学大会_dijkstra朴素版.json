{
  "id": "AP_1beb3553",
  "title": "dijkstra（朴素版）精讲",
  "alternative_titles": [],
  "platform": "kamacoder",
  "url": "https://kamacoder.com/problempage.php?pid=1047",
  "description": "",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "图论",
    "最短路径"
  ],
  "data_structure_tags": [
    "邻接矩阵/表",
    "数组"
  ],
  "technique_tags": [
    "贪心算法"
  ],
  "difficulty": null,
  "solution_approach": "使用Dijkstra算法求解从起点到终点的最短路径。该方法适用于边权非负的情况，通过贪心策略逐步扩展最短路径树来找到从源点到所有其他顶点的最短路径。",
  "key_insights": [
    {
      "content": "每次迭代中选取当前已知距离最小但还未确定最终距离的节点进行处理，并更新其邻居节点的距离估计值。"
    },
    {
      "content": "此数组用于存储从起点到每个节点的当前最短路径长度估计值，随着算法推进不断被更新至实际最短路径长度。"
    },
    {
      "content": "访问过的节点不会再被重新考虑，因此在存在负权边的情况下，Dijkstra算法可能无法找到真正的最短路径。"
    },
    {
      "content": "Dijkstra算法与Prim算法虽然相似，但在更新非访问节点到源点或生成树的距离时有所不同。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "本题就是求最短路，最短路是图论中的经典问题即：给出一个有向图，一个起点，一个终点，问起点到终点的最短路径。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++实现Dijkstra算法求解最短路径问题"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java实现Dijkstra算法求解最短路径问题"
        },
        {
          "language": "python",
          "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python实现Dijkstra算法求解最短路径问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "朴素版dijkstra",
      "text": "#模拟过程",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用Dijkstra算法计算起点到终点的最短路径"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "使用Dijkstra算法计算起点到终点的最短路径"
        },
        {
          "language": "python",
          "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "使用Dijkstra算法计算起点到终点的最短路径"
        }
      ],
      "subsections": []
    },
    {
      "name": "模拟过程",
      "text": "0、初始化",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "代码实现",
      "text": "本题代码如下，里面的 三部曲 我都做了注释，大家按照我上面的讲解 来看如下代码：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用C++实现Dijkstra算法求解最短路径问题"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "使用Java实现Dijkstra算法求解最短路径问题"
        },
        {
          "language": "python",
          "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "使用Python实现Dijkstra算法求解最短路径问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "朴素版Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的朴素版Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的朴素版Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <climits>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++实现的Dijkstra算法"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java实现的Dijkstra算法"
        },
        {
          "language": "python",
          "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python实现的Dijkstra算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "debug方法",
      "text": "写这种题目难免会有各种各样的问题，我们如何发现自己的代码是否有问题呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用Dijkstra算法求解从起点到终点的最短路径"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "使用Dijkstra算法求解从起点到终点的最短路径"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "使用Dijkstra算法求解从起点到终点的最短路径"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <climits>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用Dijkstra算法计算从起点到终点的最短路径"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版使用Dijkstra算法计算从起点到终点的最短路径"
        },
        {
          "language": "python",
          "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版使用Dijkstra算法计算从起点到终点的最短路径"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "朴素版Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的朴素版Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的朴素版Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "如何求路径",
      "text": "如果题目要求把最短路的路径打印出来，应该怎么办呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用Dijkstra算法计算起点到终点的最短路径"
        },
        {
          "language": "Java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法实现，用于求解给定图中起点到终点的最短路径"
        },
        {
          "language": "Python",
          "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python实现的Dijkstra算法，通过输入获取图的信息，并计算从指定起点到终点的最短路径长度"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "朴素版Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的朴素版Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的朴素版Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <climits>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++实现的Dijkstra算法求解最短路径问题"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java实现的Dijkstra算法求解最短路径问题"
        },
        {
          "language": "python",
          "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python实现的Dijkstra算法求解最短路径问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "出现负数",
      "text": "如果图中边的权值为负数，dijkstra 还合适吗？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "dijkstra与prim算法的区别",
      "text": "这里再次提示，需要先看我的 prim算法精讲 ，否则可能不知道我下面讲的是什么。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "本篇，我们深入讲解的dijkstra算法，详细模拟其工作的流程。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "朴素版Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的朴素版Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的朴素版Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "使用Dijkstra算法求解起点到终点的最短路径"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法实现，用于寻找图中两点之间的最短路径"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的Dijkstra算法实现，以函数形式封装，通过标准输入读取数据并输出最短路径长度"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "import java.util.Arrays;",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的Dijkstra算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "import sys",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
          "description": "朴素版Dijkstra算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
          "description": "Java版本的朴素版Dijkstra算法实现"
        },
        {
          "language": "python",
          "code": "import sys\n\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
          "description": "Python版本的朴素版Dijkstra算法实现"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n^2)",
    "explanation": null
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n}",
      "description": "朴素版Dijkstra算法实现"
    },
    {
      "language": "java",
      "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}",
      "description": "朴素版Dijkstra算法实现"
    },
    {
      "language": "python",
      "code": "import sys\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)",
      "description": "朴素版Dijkstra算法实现"
    }
  ],
  "common_mistakes": [
    "忽略初始化步骤，特别是将minDist设置为极大值。",
    "未能正确标记访问过的节点，导致无限循环或错误计算。",
    "在更新minDist时未考虑现有值与新计算值之间的比较。",
    "试图直接应用Dijkstra于含负权边的图上，这会导致不正确的结果。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240227101345.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20240227101345.png",
      "context": "该图片展示了从1号车站到7号车站的最短路径示例，其中绿色路线表示最短路径，总长度为12。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240227101401.png",
      "description": "这是一张展示有向加权图的图片，节点通过带权重的边相连，可用于最短路径算法（如Dijkstra算法）的分析。",
      "context": "该图片展示了当从起始车站不能到达终点车站时的情况，用于说明此时应输出-1。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240125162647.png",
      "description": "这张图片展示了一个有向加权图，节点间通过带权重的边连接，适用于最短路径算法（如Dijkstra算法）的分析。",
      "context": "该图展示了从起点（节点1）到终点（节点7）的最短路径，其中最短路径用绿线标出，其权值为12，用于说明dijkstra算法的应用。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240130115306.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20240130115306.png",
      "context": "该图展示了minDist数组初始化状态及节点访问情况，辅助解释Dijkstra算法的初始设置与工作原理。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240130115421.png",
      "description": "这张图片展示了一个使用Dijkstra算法进行最短路径计算的过程，图中包含了节点、边的权重以及当前的最小距离数组和访问状态数组。",
      "context": "该图展示了Dijkstra算法中更新从源点到其他节点最短路径的过程，特别是更新minDist数组的具体步骤。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240130121240.png",
      "description": "这张图片展示了Dijkstra算法在加权图中的应用，通过`minDist`数组记录最短路径距离和`visited`数组标记已访问节点来逐步找到从起点到各节点的最短路径。",
      "context": "该图展示了更新minDist数组的过程，具体表现为源点（节点1）通过已访问过的节点2到达其他节点（如节点3、4和6）时，相应最短路径值的变化。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240130120434.png",
      "description": "这张图片展示了Dijkstra算法在图中的应用，通过节点间的最短路径计算和相关数据结构（如`minDist`和`visited`数组）来逐步确定最短路径。",
      "context": "该图展示了在将节点3标记为已访问后，根据新的路径更新minDist数组的过程，特别指出了源点到节点4的最短距离从6更新为5。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240201105335.png",
      "description": "这张图片展示了Dijkstra算法在加权图中的应用，通过节点间的最短路径计算和相应的距离数组（minDist）与访问状态（visited）来逐步找到最短路径。",
      "context": "该图展示了在节点4被访问后，更新minDist数组的过程，特别是显示了源点到节点5的最短距离从max更新为8的变化。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240201110250.png",
      "description": "这张图片展示了Dijkstra算法在加权图中的应用，通过minDist数组和visited数组记录最短路径距离和访问状态。",
      "context": "该图展示了在将节点6标记为访问过后，基于其连接更新minDist数组的过程，特别是显示了源点到节点7的最短路径距离被更新为14。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240201110651.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20240201110651.png",
      "context": "此图展示了在节点5被标记访问后，更新minDist数组的过程，特别是通过新路径使得源点到节点7的最短距离从14减少到了12。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240201110920.png",
      "description": "这张图片展示了Dijkstra算法在图中的应用，通过节点间的边权和距离数组来找到最短路径。",
      "context": "该图展示了在更新minDist数组后，节点7被标记为已访问的状态，以及此时各节点到源点的最短距离情况。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240201111352.png",
      "description": "这张图片展示了一个加权有向图，可用于解释最短路径算法（如Dijkstra算法）的解题过程。",
      "context": "该图展示了从节点1到节点7的最短路径，其中节点1到节点7的最短距离为12。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240201111352.png",
      "description": "这张图片展示了一个加权有向图，可用于最短路径算法（如Dijkstra算法）的分析和求解。",
      "context": "该图片展示了从节点1到节点7的最短路径，其长度为12，直观地呈现了Dijkstra算法计算结果。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240227104334.png",
      "description": "这张图片展示了一个带权有向图，涉及节点间的路径和权重，可用于最短路径算法（如Dijkstra或Bellman-Ford）的分析。",
      "context": "该图展示了含有负权值边的网络结构，用于讨论在这种情况下Dijkstra算法是否仍然适用。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240227104801.png",
      "description": "这张图片展示了一个图的最短路径算法（如Dijkstra算法）的初始状态，包括节点间的边权、距离数组`minDist`和访问标记数组`visited`。",
      "context": "这张图片展示了Dijkstra算法初始化阶段的状态，包括各节点之间的初始距离设置。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240227110217.png",
      "description": "这张图片展示了使用Dijkstra算法在加权图中寻找最短路径的过程，包括节点间的权重、当前最短距离（minDist）数组和已访问节点（visited）状态。",
      "context": "该图展示了更新minDist数组的过程，具体显示了源点（节点1）到节点2和节点3的最短距离被更新后的状态。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240227110330.png",
      "description": "这张图片展示了使用Dijkstra算法在带权图中寻找最短路径的过程，包括节点间的距离、当前最小距离数组（minDist）和已访问节点状态（visited）。",
      "context": "该图展示了在标记节点3访问过后，更新非访问节点到源点的距离（即minDist数组）的过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240227110346.png",
      "description": "这张图片展示了使用Dijkstra算法在带权图中寻找最短路径的过程，包括节点间的权重、距离数组（minDist）和访问状态（visited）。",
      "context": "该图展示了在加入新节点后，根据最新路径更新minDist数组的过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240227110405.png",
      "description": "这张图片展示了使用Dijkstra算法在带权图中寻找最短路径的过程，包括节点间的权重、距离数组（minDist）和访问状态（visited）。",
      "context": "该图展示了在节点5被访问后，minDist数组更新的状态，此时由于节点5没有链接到其他节点，因此minDist数组未发生变化。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240227110711.png",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/20240227110711.png",
      "context": "该图片展示了在Dijkstra算法执行过程中，更新minDist数组后的状态，特别是在节点2被标记为已访问之后的情形。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240227101345.png",
      "description": "GIF展示了从起点到终点寻找最短路径的过程，通过逐步探索并标记每个节点来确定最优路线。",
      "context": "GIF动画展示了从起点到终点找到最短路径的过程，其中绿色路线表示计算出的最短路径。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240227101401.png",
      "description": "GIF展示了从起点到终点寻找最短路径的过程，使用了dijkstra算法逐步探索并更新最短路径。",
      "context": "此GIF动画展示了当从起始车站无法到达终点车站时的情景，符合说明中提到的不能到达情况下的示例。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240125162647.png",
      "description": "GIF展示了Dijkstra算法执行过程，从起点出发逐步找到到达终点的最短路径。",
      "context": "GIF动画展示了使用Dijkstra算法从起点到终点寻找最短路径的过程，其中绿色标记的路径表示找到的最短路径。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240130115306.png",
      "description": "GIF展示了Dijkstra算法执行过程中，从源点开始逐步更新各节点到源点最短路径的过程。",
      "context": "GIF动画展示了Dijkstra算法初始化阶段minDist数组的设置过程，其中所有节点到源点的最短路径初始为最大值，而源点自身距离设为0。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240130115421.png",
      "description": "GIF展示了Dijkstra算法中从源点出发更新到各节点最短路径的过程。",
      "context": "GIF动画展示了Dijkstra算法中，从源点出发更新至其他节点最短路径的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240130121240.png",
      "description": "GIF展示了Dijkstra算法执行过程中，从源点出发通过最近访问节点更新其他节点最短路径的过程。",
      "context": "此GIF动画展示了在算法执行过程中，如何通过已访问的节点（这里是节点2）来更新源点到其他可达节点（节点3、4、6）的最短距离。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240130120434.png",
      "description": "GIF展示了通过更新minDist数组来寻找并标记从源点出发最近未访问节点的过程，同时调整相关节点的最短路径估计值。",
      "context": "此GIF动画展示了在算法执行过程中，随着节点3被标记为已访问，如何通过它更新源点到其他未访问节点（特别是节点4）的最短距离。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240201105335.png",
      "description": "GIF展示了通过加入新节点来更新minDist数组的过程，反映了最短路径算法的执行步骤。",
      "context": "GIF动画展示了在选择最近且未访问过的节点后，更新minDist数组的过程，特别是当节点4被标记为已访问并加入到路径中时，源点到其他节点（如节点5）的距离如何得到更新。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240201110250.png",
      "description": "GIF展示了在图算法中更新minDist数组的过程，随着节点的访问和最短路径的发现，逐步标记节点并调整源点到其他各节点的距离。",
      "context": "GIF动画展示了在算法执行过程中，随着节点被访问以及最短路径更新时minDist数组的变化情况。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240201110651.png",
      "description": "GIF展示了Dijkstra算法执行过程中，随着节点被访问，minDist数组更新以反映从源点到各节点的最短路径变化。",
      "context": "GIF动画展示了在算法执行过程中，随着节点5被标记为已访问并加入路径后，如何更新源点到其他未访问节点（特别是节点7）的最短距离的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240201110920.png",
      "description": "GIF展示了Dijkstra算法执行过程中，随着节点5的加入，更新从源点到各节点最短路径的过程。",
      "context": "GIF动画展示了在找到距离源点最近且未被访问过的节点7后，将其标记为已访问，并考虑是否需要更新其他节点到源点的最短距离的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240201111352.png",
      "description": "GIF展示了从起点节点1到终点节点7的最短路径寻找过程，最终确定最短路径长度为12。",
      "context": "GIF动画展示了从起点（节点1）到终点（节点7）的最短路径计算过程，形象地解释了Dijkstra算法每一步的操作。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240227104334.png",
      "description": "该GIF展示了Dijkstra算法在含有负权边的图中寻找从节点1到节点5最短路径的过程。",
      "context": "该GIF动画展示了使用Dijkstra算法在含有负权边的图中寻找从节点1到节点5的路径过程，用以说明当图中存在负权边时Dijkstra算法可能遇到的问题。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240227104801.png",
      "description": "GIF展示了Dijkstra算法在含有负权边的图中寻找最短路径时的初始化过程。",
      "context": "此GIF动画展示了Dijkstra算法初始化阶段的状态，包括各节点的初始距离设置。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240227110217.png",
      "description": "Dijkstra算法逐步寻找从源点到其他各节点最短路径的过程演示。",
      "context": "该GIF动画展示了在选定最近且未访问过的节点后，如何更新从源点到其他非访问节点的最短距离的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240227110330.png",
      "description": "GIF展示了通过更新minDist数组来逐步找到从源点到其他各节点最短路径的过程。",
      "context": "该GIF动画展示了在算法执行过程中，如何根据新访问的节点更新其他节点到源点的最短距离。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240227110346.png",
      "description": "GIF展示了在算法执行过程中，随着节点3被访问后，更新源点到其他未访问节点（特别是节点4）的距离，并逐步标记新近节点为已访问的过程。",
      "context": "此GIF动画展示了随着新节点的加入，如何逐步更新从源点到其他节点的最短路径，并标记已访问节点的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240227110405.png",
      "description": "GIF展示了Dijkstra算法执行过程中，从源点出发逐步访问最近节点并更新最小距离数组(minDist)直至找到节点1到节点5的最短路径。",
      "context": "该GIF动画展示了在算法执行过程中，随着新节点的加入和访问状态的变化，如何更新源点到其他各节点的最短距离（minDist数组）。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240227110711.png",
      "description": "Dijkstra算法执行过程中，节点被访问及最短路径更新的动态变化。",
      "context": "GIF展示了在Dijkstra算法执行过程中，选择最近未访问节点后更新minDist数组的具体步骤。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\最短路\\参加科学大会_dijkstra朴素版.txt",
  "extracted_at": "2025-07-22T11:47:25.070067",
  "raw_content": "dijkstra（朴素版）精讲\n卡码网：47. 参加科学大会(https://kamacoder.com/problempage.php?pid=1047)\n\n【题目描述】\n\n小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。\n\n小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。\n\n小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。\n\n【输入描述】\n\n第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。\n\n接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。\n\n【输出描述】\n\n输出一个整数，代表小明从起点到终点所花费的最小时间。\n\n输入示例\n\n7 9\n1 2 1\n1 3 4\n2 3 2\n2 4 5\n3 4 2\n4 5 3\n2 6 4\n5 7 4\n6 7 9\n输出示例：12\n\n【提示信息】\n\n能够到达的情况：\n\n如下图所示，起始车站为 1 号车站，终点车站为 7 号车站，绿色路线为最短的路线，路线总长度为 12，则输出 12。\n\nhttps://file1.kamacoder.com/i/algo/20240227101345.png\n\n不能到达的情况：\n\n如下图所示，当从起始车站不能到达终点车站时，则输出 -1。\nhttps://file1.kamacoder.com/i/algo/20240227101401.png\n\n\n数据范围：\n\n1 <= N <= 500; 1 <= M <= 5000;\n\n#思路\n本题就是求最短路，最短路是图论中的经典问题即：给出一个有向图，一个起点，一个终点，问起点到终点的最短路径。\n\n接下来，我们来详细讲解最短路算法中的 dijkstra 算法。\n\ndijkstra算法：在有权图（权值非负数）中求从起点到其他节点的最短路径算法。\n\n需要注意两点：\n\ndijkstra 算法可以同时求 起点到所有节点的最短路径\n权值不能为负数\n（这两点后面我们会讲到）\n\n如本题示例中的图：\nhttps://file1.kamacoder.com/i/algo/20240125162647.png\n\n\n起点（节点1）到终点（节点7） 的最短路径是 图中 标记绿线的部分。\n\n最短路径的权值为12。\n\n其实 dijkstra 算法 和 我们之前讲解的prim算法思路非常接近，如果大家认真学过prim算法，那么理解 Dijkstra 算法会相对容易很多。（这也是我要先讲prim再讲dijkstra的原因）\n\ndijkstra 算法 同样是贪心的思路，不断寻找距离 源点最近的没有访问过的节点。\n\n这里我也给出 dijkstra三部曲：\n\n第一步，选源点到哪个节点近且该节点未被访问过\n第二步，该最近节点被标记访问过\n第三步，更新非访问节点到源点的距离（即更新minDist数组）\n大家此时已经会发现，这和prim算法 怎么这么像呢。\n\n我在prim算法讲解中也给出了三部曲。 prim 和 dijkstra 确实很像，思路也是类似的，这一点我在后面还会详细来讲。\n\n在dijkstra算法中，同样有一个数组很重要，起名为：minDist。\n\nminDist数组 用来记录 每一个节点距离源点的最小距离。\n\n理解这一点很重要，也是理解 dijkstra 算法的核心所在。\n\n大家现在看着可能有点懵，不知道什么意思。\n\n没关系，先让大家有一个印象，对理解后面讲解有帮助。\n\n我们先来画图看一下 dijkstra 的工作过程，以本题示例为例： （以下为朴素版dijkstra的思路）\n\n（示例中节点编号是从1开始，所以为了让大家看的不晕，minDist数组下标我也从 1 开始计数，下标0 就不使用了，这样 下标和节点标号就可以对应上了，避免大家搞混）\n\n#朴素版dijkstra\n#模拟过程\n0、初始化\n\nminDist数组数值初始化为int最大值。\n\n这里在强点一下 minDist数组的含义：记录所有节点到源点的最短路径，那么初始化的时候就应该初始为最大值，这样才能在后续出现最短路径的时候及时更新。\n\nhttps://file1.kamacoder.com/i/algo/20240130115306.png\n\n（图中，max 表示默认值，节点0 不做处理，统一从下标1 开始计算，这样下标和节点数值统一， 方便大家理解，避免搞混）\n\n源点（节点1） 到自己的距离为0，所以 minDist[1] = 0\n\n此时所有节点都没有被访问过，所以 visited数组都为0\n\n以下为dijkstra 三部曲\n\n1、选源点到哪个节点近且该节点未被访问过\n\n源点距离源点最近，距离为0，且未被访问。\n\n2、该最近节点被标记访问过\n\n标记源点访问过\n\n3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240130115421.png\n\n更新 minDist数组，即：源点（节点1） 到 节点2 和 节点3的距离。\n\n源点到节点2的最短距离为1，小于原minDist[2]的数值max，更新minDist[2] = 1\n源点到节点3的最短距离为4，小于原minDist[3]的数值max，更新minDist[3] = 4\n可能有录友问：为啥和 minDist[2] 比较？\n\n再强调一下 minDist[2] 的含义，它表示源点到节点2的最短距离，那么目前我们得到了 源点到节点2的最短距离为1，小于默认值max，所以更新。 minDist[3]的更新同理\n\n1、选源点到哪个节点近且该节点未被访问过\n\n未访问过的节点中，源点到节点2距离最近，选节点2\n\n2、该最近节点被标记访问过\n\n节点2被标记访问过\n\n3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：\nhttps://file1.kamacoder.com/i/algo/20240130121240.png\n\n\n更新 minDist数组，即：源点（节点1） 到 节点6 、 节点3 和 节点4的距离。\n\n为什么更新这些节点呢？ 怎么不更新其他节点呢？\n\n因为 源点（节点1）通过 已经计算过的节点（节点2） 可以链接到的节点 有 节点3，节点4和节点6.\n\n更新 minDist数组：\n\n源点到节点6的最短距离为5，小于原minDist[6]的数值max，更新minDist[6] = 5\n源点到节点3的最短距离为3，小于原minDist[3]的数值4，更新minDist[3] = 3\n源点到节点4的最短距离为6，小于原minDist[4]的数值max，更新minDist[4] = 6\n1、选源点到哪个节点近且该节点未被访问过\n\n未访问过的节点中，源点距离哪些节点最近，怎么算的？\n\n其实就是看 minDist数组里的数值，minDist 记录了 源点到所有节点的最近距离，结合visited数组筛选出未访问的节点就好。\n\n从 上面的图，或者 从minDist数组中，我们都能看出 未访问过的节点中，源点（节点1）到节点3距离最近。\n\n2、该最近节点被标记访问过\n\n节点3被标记访问过\n\n3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240130120434.png\n\n由于节点3的加入，那么源点可以有新的路径链接到节点4 所以更新minDist数组：\n\n更新 minDist数组：\n\n源点到节点4的最短距离为5，小于原minDist[4]的数值6，更新minDist[4] = 5\n1、选源点到哪个节点近且该节点未被访问过\n\n距离源点最近且没有被访问过的节点，有节点4 和 节点6，距离源点距离都是 5 （minDist[4] = 5，minDist[6] = 5） ，选哪个节点都可以。\n\n2、该最近节点被标记访问过\n\n节点4被标记访问过\n\n3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240201105335.png\n\n由于节点4的加入，那么源点可以链接到节点5 所以更新minDist数组：\n\n源点到节点5的最短距离为8，小于原minDist[5]的数值max，更新minDist[5] = 8\n1、选源点到哪个节点近且该节点未被访问过\n\n距离源点最近且没有被访问过的节点，是节点6，距离源点距离是 5 （minDist[6] = 5）\n\n2、该最近节点被标记访问过\n\n节点6 被标记访问过\n\n3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240201110250.png\n\n由于节点6的加入，那么源点可以链接到节点7 所以 更新minDist数组：\n\n源点到节点7的最短距离为14，小于原minDist[7]的数值max，更新minDist[7] = 14\n1、选源点到哪个节点近且该节点未被访问过\n\n距离源点最近且没有被访问过的节点，是节点5，距离源点距离是 8 （minDist[5] = 8）\n\n2、该最近节点被标记访问过\n\n节点5 被标记访问过\n\n3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240201110651.png\n\n由于节点5的加入，那么源点有新的路径可以链接到节点7 所以 更新minDist数组：\n\n源点到节点7的最短距离为12，小于原minDist[7]的数值14，更新minDist[7] = 12\n1、选源点到哪个节点近且该节点未被访问过\n\n距离源点最近且没有被访问过的节点，是节点7（终点），距离源点距离是 12 （minDist[7] = 12）\n\n2、该最近节点被标记访问过\n\n节点7 被标记访问过\n\n3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240201110920.png\n\n节点7加入，但节点7到节点7的距离为0，所以 不用更新minDist数组\n\n最后我们要求起点（节点1） 到终点 （节点7）的距离。\n\n再来回顾一下minDist数组的含义：记录 每一个节点距离源点的最小距离。\n\n那么起到（节点1）到终点（节点7）的最短距离就是 minDist[7] ，按上面举例讲解来说，minDist[7] = 12，节点1 到节点7的最短路径为 12。\n\n路径如图：\n\nhttps://file1.kamacoder.com/i/algo/20240201111352.png\n\n在上面的讲解中，每一步 我都是按照 dijkstra 三部曲来讲解的，理解了这三部曲，代码也就好懂的。\n\n#代码实现\n本题代码如下，里面的 三部曲 我都做了注释，大家按照我上面的讲解 来看如下代码：\n\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    // 存储从源点到每个节点的最短距离\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    // 记录顶点是否被访问过\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;  // 起始点到自身的距离为0\n\n    for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        // 1、选距离源点最近且未访问过的节点\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;  // 2、标记该节点已被访问\n\n        // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n    }\n\n    if (minDist[end] == INT_MAX) cout << -1 << endl; // 不能到达终点\n    else cout << minDist[end] << endl; // 到达终点最短路径\n\n}\n时间复杂度：O(n^2)\n空间复杂度：O(n^2)\n#debug方法\n写这种题目难免会有各种各样的问题，我们如何发现自己的代码是否有问题呢？\n\n最好的方式就是打日志，本题的话，就是将 minDist 数组打印出来，就可以很明显发现 哪里出问题了。\n\n每次选择节点后，minDist数组的变化是否符合预期 ，是否和我上面讲的逻辑是对应的。\n\n例如本题，如果想debug的话，打印日志可以这样写：\n\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0;\n    for (int i = 1; i <= n; i++) {\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;\n\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n            }\n        }\n\n        // 打印日志：\n        cout << \"select:\" << cur << endl;\n        for (int v = 1; v <= n; v++) cout <<  v << \":\" << minDist[v] << \" \";\n        cout << endl << endl;;\n\n    }\n    if (minDist[end] == INT_MAX) cout << -1 << endl;\n    else cout << minDist[end] << endl;\n\n}\n\n打印后的结果：\n\nselect:1\n1:0 2:1 3:4 4:2147483647 5:2147483647 6:2147483647 7:2147483647\n\nselect:2\n1:0 2:1 3:3 4:6 5:2147483647 6:5 7:2147483647\n\nselect:3\n1:0 2:1 3:3 4:5 5:2147483647 6:5 7:2147483647\n\nselect:4\n1:0 2:1 3:3 4:5 5:8 6:5 7:2147483647\n\nselect:6\n1:0 2:1 3:3 4:5 5:8 6:5 7:14\n\nselect:5\n1:0 2:1 3:3 4:5 5:8 6:5 7:12\n\nselect:7\n1:0 2:1 3:3 4:5 5:8 6:5 7:12\n打印日志可以和上面我讲解的过程进行对比，每一步的结果是完全对应的。\n\n所以如果大家如果代码有问题，打日志来debug是最好的方法\n\n#如何求路径\n如果题目要求把最短路的路径打印出来，应该怎么办呢？\n\n这里还是有一些“坑”的，本题打印路径和 prim 打印路径是一样的，我在 prim算法精讲 【拓展】中 已经详细讲解了。\n\n在这里就不再赘述。\n\n打印路径只需要添加 几行代码， 打印路径的代码我都加上的日志，如下：\n\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1][p2] = val;\n    }\n\n    int start = 1;\n    int end = n;\n\n    std::vector<int> minDist(n + 1, INT_MAX);\n\n    std::vector<bool> visited(n + 1, false);\n\n    minDist[start] = 0; \n\n    //加上初始化\n    vector<int> parent(n + 1, -1);\n\n    for (int i = 1; i <= n; i++) {\n\n        int minVal = INT_MAX;\n        int cur = 1;\n\n        for (int v = 1; v <= n; ++v) {\n            if (!visited[v] && minDist[v] < minVal) {\n                minVal = minDist[v];\n                cur = v;\n            }\n        }\n\n        visited[cur] = true;\n\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n                minDist[v] = minDist[cur] + grid[cur][v];\n                parent[v] = cur; // 记录边\n            }\n        }\n\n    }\n\n    // 输出最短情况\n    for (int i = 1; i <= n; i++) {\n        cout << parent[i] << \"->\" << i << endl;\n    }\n}\n打印结果：\n\n-1->1\n1->2\n2->3\n3->4\n4->5\n2->6\n5->7\n对应如图：\n\nhttps://file1.kamacoder.com/i/algo/20240201111352.png\n\n#出现负数\n如果图中边的权值为负数，dijkstra 还合适吗？\n\n看一下这个图： （有负权值）\nhttps://file1.kamacoder.com/i/algo/20240227104334.png\n\n\n节点1 到 节点5 的最短路径 应该是 节点1 -> 节点2 -> 节点3 -> 节点4 -> 节点5\n\n那我们来看dijkstra 求解的路径是什么样的，继续dijkstra 三部曲来模拟 ：（dijkstra模拟过程上面已经详细讲过，以下只模拟重要过程，例如如何初始化就省略讲解了）\n\n初始化：\nhttps://file1.kamacoder.com/i/algo/20240227104801.png\n\n\n1、选源点到哪个节点近且该节点未被访问过\n\n源点距离源点最近，距离为0，且未被访问。\n\n2、该最近节点被标记访问过\n\n标记源点访问过\n\n3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240227110217.png\n\n更新 minDist数组，即：源点（节点1） 到 节点2 和 节点3的距离。\n\n源点到节点2的最短距离为100，小于原minDist[2]的数值max，更新minDist[2] = 100\n源点到节点3的最短距离为1，小于原minDist[3]的数值max，更新minDist[3] = 1\n1、选源点到哪个节点近且该节点未被访问过\n\n源点距离节点3最近，距离为1，且未被访问。\n\n2、该最近节点被标记访问过\n\n标记节点3访问过\n\n3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240227110330.png\n\n由于节点3的加入，那么源点可以有新的路径链接到节点4 所以更新minDist数组：\n\n源点到节点4的最短距离为2，小于原minDist[4]的数值max，更新minDist[4] = 2\n1、选源点到哪个节点近且该节点未被访问过\n\n源点距离节点4最近，距离为2，且未被访问。\n\n2、该最近节点被标记访问过\n\n标记节点4访问过\n\n3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：\nhttps://file1.kamacoder.com/i/algo/20240227110346.png\n\n\n由于节点4的加入，那么源点可以有新的路径链接到节点5 所以更新minDist数组：\n\n源点到节点5的最短距离为3，小于原minDist[5]的数值max，更新minDist[5] = 5\n1、选源点到哪个节点近且该节点未被访问过\n\n源点距离节点5最近，距离为3，且未被访问。\n\n2、该最近节点被标记访问过\n\n标记节点5访问过\n\n3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240227110405.png\n\n节点5的加入，而节点5 没有链接其他节点， 所以不用更新minDist数组，仅标记节点5被访问过了\n\n1、选源点到哪个节点近且该节点未被访问过\n\n源点距离节点2最近，距离为100，且未被访问。\n\n2、该最近节点被标记访问过\n\n标记节点2访问过\n\n3、更新非访问节点到源点的距离（即更新minDist数组） ，如图：\nhttps://file1.kamacoder.com/i/algo/20240227110711.png\n\n\n至此dijkstra的模拟过程就结束了，根据最后的minDist数组，我们求 节点1 到 节点5 的最短路径的权值总和为 3，路径： 节点1 -> 节点3 -> 节点4 -> 节点5\n\n通过以上的过程模拟，我们可以发现 之所以 没有走有负权值的最短路径 是因为 在 访问 节点 2 的时候，节点 3 已经访问过了，就不会再更新了。\n\n那有录友可能会想： 我可以改代码逻辑啊，访问过的节点，也让它继续访问不就好了？\n\n那么访问过的节点还能继续访问会不会有死循环的出现呢？控制逻辑不让其死循环？那特殊情况自己能都想清楚吗？（可以试试，实践出真知）\n\n对于负权值的出现，大家可以针对某一个场景 不断去修改 dijkstra 的代码，但最终会发现只是 拆了东墙补西墙，对dijkstra的补充逻辑只能满足某特定场景最短路求解。\n\n对于求解带有负权值的最短路问题，可以使用 Bellman-Ford 算法 ，我在后序会详细讲解。\n\n#dijkstra与prim算法的区别\n这里再次提示，需要先看我的 prim算法精讲 ，否则可能不知道我下面讲的是什么。\n\n大家可以发现 dijkstra的代码看上去 怎么和 prim算法这么像呢。\n\n其实代码大体不差，唯一区别在 三部曲中的 第三步： 更新minDist数组\n\n因为prim是求 非访问节点到最小生成树的最小距离，而 dijkstra是求 非访问节点到源点的最小距离。\n\nprim 更新 minDist数组的写法：\n\nfor (int j = 1; j <= v; j++) {\n    if (!isInTree[j] && grid[cur][j] < minDist[j]) {\n        minDist[j] = grid[cur][j];\n    }\n}\n因为 minDist表示 节点到最小生成树的最小距离，所以 新节点cur的加入，只需要 使用 grid[cur][j] ，grid[cur][j] 就表示 cur 加入生成树后，生成树到 节点j 的距离。\n\ndijkstra 更新 minDist数组的写法：\n\nfor (int v = 1; v <= n; v++) {\n    if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {\n        minDist[v] = minDist[cur] + grid[cur][v];\n    }\n}\n因为 minDist表示 节点到源点的最小距离，所以 新节点 cur 的加入，需要使用 源点到cur的距离 （minDist[cur]） + cur 到 节点 v 的距离 （grid[cur][v]），才是 源点到节点v的距离。\n\n此时大家可能不禁要想 prim算法 可以有负权值吗？\n\n当然可以！\n\n录友们可以自己思考思考一下，这是为什么？\n\n这里我提示一下：prim算法只需要将节点以最小权值和链接在一起，不涉及到单一路径。\n\n#总结\n本篇，我们深入讲解的dijkstra算法，详细模拟其工作的流程。\n\n这里我给出了 dijkstra 三部曲 来 帮助大家理解 该算法，不至于 每次写 dijkstra 都是黑盒操作，没有框架没有章法。\n\n在给出的代码中，我也按照三部曲的逻辑来给大家注释，只要理解这三部曲，即使 过段时间 对 dijkstra 算法有些遗忘，依然可以写出一个框架出来，然后再去调试细节。\n\n对于图论算法，一般代码都比较长，很难写出代码直接可以提交通过，都需要一个debug的过程，所以 学习如何debug 非常重要！\n\n这也是我为什么 在本文中 单独用来讲解 debug方法。\n\n本题求的是最短路径和是多少，同时我们也要掌握 如何把最短路径打印出来。\n\n我还写了大篇幅来讲解 负权值的情况， 只有画图带大家一步一步去 看 出现负权值 dijkstra的求解过程，才能帮助大家理解，问题出在哪里。\n\n如果我直接讲：是因为访问过的节点 不能再访问，导致错过真正的最短路，我相信大家都不知道我在说啥。\n\n最后我还讲解了 dijkstra 和 prim 算法的 相同 与 不同之处， 我在图论的讲解安排中 先讲 prim算法 再讲 dijkstra 是有目的的， 理解这两个算法的相同与不同之处 有助于大家学习的更深入。\n\n而不是 学了 dijkstra 就只看 dijkstra， 算法之间 都是有联系的，多去思考 算法之间的相互联系，会帮助大家思考的更深入，掌握的更彻底。\n\n本篇写了这么长，我也只讲解了 朴素版dijkstra，关于 堆优化dijkstra，我会在下一篇再来给大家详细讲解。\n\n加油\n\n#其他语言版本\n#Java\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        int[][] grid = new int[n + 1][n + 1];\n        for (int i = 0; i <= n; i++) {\n            Arrays.fill(grid[i], Integer.MAX_VALUE);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int p1 = scanner.nextInt();\n            int p2 = scanner.nextInt();\n            int val = scanner.nextInt();\n            grid[p1][p2] = val;\n        }\n\n        int start = 1;\n        int end = n;\n\n        // 存储从源点到每个节点的最短距离\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n\n        // 记录顶点是否被访问过\n        boolean[] visited = new boolean[n + 1];\n\n        minDist[start] = 0;  // 起始点到自身的距离为0\n\n        for (int i = 1; i <= n; i++) { // 遍历所有节点\n\n            int minVal = Integer.MAX_VALUE;\n            int cur = 1;\n\n            // 1、选距离源点最近且未访问过的节点\n            for (int v = 1; v <= n; ++v) {\n                if (!visited[v] && minDist[v] < minVal) {\n                    minVal = minDist[v];\n                    cur = v;\n                }\n            }\n\n            visited[cur] = true;  // 2、标记该节点已被访问\n\n            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）\n            for (int v = 1; v <= n; v++) {\n                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {\n                    minDist[v] = minDist[cur] + grid[cur][v];\n                }\n            }\n        }\n\n        if (minDist[end] == Integer.MAX_VALUE) {\n            System.out.println(-1); // 不能到达终点\n        } else {\n            System.out.println(minDist[end]); // 到达终点最短路径\n        }\n    }\n}\n\n#Python\nimport sys\n\ndef dijkstra(n, m, edges, start, end):\n    # 初始化邻接矩阵\n    grid = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for p1, p2, val in edges:\n        grid[p1][p2] = val\n\n    # 初始化距离数组和访问数组\n    minDist = [float('inf')] * (n + 1)\n    visited = [False] * (n + 1)\n\n    minDist[start] = 0  # 起始点到自身的距离为0\n\n    for _ in range(1, n + 1):  # 遍历所有节点\n        minVal = float('inf')\n        cur = -1\n\n        # 选择距离源点最近且未访问过的节点\n        for v in range(1, n + 1):\n            if not visited[v] and minDist[v] < minVal:\n                minVal = minDist[v]\n                cur = v\n\n        if cur == -1:  # 如果找不到未访问过的节点，提前结束\n            break\n\n        visited[cur] = True  # 标记该节点已被访问\n\n        # 更新未访问节点到源点的距离\n        for v in range(1, n + 1):\n            if not visited[v] and grid[cur][v] != float('inf') and minDist[cur] + grid[cur][v] < minDist[v]:\n                minDist[v] = minDist[cur] + grid[cur][v]\n\n    return -1 if minDist[end] == float('inf') else minDist[end]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        p1 = int(data[index])\n        p2 = int(data[index + 1])\n        val = int(data[index + 2])\n        edges.append((p1, p2, val))\n        index += 3\n    start = 1  # 起点\n    end = n    # 终点\n\n    result = dijkstra(n, m, edges, start, end)\n    print(result)"
}