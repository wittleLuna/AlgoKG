{
  "id": "AP_35f56f4b",
  "title": "bellman_ford之单源有限最短路",
  "alternative_titles": [],
  "platform": "kamacoder",
  "url": "https://kamacoder.com/problempage.php?pid=1154",
  "description": "计算在最多经过 k 个城市的条件下，从城市 src 到城市 dst 的最低运输成本。\n\n【输入描述】\n\n第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。\n\n接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。\n\n最后一行包含三个正整数，src、dst、和 k，src 和 dst 为城市编号，从 src 到 dst 经过的城市数量限制。\n\n【输出描述】\n\n输出一个整数，表示从城市 src 到城市 dst 的最低运输成本，如果无法在给定经过城市数量限制下找到从 src 到 dst 的路径，则输出 \"unreachable\"，表示不存在符合条件的运输方案。\n\n输入",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "图论",
    "最短路径"
  ],
  "data_structure_tags": [
    "数组",
    "列表"
  ],
  "technique_tags": [
    "松弛操作",
    "迭代"
  ],
  "difficulty": null,
  "solution_approach": "本题通过Bellman-Ford算法求解单源有限最短路径问题。与标准Bellman-Ford算法不同的是，这里需要限制最多经过k个城市（即最多通过k+1条边）来找到从起始城市到目标城市的最小运输成本。首先初始化所有节点的距离为无穷大，起始点距离设为0。然后对所有边进行k+1轮松弛操作，每次更新能够到达更短路径的情况。最后检查终点是否可达以及最短路径。",
  "key_insights": [
    {
      "content": "在有向图中，从一个顶点到另一个顶点的最大边数是n-1（n为顶点数量）。因此，在无负权环的情况下，执行n-1次松弛操作可以确保找到最短路径。对于本题，由于限制了最多经过的城市数量k，故只需执行k+1次松弛操作即可。"
    },
    {
      "content": "当图中存在负权回路时，如果未正确处理，则可能导致无限降低成本的问题。此题并未直接解决这一问题，但在实际应用中应考虑增加额外的检查以防止这种情况发生。"
    },
    {
      "content": "使用minDist_copy记录上一次松弛的结果，以保证每次松弛都是基于上一次的结果，从而避免因本次松弛导致的错误更新。"
    },
    {
      "content": "边的顺序会影响松弛过程中节点的更新情况，但通过minDist_copy可以控制每次松弛都基于上一轮的结果，从而确保结果的准确性。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "本题为单源有限最短路问题，同样是 kama94.城市间货物运输I 延伸题目。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法求解单源有限最短路问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}\n",
          "description": "Java版本的Bellman-Ford算法求解单源有限最短路问题。"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法求解单源有限最短路问题。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0\n    que = deque([src])\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]\n        que_size = len(que)\n        temp_dist = min_dist.copy()\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法求解单源有限最短路问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    for (int i = 1; i <= k + 1; i++) { // 对所有边松弛 k + 1次\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n        }\n\n    }\n\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "C++版本的Bellman-Ford算法实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    minDist[src] = 0;\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "改进后的C++版本的Bellman-Ford算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { // Relax all edges k + 1 times\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                // Use minDistCopy to calculate minDist\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}\nclass Edge {\n    public int u; \n    public int v; \n    public int val; \n\n    public Edge() {\n    }\n\n    public Edge(int u, int v) {\n        this.u = u;\n        this.v = v;\n        this.val = 0;\n    }\n\n    public Edge(int u, int v, int val) {\n        this.u = u;\n        this.v = v;\n        this.val = val;\n    }\n}\n\npublic class SPFAForSSSP {\n\n    public static int[] spfa(int n, List<List<Edge>> graph, int startIdx, int k) {\n        int maxVal = Integer.MAX_VALUE;\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, maxVal);\n        minDist[startIdx] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(startIdx);\n\n        while (k + 1 > 0 && !queue.isEmpty()) {\n            int curSize = queue.size();\n            while (curSize-- > 0) {\n                int[] minDist_copy = Arrays.copyOfRange(minDist, 0, minDist.length);\n                int cur = queue.poll();\n                List<Edge> relateEdges = graph.get(cur);\n                for (Edge edge : relateEdges) {\n                    int u = edge.u;\n                    int v = edge.v;\n                    int weight = edge.val;\n                    if (minDist_copy[u] + weight < minDist[v]) {\n                        minDist[v] = minDist_copy[u] + weight;\n                        if (!queue.contains(v)) {\n                            queue.offer(v);\n                        }\n                    }\n                }\n            }\n            k--;\n        }\n        return minDist;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        while (m-- > 0) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int weight = sc.nextInt();\n            graph.get(u).add(new Edge(u, v, weight));\n        }\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n        int[] minDist = SPFAForSSSP.spfa(n, graph, src, k);\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(\"最短路径：\" + minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford与SPFA算法实现"
        },
        {
          "language": "python",
          "code": "def main():\n    # 輸入\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    \n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    \n    # 只能經過k個城市，所以從起始點到中間有(k + 1)個邊連接\n    # 需要鬆弛(k + 1)次\n    \n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    # 輸出\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0  # 初始化起点的距离\n    que = deque([src])\n\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]  # 用于保证每次松弛时一个节点最多加入队列一次\n        que_size = len(que)\n        temp_dist = min_dist.copy()  # 用于记录上一次遍历的结果\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "使用Bellman-Ford算法解决单源有限最短路问题的C++实现。"
        },
        {
          "language": "Java",
          "code": "import java.util.*;\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<Edge> graph = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n        for (int i = 0; i < k + 1; i++) {\n            int[] minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "使用Bellman-Ford算法解决单源有限最短路问题的Java实现。"
        },
        {
          "language": "Python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\nif __name__ == \"__main__\":\n    main()",
          "description": "使用Bellman-Ford算法解决单源有限最短路问题的Python实现。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <list>",
      "text": "#include <climits>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { \n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        \n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "c++",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); \n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; \n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; \n    else cout << minDist[dst] << endl; \n}",
          "description": "使用Bellman-Ford算法计算从src到dst的最短路径，限制最多经过k个城市。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于计算在最多经过k个城市的条件下，从城市src到城市dst的最低运输成本。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    for (int i = 1; i <= k + 1; i++) { // 对所有边松弛 k + 1次\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n        }\n\n    }\n\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "C++版本的Bellman-Ford算法解决单源有限最短路问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "改进后的C++版本的Bellman-Ford算法解决单源有限最短路问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { // Relax all edges k + 1 times\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                // Use minDistCopy to calculate minDist\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法解决单源有限最短路问题"
        },
        {
          "language": "python",
          "code": "def main():\n    # 輸入\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split() )))\n    \n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    \n    # 只能經過k個城市，所以从起始点到中间有(k + 1)个边连接\n    # 需要松弛(k + 1)次\n    \n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    # 輸出\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法解决单源有限最短路问题"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0  # 初始化起点的距离\n    que = deque([src])\n\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]  # 用于保证每次松弛时一个节点最多加入队列一次\n        que_size = len(que)\n        temp_dist = min_dist.copy()  # 用于记录上一次遍历的结果\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法解决单源有限最短路问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst, k, p1, p2, val, m, n;\n    cin >> n >> m;\n    vector<vector<int>> grid;\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid.push_back({p1, p2, val});\n    }\n    cin >> src >> dst >> k;\n    vector<int> minDist(n + 1, INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1);\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist;\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {\n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl;\n    else cout << minDist[dst] << endl;\n}",
          "description": "C++实现的Bellman-Ford算法求解单源有限最短路径问题。"
        },
        {
          "language": "Java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<Edge> graph = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n        for (int i = 0; i < k + 1; i++) {\n            int[] minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java实现的Bellman-Ford算法求解单源有限最短路径问题。"
        },
        {
          "language": "Python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf')] * (n + 1)\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == '__main__':\n    main()",
          "description": "Python实现的Bellman-Ford算法求解单源有限最短路径问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <list>",
      "text": "#include <climits>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "C++版本的Bellman-Ford算法实现单源有限最短路问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { \n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}\nclass Edge {\n    public int u; \n    public int v; \n    public int val; \n\n    public Edge() {\n    }\n\n    public Edge(int u, int v) {\n        this.u = u;\n        this.v = v;\n        this.val = 0;\n    }\n\n    public Edge(int u, int v, int val) {\n        this.u = u;\n        this.v = v;\n        this.val = val;\n    }\n}\n\npublic class SPFAForSSSP {\n\n    public static int[] spfa(int n, List<List<Edge>> graph, int startIdx, int k) {\n        int maxVal = Integer.MAX_VALUE;\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, maxVal);\n        minDist[startIdx] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(startIdx);\n\n        while (k + 1 > 0 && !queue.isEmpty()) {\n            int curSize = queue.size();\n            while (curSize-- > 0) {\n                int[] minDist_copy = Arrays.copyOfRange(minDist, 0, minDist.length);\n\n                int cur = queue.poll();\n                List<Edge> relateEdges = graph.get(cur);\n                for (Edge edge : relateEdges) {\n                    int u = edge.u;\n                    int v = edge.v;\n                    int weight = edge.val;\n                    if (minDist_copy[u] + weight < minDist[v]) {\n                        minDist[v] = minDist_copy[u] + weight;\n                        if (!queue.contains(v)) {\n                            queue.offer(v);\n                        }\n                    }\n                }\n            }\n            k--;\n        }\n\n        return minDist;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        while (m-- > 0) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int weight = sc.nextInt();\n            graph.get(u).add(new Edge(u, v, weight));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = SPFAForSSSP.spfa(n, graph, src, k);\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(\"最短路径：\" + minDist[n]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford和SPFA算法实现单源有限最短路问题。"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    \n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    \n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()\n\nfrom collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0  # 初始化起点的距离\n    que = deque([src])\n\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]  # 用于保证每次松弛时一个节点最多加入队列一次\n        que_size = len(que)\n        temp_dist = min_dist.copy()  # 用于记录上一次遍历的结果\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford和SPFA算法实现单源有限最短路问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现，处理单源有限最短路问题。"
        },
        {
          "language": "python",
          "code": "def main():\n    # 輸入\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    \n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    \n    # 只能經過k個城市，所以从起始点到中间有(k + 1)个边连接\n    # 需要松弛(k + 1)次\n    \n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    # 输出\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于求解单源有限最短路问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst, k, p1, p2, val, m, n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1, INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <list>",
      "text": "#include <climits>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { // Relax all edges k + 1 times\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                // Use minDistCopy to calculate minDist\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "c++",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法实现，用于解决单源有限最短路问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        \n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现，处理单源有限最短路问题"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于寻找单源有限最短路"
        }
      ],
      "subsections": []
    },
    {
      "name": "拓展一（边的顺序的影响）",
      "text": "其实边的顺序会影响我们每一次拓展的结果。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "基于Bellman-Ford算法的C++实现，解决单源有限最短路问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            int[] minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现，用于求解单源有限最短路问题。"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，解决单源有限最短路问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "拓展二（本题本质）",
      "text": "那么前面讲解过的 94.城市间货物运输I 和 95.城市间货物运输II 也是bellman_ford经典算法，也没使用 minDist_copy，怎么就没问题呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    for (int i = 1; i <= k + 1; i++) { // 对所有边松弛 k + 1次\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n        }\n\n    }\n\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "原始的Bellman-Ford算法实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "改进后的Bellman-Ford算法，使用minDist_copy记录上一次遍历的结果"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start, end, k;\n    cin >> start >> end >> k;\n\n    k++;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); // 用来记录每一次遍历的结果\n\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    int que_size;\n    while (k-- && !que.empty()) {\n\n        minDist_copy = minDist; // 获取上一次计算的结果\n        que_size = que.size(); // 记录上次入队列的节点个数\n        while (que_size--) { // 上一轮松弛入队列的节点，这次对应的边都要做松弛\n            int node = que.front(); que.pop();\n            for (Edge edge : grid[node]) {\n                int from = node;\n                int to = edge.to;\n                int price = edge.val;\n                if (minDist[to] > minDist_copy[from] + price) {\n                    minDist[to] = minDist_copy[from] + price;\n                    que.push(to);\n                }\n            }\n\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << \"unreachable\" << endl;\n    else cout << minDist[end] << endl;\n\n}",
          "description": "使用SPFA算法解决单源有限最短路问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start, end, k;\n    cin >> start >> end >> k;\n\n    k++;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); // 用来记录每一次遍历的结果\n\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    int que_size;\n    while (k-- && !que.empty()) {\n\n        vector<bool> visited(n + 1, false); // 每一轮松弛中，控制节点不用重复入队列\n        minDist_copy = minDist; \n        que_size = que.size(); \n        while (que_size--) { \n            int node = que.front(); que.pop();\n            for (Edge edge : grid[node]) {\n                int from = node;\n                int to = edge.to;\n                int price = edge.val;\n                if (minDist[to] > minDist_copy[from] + price) {\n                    minDist[to] = minDist_copy[from] + price;\n                    if(visited[to]) continue; // 不用重复放入队列，但需要重复松弛，所以放在这里位置\n                    visited[to] = true;\n                    que.push(to);\n                }\n            }\n\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << \"unreachable\" << endl;\n    else cout << minDist[end] << endl;\n}",
          "description": "优化后的SPFA算法，避免了重复节点入队列的问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { // Relax all edges k + 1 times\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                // Use minDistCopy to calculate minDist\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        \n        // Output printing\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class SPFAForSSSP {\n\n    public static int[] spfa(int n, List<List<Edge>> graph, int startIdx, int k) {\n        int maxVal = Integer.MAX_VALUE;\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, maxVal);\n        minDist[startIdx] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(startIdx);\n\n        while (k + 1 > 0 && !queue.isEmpty()) {\n            int curSize = queue.size();\n            while (curSize-- > 0) {\n                int[] minDist_copy = Arrays.copyOfRange(minDist, 0, minDist.length);\n\n                int cur = queue.poll();\n                List<Edge> relateEdges = graph.get(cur);\n                for (Edge edge : relateEdges) {\n                    int u = edge.u;\n                    int v = edge.v;\n                    int weight = edge.val;\n                    if (minDist_copy[u] + weight < minDist[v]) {\n                        minDist[v] = minDist_copy[u] + weight;\n                        if (!queue.contains(v)) {\n                            queue.offer(v);\n                        }\n                    }\n                }\n            }\n            k--;\n        }\n\n        return minDist;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        while (m-- > 0) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int weight = sc.nextInt();\n            graph.get(u).add(new Edge(u, v, weight));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = SPFAForSSSP.spfa(n, graph, src, k);\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(\"最短路径：\" + minDist[dst]);\n        }\n    }\n}\nclass Edge {\n    public int u;\n    public int v;\n    public int val;\n\n    public Edge() {\n    }\n\n    public Edge(int u, int v) {\n        this.u = u;\n        this.v = v;\n        this.val = 0;\n    }\n\n    public Edge(int u, int v, int val) {\n        this.u = u;\n        this.v = v;\n        this.val = val;\n    }\n}",
          "description": "Java版本的SPFA算法实现"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    \n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    \n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0  # 初始化起点的距离\n    que = deque([src])\n\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]  # 用于保证每次松弛时一个节点最多加入队列一次\n        que_size = len(que)\n        temp_dist = min_dist.copy()  # 用于记录上一次遍历的结果\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "拓展三（SPFA）",
      "text": "本题也可以用 SPFA来做，关于 SPFA ，已经在这里 0094.城市间货物运输I-SPFA 有详细讲解。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "C++版本的Bellman-Ford算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { \n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        \n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现"
        },
        {
          "language": "python",
          "code": "def main():\n    # 输入\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    \n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    \n    # 只能经过k个城市，所以从起始点到中间有(k + 1)个边连接\n    # 需要松弛(k + 1)次\n    \n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    # 输出\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { \n    int to;  \n    int val; \n\n    Edge(int t, int w): to(t), val(w) {}  \n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); \n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start, end, k;\n    cin >> start >> end >> k;\n\n    k++;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); \n\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); \n\n    int que_size;\n    while (k-- && !que.empty()) {\n\n        vector<bool> visited(n + 1, false); \n        minDist_copy = minDist; \n        que_size = que.size(); \n        while (que_size--) { \n            int node = que.front(); que.pop();\n            for (Edge edge : grid[node]) {\n                int from = node;\n                int to = edge.to;\n                int price = edge.val;\n                if (minDist[to] > minDist_copy[from] + price) {\n                    minDist[to] = minDist_copy[from] + price;\n                    if(visited[to]) continue; \n                    visited[to] = true;\n                    que.push(to);\n                }\n            }\n\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << \"unreachable\" << endl;\n    else cout << minDist[end] << endl;\n}",
          "description": "C++版本的SPFA算法实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0  # 初始化起点的距离\n    que = deque([src])\n\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]  # 用于保证每次松弛时一个节点最多加入队列一次\n        que_size = len(que)\n        temp_dist = min_dist.copy()  # 用于记录上一次遍历的结果\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "C++版本的Bellman-Ford算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        \n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现"
        },
        {
          "language": "python",
          "code": "def main():\n    # 輸入\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    \n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    \n    # 只能經過k個城市，所以从起始点到中间有(k + 1)个边连接\n    # 需要松弛(k + 1)次\n    \n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    # 输出\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    for (int i = 1; i <= k + 1; i++) { // 对所有边松弛 k + 1次\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n        }\n\n    }\n\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "使用C++实现Bellman-Ford算法解决单源有限最短路问题的初始版本"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "使用C++改进版Bellman-Ford算法解决单源有限最短路问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start, end, k;\n    cin >> start >> end >> k;\n\n    k++;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); // 用来记录每一次遍历的结果\n\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    int que_size;\n    while (k-- && !que.empty()) {\n\n        minDist_copy = minDist; \n        que_size = que.size(); \n        while (que_size--) { \n            int node = que.front(); que.pop();\n            for (Edge edge : grid[node]) {\n                int from = node;\n                int to = edge.to;\n                int price = edge.val;\n                if (minDist[to] > minDist_copy[from] + price) {\n                    minDist[to] = minDist_copy[from] + price;\n                    que.push(to);\n                }\n            }\n\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << \"unreachable\" << endl;\n    else cout << minDist[end] << endl;\n\n}",
          "description": "使用C++ SPFA算法解决单源有限最短路问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start, end, k;\n    cin >> start >> end >> k;\n\n    k++;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); // 用来记录每一次遍历的结果\n\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    int que_size;\n    while (k-- && !que.empty()) {\n\n        vector<bool> visited(n + 1, false); // 每一轮松弛中，控制节点不用重复入队列\n        minDist_copy = minDist; \n        que_size = que.size(); \n        while (que_size--) { \n            int node = que.front(); que.pop();\n            for (Edge edge : grid[node]) {\n                int from = node;\n                int to = edge.to;\n                int price = edge.val;\n                if (minDist[to] > minDist_copy[from] + price) {\n                    minDist[to] = minDist_copy[from] + price;\n                    if(visited[to]) continue; // 不用重复放入队列，但需要重复松弛，所以放在这里位置\n                    visited[to] = true;\n                    que.push(to);\n                }\n            }\n\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << \"unreachable\" << endl;\n    else cout << minDist[end] << endl;\n}",
          "description": "使用C++优化版SPFA算法解决单源有限最短路问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { \n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "使用Java实现Bellman-Ford算法解决单源有限最短路问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\nclass Edge {\n    public int u; \n    public int v; \n    public int val; \n\n    public Edge() {\n    }\n\n    public Edge(int u, int v) {\n        this.u = u;\n        this.v = v;\n        this.val = 0;\n    }\n\n    public Edge(int u, int v, int val) {\n        this.u = u;\n        this.v = v;\n        this.val = val;\n    }\n}\n\npublic class SPFAForSSSP {\n    public static int[] spfa(int n, List<List<Edge>> graph, int startIdx, int k) {\n        int maxVal = Integer.MAX_VALUE;\n        int[] minDist = new int[n + 1]; \n        Arrays.fill(minDist, maxVal);\n        minDist[startIdx] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(startIdx);\n\n        while (k + 1 > 0 && !queue.isEmpty()) {\n            int curSize = queue.size();\n            while (curSize-- > 0) {\n                int[] minDist_copy = Arrays.copyOfRange(minDist, 0, minDist.length);\n\n                int cur = queue.poll();\n                List<Edge> relateEdges = graph.get(cur);\n                for (Edge edge : relateEdges) {\n                    int u = edge.u;\n                    int v = edge.v;\n                    int weight = edge.val;\n                    if (minDist_copy[u] + weight < minDist[v]) {\n                        minDist[v] = minDist_copy[u] + weight; \n                        if (!queue.contains(v)) {\n                            queue.offer(v);\n                        }\n                    }\n                }\n            }\n            k--;\n        }\n\n        return minDist;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        while (m-- > 0) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int weight = sc.nextInt();\n            graph.get(u).add(new Edge(u, v, weight));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = SPFAForSSSP.spfa(n, graph, src, k);\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(\"最短路径：\" + minDist[dst]);\n        }\n    }\n}",
          "description": "使用Java实现SPFA算法解决单源有限最短路问题"
        },
        {
          "language": "python",
          "code": "def main():\n    # 輸入\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    \n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    \n    # 只能經過k個城市，所以从起始点到中间有(k + 1)个边连接\n    # 需要松弛(k + 1)次\n    \n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    # 輸出\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "使用Python实现Bellman-Ford算法解决单源有限最短路问题"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0  # 初始化起点的距离\n    que = deque([src])\n\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]  # 用于保证每次松弛时一个节点最多加入队列一次\n        que_size = len(que)\n        temp_dist = min_dist.copy()  # 用于记录上一次遍历的结果\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "使用Python实现SPFA算法解决单源有限最短路问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <queue>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    for (int i = 1; i <= k + 1; i++) { // 对所有边松弛 k + 1次\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n        }\n\n    }\n\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "使用Bellman-Ford算法计算从src到dst的最低运输成本"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "修改后的Bellman-Ford算法，通过复制minDist数组来避免在每次迭代中更新同一节点多次"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start, end, k;\n    cin >> start >> end >> k;\n\n    k++;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); // 用来记录每一次遍历的结果\n\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    int que_size;\n    while (k-- && !que.empty()) {\n\n        minDist_copy = minDist; // 获取上一次计算的结果\n        que_size = que.size(); // 记录上次入队列的节点个数\n        while (que_size--) { // 上一轮松弛入队列的节点，这次对应的边都要做松弛\n            int node = que.front(); que.pop();\n            for (Edge edge : grid[node]) {\n                int from = node;\n                int to = edge.to;\n                int price = edge.val;\n                if (minDist[to] > minDist_copy[from] + price) {\n                    minDist[to] = minDist_copy[from] + price;\n                    que.push(to);\n                }\n            }\n\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << \"unreachable\" << endl;\n    else cout << minDist[end] << endl;\n\n}",
          "description": "使用SPFA算法解决单源有限最短路问题，并控制最多经过k个节点"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start, end, k;\n    cin >> start >> end >> k;\n\n    k++;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); // 用来记录每一次遍历的结果\n\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    int que_size;\n    while (k-- && !que.empty()) {\n\n        vector<bool> visited(n + 1, false); // 每一轮松弛中，控制节点不用重复入队列\n        minDist_copy = minDist; \n        que_size = que.size(); \n        while (que_size--) { \n            int node = que.front(); que.pop();\n            for (Edge edge : grid[node]) {\n                int from = node;\n                int to = edge.to;\n                int price = edge.val;\n                if (minDist[to] > minDist_copy[from] + price) {\n                    minDist[to] = minDist_copy[from] + price;\n                    if(visited[to]) continue; // 不用重复放入队列，但需要重复松弛，所以放在这里位置\n                    visited[to] = true;\n                    que.push(to);\n                }\n            }\n\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << \"unreachable\" << endl;\n    else cout << minDist[end] << endl;\n\n}",
          "description": "优化后的SPFA算法，防止重复节点进入队列以减少不必要的计算"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { // Relax all edges k + 1 times\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                // Use minDistCopy to calculate minDist\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}\n",
          "description": "Java版本的Bellman-Ford算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class SPFAForSSSP {\n\n    public static int[] spfa(int n, List<List<Edge>> graph, int startIdx, int k) {\n        int maxVal = Integer.MAX_VALUE;\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, maxVal);\n        minDist[startIdx] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(startIdx);\n\n        while (k + 1 > 0 && !queue.isEmpty()) {\n            int curSize = queue.size();\n            while (curSize-- > 0) {\n                int[] minDist_copy = Arrays.copyOfRange(minDist, 0, minDist.length);\n\n                int cur = queue.poll();\n                List<Edge> relateEdges = graph.get(cur);\n                for (Edge edge : relateEdges) {\n                    int u = edge.u;\n                    int v = edge.v;\n                    int weight = edge.val;\n                    if (minDist_copy[u] + weight < minDist[v]) {\n                        minDist[v] = minDist_copy[u] + weight;\n                        if (!queue.contains(v)) {\n                            queue.offer(v);\n                        }\n                    }\n                }\n            }\n            k--;\n        }\n\n        return minDist;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        while (m-- > 0) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int weight = sc.nextInt();\n            graph.get(u).add(new Edge(u, v, weight));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = spfa(n, graph, src, k);\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(\"最短路径：\" + minDist[dst]);\n        }\n    }\n}\n\nclass Edge {\n    public int u;\n    public int v;\n    public int val;\n\n    public Edge() {}\n\n    public Edge(int u, int v) {\n        this.u = u;\n        this.v = v;\n        this.val = 0;\n    }\n\n    public Edge(int u, int v, int val) {\n        this.u = u;\n        this.v = v;\n        this.val = val;\n    }\n}\n",
          "description": "Java版本的SPFA算法实现，处理含负权回路的有向图的最短路径问题"
        },
        {
          "language": "python",
          "code": "def main():\n    # 輸入\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    \n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    \n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    # 輸出\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于求解单源有限最短路问题"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0  # 初始化起点的距离\n    que = deque([src])\n\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]  # 用于保证每次松弛时一个节点最多加入队列一次\n        que_size = len(que)\n        temp_dist = min_dist.copy()  # 用于记录上一次遍历的结果\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法实现，用于求解单源有限最短路问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <list>",
      "text": "#include <climits>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<Edge> graph = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        },
        {
          "language": "python",
          "code": "def main():\n    # 输入\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    # 只能经过k个城市，所以从起始点到中间有(k + 1)个边连接\n    # 需要松弛(k + 1)次\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    # 输出\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于解决单源有限最短路问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    for (int i = 1; i <= k + 1; i++) { // 对所有边松弛 k + 1次\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n        }\n\n    }\n\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "基于Bellman-Ford算法的C++实现，用于解决单源有限最短路问题。"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    minDist[src] = 0;\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "改进后的C++代码，通过复制上一次迭代的距离数组来确保每次更新都是基于前一轮的结果，以正确处理负权回路。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现，用于求解单源有限最短路问题，同样采用了保留上次迭代结果的方法来避免错误更新。"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现的Bellman-Ford算法，用于找到从起点到终点经过最多k个节点的最小运输成本，考虑了图中可能存在的负权边。"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0  # 初始化起点的距离\n    que = deque([src])\n\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]  # 用于保证每次松弛时一个节点最多加入队列一次\n        que_size = len(que)\n        temp_dist = min_dist.copy()  # 用于记录上一次遍历的结果\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "利用SPFA算法（Shortest Path Faster Algorithm）的Python实现，用于在有负权边的情况下高效地查找单源最短路径，并限制了最大访问节点数。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法实现单源有限最短路问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现单源有限最短路问题。"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现单源有限最短路问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <queue>",
      "text": "#include <list>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++代码实现Bellman-Ford算法求解单源有限最短路问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java代码实现Bellman-Ford算法求解单源有限最短路问题"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\nif __name__ == \"__main__\":\n    main()",
          "description": "Python代码实现Bellman-Ford算法求解单源有限最短路问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <list>",
      "text": "#include <climits>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
          "description": "C++版本的Bellman-Ford算法实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { // Relax all edges k + 1 times\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                // Use minDistCopy to calculate minDist\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}\nclass Edge {\n    public int u; // 边的端点1\n    public int v; // 边的端点2\n    public int val; // 边的权值\n\n    public Edge() {\n    }\n\n    public Edge(int u, int v) {\n        this.u = u;\n        this.v = v;\n        this.val = 0;\n    }\n\n    public Edge(int u, int v, int val) {\n        this.u = u;\n        this.v = v;\n        this.val = val;\n    }\n}\n\npublic class SPFAForSSSP {\n\n    public static int[] spfa(int n, List<List<Edge>> graph, int startIdx, int k) {\n        int maxVal = Integer.MAX_VALUE;\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, maxVal);\n        minDist[startIdx] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(startIdx);\n\n        while (k + 1 > 0 && !queue.isEmpty()) {\n            int curSize = queue.size();\n            while (curSize-- > 0) {\n                int[] minDist_copy = Arrays.copyOfRange(minDist, 0, minDist.length);\n\n                int cur = queue.poll();\n                List<Edge> relateEdges = graph.get(cur);\n                for (Edge edge : relateEdges) {\n                    int u = edge.u;\n                    int v = edge.v;\n                    int weight = edge.val;\n                    if (minDist_copy[u] + weight < minDist[v]) {\n                        minDist[v] = minDist_copy[u] + weight;\n                        if (!queue.contains(v)) {\n                            queue.offer(v);\n                        }\n                    }\n                }\n            }\n            k--;\n        }\n\n        return minDist;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        while (m-- > 0) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int weight = sc.nextInt();\n            graph.get(u).add(new Edge(u, v, weight));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = SPFAForSSSP.spfa(n, graph, src, k);\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(\"最短路径：\" + minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford和SPFA算法实现"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    \n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    \n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0  # 初始化起点的距离\n    que = deque([src])\n\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]\n        que_size = len(que)\n        temp_dist = min_dist.copy()\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的SPFA算法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <climits>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法实现，用于解决单源有限最短路问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现，用于解决单源有限最短路问题"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(m)]\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于解决单源有限最短路问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "拓展四（能否用dijkstra）",
      "text": "本题能否使用 dijkstra 算法呢？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    for (int i = 1; i <= k + 1; i++) { // 对所有边松弛 k + 1次\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n        }\n    }\n\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "使用Bellman-Ford算法求解单源有限最短路问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "基于Bellman-Ford算法的改进版本，通过复制上次的最小距离数组来避免更新顺序问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { // Relax all edges k + 1 times\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                // Use minDistCopy to calculate minDist\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java实现的Bellman-Ford算法求解单源有限最短路问题"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现的Bellman-Ford算法求解单源有限最短路问题"
        },
        {
          "language": "python",
          "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0  # 初始化起点的距离\n    que = deque([src])\n\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]  # 用于保证每次松弛时一个节点最多加入队列一次\n        que_size = len(que)\n        temp_dist = min_dist.copy()  # 用于记录上一次遍历的结果\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现的SPFA算法求解单源有限最短路问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "本题是单源有限最短路问题，也是 bellman_ford的一个拓展问题，如果理解bellman_ford 其实思路比较容易理解，但有很多细节。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++实现的Bellman-Ford算法版本二"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}\nclass Edge {\n    public int u;\n    public int v;\n    public int val;\n\n    public Edge() {}\n\n    public Edge(int u, int v) {\n        this.u = u;\n        this.v = v;\n        this.val = 0;\n    }\n\n    public Edge(int u, int v, int val) {\n        this.u = u;\n        this.v = v;\n        this.val = val;\n    }\n}\n\npublic class SPFAForSSSP {\n\n    public static int[] spfa(int n, List<List<Edge>> graph, int startIdx, int k) {\n        int maxVal = Integer.MAX_VALUE;\n        int[] minDist = new int[n + 1];\n        Arrays.fill(minDist, maxVal);\n        minDist[startIdx] = 0;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(startIdx);\n\n        while (k + 1 > 0 && !queue.isEmpty()) {\n            int curSize = queue.size();\n            while (curSize-- > 0) {\n                int[] minDist_copy = Arrays.copyOfRange(minDist, 0, minDist.length);\n                int cur = queue.poll();\n                List<Edge> relateEdges = graph.get(cur);\n                for (Edge edge : relateEdges) {\n                    int u = edge.u;\n                    int v = edge.v;\n                    int weight = edge.val;\n                    if (minDist_copy[u] + weight < minDist[v]) {\n                        minDist[v] = minDist_copy[u] + weight;\n                        if (!queue.contains(v)) {\n                            queue.offer(v);\n                        }\n                    }\n                }\n            }\n            k--;\n        }\n        return minDist;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        while (m-- > 0) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int weight = sc.nextInt();\n            graph.get(u).add(new Edge(u, v, weight));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = SPFAForSSSP.spfa(n, graph, src, k);\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(\"最短路径：\" + minDist[dst]);\n        }\n    }\n}",
          "description": "Java实现的Bellman-Ford和SPFA算法"
        },
        {
          "language": "python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\nif __name__ == \"__main__\":\n    main()\n\nfrom collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0\n    que = deque([src])\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]\n        que_size = len(que)\n        temp_dist = min_dist.copy()\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现的Bellman-Ford和SPFA算法"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "import java.util.*;public class Main {static class Edge {int from; int to; int val; public Edge(int from, int to, int val) {this.from = from; this.to = to; this.val = val;}} public static void main(String[] args) {Scanner sc = new Scanner(System.in);int n = sc.nextInt();int m = sc.nextInt();List<Edge> graph = new ArrayList<>();for (int i = 0; i < m; i++) {int from = sc.nextInt();int to = sc.nextInt();int val = sc.nextInt();graph.add(new Edge(from, to, val));}int src = sc.nextInt();int dst = sc.nextInt();int k = sc.nextInt();int[] minDist = new int[n + 1];int[] minDistCopy;Arrays.fill(minDist, Integer.MAX_VALUE);minDist[src] = 0;for (int i = 0; i < k + 1; i++) {minDistCopy = Arrays.copyOf(minDist, n + 1);for (Edge edge : graph) {int from = edge.from;int to = edge.to;int val = edge.val;if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {minDist[to] = minDistCopy[from] + val;}}}if (minDist[dst] == Integer.MAX_VALUE) {System.out.println(\"unreachable\");} else {System.out.println(minDist[dst]);}}}",
          "description": "基于Bellman-Ford算法解决单源最短路径问题的Java实现"
        },
        {
          "language": "java",
          "code": "import java.util.*;class Edge {public int u; public int v; public int val; public Edge() {} public Edge(int u, int v) {this.u = u; this.v = v; this.val = 0;} public Edge(int u, int v, int val) {this.u = u; this.v = v; this.val = val;}} public class SPFAForSSSP {public static int[] spfa(int n, List<List<Edge>> graph, int startIdx, int k) {int maxVal = Integer.MAX_VALUE;int[] minDist = new int[n + 1];Arrays.fill(minDist, maxVal);minDist[startIdx] = 0;Queue<Integer> queue = new LinkedList<>();queue.offer(startIdx);while (k + 1 > 0 && !queue.isEmpty()) {int curSize = queue.size();while (curSize-- > 0) {int[] minDist_copy = Arrays.copyOfRange(minDist, 0, minDist.length);int cur = queue.poll();List<Edge> relateEdges = graph.get(cur);for (Edge edge : relateEdges) {int u = edge.u;int v = edge.v;int weight = edge.val;if (minDist_copy[u] + weight < minDist[v]) {minDist[v] = minDist_copy[u] + weight;if (!queue.contains(v)) {queue.offer(v);}}}}}k--;}return minDist;}public static void main(String[] args) {Scanner sc = new Scanner(System.in);int n = sc.nextInt();int m = sc.nextInt();List<List<Edge>> graph = new ArrayList<>();for (int i = 0; i <= n; i++) {graph.add(new ArrayList<>());}while (m-- > 0) {int u = sc.nextInt();int v = sc.nextInt();int weight = sc.nextInt();graph.get(u).add(new Edge(u, v, weight));}int src = sc.nextInt();int dst = sc.nextInt();int k = sc.nextInt();int[] minDist = SPFAForSSSP.spfa(n, graph, src, k);if (minDist[dst] == Integer.MAX_VALUE) {System.out.println(\"unreachable\");} else {System.out.println(\"最短路径：\" + minDist[dst]);}}}",
          "description": "使用SPFA算法求解限定起点、终点及至多途径节点数下的最短路径问题"
        },
        {
          "language": "python",
          "code": "def main():n, m = map(int, input().split())edges = [list(map(int, input().split())) for _ in range(m)]start, end, k = map(int, input().split())min_dist = [float('inf') for _ in range(n + 1)]min_dist[start] = 0for _ in range(k + 1):update = Falsemin_dist_copy = min_dist.copy()for src, desc, w in edges:if (min_dist_copy[src] != float('inf') and min_dist_copy[src] + w < min_dist[desc]):min_dist[desc] = min_dist_copy[src] + wupdate = Trueif not update:breakif min_dist[end] == float('inf'):print('unreachable')else:print(min_dist[end])if __name__ == \"__main__\":main()",
          "description": "Python中使用Bellman-Ford方法求解单源有限最短路"
        },
        {
          "language": "python",
          "code": "from collections import deque;from math import inf;def main():n, m = [int(i) for i in input().split()]graph = [[] for _ in range(n+1)];for _ in range(m):v1, v2, val = [int(i) for i in input().split()]graph[v1].append([v2, val])src, dst, k = [int(i) for i in input().split()]min_dist = [inf for _ in range(n+1)]min_dist[src] = 0que = deque([src]);while k != -1 and que:visited = [False for _ in range(n+1)]que_size = len(que)temp_dist = min_dist.copy()for _ in range(que_size):cur_node = que.popleft()for next_node, val in graph[cur_node]:if min_dist[next_node] > temp_dist[cur_node] + val:min_dist[next_node] = temp_dist[cur_node] + valif not visited[next_node]:que.append(next_node)visited[next_node] = Truek -= 1;if min_dist[dst] == inf:print(\"unreachable\")else:print(min_dist[dst])if __name__ == \"__main__\":main()",
          "description": "Python中使用SPFA方法求解单源有限最短路"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "import java.util.*;",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法解决单源有限最短路问题"
        },
        {
          "language": "Java",
          "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法解决单源有限最短路问题"
        },
        {
          "language": "Python",
          "code": "def main():\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法解决单源有限最短路问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "Bellman-Ford方法求解单源有限最短路",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n}",
          "description": "C++版本的Bellman-Ford算法实现，用于求解单源有限最短路问题。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\npublic class Main {\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) {\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
          "description": "Java版本的Bellman-Ford算法实现，用于求解单源有限最短路问题。"
        },
        {
          "language": "python",
          "code": "def main():\n    # 輸入\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split())))\n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    # 只能經過k個城市，所以从起始点到中间有(k + 1)个边连接\n    # 需要松弛(k + 1)次\n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    # 输出\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的Bellman-Ford算法实现，用于求解单源有限最短路问题。"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(K * E)",
    "space_complexity": "O(N)",
    "explanation": "K为至多经过K个节点，E为图中边的数量"
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    for (int i = 1; i <= k + 1; i++) { // 对所有边松弛 k + 1次\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n        }\n\n    }\n\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
      "description": "使用C++实现的Bellman-Ford算法版本一"
    },
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}",
      "description": "使用C++实现的Bellman-Ford算法版本二"
    },
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start, end, k;\n    cin >> start >> end >> k;\n\n    k++;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); // 用来记录每一次遍历的结果\n\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    int que_size;\n    while (k-- && !que.empty()) {\n\n        minDist_copy = minDist; // 获取上一次计算的结果\n        que_size = que.size(); // 记录上次入队列的节点个数\n        while (que_size--) { // 上一轮松弛入队列的节点，这次对应的边都要做松弛\n            int node = que.front(); que.pop();\n            for (Edge edge : grid[node]) {\n                int from = node;\n                int to = edge.to;\n                int price = edge.val;\n                if (minDist[to] > minDist_copy[from] + price) {\n                    minDist[to] = minDist_copy[from] + price;\n                    que.push(to);\n                }\n            }\n\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << \"unreachable\" << endl;\n    else cout << minDist[end] << endl;\n\n}",
      "description": "使用C++实现的SPFA算法版本一"
    },
    {
      "language": "cpp",
      "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start, end, k;\n    cin >> start >> end >> k;\n\n    k++;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); // 用来记录每一次遍历的结果\n\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    int que_size;\n    while (k-- && !que.empty()) {\n\n        vector<bool> visited(n + 1, false); // 每一轮松弛中，控制节点不用重复入队列\n        minDist_copy = minDist; \n        que_size = que.size(); \n        while (que_size--) { \n            int node = que.front(); que.pop();\n            for (Edge edge : grid[node]) {\n                int from = node;\n                int to = edge.to;\n                int price = edge.val;\n                if (minDist[to] > minDist_copy[from] + price) {\n                    minDist[to] = minDist_copy[from] + price;\n                    if(visited[to]) continue; // 不用重复放入队列，但需要重复松弛，所以放在这里位置\n                    visited[to] = true;\n                    que.push(to);\n                }\n            }\n\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << \"unreachable\" << endl;\n    else cout << minDist[end] << endl;\n}",
      "description": "使用C++实现的优化后的SPFA算法版本"
    },
    {
      "language": "java",
      "code": "import java.util.*;\n\npublic class Main {\n    // 基于Bellman_for一般解法解决单源最短路径问题\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { // Relax all edges k + 1 times\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                // Use minDistCopy to calculate minDist\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        \n        // Output printing\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}",
      "description": "使用Java实现的Bellman-Ford算法"
    },
    {
      "language": "java",
      "code": "class Edge {\n    public int u; // 边的端点1\n    public int v; // 边的端点2\n    public int val; // 边的权值\n\n    public Edge() {\n    }\n\n    public Edge(int u, int v) {\n        this.u = u;\n        this.v = v;\n        this.val = 0;\n    }\n\n    public Edge(int u, int v, int val) {\n        this.u = u;\n        this.v = v;\n        this.val = val;\n    }\n}\n\n/**\n * SPFA算法（版本3）：处理含【负权回路】的有向图的最短路径问题\n * bellman_ford（版本3） 的队列优化算法版本\n * 限定起点、终点、至多途径k个节点\n */\npublic class SPFAForSSSP {\n\n    /**\n     * SPFA算法\n     *\n     * @param n        节点个数[1,n]\n     * @param graph    邻接表\n     * @param startIdx 开始节点（源点）\n     */\n    public static int[] spfa(int n, List<List<Edge>> graph, int startIdx, int k) {\n        // 定义最大范围\n        int maxVal = Integer.MAX_VALUE;\n        // minDist[i] 源点到节点i的最短距离\n        int[] minDist = new int[n + 1]; // 有效节点编号范围：[1,n]\n        Arrays.fill(minDist, maxVal); // 初始化为maxVal\n        minDist[startIdx] = 0; // 设置源点到源点的最短路径为0\n\n        // 定义queue记录每一次松弛更新的节点\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(startIdx); // 初始化：源点开始（queue和minDist的更新是同步的）\n\n\n        // SPFA算法核心：只对上一次松弛的时候更新过的节点关联的边进行松弛操作\n        while (k + 1 > 0 && !queue.isEmpty()) { // 限定松弛 k+1 次\n            int curSize = queue.size(); // 记录当前队列节点个数（上一次松弛更新的节点个数，用作分层统计）\n            while (curSize-- > 0) { //分层控制，限定本次松弛只针对上一次松弛更新的节点，不对新增的节点做处理\n                // 记录当前minDist状态，作为本次松弛的基础\n                int[] minDist_copy = Arrays.copyOfRange(minDist, 0, minDist.length);\n\n                // 取出节点\n                int cur = queue.poll();\n                // 获取cur节点关联的边，进行松弛操作\n                List<Edge> relateEdges = graph.get(cur);\n                for (Edge edge : relateEdges) {\n                    int u = edge.u; // 与`cur`对照\n                    int v = edge.v;\n                    int weight = edge.val;\n                    if (minDist_copy[u] + weight < minDist[v]) {\n                        minDist[v] = minDist_copy[u] + weight; // 更新\n                        // 队列同步更新（此处有一个针对队列的优化:就是如果已经存在于队列的元素不需要重复添加）\n                        if (!queue.contains(v)) {\n                            queue.offer(v); // 与minDist[i]同步更新，将本次更新的节点加入队列，用做下一个松弛的参考基础\n                        }\n                    }\n                }\n            }\n            // 当次松弛结束，次数-1\n            k--;\n        }\n\n        // 返回minDist\n        return minDist;\n    }\n\n    public static void main(String[] args) {\n        // 输入控制\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"1.输入N个节点、M条边（u v weight）\");\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        System.out.println(\"2.输入M条边\");\n        List<List<Edge>> graph = new ArrayList<>(); // 构建邻接表\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        while (m-- > 0) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int weight = sc.nextInt();\n            graph.get(u).add(new Edge(u, v, weight));\n        }\n\n        System.out.println(\"3.输入src dst k（起点、终点、至多途径k个点）\");\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        // 调用算法\n        int[] minDist = SPFAForSSSP.spfa(n, graph, src, k);\n        // 校验起点->终点\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(\"最短路径：\" + minDist[n]);\n        }\n    }\n}",
      "description": "使用Java实现的SPFA算法"
    },
    {
      "language": "python",
      "code": "def main():\n    # 輸入\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split() )))\n    \n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    \n    # 只能經過k個城市，所以从起始点到中间有(k + 1)个边连接\n    # 需要鬆弛(k + 1)次\n    \n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    # 輸出\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n            \n\nif __name__ == \"__main__\":\n    main()",
      "description": "使用Python实现的Bellman-Ford算法"
    },
    {
      "language": "python",
      "code": "from collections import deque\nfrom math import inf\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0  # 初始化起点的距离\n    que = deque([src])\n\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]  # 用于保证每次松弛时一个节点最多加入队列一次\n        que_size = len(que)\n        temp_dist = min_dist.copy()  # 用于记录上一次遍历的结果\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\nif __name__ == \"__main__\":\n    main()",
      "description": "使用Python实现的SPFA算法"
    }
  ],
  "common_mistakes": [
    "没有考虑到可能存在负权回路导致的成本无限减少问题。",
    "错误地将松弛操作次数设置为n-1而非k+1，忽略了题目中关于最大经过城市数量的限制。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240402115614.png",
      "description": "这张图片展示了一个链表数据结构，节点值分别为1、2、3、4，且每个节点的值与其下一个节点的值相等或相差1，体现了链表的基本特性和节点间的关系。",
      "context": "该图示例展示了从起点出发，经过最多2个中间节点到达终点的过程，用以解释为何在最多经过k个城市的情况下需要考虑k+1条边。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240409111940.png",
      "description": "这张图片展示了一个图的最短路径问题，使用Dijkstra算法进行求解，图中节点间的权重和距离数组（minDist）的初始化状态被清晰标注。",
      "context": "这张图片展示了从节点1开始，初始化各节点的最小距离值时的状态，其中minDist[1]设置为0，而其他节点的minDist值被初始化为最大整数。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240409111914.png",
      "description": "这张图片展示了使用Dijkstra算法在带权图中寻找最短路径的过程，特别关注了节点间的距离更新和最小距离数组的初始化状态。",
      "context": "该图片展示了在对边“节点1 -> 节点2”进行松弛操作后，minDist数组更新的情况，其中minDist[2]从初始的最大值被更新为-1。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240409111903.png",
      "description": "这张图片展示了一个图的最短路径算法（如Dijkstra算法）的解题过程，包含节点间的边权值和一个记录最小距离的数组`minDist`。",
      "context": "该图展示了从节点2到节点3的边，以及更新节点3最短距离的过程。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240409111849.png",
      "description": "这张图片展示了一个带有负权边的图及其最短路径算法（如Bellman-Ford算法）的解题过程，图中节点间的权重和一个记录最小距离的数组`minDist`被清晰标注。",
      "context": "展示了从节点3到节点1边的松弛过程，其中权值为-1，更新了minDist[1]的值。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20241018192042.png",
      "description": "这张图片展示了一个有向图及其最短路径计算过程，使用了Dijkstra算法来更新节点间的最小距离。",
      "context": "该图展示了从节点3到节点4的边，权值为1，以及minDist数组更新的过程，其中minDist[4]被更新为1。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240410154340.png",
      "description": "这张图片展示了一个有向图，包含四个节点（1、2、3、4）及其之间的加权边，体现了图论中的数据结构和算法概念。",
      "context": "该图展示了即使边的顺序不同，所构成的图结构保持一致的情况，用以说明边的顺序如何影响算法的执行结果。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240410155545.png",
      "description": "这张图片展示了一个图的最短路径算法示例，使用了Dijkstra算法，图中节点间的边权值和当前节点到起点的最小距离数组（minDist）被清晰标注。",
      "context": "该图片展示了在算法初始化阶段，各节点及其边的初始状态和权值，用于说明按照特定顺序处理边时对结果的影响。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240410160046.png",
      "description": "这张图片展示了一个使用Dijkstra算法求解最短路径的过程，图中包含节点、边权值以及距离数组的更新状态。",
      "context": "图片展示了在对所有边进行一次松弛操作后，基于给定的边及其权值条件，节点间最短路径更新的情况。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240508112249.png",
      "description": "这张图片展示了一个加权有向图，节点间通过带权重的边连接，适用于最短路径算法（如Dijkstra算法）的分析。",
      "context": "这张图展示了求解节点1到节点7最多经过2个节点情况下的最短路径问题背景。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240508112416.png",
      "description": "这张图片展示了一个加权有向图，节点间通过带权重的边连接，适用于最短路径算法（如Dijkstra算法）的分析。",
      "context": "这张图片展示了从节点1到节点7，最多经过2个节点（即通过3条边）的最短路径。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240130115306.png",
      "description": "这张图片展示了一个图的最短路径算法（如Dijkstra算法）的初始状态，包括节点间的边权、距离数组`minDist`和访问标记数组`visited`。",
      "context": "此图为Dijkstra算法求解过程中的初始化状态图，展示了起点到其他各点的初始距离设定。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240130115421.png",
      "description": "这张图片展示了Dijkstra算法在加权图中的应用，通过更新节点的最短距离（minDist）和访问状态（visited）来找到从起点到其他节点的最短路径。",
      "context": "这张图片展示了在Dijkstra算法执行过程中，选取节点2作为当前距离源点最近且未被访问过的节点时的状态。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240130121240.png",
      "description": "这张图片展示了Dijkstra算法在加权图中的应用，通过`minDist`数组记录最短路径距离和`visited`数组标记已访问节点来逐步找到从起点到各节点的最短路径。",
      "context": "展示了在Dijkstra算法执行过程中，选择距离源点最近且未被访问过的节点2时的状态。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240130120434.png",
      "description": "这张图片展示了Dijkstra算法在图中的应用，通过节点间的最短路径计算和相关数据结构（如`minDist`和`visited`数组）来逐步确定最短路径。",
      "context": "展示了在寻找距离源点最近且未被访问过的节点过程中，找到节点3的情况。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240201105335.png",
      "description": "这张图片展示了Dijkstra算法在加权图中的应用，通过更新节点的最短距离（minDist）和访问状态（visited）来找到从起点到各节点的最短路径。",
      "context": "这张图片展示了在Dijkstra算法执行过程中，找到距离源点最近且未被访问过的节点4时的状态。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240402115614.png",
      "description": "GIF展示了通过逐步松弛边来寻找从起点到终点最多经过k+1条边的最短路径的过程。",
      "context": "该GIF动画展示了从起点出发，经过最多k个中间节点到达终点的过程，帮助理解为何需要考虑k+1条边来计算最短路径。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240409111940.png",
      "description": "GIF展示了从起点出发，通过不断更新各节点的最短路径估计值来寻找到达每个节点最短路径的过程。",
      "context": "此GIF动画展示了从起点节点1出发，对所有边进行第一次松弛操作的过程，特别是更新到达各节点的最短路径值。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240409111914.png",
      "description": "GIF展示了从节点1开始，通过更新相邻节点的最小距离来逐步探索图中各节点的过程。",
      "context": "GIF展示了从节点1到节点2边的松弛过程，其中更新了节点2的最小距离值。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240409111903.png",
      "description": "GIF展示了在图中对节点间边进行松弛操作以更新最短路径的过程。",
      "context": "该GIF动画展示了从节点2到节点3的边权值为1时，更新节点3的最短路径估计值的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240409111849.png",
      "description": "GIF展示了在图中通过边更新各节点最短路径的过程。",
      "context": "该GIF动画展示了从节点3出发，根据边的权值更新目标节点1的距离值的过程，体现了算法中距离更新（松弛）的操作。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20241018192042.png",
      "description": "该GIF动画展示了在图中对节点间距离进行松弛操作的过程，以更新从起点出发到达其他各节点的最短路径值。",
      "context": "该GIF动画展示了从节点3到节点4的边进行松弛操作的过程，其中minDist[4]被更新为1。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240410154340.png",
      "description": "GIF展示了在不同边顺序下，算法对图中节点进行最短路径计算的过程。",
      "context": "该GIF动画展示了按照修改后的边的顺序对图进行初始化及第一次拓展的过程，直观地解释了边的顺序如何影响算法运行的结果。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240410155545.png",
      "description": "该GIF动画展示了图算法中，依据特定边顺序对节点进行初始化及第一次松弛操作的过程。",
      "context": "该GIF动画展示了算法初始化阶段及对所有边进行第一次拓展的情况，特别是如何根据边的顺序和权值更新节点间最短路径的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240410160046.png",
      "description": "GIF展示了在Bellman-Ford算法中，对图的所有边进行第一次松弛操作后节点间最短路径更新的过程。",
      "context": "GIF动画展示了在对所有边进行一次松弛操作过程中，节点间距离更新的具体情况。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240508112249.png",
      "description": "GIF展示了使用Dijkstra算法求解从节点1到节点7最多经过2个节点的最短路径的过程。",
      "context": "GIF动画展示了Dijkstra算法在求解从节点1到节点7最多经过2个节点的最短路径时的步骤模拟。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240508112416.png",
      "description": "GIF展示了Dijkstra算法寻找从节点1到节点7最短路径的过程，限制最多经过2个中间节点。",
      "context": "该GIF动画展示了使用Dijkstra算法求解从节点1到节点7最多经过2个节点的最短路径的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240130115306.png",
      "description": "GIF展示了Dijkstra算法求解从节点1到其他节点最短路径的过程。",
      "context": "该GIF动画展示了Dijkstra算法初始化时的状态，为后续寻找最短路径的过程奠定基础。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240130115421.png",
      "description": "GIF展示了Dijkstra算法寻找从源点出发最近未访问节点的过程。",
      "context": "此GIF动画展示了Dijkstra算法中选取距离源点最近且未被访问过的节点2的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240130121240.png",
      "description": "Dijkstra算法逐步寻找从源点出发、未被访问过的最近节点的过程演示。",
      "context": "该GIF动画展示了在Dijkstra算法执行过程中，找到距离源点最近且未被访问过的节点2，并更新与其相连节点的距离的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240130120434.png",
      "description": "Dijkstra算法逐步选择距离源点最近且未被访问过的节点的过程演示。",
      "context": "此GIF动画展示了在Dijkstra算法执行过程中，逐步找到距离源点最近且未被访问过的节点3的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240201105335.png",
      "description": "GIF展示了Dijkstra算法执行过程中逐步选择距离源点最近且未被访问过的节点的过程。",
      "context": "该GIF动画展示了在Dijkstra算法执行过程中，从源点开始逐步找到最近且未访问过的节点直至搜索结束的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\最短路\\bellman_ford之单源有限最短路.txt",
  "extracted_at": "2025-07-22T03:11:02.942045",
  "raw_content": "bellman_ford之单源有限最短路\n卡码网：96. 城市间货物运输 III(https://kamacoder.com/problempage.php?pid=1154)\n\n【题目描述】\n\n某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。\n\n网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。\n\n权值为正表示扣除了政府补贴后运输货物仍需支付的费用；\n\n权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。\n\n请计算在最多经过 k 个城市的条件下，从城市 src 到城市 dst 的最低运输成本。\n\n【输入描述】\n\n第一行包含两个正整数，第一个正整数 n 表示该国一共有 n 个城市，第二个整数 m 表示这些城市中共有 m 条道路。\n\n接下来为 m 行，每行包括三个整数，s、t 和 v，表示 s 号城市运输货物到达 t 号城市，道路权值为 v。\n\n最后一行包含三个正整数，src、dst、和 k，src 和 dst 为城市编号，从 src 到 dst 经过的城市数量限制。\n\n【输出描述】\n\n输出一个整数，表示从城市 src 到城市 dst 的最低运输成本，如果无法在给定经过城市数量限制下找到从 src 到 dst 的路径，则输出 \"unreachable\"，表示不存在符合条件的运输方案。\n\n输入示例：\n\n6 7\n1 2 1\n2 4 -3\n2 5 2\n1 3 5\n3 5 1\n4 6 4\n5 6 -2\n2 6 1\n输出示例：\n\n0\n#思路\n本题为单源有限最短路问题，同样是 kama94.城市间货物运输I 延伸题目。\n\n注意题目中描述是 最多经过 k 个城市的条件下，而不是一定经过k个城市，也可以经过的城市数量比k小，但要最短的路径。\n\n在 kama94.城市间货物运输I 中我们讲了：对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离。\n\n节点数量为n，起点到终点，最多是 n-1 条边相连。 那么对所有边松弛 n-1 次 就一定能得到 起点到达 终点的最短距离。\n\n（如果对以上讲解看不懂，建议详看 kama94.城市间货物运输I ）\n\n本题是最多经过 k 个城市， 那么是 k + 1条边相连的节点。 这里可能有录友想不懂为什么是k + 1，来看这个图：\nhttps://file1.kamacoder.com/i/algo/20240402115614.png\n\n\n图中，节点1 最多已经经过2个节点 到达节点4，那么中间是有多少条边呢，是 3 条边对吧。\n\n所以本题就是求：起点最多经过k + 1 条边到达终点的最短距离。\n\n对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离，那么对所有边松弛 k + 1次，就是求 起点到达 与起点k + 1条边相连的节点的 最短距离。\n\n注意： 本题是 kama94.城市间货物运输I 的拓展题，如果对 bellman_ford 没有深入了解，强烈建议先看 kama94.城市间货物运输I 再做本题。\n\n理解以上内容，其实本题代码就很容易了，bellman_ford 标准写法是松弛 n-1 次，本题就松弛 k + 1次就好。\n\n此时我们可以写出如下代码：\n\n// 版本一\n#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    for (int i = 1; i <= k + 1; i++) { // 对所有边松弛 k + 1次\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n        }\n\n    }\n\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}\n\n以上代码 标准 bellman_ford 写法，松弛 k + 1次，看上去没什么问题。\n\n但大家提交后，居然没通过！\n\n这是为什么呢？\n\n接下来我们拿这组数据来举例：\n\n4 4\n1 2 -1\n2 3 1\n3 1 -1\n3 4 1\n1 4 3\n（注意上面的示例是有负权回路的，只有带负权回路的图才能说明问题）\n\n负权回路是指一条道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。\n\n正常来说，这组数据输出应该是 1，但以上代码输出的是 -2。\n\n在讲解原因的时候，强烈建议大家，先把 minDist数组打印出来，看看minDist数组是不是按照自己的想法变化的，这样更容易理解我接下来的讲解内容。 （一定要动手，实践出真实，脑洞模拟不靠谱）\n\n打印的代码可以是这样：\n\n#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    for (int i = 1; i <= k + 1; i++) { // 对所有边松弛 k + 1次\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;\n        }\n        // 打印 minDist 数组 \n        for (int j = 1; j <= n; j++) cout << minDist[j] << \" \";\n        cout << endl;\n\n    }\n\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}\n\n接下来，我按照上面的示例带大家 画图举例 对所有边松弛一次 的效果图。\n\n起点为节点1， 起点到起点的距离为0，所以 minDist[1] 初始化为0 ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240409111940.png\n\n其他节点对应的minDist初始化为max，因为我们要求最小距离，那么还没有计算过的节点 默认是一个最大数，这样才能更新最小距离。\n\n当我们开始对所有边开始第一次松弛：\n\n边：节点1 -> 节点2，权值为-1 ，minDist[2] > minDist[1] + (-1)，更新 minDist[2] = minDist[1] + (-1) = 0 - 1 = -1 ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240409111914.png\n\n边：节点2 -> 节点3，权值为1 ，minDist[3] > minDist[2] + 1 ，更新 minDist[3] = minDist[2] + 1 = -1 + 1 = 0 ，如图： \nhttps://file1.kamacoder.com/i/algo/20240409111903.png\n\n边：节点3 -> 节点1，权值为-1 ，minDist[1] > minDist[3] + (-1)，更新 minDist[1] = 0 + (-1) = -1 ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240409111849.png\n\n边：节点3 -> 节点4，权值为1 ，minDist[4] > minDist[3] + 1，更新 minDist[4] = 0 + 1 = 1 ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20241018192042.png\n\n以上是对所有边进行的第一次松弛，最后 minDist数组为 ：-1 -1 0 1 ，（从下标1算起）\n\n后面几次松弛我就不挨个画图了，过程大同小异，我直接给出minDist数组的变化：\n\n所有边进行的第二次松弛，minDist数组为 ： -2 -2 -1 0 所有边进行的第三次松弛，minDist数组为 ： -3 -3 -2 -1 所有边进行的第四次松弛，minDist数组为 ： -4 -4 -3 -2 （本示例中k为3，所以松弛4次）\n\n最后计算的结果minDist[4] = -2，即 起点到 节点4，最多经过 3 个节点的最短距离是 -2，但 正确的结果应该是 1，即路径：节点1 -> 节点2 -> 节点3 -> 节点4。\n\n理论上来说，对所有边松弛一次，相当于计算 起点到达 与起点一条边相连的节点 的最短距离。\n\n对所有边松弛两次，相当于计算 起点到达 与起点两条边相连的节点的最短距离。\n\n对所有边松弛三次，以此类推。\n\n但在对所有边松弛第一次的过程中，大家会发现，不仅仅 与起点一条边相连的节点更新了，所有节点都更新了。\n\n而且对所有边的后面几次松弛，同样是更新了所有的节点，说明 至多经过k 个节点 这个限制 根本没有限制住，每个节点的数值都被更新了。\n\n这是为什么？\n\n在上面画图距离中，对所有边进行第一次松弛，在计算 边（节点2 -> 节点3） 的时候，更新了 节点3。\n\nhttps://file1.kamacoder.com/i/algo/20240409111903.png\n\n理论上来说节点3 应该在对所有边第二次松弛的时候才更新。 这因为当时是基于已经计算好的 节点2（minDist[2]）来做计算了。\n\nminDist[2]在计算边：（节点1 -> 节点2）的时候刚刚被赋值为 -1。\n\n这样就造成了一个情况，即：计算minDist数组的时候，基于了本次松弛的 minDist数值，而不是上一次 松弛时候minDist的数值。\n所以在每次计算 minDist 时候，要基于 对所有边上一次松弛的 minDist 数值才行，所以我们要记录上一次松弛的minDist。\n\n代码修改如下： （关键地方已经注释）\n\n// 版本二\n#include <iostream>\n#include <vector>\n#include <list>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int src, dst,k ,p1, p2, val ,m , n;\n    \n    cin >> n >> m;\n\n    vector<vector<int>> grid;\n\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        grid.push_back({p1, p2, val});\n    }\n\n    cin >> src >> dst >> k;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    minDist[src] = 0;\n    vector<int> minDist_copy(n + 1); // 用来记录上一次遍历的结果\n    for (int i = 1; i <= k + 1; i++) {\n        minDist_copy = minDist; // 获取上一次计算的结果\n        for (vector<int> &side : grid) {\n            int from = side[0];\n            int to = side[1];\n            int price = side[2];\n            // 注意使用 minDist_copy 来计算 minDist \n            if (minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + price) {  \n                minDist[to] = minDist_copy[from] + price;\n            }\n        }\n    }\n    if (minDist[dst] == INT_MAX) cout << \"unreachable\" << endl; // 不能到达终点\n    else cout << minDist[dst] << endl; // 到达终点最短路径\n\n}\n\n时间复杂度： O(K * E) , K为至多经过K个节点，E为图中边的数量\n空间复杂度： O(N) ，即 minDist 数组所开辟的空间\n#拓展一（边的顺序的影响）\n其实边的顺序会影响我们每一次拓展的结果。\n\n我来给大家举个例子。\n\n我上面讲解中，给出的示例是这样的：\n\n4 4\n1 2 -1\n2 3 1\n3 1 -1\n3 4 1\n1 4 3\n我将示例中边的顺序改一下，给成：\n\n4 4\n3 1 -1\n3 4 1\n2 3 1\n1 2 -1\n1 4 3\n所构成是图是一样的，都是如下的这个图，但给出的边的顺序是不一样的。\nhttps://file1.kamacoder.com/i/algo/20240410154340.png\n\n\n再用版本一的代码是运行一下，发现结果输出是 1， 是对的。\n\n\n\n分明刚刚输出的结果是 -2，是错误的，怎么 一样的图，这次输出的结果就对了呢？\n\n其实这是和示例中给出的边的顺序是有关的，\n\n我们按照修改后的示例再来模拟 对所有边的第一次拓展情况。\n\n初始化：\n\nhttps://file1.kamacoder.com/i/algo/20240410155545.png\n\n边：节点3 -> 节点1，权值为-1 ，节点3还没有被计算过，节点1 不更新。\n\n边：节点3 -> 节点4，权值为1 ，节点3还没有被计算过，节点4 不更新。\n\n边：节点2 -> 节点3，权值为 1 ，节点2还没有被计算过，节点3 不更新。\n\n边：节点1 -> 节点2，权值为 -1 ，minDist[2] > minDist[1] + (-1)，更新 minDist[2] = 0 + (-1) = -1 ，如图：\n\nhttps://file1.kamacoder.com/i/algo/20240410160046.png\n\n以上是对所有边 松弛一次的状态。\n\n可以发现 同样的图，边的顺序不一样，使用版本一的代码 每次松弛更新的节点也是不一样的。\n\n而边的顺序是随机的，是题目给我们的，所以本题我们才需要 记录上一次松弛的minDist，来保障 每一次对所有边松弛的结果。\n\n#拓展二（本题本质）\n那么前面讲解过的 94.城市间货物运输I 和 95.城市间货物运输II 也是bellman_ford经典算法，也没使用 minDist_copy，怎么就没问题呢？\n\n如果没看过我上面这两篇讲解的话，建议详细学习上面两篇，再看我下面讲的区别，否则容易看不懂。\n\n94.城市间货物运输I， 是没有 负权回路的，那么 多松弛多少次，对结果都没有影响。\n\n求 节点1 到 节点n 的最短路径，松弛n-1 次就够了，松弛 大于 n-1次，结果也不会变。\n\n那么在对所有边进行第一次松弛的时候，如果基于 本次计算的 minDist 来计算 minDist （相当于多做松弛了），也是对最终结果没影响。\n\n95.城市间货物运输II 是判断是否有 负权回路，一旦有负权回路， 对所有边松弛 n-1 次以后，在做松弛 minDist 数值一定会变，根据这一点来判断是否有负权回路。\n\n所以，95.城市间货物运输II 只需要判断minDist数值变化了就行，而 minDist 的数值对不对，并不是我们关心的。\n\n那么本题 为什么计算minDist 一定要基于上次 的 minDist 数值。\n\n其关键在于本题的两个因素：\n\n本题可以有负权回路，说明只要多做松弛，结果是会变的。\n本题要求最多经过k个节点，对松弛次数是有限制的。\n#拓展三（SPFA）\n本题也可以用 SPFA来做，关于 SPFA ，已经在这里 0094.城市间货物运输I-SPFA 有详细讲解。\n\n使用SPFA算法解决本题的时候，关键在于 如何控制松弛k次。\n\n其实实现不难，但有点技巧，可以用一个变量 que_size 记录每一轮松弛入队列的所有节点数量。\n\n下一轮松弛的时候，就把队列里 que_size 个节点都弹出来，就是上一轮松弛入队列的节点。\n\n代码如下（详细注释）\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start, end, k;\n    cin >> start >> end >> k;\n\n    k++;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); // 用来记录每一次遍历的结果\n\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    int que_size;\n    while (k-- && !que.empty()) {\n\n        minDist_copy = minDist; // 获取上一次计算的结果\n        que_size = que.size(); // 记录上次入队列的节点个数\n        while (que_size--) { // 上一轮松弛入队列的节点，这次对应的边都要做松弛\n            int node = que.front(); que.pop();\n            for (Edge edge : grid[node]) {\n                int from = node;\n                int to = edge.to;\n                int price = edge.val;\n                if (minDist[to] > minDist_copy[from] + price) {\n                    minDist[to] = minDist_copy[from] + price;\n                    que.push(to);\n                }\n            }\n\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << \"unreachable\" << endl;\n    else cout << minDist[end] << endl;\n\n}\n\n时间复杂度： O(K * H) H 为不确定数，取决于 图的稠密度，但H 一定是小于等于 E 的\n\n关于 SPFA的是时间复杂度分析，我在0094.城市间货物运输I-SPFA 有详细讲解\n\n但大家会发现，以上代码大家提交后，怎么耗时这么多？\n\n\n\n理论上，SPFA的时间复杂度不是要比 bellman_ford 更优吗？\n\n怎么耗时多了这么多呢？\n\n以上代码有一个可以改进的点，每一轮松弛中，重复节点可以不用入队列。\n\n因为重复节点入队列，下次从队列里取节点的时候，该节点要取很多次，而且都是重复计算。\n\n所以代码可以优化成这样：\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <list>\n#include <climits>\nusing namespace std;\n\nstruct Edge { //邻接表\n    int to;  // 链接的节点\n    int val; // 边的权重\n\n    Edge(int t, int w): to(t), val(w) {}  // 构造函数\n};\n\n\nint main() {\n    int n, m, p1, p2, val;\n    cin >> n >> m;\n\n    vector<list<Edge>> grid(n + 1); // 邻接表\n\n    // 将所有边保存起来\n    for(int i = 0; i < m; i++){\n        cin >> p1 >> p2 >> val;\n        // p1 指向 p2，权值为 val\n        grid[p1].push_back(Edge(p2, val));\n    }\n    int start, end, k;\n    cin >> start >> end >> k;\n\n    k++;\n\n    vector<int> minDist(n + 1 , INT_MAX);\n    vector<int> minDist_copy(n + 1); // 用来记录每一次遍历的结果\n\n    minDist[start] = 0;\n\n    queue<int> que;\n    que.push(start); // 队列里放入起点\n\n    int que_size;\n    while (k-- && !que.empty()) {\n\n        vector<bool> visited(n + 1, false); // 每一轮松弛中，控制节点不用重复入队列\n        minDist_copy = minDist; \n        que_size = que.size(); \n        while (que_size--) { \n            int node = que.front(); que.pop();\n            for (Edge edge : grid[node]) {\n                int from = node;\n                int to = edge.to;\n                int price = edge.val;\n                if (minDist[to] > minDist_copy[from] + price) {\n                    minDist[to] = minDist_copy[from] + price;\n                    if(visited[to]) continue; // 不用重复放入队列，但需要重复松弛，所以放在这里位置\n                    visited[to] = true;\n                    que.push(to);\n                }\n            }\n\n        }\n    }\n    if (minDist[end] == INT_MAX) cout << \"unreachable\" << endl;\n    else cout << minDist[end] << endl;\n}\n以上代码提交后，耗时情况：\n\n\n\n大家发现 依然远比 bellman_ford 的代码版本 耗时高。\n\n这又是为什么呢？\n\n对于后台数据，我特别制作的一个稠密大图，该图有250个节点和10000条边， 在这种情况下， SPFA 的时间复杂度 是接近与 bellman_ford的。\n\n但因为 SPFA 节点的进出队列操作，耗时很大，所以相同的时间复杂度的情况下，SPFA 实际上更耗时了。\n\n这一点我在 0094.城市间货物运输I-SPFA 有分析，感兴趣的录友再回头去看看。\n\n#拓展四（能否用dijkstra）\n本题能否使用 dijkstra 算法呢？\n\ndijkstra 是贪心的思路 每一次搜索都只会找距离源点最近的非访问过的节点。\n\n如果限制最多访问k个节点，那么 dijkstra 未必能在有限次就能到达终点，即使在经过k个节点确实可以到达终点的情况下。\n\n这么说大家会感觉有点抽象，我用 dijkstra朴素版精讲 里的示例在举例说明： （如果没看过我讲的dijkstra朴素版精讲，建议去仔细看一下，否则下面讲解容易看不懂）\n\n在以下这个图中，求节点1 到 节点7 最多经过2个节点 的最短路是多少呢？\nhttps://file1.kamacoder.com/i/algo/20240508112249.png\n\n\n最短路显然是：\n\nhttps://file1.kamacoder.com/i/algo/20240508112416.png\n\n最多经过2个节点，也就是3条边相连的路线：节点1 -> 节点2 -> 节点6-> 节点7\n\n如果是 dijkstra 求解的话，求解过程是这样的： （下面是dijkstra的模拟过程，我精简了很多，如果看不懂，一定要先看dijkstra朴素版精讲）\n\n初始化如图所示：\n\nhttps://file1.kamacoder.com/i/algo/20240130115306.png\n\n找距离源点最近且没有被访问过的节点，先找节点1\n\nhttps://file1.kamacoder.com/i/algo/20240130115421.png\n\n距离源点最近且没有被访问过的节点，找节点2：\nhttps://file1.kamacoder.com/i/algo/20240130121240.png\n\n\n距离源点最近且没有被访问过的节点，找到节点3：\nhttps://file1.kamacoder.com/i/algo/20240130120434.png\n\n\n距离源点最近且没有被访问过的节点，找到节点4：\nhttps://file1.kamacoder.com/i/algo/20240201105335.png\n\n\n此时最多经过2个节点的搜索就完毕了，但结果中minDist[7] （即节点7的结果）并没有被更。\n\n那么 dijkstra 会告诉我们 节点1 到 节点7 最多经过2个节点的情况下是不可到达的。\n\n通过以上模拟过程，大家应该能感受到 dijkstra 贪心的过程，正是因为 贪心，所以 dijkstra 找不到 节点1 -> 节点2 -> 节点6-> 节点7 这条路径。\n\n#总结\n本题是单源有限最短路问题，也是 bellman_ford的一个拓展问题，如果理解bellman_ford 其实思路比较容易理解，但有很多细节。\n\n例如 为什么要用 minDist_copy 来记录上一轮 松弛的结果。 这也是本篇我为什么花了这么大篇幅讲解的关键所在。\n\n接下来，还给大家做了四个拓展：\n\n边的顺序的影响\n本题的本质\nSPFA的解法\n能否用dijkstra\n学透了以上四个拓展，相信大家会对bellman_ford有更深入的理解。\n\n#其他语言版本\n#Java\nimport java.util.*;\n\npublic class Main {\n    // 基于Bellman_for一般解法解决单源最短路径问题\n    // Define an inner class Edge\n    static class Edge {\n        int from;\n        int to;\n        int val;\n        public Edge(int from, int to, int val) {\n            this.from = from;\n            this.to = to;\n            this.val = val;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Input processing\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        List<Edge> graph = new ArrayList<>();\n\n        for (int i = 0; i < m; i++) {\n            int from = sc.nextInt();\n            int to = sc.nextInt();\n            int val = sc.nextInt();\n            graph.add(new Edge(from, to, val));\n        }\n\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        int[] minDist = new int[n + 1];\n        int[] minDistCopy;\n\n        Arrays.fill(minDist, Integer.MAX_VALUE);\n        minDist[src] = 0;\n\n        for (int i = 0; i < k + 1; i++) { // Relax all edges k + 1 times\n            minDistCopy = Arrays.copyOf(minDist, n + 1);\n            for (Edge edge : graph) {\n                int from = edge.from;\n                int to = edge.to;\n                int val = edge.val;\n                // Use minDistCopy to calculate minDist\n                if (minDistCopy[from] != Integer.MAX_VALUE && minDist[to] > minDistCopy[from] + val) {\n                    minDist[to] = minDistCopy[from] + val;\n                }\n            }\n        }\n        \n        // Output printing\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(minDist[dst]);\n        }\n    }\n}\n\nclass Edge {\n    public int u; // 边的端点1\n    public int v; // 边的端点2\n    public int val; // 边的权值\n\n    public Edge() {\n    }\n\n    public Edge(int u, int v) {\n        this.u = u;\n        this.v = v;\n        this.val = 0;\n    }\n\n    public Edge(int u, int v, int val) {\n        this.u = u;\n        this.v = v;\n        this.val = val;\n    }\n}\n\n/**\n * SPFA算法（版本3）：处理含【负权回路】的有向图的最短路径问题\n * bellman_ford（版本3） 的队列优化算法版本\n * 限定起点、终点、至多途径k个节点\n */\npublic class SPFAForSSSP {\n\n    /**\n     * SPFA算法\n     *\n     * @param n        节点个数[1,n]\n     * @param graph    邻接表\n     * @param startIdx 开始节点（源点）\n     */\n    public static int[] spfa(int n, List<List<Edge>> graph, int startIdx, int k) {\n        // 定义最大范围\n        int maxVal = Integer.MAX_VALUE;\n        // minDist[i] 源点到节点i的最短距离\n        int[] minDist = new int[n + 1]; // 有效节点编号范围：[1,n]\n        Arrays.fill(minDist, maxVal); // 初始化为maxVal\n        minDist[startIdx] = 0; // 设置源点到源点的最短路径为0\n\n        // 定义queue记录每一次松弛更新的节点\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(startIdx); // 初始化：源点开始（queue和minDist的更新是同步的）\n\n\n        // SPFA算法核心：只对上一次松弛的时候更新过的节点关联的边进行松弛操作\n        while (k + 1 > 0 && !queue.isEmpty()) { // 限定松弛 k+1 次\n            int curSize = queue.size(); // 记录当前队列节点个数（上一次松弛更新的节点个数，用作分层统计）\n            while (curSize-- > 0) { //分层控制，限定本次松弛只针对上一次松弛更新的节点，不对新增的节点做处理\n                // 记录当前minDist状态，作为本次松弛的基础\n                int[] minDist_copy = Arrays.copyOfRange(minDist, 0, minDist.length);\n\n                // 取出节点\n                int cur = queue.poll();\n                // 获取cur节点关联的边，进行松弛操作\n                List<Edge> relateEdges = graph.get(cur);\n                for (Edge edge : relateEdges) {\n                    int u = edge.u; // 与`cur`对照\n                    int v = edge.v;\n                    int weight = edge.val;\n                    if (minDist_copy[u] + weight < minDist[v]) {\n                        minDist[v] = minDist_copy[u] + weight; // 更新\n                        // 队列同步更新（此处有一个针对队列的优化:就是如果已经存在于队列的元素不需要重复添加）\n                        if (!queue.contains(v)) {\n                            queue.offer(v); // 与minDist[i]同步更新，将本次更新的节点加入队列，用做下一个松弛的参考基础\n                        }\n                    }\n                }\n            }\n            // 当次松弛结束，次数-1\n            k--;\n        }\n\n        // 返回minDist\n        return minDist;\n    }\n\n    public static void main(String[] args) {\n        // 输入控制\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"1.输入N个节点、M条边（u v weight）\");\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        System.out.println(\"2.输入M条边\");\n        List<List<Edge>> graph = new ArrayList<>(); // 构建邻接表\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        while (m-- > 0) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int weight = sc.nextInt();\n            graph.get(u).add(new Edge(u, v, weight));\n        }\n\n        System.out.println(\"3.输入src dst k（起点、终点、至多途径k个点）\");\n        int src = sc.nextInt();\n        int dst = sc.nextInt();\n        int k = sc.nextInt();\n\n        // 调用算法\n        int[] minDist = SPFAForSSSP.spfa(n, graph, src, k);\n        // 校验起点->终点\n        if (minDist[dst] == Integer.MAX_VALUE) {\n            System.out.println(\"unreachable\");\n        } else {\n            System.out.println(\"最短路径：\" + minDist[n]);\n        }\n    }\n}\n#Python\nBellman-Ford方法求解单源有限最短路\n\ndef main():\n    # 輸入\n    n, m = map(int, input().split())\n    edges = list()\n    for _ in range(m):\n        edges.append(list(map(int, input().split() )))\n    \n    start, end, k = map(int, input().split())\n    min_dist = [float('inf') for _ in range(n + 1)]\n    min_dist[start] = 0\n    \n    # 只能經過k個城市，所以從起始點到中間有(k + 1)個邊連接\n    # 需要鬆弛(k + 1)次\n    \n    for _ in range(k + 1):\n        update = False\n        min_dist_copy = min_dist.copy()\n        for src, desc, w in edges:\n            if (min_dist_copy[src] != float('inf') and \n            min_dist_copy[src] + w < min_dist[desc]):\n                min_dist[desc] = min_dist_copy[src] + w\n                update = True\n        if not update:\n            break\n    # 輸出\n    if min_dist[end] == float('inf'):\n        print('unreachable')\n    else:\n        print(min_dist[end])\n            \n            \n\nif __name__ == \"__main__\":\n    main()\nSPFA方法求解单源有限最短路\n\nfrom collections import deque\nfrom math import inf\n\n\ndef main():\n    n, m = [int(i) for i in input().split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        v1, v2, val = [int(i) for i in input().split()]\n        graph[v1].append([v2, val])\n    src, dst, k = [int(i) for i in input().split()]\n    min_dist = [inf for _ in range(n+1)]\n    min_dist[src] = 0  # 初始化起点的距离\n    que = deque([src])\n\n    while k != -1 and que:\n        visited = [False for _ in range(n+1)]  # 用于保证每次松弛时一个节点最多加入队列一次\n        que_size = len(que)\n        temp_dist = min_dist.copy()  # 用于记录上一次遍历的结果\n        for _ in range(que_size):\n            cur_node = que.popleft()\n            for next_node, val in graph[cur_node]:\n                if min_dist[next_node] > temp_dist[cur_node] + val:\n                    min_dist[next_node] = temp_dist[cur_node] + val\n                    if not visited[next_node]:\n                        que.append(next_node)\n                        visited[next_node] = True\n        k -= 1\n\n    if min_dist[dst] == inf:\n        print(\"unreachable\")\n    else:\n        print(min_dist[dst])\n\n\nif __name__ == \"__main__\":\n    main()"
}