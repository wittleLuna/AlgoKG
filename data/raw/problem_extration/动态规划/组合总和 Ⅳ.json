{
  "id": "AP_d2d4c7d6",
  "title": "组合总和 Ⅳ",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/combination-sum-iv/",
  "description": "一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划",
    "完全背包"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "迭代"
  ],
  "difficulty": null,
  "solution_approach": "本题采用动态规划求解，定义dp[i]表示凑成目标值i的排列个数。通过两层循环更新dp数组：外层循环遍历从0到target的目标值，内层循环遍历给定的nums数组元素。这样可以确保每个元素在每种可能的位置上都被考虑到，从而计算出所有不同的排列组合。",
  "key_insights": [
    {
      "content": "本题实际是求排列数而非组合数，因此不同顺序的序列被视为不同的解。"
    },
    {
      "content": "初始化dp[0]=1是为了递推公式能够正确地进行累加，即使它在题目背景下没有直接意义。"
    },
    {
      "content": "遍历顺序至关重要：外层遍历背包容量（即目标值），内层遍历物品列表，以确保得到的是排列数。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "对完全背包还不了解的同学，可以看这篇：动态规划：关于完全背包，你该了解这些！(https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html)",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int combinationSum4(vector<int>& nums, int target) {vector<int> dp(target + 1, 0);dp[0] = 1;for (int i = 0; i <= target; i++) {for (int j = 0; j < nums.size(); j++) {if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {dp[i] += dp[i - nums[j]];}}}return dp[target];}};",
          "description": "C++版本的组合总和IV解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public int combinationSum4(int[] nums, int target) {int[] dp = new int[target + 1];dp[0] = 1;for (int i = 0; i <= target; i++) {for (int j = 0; j < nums.length; j++) {if (i >= nums[j]) {dp[i] += dp[i - nums[j]];}}}return dp[target];}}",
          "description": "Java版本的组合总和IV解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in range(len(nums)): if i - nums[j] >= 0: dp[i] += dp[i - nums[j]] return dp[target]",
          "description": "Python版本的组合总和IV解决方案（卡哥版）"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in nums: if i >= j: dp[i] += dp[i - j] return dp[-1]",
          "description": "Python版本的组合总和IV优化版解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [[0] * (target+1) for _ in nums] for i in range(len(nums)): dp[i][0] = 1 for j in range(1, target+1): for i in range(len(nums)): if j - nums[i] >= 0: dp[i][j] = dp[i-1][j] + dp[-1][j-nums[i]] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]",
          "description": "Python版本的二维DP组合总和IV解决方案"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "求装满背包有几种方法，递归公式都是一样的，没有什么差别，但关键在于遍历顺序！",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int combinationSum4(vector<int>& nums, int target) {vector<int> dp(target + 1, 0); dp[0] = 1; for (int i = 0; i <= target; i++) {for (int j = 0; j < nums.size(); j++) {if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {dp[i] += dp[i - nums[j]];}}} return dp[target];}};",
          "description": "C++版本的组合总和IV解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public int combinationSum4(int[] nums, int target) {int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i <= target; i++) {for (int j = 0; j < nums.length; j++) {if (i >= nums[j]) {dp[i] += dp[i - nums[j]];}}} return dp[target];}}",
          "description": "Java版本的组合总和IV解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in range(len(nums)): if i - nums[j] >= 0: dp[i] += dp[i - nums[j]] return dp[target]",
          "description": "Python版本的组合总和IV解决方案，卡哥版"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in nums: if i >= j: dp[i] += dp[i - j] return dp[-1]",
          "description": "Python版本的组合总和IV解决方案，优化版"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [[0] * (target+1) for _ in nums] for i in range(len(nums)): dp[i][0] = 1 for j in range(1, target+1): for i in range(len(nums)): if j - nums[i] >= 0: dp[i][j] = dp[i-1][j] + dp[-1][j-nums[i]] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]",
          "description": "Python版本的组合总和IV解决方案，二维DP版"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int combinationSum4(vector<int>& nums, int target) {vector<int> dp(target + 1, 0);dp[0] = 1;for (int i = 0; i <= target; i++) { for (int j = 0; j < nums.size(); j++) { if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) { dp[i] += dp[i - nums[j]]; }}}}return dp[target];}};",
          "description": "C++实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int combinationSum4(int[] nums, int target) {int[] dp = new int[target + 1];dp[0] = 1;for (int i = 0; i <= target; i++) {for (int j = 0; j < nums.length; j++) {if (i >= nums[j]) {dp[i] += dp[i - nums[j]];}}}}return dp[target];}}",
          "description": "Java实现"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in range(len(nums)): if i - nums[j] >= 0: dp[i] += dp[i - nums[j]] return dp[target]",
          "description": "Python卡哥版"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in nums: if i >= j: dp[i] += dp[i - j] return dp[-1]",
          "description": "Python优化版"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [[0] * (target+1) for _ in nums] for i in range(len(nums)): dp[i][0] = 1 for j in range(1, target+1): for i in range(len(nums)): if j - nums[i] >= 0: dp[i][j] = dp[i-1][j] + dp[-1][j-nums[i]] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]",
          "description": "Python二维DP版"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "class Solution {",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int combinationSum4(vector<int>& nums, int target) {vector<int> dp(target + 1, 0);dp[0] = 1;for (int i = 0; i <= target; i++) {for (int j = 0; j < nums.size(); j++) {if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {dp[i] += dp[i - nums[j]];}}}return dp[target];}};",
          "description": "C++实现组合总和IV"
        },
        {
          "language": "java",
          "code": "class Solution {public int combinationSum4(int[] nums, int target) {int[] dp = new int[target + 1];dp[0] = 1;for (int i = 0; i <= target; i++) {for (int j = 0; j < nums.length; j++) {if (i >= nums[j]) {dp[i] += dp[i - nums[j]];}}}return dp[target];}}",
          "description": "Java实现组合总和IV"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in range(len(nums)): if i - nums[j] >= 0: dp[i] += dp[i - nums[j]] return dp[target]",
          "description": "Python实现组合总和IV（卡哥版）"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in nums: if i >= j: dp[i] += dp[i - j] return dp[-1]",
          "description": "Python实现组合总和IV（优化版）"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [[0] * (target+1) for _ in nums] for i in range(len(nums)): dp[i][0] = 1 for j in range(1, target+1): for i in range(len(nums)): if j - nums[i] >= 0: dp[i][j] = dp[i-1][j] + dp[-1][j-nums[i]] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]",
          "description": "Python实现组合总和IV（二维DP版）"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "卡哥版",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int combinationSum4(vector<int>& nums, int target) {vector<int> dp(target + 1, 0); dp[0] = 1; for (int i = 0; i <= target; i++) {for (int j = 0; j < nums.size(); j++) {if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {dp[i] += dp[i - nums[j]];}}}} return dp[target];}};",
          "description": "C++实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int combinationSum4(int[] nums, int target) {int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i <= target; i++) {for (int j = 0; j < nums.length; j++) {if (i >= nums[j]) {dp[i] += dp[i - nums[j]];}}}} return dp[target];}}",
          "description": "Java实现"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in range(len(nums)): if i - nums[j] >= 0: dp[i] += dp[i - nums[j]] return dp[target]",
          "description": "Python卡哥版实现"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in nums: if i >= j: dp[i] += dp[i - j] return dp[-1]",
          "description": "Python优化版实现"
        },
        {
          "language": "python",
          "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [[0] * (target+1) for _ in nums] for i in range(len(nums)): dp[i][0] = 1 for j in range(1, target+1): for i in range(len(nums)): if j - nums[i] >= 0: dp[i][j] = dp[i-1][j] + dp[-1][j-nums[i]] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]",
          "description": "Python二维DP版实现"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(target * n)",
    "space_complexity": "O(target)",
    "explanation": "其中 n 为 nums 的长度"
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int combinationSum4(vector<int>& nums, int target) {vector<int> dp(target + 1, 0);dp[0] = 1;for (int i = 0; i <= target; i++) { for (int j = 0; j < nums.size(); j++) { if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) { dp[i] += dp[i - nums[j]]; } } }return dp[target];}};",
      "description": null
    },
    {
      "language": "java",
      "code": "class Solution { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target + 1]; dp[0] = 1; for (int i = 0; i <= target; i++) { for (int j = 0; j < nums.length; j++) { if (i >= nums[j]) { dp[i] += dp[i - nums[j]]; } } } return dp[target]; }}",
      "description": null
    },
    {
      "language": "python",
      "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in range(len(nums)): if i - nums[j] >= 0: dp[i] += dp[i - nums[j]] return dp[target]",
      "description": null
    },
    {
      "language": "python",
      "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for j in nums: if i >= j: dp[i] += dp[i - j] return dp[-1]",
      "description": null
    },
    {
      "language": "python",
      "code": "class Solution: def combinationSum4(self, nums: List[int], target: int) -> int: dp = [[0] * (target+1) for _ in nums] for i in range(len(nums)): dp[i][0] = 1 for j in range(1, target+1): for i in range(len(nums)): if j - nums[i] >= 0: dp[i][j] = dp[i-1][j] + dp[-1][j-nums[i]] else: dp[i][j] = dp[i-1][j] return dp[-1][-1]",
      "description": null
    }
  ],
  "common_mistakes": [
    "混淆了排列和组合的概念，导致选择了错误的遍历顺序。",
    "忽略dp[0]的初始化，从而影响后续的状态转移。",
    "未考虑到数值溢出情况，特别是在C++实现中，这可能导致错误的结果。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20230310000625.png",
      "description": "这张图片展示了使用动态规划算法解决组合总和问题的过程，具体为计算数组 `[1, 2, 3]` 中元素组合成目标值 `4` 的方法数。",
      "context": "该图片展示了通过特定遍历顺序推导dp数组的过程，帮助理解如何根据给定的nums和target值来计算组合总数。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20230310000625.png",
      "description": "GIF展示了通过动态规划方法解决组合总和问题时，dp数组随背包容量增加而逐步更新的过程。",
      "context": "GIF动画展示了如何通过特定顺序遍历来构建dp数组的过程，帮助理解为何需要将target（背包）放在外循环而将nums（物品）置于内循环。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\组合总和 Ⅳ.txt",
  "extracted_at": "2025-07-20T23:42:04.011161",
  "raw_content": "组合总和 Ⅳ\n力扣题目链接(https://leetcode.cn/problems/combination-sum-iv/)\n\n难度：中等\n\n给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。\n\n示例:\n\nnums = [1, 2, 3]\ntarget = 4\n所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)\n\n请注意，顺序不同的序列被视作不同的组合。\n\n因此输出为 7。\n\n\n\n#思路\n对完全背包还不了解的同学，可以看这篇：动态规划：关于完全背包，你该了解这些！(https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html)\n\n本题题目描述说是求组合，但又说是可以元素相同顺序不同的组合算两个组合，其实就是求排列！\n\n弄清什么是组合，什么是排列很重要。\n\n组合不强调顺序，(1,5)和(5,1)是同一个组合。\n\n排列强调顺序，(1,5)和(5,1)是两个不同的排列。\n\n大家在公众号里学习回溯算法专题的时候，一定做过这两道题目回溯算法：39.组合总和 (https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)和回溯算法：40.组合总和II (https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html)会感觉这两题和本题很像！\n\n但其本质是本题求的是排列总和，而且仅仅是求排列总和的个数，并不是把所有的排列都列出来。\n\n如果本题要把排列都列出来的话，只能使用回溯算法爆搜。\n\n动规五部曲分析如下：\n\n确定dp数组以及下标的含义\ndp[i]: 凑成目标正整数为i的排列个数为dp[i]\n\n确定递推公式\ndp[i]（考虑nums[j]）可以由 dp[i - nums[j]]（不考虑nums[j]） 推导出来。\n\n因为只要得到nums[j]，排列个数dp[i - nums[j]]，就是dp[i]的一部分。\n\n在动态规划：494.目标和 (https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)和 动态规划：518.零钱兑换II (https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)中我们已经讲过了，求装满背包有几种方法，递推公式一般都是dp[i] += dp[i - nums[j]];\n\n本题也一样。\n\ndp数组如何初始化\n因为递推公式dp[i] += dp[i - nums[j]]的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。\n\n至于dp[0] = 1 有没有意义呢？\n\n其实没有意义，所以我也不去强行解释它的意义了，因为题目中也说了：给定目标值是正整数！ 所以dp[0] = 1是没有意义的，仅仅是为了推导递推公式。\n\n至于非0下标的dp[i]应该初始为多少呢？\n\n初始化为0，这样才不会影响dp[i]累加所有的dp[i - nums[j]]。\n\n确定遍历顺序\n个数可以不限使用，说明这是一个完全背包。\n\n得到的集合是排列，说明需要考虑元素之间的顺序。\n\n本题要求的是排列，那么这个for循环嵌套的顺序可以有说法了。\n\n在动态规划：518.零钱兑换II (https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)中就已经讲过了。\n\n如果求组合数就是外层for循环遍历物品，内层for遍历背包。\n\n如果求排列数就是外层for遍历背包，内层for循环遍历物品。\n\n如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！\n\n所以本题遍历顺序最终遍历顺序：target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历。\n\n举例来推导dp数组\n我们再来用示例中的例子推导一下：\n\nhttps://file1.kamacoder.com/i/algo/20230310000625.png\n\n如果代码运行处的结果不是想要的结果，就把dp[i]都打出来，看看和我们推导的一不一样。\n\n以上分析完毕，C++代码如下：\n\nclass Solution {\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n        vector<int> dp(target + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i <= target; i++) { // 遍历背包\n            for (int j = 0; j < nums.size(); j++) { // 遍历物品\n                if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {\n                    dp[i] += dp[i - nums[j]];\n                }\n            }\n        }\n        return dp[target];\n    }\n};\n\n时间复杂度: O(target * n)，其中 n 为 nums 的长度\n空间复杂度: O(target)\nC++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[i] < INT_MAX - dp[i - num]。\n\n但java就不用考虑这个限制，java里的int也是四个字节吧，也有可能leetcode后台对不同语言的测试数据不一样。\n\n#总结\n求装满背包有几种方法，递归公式都是一样的，没有什么差别，但关键在于遍历顺序！\n\n本题与动态规划：518.零钱兑换II (https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)就是一个鲜明的对比，一个是求排列，一个是求组合，遍历顺序完全不同。\n\n如果对遍历顺序没有深度理解的话，做这种完全背包的题目会很懵逼，即使题目刷过了可能也不太清楚具体是怎么过的。\n\n此时大家应该对动态规划中的遍历顺序又有更深的理解了。\n\n#其他语言版本\n#Java：\nclass Solution {\n    public int combinationSum4(int[] nums, int target) {\n        int[] dp = new int[target + 1];\n        dp[0] = 1;\n        for (int i = 0; i <= target; i++) {\n            for (int j = 0; j < nums.length; j++) {\n                if (i >= nums[j]) {\n                    dp[i] += dp[i - nums[j]];\n                }\n            }\n        }\n        return dp[target];\n    }\n}\n#Python：\n卡哥版\n\nclass Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for i in range(1, target + 1):  # 遍历背包\n            for j in range(len(nums)):  # 遍历物品\n                if i - nums[j] >= 0:\n                    dp[i] += dp[i - nums[j]]\n        return dp[target]\n\n优化版\n\nclass Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        dp = [0] * (target + 1)  # 创建动态规划数组，用于存储组合总数\n        dp[0] = 1  # 初始化背包容量为0时的组合总数为1\n\n        for i in range(1, target + 1):  # 遍历背包容量\n            for j in nums:  # 遍历物品列表\n                if i >= j:  # 当背包容量大于等于当前物品重量时\n                    dp[i] += dp[i - j]  # 更新组合总数\n\n        return dp[-1]  # 返回背包容量为target时的组合总数\n\n\n二维DP版\n\nclass Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        # dp[][j]和为j的组合的总数\n        dp = [[0] * (target+1) for _ in nums]\n        \n        for i in range(len(nums)):\n            dp[i][0] = 1\n            \n        # 这里不能初始化dp[0][j]。dp[0][j]的值依赖于dp[-1][j-nums[0]]\n            \n        for j in range(1, target+1):\n            for i in range(len(nums)):\n                \n                if j - nums[i] >= 0:\n                    dp[i][j] = (\n                        # 不放nums[i]\n                        # i = 0 时，dp[-1][j]恰好为0，所以没有特殊处理\n                        dp[i-1][j] +\n                        # 放nums[i]。对于和为j的组合，只有试过全部物品，才能知道有几种组合方式。所以取最后一个物品dp[-1][j-nums[i]]\n                        dp[-1][j-nums[i]]\n                    )\n                else:\n                    dp[i][j] = dp[i-1][j]\n        return dp[-1][-1]"
}