{
  "id": "AP_a7c5b2fe",
  "title": "找树左下角的值",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/find-bottom-left-tree-value/",
  "description": "一个二叉树，在树的最后一行找到最左边的值。",
  "examples": [
    {
      "input": "见图",
      "output": "见图",
      "explanation": null,
      "image": "https://file1.kamacoder.com/i/algo/20210204152956836.png"
    },
    {
      "input": "见图",
      "output": "见图",
      "explanation": null,
      "image": "https://file1.kamacoder.com/i/algo/20210204153017586.png"
    }
  ],
  "constraints": [],
  "algorithm_tags": [
    "递归",
    "广度优先搜索"
  ],
  "data_structure_tags": [
    "二叉树",
    "队列"
  ],
  "technique_tags": [
    "回溯",
    "层序遍历"
  ],
  "difficulty": null,
  "solution_approach": "通过递归或迭代法（层序遍历）来找到二叉树最后一行最左边的值。主要思路是记录每个节点的深度，更新最大深度及相应节点值。",
  "key_insights": [
    {
      "content": "采用前序遍历（根-左-右），确保了优先访问更左侧的节点，从而能够在相同深度时正确获取到最左侧的节点值。"
    },
    {
      "content": "使用一个全局变量maxDepth来追踪当前发现的最大深度，并在遇到叶子节点时比较当前深度与maxDepth，更新结果为当前节点值。这样能够保证最终得到的是最后一行且最左侧的节点值。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "本题要找出树的最后一行的最左边的值。此时大家应该想起用层序遍历是非常简单的了，反而用递归的话会比较难一点。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxDepth = INT_MIN; int result; void traversal(TreeNode* root, int depth) { if (root->left == NULL && root->right == NULL) { if (depth > maxDepth) { maxDepth = depth; result = root->val; } return; } if (root->left) { depth++; traversal(root->left, depth); depth--; // 回溯 } if (root->right) { depth++; traversal(root->right, depth); depth--; // 回溯 } return; } int findBottomLeftValue(TreeNode* root) { traversal(root, 0); return result; }};",
          "description": "递归方法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxDepth = INT_MIN; int result; void traversal(TreeNode* root, int depth) { if (root->left == NULL && root->right == NULL) { if (depth > maxDepth) { maxDepth = depth; result = root->val; } return; } if (root->left) { traversal(root->left, depth + 1); // 隐藏着回溯 } if (root->right) { traversal(root->right, depth + 1); // 隐藏着回溯 } return; } int findBottomLeftValue(TreeNode* root) { traversal(root, 0); return result; }};",
          "description": "简化递归方法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findBottomLeftValue(TreeNode* root) { queue<TreeNode*> que; if (root != NULL) que.push(root); int result = 0; while (!que.empty()) { int size = que.size(); for (int i = 0; i < size; i++) { TreeNode* node = que.front(); que.pop(); if (i == 0) result = node->val; // 记录最后一行第一个元素 if (node->left) que.push(node->left); if (node->right) que.push(node->right); } } return result; }};",
          "description": "迭代法"
        },
        {
          "language": "java",
          "code": "class Solution {private int Deep = -1; private int value = 0; public int findBottomLeftValue(TreeNode root) { value = root.val; findLeftValue(root,0); return value; } private void findLeftValue (TreeNode root,int deep) { if (root == null) return; if (root.left == null && root.right == null) { if (deep > Deep) { value = root.val; Deep = deep; } } if (root.left != null) findLeftValue(root.left,deep + 1); if (root.right != null) findLeftValue(root.right,deep + 1); }}",
          "description": "递归法"
        },
        {
          "language": "java",
          "code": "class Solution {public int findBottomLeftValue(TreeNode root) { Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); int res = 0; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i < size; i++) { TreeNode poll = queue.poll(); if (i == 0) { res = poll.val; } if (poll.left != null) { queue.offer(poll.left); } if (poll.right != null) { queue.offer(poll.right); } } } return res; }}",
          "description": "迭代法"
        },
        {
          "language": "python",
          "code": "class Solution: def findBottomLeftValue(self, root: TreeNode) -> int: self.max_depth = float('-inf') self.result = None self.traversal(root, 0) return self.result def traversal(self, node, depth): if not node.left and not node.right: if depth > self.max_depth: self.max_depth = depth self.result = node.val return if node.left: depth += 1 self.traversal(node.left, depth) depth -= 1 if node.right: depth += 1 self.traversal(node.right, depth) depth -= 1",
          "description": "递归法 + 回溯"
        },
        {
          "language": "python",
          "code": "class Solution: def findBottomLeftValue(self, root: TreeNode) -> int: self.max_depth = float('-inf') self.result = None self.traversal(root, 0) return self.result def traversal(self, node, depth): if not node.left and not node.right: if depth > self.max_depth: self.max_depth = depth self.result = node.val return if node.left: self.traversal(node.left, depth+1) if node.right: self.traversal(node.right, depth+1)",
          "description": "精简递归法"
        },
        {
          "language": "python",
          "code": "from collections import deque class Solution: def findBottomLeftValue(self, root): if root is None: return 0 queue = deque() queue.append(root) result = 0 while queue: size = len(queue) for i in range(size): node = queue.popleft() if i == 0: result = node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result",
          "description": "迭代法"
        }
      ],
      "subsections": []
    },
    {
      "name": "递归",
      "text": "咋眼一看，这道题目用递归的话就就一直向左遍历，最后一个就是答案呗？",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "int maxDepth = INT_MIN;   // 全局变量 记录最大深度\nint result;       // 全局变量 最大深度最左节点的数值\nvoid traversal(TreeNode* root, int depth) {\n    if (root->left == NULL && root->right == NULL) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            result = root->val;\n        }\n        return;\n    }\n    if (root->left) {\n        depth++;\n        traversal(root->left, depth);\n        depth--; // 回溯\n    }\n    if (root->right) {\n        depth++;\n        traversal(root->right, depth);\n        depth--; // 回溯\n    }\n    return;\n}\nint findBottomLeftValue(TreeNode* root) {\n    traversal(root, 0);\n    return result;\n}",
          "description": "使用递归找到二叉树最后一行最左边的值"
        },
        {
          "language": "cpp",
          "code": "int maxDepth = INT_MIN;\nint result;\nvoid traversal(TreeNode* root, int depth) {\n    if (root->left == NULL && root->right == NULL) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            result = root->val;\n        }\n        return;\n    }\n    if (root->left) {\n        traversal(root->left, depth + 1); // 隐藏着回溯\n    }\n    if (root->right) {\n        traversal(root->right, depth + 1); // 隐藏着回溯\n    }\n    return;\n}\nint findBottomLeftValue(TreeNode* root) {\n    traversal(root, 0);\n    return result;\n}",
          "description": "简化版的递归方法，用于查找二叉树最后一行最左边的值"
        },
        {
          "language": "cpp",
          "code": "int findBottomLeftValue(TreeNode* root) {\n    queue<TreeNode*> que;\n    if (root != NULL) que.push(root);\n    int result = 0;\n    while (!que.empty()) {\n        int size = que.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode* node = que.front();\n            que.pop();\n            if (i == 0) result = node->val; // 记录最后一行第一个元素\n            if (node->left) que.push(node->left);\n            if (node->right) que.push(node->right);\n        }\n    }\n    return result;\n}",
          "description": "使用迭代法（层序遍历）来找到二叉树最后一行最左边的值"
        },
        {
          "language": "java",
          "code": "private int Deep = -1;\nprivate int value = 0;\npublic int findBottomLeftValue(TreeNode root) {\n    value = root.val;\n    findLeftValue(root,0);\n    return value;\n}\nprivate void findLeftValue (TreeNode root,int deep) {\n    if (root == null) return;\n    if (root.left == null && root.right == null) {\n        if (deep > Deep) {\n            value = root.val;\n            Deep = deep;\n        }\n    }\n    if (root.left != null) findLeftValue(root.left,deep + 1);\n    if (root.right != null) findLeftValue(root.right,deep + 1);\n}",
          "description": "Java版本的递归方法，用于寻找二叉树最后一行最左边的值"
        },
        {
          "language": "java",
          "code": "public int findBottomLeftValue(TreeNode root) {\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    int res = 0;\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode poll = queue.poll();\n            if (i == 0) {\n                res = poll.val;\n            }\n            if (poll.left != null) {\n                queue.offer(poll.left);\n            }\n            if (poll.right != null) {\n                queue.offer(poll.right);\n            }\n        }\n    }\n    return res;\n}",
          "description": "Java版本的迭代法，通过层序遍历来找到二叉树最后一行最左边的值"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findBottomLeftValue(self, root: TreeNode) -> int:\n        self.max_depth = float('-inf')\n        self.result = None\n        self.traversal(root, 0)\n        return self.result\n    \n    def traversal(self, node, depth):\n        if not node.left and not node.right:\n            if depth > self.max_depth:\n                self.max_depth = depth\n                self.result = node.val\n            return\n        \n        if node.left:\n            depth += 1\n            self.traversal(node.left, depth)\n            depth -= 1\n        if node.right:\n            depth += 1\n            self.traversal(node.right, depth)\n            depth -= 1",
          "description": "Python版本的递归加回溯方法，用于找到二叉树最后一行最左边的值"
        },
        {
          "language": "python",
          "code": "class Solution:\n    def findBottomLeftValue(self, root: TreeNode) -> int:\n        self.max_depth = float('-inf')\n        self.result = None\n        self.traversal(root, 0)\n        return self.result\n    \n    def traversal(self, node, depth):\n        if not node.left and not node.right:\n            if depth > self.max_depth:\n                self.max_depth = depth\n                self.result = node.val\n            return\n        \n        if node.left:\n            self.traversal(node.left, depth+1)\n        if node.right:\n            self.traversal(node.right, depth+1)",
          "description": "简化版的Python递归方法，用于找到二叉树最后一行最左边的值"
        },
        {
          "language": "python",
          "code": "from collections import deque\nclass Solution:\n    def findBottomLeftValue(self, root):\n        if root is None:\n            return 0\n        queue = deque()\n        queue.append(root)\n        result = 0\n        while queue:\n            size = len(queue)\n            for i in range(size):\n                node = queue.popleft()\n                if i == 0:\n                    result = node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return result",
          "description": "Python版本的迭代法（层序遍历），用于找到二叉树最后一行最左边的值"
        }
      ],
      "subsections": []
    },
    {
      "name": "迭代法",
      "text": "本题使用层序遍历再合适不过了，比递归要好理解得多！",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int maxDepth = INT_MIN; int result; void traversal(TreeNode* root, int depth) {if (root->left == NULL && root->right == NULL) {if (depth > maxDepth) {maxDepth = depth;result = root->val;}return;}if (root->left) {depth++;traversal(root->left, depth);depth--;}if (root->right) {depth++;traversal(root->right, depth);depth--;}return;}int findBottomLeftValue(TreeNode* root) {traversal(root, 0);return result;}};",
          "description": "C++递归法实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int maxDepth = INT_MIN; int result; void traversal(TreeNode* root, int depth) {if (root->left == NULL && root->right == NULL) {if (depth > maxDepth) {maxDepth = depth;result = root->val;}return;}if (root->left) {traversal(root->left, depth + 1);}if (root->right) {traversal(root->right, depth + 1);}return;}int findBottomLeftValue(TreeNode* root) {traversal(root, 0);return result;}};",
          "description": "C++精简递归法实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findBottomLeftValue(TreeNode* root) {queue<TreeNode*> que;if (root != NULL) que.push(root);int result = 0;while (!que.empty()) {int size = que.size();for (int i = 0; i < size; i++) {TreeNode* node = que.front();que.pop();if (i == 0) result = node->val;if (node->left) que.push(node->left);if (node->right) que.push(node->right);}}return result;}};",
          "description": "C++迭代法实现"
        },
        {
          "language": "java",
          "code": "class Solution {private int Deep = -1; private int value = 0; public int findBottomLeftValue(TreeNode root) {value = root.val;findLeftValue(root,0);return value;}private void findLeftValue (TreeNode root,int deep) {if (root == null) return;if (root.left == null && root.right == null) {if (deep > Deep) {value = root.val;Deep = deep;}}if (root.left != null) findLeftValue(root.left,deep + 1);if (root.right != null) findLeftValue(root.right,deep + 1);}}",
          "description": "Java递归法实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int findBottomLeftValue(TreeNode root) {Queue<TreeNode> queue = new LinkedList<>();queue.offer(root);int res = 0;while (!queue.isEmpty()) {int size = queue.size();for (int i = 0; i < size; i++) {TreeNode poll = queue.poll();if (i == 0) {res = poll.val;}if (poll.left != null) {queue.offer(poll.left);}if (poll.right != null) {queue.offer(poll.right);}}}return res;}}",
          "description": "Java迭代法实现"
        },
        {
          "language": "python",
          "code": "class Solution: def findBottomLeftValue(self, root: TreeNode) -> int: self.max_depth = float('-inf') self.result = None self.traversal(root, 0) return self.result def traversal(self, node, depth): if not node.left and not node.right: if depth > self.max_depth: self.max_depth = depth self.result = node.val return if node.left: depth += 1 self.traversal(node.left, depth) depth -= 1 if node.right: depth += 1 self.traversal(node.right, depth) depth -= 1",
          "description": "Python递归法+回溯实现"
        },
        {
          "language": "python",
          "code": "class Solution: def findBottomLeftValue(self, root: TreeNode) -> int: self.max_depth = float('-inf') self.result = None self.traversal(root, 0) return self.result def traversal(self, node, depth): if not node.left and not node.right: if depth > self.max_depth: self.max_depth = depth self.result = node.val return if node.left: self.traversal(node.left, depth+1) if node.right: self.traversal(node.right, depth+1)",
          "description": "Python递归法+精简实现"
        },
        {
          "language": "python",
          "code": "from collections import deque class Solution: def findBottomLeftValue(self, root): if root is None: return 0 queue = deque() queue.append(root) result = 0 while queue: size = len(queue) for i in range(size): node = queue.popleft() if i == 0: result = node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result",
          "description": "Python迭代法实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "本题涉及如下几点：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "int maxDepth = INT_MIN;   // 全局变量 记录最大深度\nint result;       // 全局变量 最大深度最左节点的数值\nvoid traversal(TreeNode* root, int depth) {\n    if (root->left == NULL && root->right == NULL) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            result = root->val;\n        }\n        return;\n    }\n    if (root->left) {\n        depth++;\n        traversal(root->left, depth);\n        depth--; // 回溯\n    }\n    if (root->right) {\n        depth++;\n        traversal(root->right, depth);\n        depth--; // 回溯\n    }\n    return;\n}\nint findBottomLeftValue(TreeNode* root) {\n    traversal(root, 0);\n    return result;\n}",
          "description": "递归法"
        },
        {
          "language": "cpp",
          "code": "int maxDepth = INT_MIN;\nint result;\nvoid traversal(TreeNode* root, int depth) {\n    if (root->left == NULL && root->right == NULL) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            result = root->val;\n        }\n        return;\n    }\n    if (root->left) {\n        traversal(root->left, depth + 1); // 隐藏着回溯\n    }\n    if (root->right) {\n        traversal(root->right, depth + 1); // 隐藏着回溯\n    }\n    return;\n}\nint findBottomLeftValue(TreeNode* root) {\n    traversal(root, 0);\n    return result;\n}",
          "description": "精简后的递归法"
        },
        {
          "language": "cpp",
          "code": "int findBottomLeftValue(TreeNode* root) {\n    queue<TreeNode*> que;\n    if (root != NULL) que.push(root);\n    int result = 0;\n    while (!que.empty()) {\n        int size = que.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode* node = que.front();\n            que.pop();\n            if (i == 0) result = node->val; // 记录最后一行第一个元素\n            if (node->left) que.push(node->left);\n            if (node->right) que.push(node->right);\n        }\n    }\n    return result;\n}",
          "description": "迭代法"
        },
        {
          "language": "java",
          "code": "private int Deep = -1;\nprivate int value = 0;\npublic int findBottomLeftValue(TreeNode root) {\n    value = root.val;\n    findLeftValue(root,0);\n    return value;\n}\nprivate void findLeftValue (TreeNode root,int deep) {\n    if (root == null) return;\n    if (root.left == null && root.right == null) {\n        if (deep > Deep) {\n            value = root.val;\n            Deep = deep;\n        }\n    }\n    if (root.left != null) findLeftValue(root.left,deep + 1);\n    if (root.right != null) findLeftValue(root.right,deep + 1);\n}",
          "description": "Java递归法"
        },
        {
          "language": "java",
          "code": "public int findBottomLeftValue(TreeNode root) {\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    int res = 0;\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode poll = queue.poll();\n            if (i == 0) {\n                res = poll.val;\n            }\n            if (poll.left != null) {\n                queue.offer(poll.left);\n            }\n            if (poll.right != null) {\n                queue.offer(poll.right);\n            }\n        }\n    }\n    return res;\n}",
          "description": "Java迭代法"
        },
        {
          "language": "python",
          "code": "def findBottomLeftValue(self, root: TreeNode) -> int:\n    self.max_depth = float('-inf')\n    self.result = None\n    self.traversal(root, 0)\n    return self.result\n\ndef traversal(self, node, depth):\n    if not node.left and not node.right:\n        if depth > self.max_depth:\n            self.max_depth = depth\n            self.result = node.val\n        return\n    \n    if node.left:\n        depth += 1\n        self.traversal(node.left, depth)\n        depth -= 1\n    if node.right:\n        depth += 1\n        self.traversal(node.right, depth)\n        depth -= 1",
          "description": "Python递归法+回溯"
        },
        {
          "language": "python",
          "code": "def findBottomLeftValue(self, root: TreeNode) -> int:\n    self.max_depth = float('-inf')\n    self.result = None\n    self.traversal(root, 0)\n    return self.result\n\ndef traversal(self, node, depth):\n    if not node.left and not node.right:\n        if depth > self.max_depth:\n            self.max_depth = depth\n            self.result = node.val\n        return\n    \n    if node.left:\n        self.traversal(node.left, depth+1)\n    if node.right:\n        self.traversal(node.right, depth+1)",
          "description": "Python递归法+精简"
        },
        {
          "language": "python",
          "code": "from collections import deque\nclass Solution:\n    def findBottomLeftValue(self, root):\n        if root is None:\n            return 0\n        queue = deque()\n        queue.append(root)\n        result = 0\n        while queue:\n            size = len(queue)\n            for i in range(size):\n                node = queue.popleft()\n                if i == 0:\n                    result = node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return result",
          "description": "Python迭代法"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "int maxDepth = INT_MIN;   // 全局变量 记录最大深度\nint result;       // 全局变量 最大深度最左节点的数值\nvoid traversal(TreeNode* root, int depth) {\n    if (root->left == NULL && root->right == NULL) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            result = root->val;\n        }\n        return;\n    }\n    if (root->left) {\n        depth++;\n        traversal(root->left, depth);\n        depth--;\n    }\n    if (root->right) {\n        depth++;\n        traversal(root->right, depth);\n        depth--;\n    }\n    return;\n}\nint findBottomLeftValue(TreeNode* root) {\n    traversal(root, 0);\n    return result;\n}",
          "description": "C++递归法，找到树的最后一行最左边的值"
        },
        {
          "language": "cpp",
          "code": "int maxDepth = INT_MIN;\nint result;\nvoid traversal(TreeNode* root, int depth) {\n    if (root->left == NULL && root->right == NULL) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            result = root->val;\n        }\n        return;\n    }\n    if (root->left) {\n        traversal(root->left, depth + 1);\n    }\n    if (root->right) {\n        traversal(root->right, depth + 1);\n    }\n    return;\n}\nint findBottomLeftValue(TreeNode* root) {\n    traversal(root, 0);\n    return result;\n}",
          "description": "C++递归法（精简版），找到树的最后一行最左边的值"
        },
        {
          "language": "cpp",
          "code": "int findBottomLeftValue(TreeNode* root) {\n    queue<TreeNode*> que;\n    if (root != NULL) que.push(root);\n    int result = 0;\n    while (!que.empty()) {\n        int size = que.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode* node = que.front();\n            que.pop();\n            if (i == 0) result = node->val;\n            if (node->left) que.push(node->left);\n            if (node->right) que.push(node->right);\n        }\n    }\n    return result;\n}",
          "description": "C++迭代法，使用层序遍历找到树的最后一行最左边的值"
        },
        {
          "language": "java",
          "code": "private int Deep = -1;\nprivate int value = 0;\npublic int findBottomLeftValue(TreeNode root) {\n    value = root.val;\n    findLeftValue(root,0);\n    return value;\n}\nprivate void findLeftValue (TreeNode root,int deep) {\n    if (root == null) return;\n    if (root.left == null && root.right == null) {\n        if (deep > Deep) {\n            value = root.val;\n            Deep = deep;\n        }\n    }\n    if (root.left != null) findLeftValue(root.left,deep + 1);\n    if (root.right != null) findLeftValue(root.right,deep + 1);\n}",
          "description": "Java递归法，找到树的最后一行最左边的值"
        },
        {
          "language": "java",
          "code": "public int findBottomLeftValue(TreeNode root) {\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    int res = 0;\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode poll = queue.poll();\n            if (i == 0) {\n                res = poll.val;\n            }\n            if (poll.left != null) {\n                queue.offer(poll.left);\n            }\n            if (poll.right != null) {\n                queue.offer(poll.right);\n            }\n        }\n    }\n    return res;\n}",
          "description": "Java迭代法，使用层序遍历找到树的最后一行最左边的值"
        },
        {
          "language": "python",
          "code": "def findBottomLeftValue(self, root: TreeNode) -> int:\n    self.max_depth = float('-inf')\n    self.result = None\n    self.traversal(root, 0)\n    return self.result\n\ndef traversal(self, node, depth):\n    if not node.left and not node.right:\n        if depth > self.max_depth:\n            self.max_depth = depth\n            self.result = node.val\n        return\n    if node.left:\n        depth += 1\n        self.traversal(node.left, depth)\n        depth -= 1\n    if node.right:\n        depth += 1\n        self.traversal(node.right, depth)\n        depth -= 1",
          "description": "Python递归法+回溯，找到树的最后一行最左边的值"
        },
        {
          "language": "python",
          "code": "def findBottomLeftValue(self, root: TreeNode) -> int:\n    self.max_depth = float('-inf')\n    self.result = None\n    self.traversal(root, 0)\n    return self.result\n\ndef traversal(self, node, depth):\n    if not node.left and not node.right:\n        if depth > self.max_depth:\n            self.max_depth = depth\n            self.result = node.val\n        return\n    if node.left:\n        self.traversal(node.left, depth+1)\n    if node.right:\n        self.traversal(node.right, depth+1)",
          "description": "Python递归法（精简版），找到树的最后一行最左边的值"
        },
        {
          "language": "python",
          "code": "def findBottomLeftValue(self, root):\n    if root is None:\n        return 0\n    queue = deque()\n    queue.append(root)\n    result = 0\n    while queue:\n        size = len(queue)\n        for i in range(size):\n            node = queue.popleft()\n            if i == 0:\n                result = node.val\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return result",
          "description": "Python迭代法，使用队列实现层序遍历找到树的最后一行最左边的值"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "// 递归法",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "int maxDepth = INT_MIN;   // 全局变量 记录最大深度\nint result;       // 全局变量 最大深度最左节点的数值\nvoid traversal(TreeNode* root, int depth) {\n    if (root->left == NULL && root->right == NULL) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            result = root->val;\n        }\n        return;\n    }\n    if (root->left) {\n        depth++;\n        traversal(root->left, depth);\n        depth--;\n    }\n    if (root->right) {\n        depth++;\n        traversal(root->right, depth);\n        depth--;\n    }\n    return;\n}\nint findBottomLeftValue(TreeNode* root) {\n    traversal(root, 0);\n    return result;\n}",
          "description": "递归法"
        },
        {
          "language": "cpp",
          "code": "int maxDepth = INT_MIN;\nint result;\nvoid traversal(TreeNode* root, int depth) {\n    if (root->left == NULL && root->right == NULL) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            result = root->val;\n        }\n        return;\n    }\n    if (root->left) {\n        traversal(root->left, depth + 1);\n    }\n    if (root->right) {\n        traversal(root->right, depth + 1);\n    }\n    return;\n}\nint findBottomLeftValue(TreeNode* root) {\n    traversal(root, 0);\n    return result;\n}",
          "description": "精简递归法"
        },
        {
          "language": "cpp",
          "code": "int findBottomLeftValue(TreeNode* root) {\n    queue<TreeNode*> que;\n    if (root != NULL) que.push(root);\n    int result = 0;\n    while (!que.empty()) {\n        int size = que.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode* node = que.front();\n            que.pop();\n            if (i == 0) result = node->val;\n            if (node->left) que.push(node->left);\n            if (node->right) que.push(node->right);\n        }\n    }\n    return result;\n}",
          "description": "迭代法"
        },
        {
          "language": "java",
          "code": "private int Deep = -1;\nprivate int value = 0;\npublic int findBottomLeftValue(TreeNode root) {\n    value = root.val;\n    findLeftValue(root,0);\n    return value;\n}\n\nprivate void findLeftValue (TreeNode root,int deep) {\n    if (root == null) return;\n    if (root.left == null && root.right == null) {\n        if (deep > Deep) {\n            value = root.val;\n            Deep = deep;\n        }\n    }\n    if (root.left != null) findLeftValue(root.left,deep + 1);\n    if (root.right != null) findLeftValue(root.right,deep + 1);\n}",
          "description": "递归法"
        },
        {
          "language": "java",
          "code": "public int findBottomLeftValue(TreeNode root) {\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    int res = 0;\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode poll = queue.poll();\n            if (i == 0) {\n                res = poll.val;\n            }\n            if (poll.left != null) {\n                queue.offer(poll.left);\n            }\n            if (poll.right != null) {\n                queue.offer(poll.right);\n            }\n        }\n    }\n    return res;\n}",
          "description": "迭代法"
        },
        {
          "language": "python",
          "code": "def findBottomLeftValue(self, root: TreeNode) -> int:\n    self.max_depth = float('-inf')\n    self.result = None\n    self.traversal(root, 0)\n    return self.result\n\ndef traversal(self, node, depth):\n    if not node.left and not node.right:\n        if depth > self.max_depth:\n            self.max_depth = depth\n            self.result = node.val\n        return\n    if node.left:\n        depth += 1\n        self.traversal(node.left, depth)\n        depth -= 1\n    if node.right:\n        depth += 1\n        self.traversal(node.right, depth)\n        depth -= 1",
          "description": "递归法+回溯"
        },
        {
          "language": "python",
          "code": "def findBottomLeftValue(self, root: TreeNode) -> int:\n    self.max_depth = float('-inf')\n    self.result = None\n    self.traversal(root, 0)\n    return self.result\n\ndef traversal(self, node, depth):\n    if not node.left and not node.right:\n        if depth > self.max_depth:\n            self.max_depth = depth\n            self.result = node.val\n        return\n    if node.left:\n        self.traversal(node.left, depth+1)\n    if node.right:\n        self.traversal(node.right, depth+1)",
          "description": "递归法+精简"
        },
        {
          "language": "python",
          "code": "from collections import deque\nclass Solution:\n    def findBottomLeftValue(self, root):\n        if root is None:\n            return 0\n        queue = deque()\n        queue.append(root)\n        result = 0\n        while queue:\n            size = len(queue)\n            for i in range(size):\n                node = queue.popleft()\n                if i == 0:\n                    result = node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return result",
          "description": "迭代法"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "（版本一）递归法 + 回溯",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "int maxDepth = INT_MIN;   // 全局变量 记录最大深度\nint result;       // 全局变量 最大深度最左节点的数值\nvoid traversal(TreeNode* root, int depth) {\n    if (root->left == NULL && root->right == NULL) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            result = root->val;\n        }\n        return;\n    }\n    if (root->left) {\n        depth++;\n        traversal(root->left, depth);\n        depth--;\n    }\n    if (root->right) {\n        depth++;\n        traversal(root->right, depth);\n        depth--;\n    }\n}\nint findBottomLeftValue(TreeNode* root) {\n    traversal(root, 0);\n    return result;\n}",
          "description": "C++实现，使用递归法找到树最后一行最左边的值"
        },
        {
          "language": "cpp",
          "code": "int maxDepth = INT_MIN;\nint result;\nvoid traversal(TreeNode* root, int depth) {\n    if (root->left == NULL && root->right == NULL) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            result = root->val;\n        }\n        return;\n    }\n    if (root->left) {\n        traversal(root->left, depth + 1);\n    }\n    if (root->right) {\n        traversal(root->right, depth + 1);\n    }\n}\nint findBottomLeftValue(TreeNode* root) {\n    traversal(root, 0);\n    return result;\n}",
          "description": "C++实现，使用递归法（精简版）找到树最后一行最左边的值"
        },
        {
          "language": "cpp",
          "code": "int findBottomLeftValue(TreeNode* root) {\n    queue<TreeNode*> que;\n    if (root != NULL) que.push(root);\n    int result = 0;\n    while (!que.empty()) {\n        int size = que.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode* node = que.front();\n            que.pop();\n            if (i == 0) result = node->val;\n            if (node->left) que.push(node->left);\n            if (node->right) que.push(node->right);\n        }\n    }\n    return result;\n}",
          "description": "C++实现，使用迭代法（层序遍历）找到树最后一行最左边的值"
        },
        {
          "language": "java",
          "code": "private int Deep = -1;\nprivate int value = 0;\npublic int findBottomLeftValue(TreeNode root) {\n    value = root.val;\n    findLeftValue(root,0);\n    return value;\n}\nprivate void findLeftValue (TreeNode root,int deep) {\n    if (root == null) return;\n    if (root.left == null && root.right == null) {\n        if (deep > Deep) {\n            value = root.val;\n            Deep = deep;\n        }\n    }\n    if (root.left != null) findLeftValue(root.left,deep + 1);\n    if (root.right != null) findLeftValue(root.right,deep + 1);\n}",
          "description": "Java实现，使用递归法找到树最后一行最左边的值"
        },
        {
          "language": "java",
          "code": "public int findBottomLeftValue(TreeNode root) {\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    int res = 0;\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode poll = queue.poll();\n            if (i == 0) {\n                res = poll.val;\n            }\n            if (poll.left != null) {\n                queue.offer(poll.left);\n            }\n            if (poll.right != null) {\n                queue.offer(poll.right);\n            }\n        }\n    }\n    return res;\n}",
          "description": "Java实现，使用迭代法（层序遍历）找到树最后一行最左边的值"
        },
        {
          "language": "python",
          "code": "def findBottomLeftValue(self, root: TreeNode) -> int:\n    self.max_depth = float('-inf')\n    self.result = None\n    self.traversal(root, 0)\n    return self.result\n\ndef traversal(self, node, depth):\n    if not node.left and not node.right:\n        if depth > self.max_depth:\n            self.max_depth = depth\n            self.result = node.val\n        return\n    if node.left:\n        depth += 1\n        self.traversal(node.left, depth)\n        depth -= 1\n    if node.right:\n        depth += 1\n        self.traversal(node.right, depth)\n        depth -= 1",
          "description": "Python实现，使用递归法找到树最后一行最左边的值"
        },
        {
          "language": "python",
          "code": "def findBottomLeftValue(self, root: TreeNode) -> int:\n    self.max_depth = float('-inf')\n    self.result = None\n    self.traversal(root, 0)\n    return self.result\n\ndef traversal(self, node, depth):\n    if not node.left and not node.right:\n        if depth > self.max_depth:\n            self.max_depth = depth\n            self.result = node.val\n        return\n    if node.left:\n        self.traversal(node.left, depth+1)\n    if node.right:\n        self.traversal(node.right, depth+1)",
          "description": "Python实现，使用递归法（精简版）找到树最后一行最左边的值"
        },
        {
          "language": "python",
          "code": "from collections import deque\nclass Solution:\n    def findBottomLeftValue(self, root):\n        if root is None:\n            return 0\n        queue = deque()\n        queue.append(root)\n        result = 0\n        while queue:\n            size = len(queue)\n            for i in range(size):\n                node = queue.popleft()\n                if i == 0:\n                    result = node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return result",
          "description": "Python实现，使用迭代法（层序遍历）找到树最后一行最左边的值"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "int maxDepth = INT_MIN;   // 全局变量 记录最大深度\nint result;       // 全局变量 最大深度最左节点的数值\nvoid traversal(TreeNode* root, int depth) {\n    if (root->left == NULL && root->right == NULL) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            result = root->val;\n        }\n        return;\n    }\n    if (root->left) {\n        depth++;\n        traversal(root->left, depth);\n        depth--;\n    }\n    if (root->right) {\n        depth++;\n        traversal(root->right, depth);\n        depth--;\n    }\n    return;\n}\nint findBottomLeftValue(TreeNode* root) {\n    traversal(root, 0);\n    return result;\n}",
      "description": null
    },
    {
      "language": "cpp",
      "code": "int maxDepth = INT_MIN;\nint result;\nvoid traversal(TreeNode* root, int depth) {\n    if (root->left == NULL && root->right == NULL) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            result = root->val;\n        }\n        return;\n    }\n    if (root->left) {\n        traversal(root->left, depth + 1);\n    }\n    if (root->right) {\n        traversal(root->right, depth + 1);\n    }\n    return;\n}\nint findBottomLeftValue(TreeNode* root) {\n    traversal(root, 0);\n    return result;\n}",
      "description": null
    },
    {
      "language": "cpp",
      "code": "int findBottomLeftValue(TreeNode* root) {\n    queue<TreeNode*> que;\n    if (root != NULL) que.push(root);\n    int result = 0;\n    while (!que.empty()) {\n        int size = que.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode* node = que.front();\n            que.pop();\n            if (i == 0) result = node->val;\n            if (node->left) que.push(node->left);\n            if (node->right) que.push(node->right);\n        }\n    }\n    return result;\n}",
      "description": null
    },
    {
      "language": "java",
      "code": "private int Deep = -1;\nprivate int value = 0;\npublic int findBottomLeftValue(TreeNode root) {\n    value = root.val;\n    findLeftValue(root,0);\n    return value;\n}\nprivate void findLeftValue (TreeNode root,int deep) {\n    if (root == null) return;\n    if (root.left == null && root.right == null) {\n        if (deep > Deep) {\n            value = root.val;\n            Deep = deep;\n        }\n    }\n    if (root.left != null) findLeftValue(root.left,deep + 1);\n    if (root.right != null) findLeftValue(root.right,deep + 1);\n}",
      "description": null
    },
    {
      "language": "java",
      "code": "public int findBottomLeftValue(TreeNode root) {\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    int res = 0;\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode poll = queue.poll();\n            if (i == 0) {\n                res = poll.val;\n            }\n            if (poll.left != null) {\n                queue.offer(poll.left);\n            }\n            if (poll.right != null) {\n                queue.offer(poll.right);\n            }\n        }\n    }\n    return res;\n}",
      "description": null
    },
    {
      "language": "python",
      "code": "self.max_depth = float('-inf')\nself.result = None\ndef traversal(self, node, depth):\n    if not node.left and not node.right:\n        if depth > self.max_depth:\n            self.max_depth = depth\n            self.result = node.val\n        return\n    if node.left:\n        depth += 1\n        self.traversal(node.left, depth)\n        depth -= 1\n    if node.right:\n        depth += 1\n        self.traversal(node.right, depth)\n        depth -= 1\ndef findBottomLeftValue(self, root: TreeNode) -> int:\n    self.traversal(root, 0)\n    return self.result",
      "description": null
    },
    {
      "language": "python",
      "code": "self.max_depth = float('-inf')\nself.result = None\ndef traversal(self, node, depth):\n    if not node.left and not node.right:\n        if depth > self.max_depth:\n            self.max_depth = depth\n            self.result = node.val\n        return\n    if node.left:\n        self.traversal(node.left, depth+1)\n    if node.right:\n        self.traversal(node.right, depth+1)\ndef findBottomLeftValue(self, root: TreeNode) -> int:\n    self.traversal(root, 0)\n    return self.result",
      "description": null
    },
    {
      "language": "python",
      "code": "from collections import deque\ndef findBottomLeftValue(self, root):\n    if root is None:\n        return 0\n    queue = deque()\n    queue.append(root)\n    result = 0\n    while queue:\n        size = len(queue)\n        for i in range(size):\n            node = queue.popleft()\n            if i == 0:\n                result = node.val\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return result",
      "description": null
    }
  ],
  "common_mistakes": [
    "忽略了非满二叉树情况下，仅向左遍历并不能保证找到最后一行最左边的值。",
    "未使用额外变量跟踪当前最大深度和对应节点值，导致无法准确找出目标节点。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210204152956836.png",
      "description": "该图片展示了一个简单的二叉树结构及其节点数量的计算结果，输入为一个包含根节点值为2、左子节点值为1和右子节点值为3的二叉树，输出为其叶子节点的数量（即1）。",
      "context": "示例1展示了给定二叉树结构，用于说明如何找到树最后一行最左边的值。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210204153017586.png",
      "description": "该图片展示了一棵二叉树的结构及其最深叶子节点的值（7），涉及树的深度优先搜索或层次遍历算法。",
      "context": "该图片展示了题目“找树左下角的值”的示例2，用于说明如何在给定二叉树的最后一行找到最左边的值。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210204152956836.png",
      "description": "GIF展示了通过递归方法寻找二叉树最后一行最左边值的过程。",
      "context": "GIF动画展示了如何通过层序遍历找到二叉树最后一行最左边的值的过程。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210204153017586.png",
      "description": "GIF展示了通过层序遍历二叉树来寻找最后一行最左边值的过程。",
      "context": "GIF动画展示了通过递归方法尝试找到二叉树最后一行最左边值的过程，但指出了单纯向左遍历并不能保证找到正确答案。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\二叉树\\找树左下角的值.txt",
  "extracted_at": "2025-07-19T22:16:53.648728",
  "raw_content": "找树左下角的值\n力扣题目链接(https://leetcode.cn/problems/find-bottom-left-tree-value/)\n\n给定一个二叉树，在树的最后一行找到最左边的值。\n\n示例 1:\n\nhttps://file1.kamacoder.com/i/algo/20210204152956836.png\n\n示例 2:\nhttps://file1.kamacoder.com/i/algo/20210204153017586.png\n\n#思路\n本题要找出树的最后一行的最左边的值。此时大家应该想起用层序遍历是非常简单的了，反而用递归的话会比较难一点。\n\n我们依然还是先介绍递归法。\n\n#递归\n咋眼一看，这道题目用递归的话就就一直向左遍历，最后一个就是答案呗？\n\n没有这么简单，一直向左遍历到最后一个，它未必是最后一行啊。\n\n我们来分析一下题目：在树的最后一行找到最左边的值。\n\n首先要是最后一行，然后是最左边的值。\n\n如果使用递归法，如何判断是最后一行呢，其实就是深度最大的叶子节点一定是最后一行。\n\n如果对二叉树深度和高度还有点疑惑的话，请看：110.平衡二叉树 (https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html)。\n\n所以要找深度最大的叶子节点。\n\n那么如何找最左边的呢？可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。\n\n递归三部曲：\n\n确定递归函数的参数和返回值\n参数必须有要遍历的树的根节点，还有就是一个int型的变量用来记录最长深度。 这里就不需要返回值了，所以递归函数的返回类型为void。\n\n本题还需要类里的两个全局变量，maxDepth用来记录最大深度，result记录最大深度最左节点的数值。\n\n代码如下：\n\nint maxDepth = INT_MIN;   // 全局变量 记录最大深度\nint result;       // 全局变量 最大深度最左节点的数值\nvoid traversal(TreeNode* root, int depth)\n确定终止条件\n当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度。\n\n代码如下：\n\nif (root->left == NULL && root->right == NULL) {\n    if (depth > maxDepth) {\n        maxDepth = depth;           // 更新最大深度\n        result = root->val;   // 最大深度最左面的数值\n    }\n    return;\n}\n确定单层递归的逻辑\n在找最大深度的时候，递归的过程中依然要使用回溯，代码如下：\n\n                    // 中\nif (root->left) {   // 左\n    depth++; // 深度加一\n    traversal(root->left, depth);\n    depth--; // 回溯，深度减一\n}\nif (root->right) { // 右\n    depth++; // 深度加一\n    traversal(root->right, depth);\n    depth--; // 回溯，深度减一\n}\nreturn;\n完整代码如下：\n\nclass Solution {\npublic:\n    int maxDepth = INT_MIN;\n    int result;\n    void traversal(TreeNode* root, int depth) {\n        if (root->left == NULL && root->right == NULL) {\n            if (depth > maxDepth) {\n                maxDepth = depth;\n                result = root->val;\n            }\n            return;\n        }\n        if (root->left) {\n            depth++;\n            traversal(root->left, depth);\n            depth--; // 回溯\n        }\n        if (root->right) {\n            depth++;\n            traversal(root->right, depth);\n            depth--; // 回溯\n        }\n        return;\n    }\n    int findBottomLeftValue(TreeNode* root) {\n        traversal(root, 0);\n        return result;\n    }\n};\n当然回溯的地方可以精简，精简代码如下：\n\nclass Solution {\npublic:\n    int maxDepth = INT_MIN;\n    int result;\n    void traversal(TreeNode* root, int depth) {\n        if (root->left == NULL && root->right == NULL) {\n            if (depth > maxDepth) {\n                maxDepth = depth;\n                result = root->val;\n            }\n            return;\n        }\n        if (root->left) {\n            traversal(root->left, depth + 1); // 隐藏着回溯\n        }\n        if (root->right) {\n            traversal(root->right, depth + 1); // 隐藏着回溯\n        }\n        return;\n    }\n    int findBottomLeftValue(TreeNode* root) {\n        traversal(root, 0);\n        return result;\n    }\n};\n如果对回溯部分精简的代码 不理解的话，可以看这篇257. 二叉树的所有路径(https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html)\n\n#迭代法\n本题使用层序遍历再合适不过了，比递归要好理解得多！\n\n只需要记录最后一行第一个节点的数值就可以了。\n\n如果对层序遍历不了解，看这篇二叉树：层序遍历登场！ (https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html)，这篇里也给出了层序遍历的模板，稍作修改就一过刷了这道题了。\n\n代码如下：\n\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> que;\n        if (root != NULL) que.push(root);\n        int result = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode* node = que.front();\n                que.pop();\n                if (i == 0) result = node->val; // 记录最后一行第一个元素\n                if (node->left) que.push(node->left);\n                if (node->right) que.push(node->right);\n            }\n        }\n        return result;\n    }\n};\n#总结\n本题涉及如下几点：\n\n递归求深度的写法，我们在110.平衡二叉树 (opens new window)中详细的分析了深度应该怎么求，高度应该怎么求。\n递归中其实隐藏了回溯，在257. 二叉树的所有路径 (opens new window)中讲解了究竟哪里使用了回溯，哪里隐藏了回溯。\n层次遍历，在二叉树：层序遍历登场！ (opens new window)深度讲解了二叉树层次遍历。 所以本题涉及到的点，我们之前都讲解过，这些知识点需要同学们灵活运用，这样就举一反三了。\n#其他语言版本\n#Java\n// 递归法\nclass Solution {\n    private int Deep = -1;\n    private int value = 0;\n    public int findBottomLeftValue(TreeNode root) {\n        value = root.val;\n        findLeftValue(root,0);\n        return value;\n    }\n\n    private void findLeftValue (TreeNode root,int deep) {\n        if (root == null) return;\n        if (root.left == null && root.right == null) {\n            if (deep > Deep) {\n                value = root.val;\n                Deep = deep;\n            }\n        }\n        if (root.left != null) findLeftValue(root.left,deep + 1);\n        if (root.right != null) findLeftValue(root.right,deep + 1);\n    }\n}\n//迭代法\nclass Solution {\n\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int res = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode poll = queue.poll();\n                if (i == 0) {\n                    res = poll.val;\n                }\n                if (poll.left != null) {\n                    queue.offer(poll.left);\n                }\n                if (poll.right != null) {\n                    queue.offer(poll.right);\n                }\n            }\n        }\n        return res;\n    }\n}\n#Python\n（版本一）递归法 + 回溯\n\nclass Solution:\n    def findBottomLeftValue(self, root: TreeNode) -> int:\n        self.max_depth = float('-inf')\n        self.result = None\n        self.traversal(root, 0)\n        return self.result\n    \n    def traversal(self, node, depth):\n        if not node.left and not node.right:\n            if depth > self.max_depth:\n                self.max_depth = depth\n                self.result = node.val\n            return\n        \n        if node.left:\n            depth += 1\n            self.traversal(node.left, depth)\n            depth -= 1\n        if node.right:\n            depth += 1\n            self.traversal(node.right, depth)\n            depth -= 1\n\n（版本二）递归法+精简\n\nclass Solution:\n    def findBottomLeftValue(self, root: TreeNode) -> int:\n        self.max_depth = float('-inf')\n        self.result = None\n        self.traversal(root, 0)\n        return self.result\n    \n    def traversal(self, node, depth):\n        if not node.left and not node.right:\n            if depth > self.max_depth:\n                self.max_depth = depth\n                self.result = node.val\n            return\n        \n        if node.left:\n            self.traversal(node.left, depth+1)\n        if node.right:\n            self.traversal(node.right, depth+1)\n(版本三） 迭代法\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def findBottomLeftValue(self, root):\n        if root is None:\n            return 0\n        queue = deque()\n        queue.append(root)\n        result = 0\n        while queue:\n            size = len(queue)\n            for i in range(size):\n                node = queue.popleft()\n                if i == 0:\n                    result = node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return result"
}