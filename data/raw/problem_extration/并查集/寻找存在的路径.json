{
  "id": "AP_f655174c",
  "title": "寻找存在的路径",
  "alternative_titles": [],
  "platform": "kamacoder",
  "url": "https://kamacoder.com/problempage.php?pid=1179",
  "description": "一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。\n\n你的任务是判断是否有一条从节点 source 出发到节点 destination 的路径存在。\n\n输入描述\n\n第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。\n\n后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t 之间有一条边。\n\n最后一行包含两个正整数，代表起始节点 source 和目标节点 destination。\n\n输出描述\n\n输出一个整数，代表是否存在从节点 source 到节点 destination 的路径。如果存在，输出 1；否则，输出 0。\n\n输入",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "图论",
    "并查集"
  ],
  "data_structure_tags": [
    "数组",
    "并查集"
  ],
  "technique_tags": [
    "路径压缩",
    "按秩合并"
  ],
  "difficulty": null,
  "solution_approach": "使用并查集来解决图中是否存在从source到destination路径的问题。通过将每条边加入并查集中，最后判断source和destination是否属于同一个集合来确定路径的存在性。",
  "key_insights": [
    {
      "content": "并查集非常适合用来解决图论中的连通性问题，如本题中需要判断两个节点是否在同一个连通分量内。"
    },
    {
      "content": "在find函数中采用路径压缩技术，可以显著提高后续查找操作的速度，从而让算法更高效。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "本题是并查集基础题目。 如果还不了解并查集，可以看这里：并查集理论基础(https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n; // 节点数量\nvector<int> father = vector<int> (101, 0); // 按照节点大小定义数组大小\n\n// 并查集初始化\nvoid init() {\n    for (int i = 1; i <= n; i++)  father[i] = i;\n}\n// 并查集里寻根的过程\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\n\n// 判断 u 和 v是否找到同一个根\nbool isSame(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\n\n// 将v->u 这条边加入并查集\nvoid join(int u, int v) {\n    u = find(u); // 寻找u的根\n    v = find(v); // 寻找v的根\n    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回\n    father[v] = u;\n}\n\nint main() {\n    int m, s, t, source, destination;\n    cin >> n >> m;\n    init();\n    while (m--) {\n        cin >> s >> t;\n        join(s, t);\n    }\n    cin >> source >> destination;\n    if (isSame(source, destination)) cout << 1 << endl;\n    else cout << 0 << endl;\n}",
          "description": "C++版本的寻找存在的路径问题解法"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main{\n    public static void main(String[] args) {\n        int N, M;\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n        DisJoint disJoint = new DisJoint(N + 1);\n        for (int i = 0; i < M; ++i) {\n            disJoint.join(scanner.nextInt(), scanner.nextInt());\n        }\n        if(disJoint.isSame(scanner.nextInt(), scanner.nextInt())) {\n            System.out.println(\"1\");\n        } else {\n            System.out.println(\"0\");\n        }\n    }\n}\n\n//并查集模板\nclass DisJoint{\n    private int[] father;\n\n    public DisJoint(int N) {\n        father = new int[N];\n        for (int i = 0; i < N; ++i){\n            father[i] = i;\n        }\n    }\n\n    public int find(int n) {\n        return n == father[n] ? n : (father[n] = find(father[n]));\n    }\n\n    public void join (int n, int m) {\n        n = find(n);\n        m = find(m);\n        if (n == m) return;\n        father[m] = n;\n    }\n\n    public boolean isSame(int n, int m){\n        n = find(n);\n        m = find(m);\n        return n == m;\n    }\n}",
          "description": "Java版本的寻找存在的路径问题解法"
        },
        {
          "language": "python",
          "code": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size + 1))  # 初始化并查集\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])  # 路径压缩\n        return self.parent[u]\n\n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            self.parent[root_v] = root_u\n\n    def is_same(self, u, v):\n        return self.find(u) == self.find(v)\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    uf = UnionFind(n)\n    \n    for _ in range(m):\n        s = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        uf.union(s, t)\n    \n    source = int(data[index])\n    index += 1\n    destination = int(data[index])\n    \n    if uf.is_same(source, destination):\n        print(1)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的寻找存在的路径问题解法"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <iostream>",
      "text": "#include <vector>",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n; // 节点数量\nvector<int> father = vector<int> (101, 0); // 按照节点大小定义数组大小\n\n// 并查集初始化\nvoid init() {\n    for (int i = 1; i <= n; i++)  father[i] = i;\n}\n// 并查集里寻根的过程\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\n\n// 判断 u 和 v是否找到同一个根\nbool isSame(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\n\n// 将v->u 这条边加入并查集\nvoid join(int u, int v) {\n    u = find(u); // 寻找u的根\n    v = find(v); // 寻找v的根\n    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回\n    father[v] = u;\n}\n\nint main() {\n    int m, s, t, source, destination;\n    cin >> n >> m;\n    init();\n    while (m--) {\n        cin >> s >> t;\n        join(s, t);\n    }\n    cin >> source >> destination;\n    if (isSame(source, destination)) cout << 1 << endl;\n    else cout << 0 << endl;\n}",
          "description": "C++实现寻找从source到destination路径的存在性检查"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main{\n    public static void main(String[] args) {\n        int N, M;\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n        DisJoint disJoint = new DisJoint(N + 1);\n        for (int i = 0; i < M; ++i) {\n            disJoint.join(scanner.nextInt(), scanner.nextInt());\n        }\n        if(disJoint.isSame(scanner.nextInt(), scanner.nextInt())) {\n            System.out.println(\"1\");\n        } else {\n            System.out.println(\"0\");\n        }\n    }\n}\n\n//并查集模板\nclass DisJoint{\n    private int[] father;\n\n    public DisJoint(int N) {\n        father = new int[N];\n        for (int i = 0; i < N; ++i){\n            father[i] = i;\n        }\n    }\n\n    public int find(int n) {\n        return n == father[n] ? n : (father[n] = find(father[n]));\n    }\n\n    public void join (int n, int m) {\n        n = find(n);\n        m = find(m);\n        if (n == m) return;\n        father[m] = n;\n    }\n\n    public boolean isSame(int n, int m){\n        n = find(n);\n        m = find(m);\n        return n == m;\n    }\n}",
          "description": "Java实现寻找从source到destination路径的存在性检查"
        },
        {
          "language": "python",
          "code": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size + 1))  # 初始化并查集\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])  # 路径压缩\n        return self.parent[u]\n\n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            self.parent[root_v] = root_u\n\n    def is_same(self, u, v):\n        return self.find(u) == self.find(v)\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    uf = UnionFind(n)\n    \n    for _ in range(m):\n        s = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        uf.union(s, t)\n    \n    source = int(data[index])\n    index += 1\n    destination = int(data[index])\n    \n    if uf.is_same(source, destination):\n        print(1)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现寻找从source到destination路径的存在性检查"
        }
      ],
      "subsections": []
    },
    {
      "name": "include <vector>",
      "text": "using namespace std;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n; // 节点数量\nvector<int> father = vector<int> (101, 0); // 按照节点大小定义数组大小\n\n// 并查集初始化\nvoid init() {\n    for (int i = 1; i <= n; i++)  father[i] = i;\n}\n// 并查集里寻根的过程\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\n\n// 判断 u 和 v是否找到同一个根\nbool isSame(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\n\n// 将v->u 这条边加入并查集\nvoid join(int u, int v) {\n    u = find(u); // 寻找u的根\n    v = find(v); // 寻找v的根\n    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回\n    father[v] = u;\n}\n\nint main() {\n    int m, s, t, source, destination;\n    cin >> n >> m;\n    init();\n    while (m--) {\n        cin >> s >> t;\n        join(s, t);\n    }\n    cin >> source >> destination;\n    if (isSame(source, destination)) cout << 1 << endl;\n    else cout << 0 << endl;\n}",
          "description": "C++实现判断图中是否存在从source到destination路径"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main{\n    public static void main(String[] args) {\n        int N, M;\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n        DisJoint disJoint = new DisJoint(N + 1);\n        for (int i = 0; i < M; ++i) {\n            disJoint.join(scanner.nextInt(), scanner.nextInt());\n        }\n        if(disJoint.isSame(scanner.nextInt(), scanner.nextInt())) {\n            System.out.println(\"1\");\n        } else {\n            System.out.println(\"0\");\n        }\n    }\n}\n\n//并查集模板\nclass DisJoint{\n    private int[] father;\n\n    public DisJoint(int N) {\n        father = new int[N];\n        for (int i = 0; i < N; ++i){\n            father[i] = i;\n        }\n    }\n\n    public int find(int n) {\n        return n == father[n] ? n : (father[n] = find(father[n]));\n    }\n\n    public void join (int n, int m) {\n        n = find(n);\n        m = find(m);\n        if (n == m) return;\n        father[m] = n;\n    }\n\n    public boolean isSame(int n, int m){\n        n = find(n);\n        m = find(m);\n        return n == m;\n    }\n}",
          "description": "Java实现判断图中是否存在从source到destination路径"
        },
        {
          "language": "python",
          "code": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size + 1))  # 初始化并查集\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])  # 路径压缩\n        return self.parent[u]\n\n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            self.parent[root_v] = root_u\n\n    def is_same(self, u, v):\n        return self.find(u) == self.find(v)\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    uf = UnionFind(n)\n    \n    for _ in range(m):\n        s = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        uf.union(s, t)\n    \n    source = int(data[index])\n    index += 1\n    destination = int(data[index])\n    \n    if uf.is_same(source, destination):\n        print(1)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现判断图中是否存在从source到destination路径"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "import java.util.*; public class Main{ public static void main(String[] args) { int N, M; Scanner scanner = new Scanner(System.in); N = scanner.nextInt(); M = scanner.nextInt(); DisJoint disJoint = new DisJoint(N + 1); for (int i = 0; i < M; ++i) { disJoint.join(scanner.nextInt(), scanner.nextInt()); } if(disJoint.isSame(scanner.nextInt(), scanner.nextInt())) { System.out.println(\"1\"); } else { System.out.println(\"0\"); } } } class DisJoint{ private int[] father; public DisJoint(int N) { father = new int[N]; for (int i = 0; i < N; ++i){ father[i] = i; } } public int find(int n) { return n == father[n] ? n : (father[n] = find(father[n])); } public void join (int n, int m) { n = find(n); m = find(m); if (n == m) return; father[m] = n; } public boolean isSame(int n, int m){ n = find(n); m = find(m); return n == m; } }",
          "description": "Java实现的并查集解决路径存在性问题"
        },
        {
          "language": "cpp",
          "code": "#include <iostream> #include <vector> using namespace std; int n; vector<int> father = vector<int> (101, 0); void init() { for (int i = 1; i <= n; i++)  father[i] = i; } int find(int u) { return u == father[u] ? u : father[u] = find(father[u]); } bool isSame(int u, int v) { u = find(u); v = find(v); return u == v; } void join(int u, int v) { u = find(u); v = find(v); if (u == v) return ; father[v] = u; } int main() { int m, s, t, source, destination; cin >> n >> m; init(); while (m--) { cin >> s >> t; join(s, t); } cin >> source >> destination; if (isSame(source, destination)) cout << 1 << endl; else cout << 0 << endl; }",
          "description": "C++实现的并查集解决路径存在性问题"
        },
        {
          "language": "python",
          "code": "class UnionFind: def __init__(self, size): self.parent = list(range(size + 1)) def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: self.parent[root_v] = root_u def is_same(self, u, v): return self.find(u) == self.find(v) def main(): import sys input = sys.stdin.read data = input().split() index = 0 n = int(data[index]) index += 1 m = int(data[index]) index += 1 uf = UnionFind(n) for _ in range(m): s = int(data[index]) index += 1 t = int(data[index]) index += 1 uf.union(s, t) source = int(data[index]) index += 1 destination = int(data[index]) if uf.is_same(source, destination): print(1) else: print(0) if __name__ == \"__main__\": main()",
          "description": "Python实现的并查集解决路径存在性问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "import java.util.*;",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n; // 节点数量\nvector<int> father = vector<int> (101, 0); // 按照节点大小定义数组大小\n\n// 并查集初始化\nvoid init() {\n    for (int i = 1; i <= n; i++)  father[i] = i;\n}\n// 并查集里寻根的过程\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\n\n// 判断 u 和 v是否找到同一个根\nbool isSame(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\n\n// 将v->u 这条边加入并查集\nvoid join(int u, int v) {\n    u = find(u); // 寻找u的根\n    v = find(v); // 寻找v的根\n    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回\n    father[v] = u;\n}\n\nint main() {\n    int m, s, t, source, destination;\n    cin >> n >> m;\n    init();\n    while (m--) {\n        cin >> s >> t;\n        join(s, t);\n    }\n    cin >> source >> destination;\n    if (isSame(source, destination)) cout << 1 << endl;\n    else cout << 0 << endl;\n}",
          "description": "C++版本的并查集实现，用于检测从一个节点到另一个节点是否存在路径。"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main{\n    public static void main(String[] args) {\n        int N, M;\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n        DisJoint disJoint = new DisJoint(N + 1);\n        for (int i = 0; i < M; ++i) {\n            disJoint.join(scanner.nextInt(), scanner.nextInt());\n        }\n        if(disJoint.isSame(scanner.nextInt(), scanner.nextInt())) {\n            System.out.println(\"1\");\n        } else {\n            System.out.println(\"0\");\n        }\n    }\n}\n\n//并查集模板\nclass DisJoint{\n    private int[] father;\n\n    public DisJoint(int N) {\n        father = new int[N];\n        for (int i = 0; i < N; ++i){\n            father[i] = i;\n        }\n    }\n\n    public int find(int n) {\n        return n == father[n] ? n : (father[n] = find(father[n]));\n    }\n\n    public void join (int n, int m) {\n        n = find(n);\n        m = find(m);\n        if (n == m) return;\n        father[m] = n;\n    }\n\n    public boolean isSame(int n, int m){\n        n = find(n);\n        m = find(m);\n        return n == m;\n    }\n}",
          "description": "Java版本的并查集实现，功能同上。"
        },
        {
          "language": "python",
          "code": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size + 1))  # 初始化并查集\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])  # 路径压缩\n        return self.parent[u]\n\n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            self.parent[root_v] = root_u\n\n    def is_same(self, u, v):\n        return self.find(u) == self.find(v)\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    uf = UnionFind(n)\n    \n    for _ in range(m):\n        s = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        uf.union(s, t)\n    \n    source = int(data[index])\n    index += 1\n    destination = int(data[index])\n    \n    if uf.is_same(source, destination):\n        print(1)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python版本的并查集实现，同样用于解决上述问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "class UnionFind:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n; // 节点数量\nvector<int> father = vector<int> (101, 0); // 按照节点大小定义数组大小\n\n// 并查集初始化\nvoid init() {\n    for (int i = 1; i <= n; i++)  father[i] = i;\n}\n// 并查集里寻根的过程\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\n\n// 判断 u 和 v是否找到同一个根\nbool isSame(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\n\n// 将v->u 这条边加入并查集\nvoid join(int u, int v) {\n    u = find(u); // 寻找u的根\n    v = find(v); // 寻找v的根\n    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回\n    father[v] = u;\n}\n\nint main() {\n    int m, s, t, source, destination;\n    cin >> n >> m;\n    init();\n    while (m--) {\n        cin >> s >> t;\n        join(s, t);\n    }\n    cin >> source >> destination;\n    if (isSame(source, destination)) cout << 1 << endl;\n    else cout << 0 << endl;\n}",
          "description": "C++实现的并查集算法来解决图中两点间路径存在性问题"
        },
        {
          "language": "java",
          "code": "import java.util.*;\n\npublic class Main{\n    public static void main(String[] args) {\n        int N, M;\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n        DisJoint disJoint = new DisJoint(N + 1);\n        for (int i = 0; i < M; ++i) {\n            disJoint.join(scanner.nextInt(), scanner.nextInt());\n        }\n        if(disJoint.isSame(scanner.nextInt(), scanner.nextInt())) {\n            System.out.println(\"1\");\n        } else {\n            System.out.println(\"0\");\n        }\n    }\n}\n\n//并查集模板\nclass DisJoint{\n    private int[] father;\n\n    public DisJoint(int N) {\n        father = new int[N];\n        for (int i = 0; i < N; ++i){\n            father[i] = i;\n        }\n    }\n\n    public int find(int n) {\n        return n == father[n] ? n : (father[n] = find(father[n]));\n    }\n\n    public void join (int n, int m) {\n        n = find(n);\n        m = find(m);\n        if (n == m) return;\n        father[m] = n;\n    }\n\n    public boolean isSame(int n, int m){\n        n = find(n);\n        m = find(m);\n        return n == m;\n    }\n}",
          "description": "Java实现的并查集算法来解决图中两点间路径存在性问题"
        },
        {
          "language": "python",
          "code": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size + 1))  # 初始化并查集\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])  # 路径压缩\n        return self.parent[u]\n\n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            self.parent[root_v] = root_u\n\n    def is_same(self, u, v):\n        return self.find(u) == self.find(v)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    uf = UnionFind(n)\n    \n    for _ in range(m):\n        s = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        uf.union(s, t)\n    \n    source = int(data[index])\n    index += 1\n    destination = int(data[index])\n    \n    if uf.is_same(source, destination):\n        print(1)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()",
          "description": "Python实现的并查集算法来解决图中两点间路径存在性问题"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "C++",
      "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n; // 节点数量\nvector<int> father = vector<int> (101, 0); // 按照节点大小定义数组大小\n\n// 并查集初始化\nvoid init() {\n    for (int i = 1; i <= n; i++)  father[i] = i;\n}\n// 并查集里寻根的过程\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\n\n// 判断 u 和 v是否找到同一个根\nbool isSame(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\n\n// 将v->u 这条边加入并查集\nvoid join(int u, int v) {\n    u = find(u); // 寻找u的根\n    v = find(v); // 寻找v的根\n    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回\n    father[v] = u;\n}\n\nint main() {\n    int m, s, t, source, destination;\n    cin >> n >> m;\n    init();\n    while (m--) {\n        cin >> s >> t;\n        join(s, t);\n    }\n    cin >> source >> destination;\n    if (isSame(source, destination)) cout << 1 << endl;\n    else cout << 0 << endl;\n}",
      "description": "C++实现寻找从源节点到目标节点路径的存在性"
    },
    {
      "language": "Java",
      "code": "import java.util.*;\n\npublic class Main{\n    public static void main(String[] args) {\n        int N, M;\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n        DisJoint disJoint = new DisJoint(N + 1);\n        for (int i = 0; i < M; ++i) {\n            disJoint.join(scanner.nextInt(), scanner.nextInt());\n        }\n        if(disJoint.isSame(scanner.nextInt(), scanner.nextInt())) {\n            System.out.println(\"1\");\n        } else {\n            System.out.println(\"0\");\n        }\n    }\n}\n\n//并查集模板\nclass DisJoint{\n    private int[] father;\n\n    public DisJoint(int N) {\n        father = new int[N];\n        for (int i = 0; i < N; ++i){\n            father[i] = i;\n        }\n    }\n\n    public int find(int n) {\n        return n == father[n] ? n : (father[n] = find(father[n]));\n    }\n\n    public void join (int n, int m) {\n        n = find(n);\n        m = find(m);\n        if (n == m) return;\n        father[m] = n;\n    }\n\n    public boolean isSame(int n, int m){\n        n = find(n);\n        m = find(m);\n        return n == m;\n    }\n}",
      "description": "Java实现寻找从源节点到目标节点路径的存在性"
    },
    {
      "language": "Python",
      "code": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size + 1))  # 初始化并查集\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])  # 路径压缩\n        return self.parent[u]\n\n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            self.parent[root_v] = root_u\n\n    def is_same(self, u, v):\n        return self.find(u) == self.find(v)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    uf = UnionFind(n)\n    \n    for _ in range(m):\n        s = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        uf.union(s, t)\n    \n    source = int(data[index])\n    index += 1\n    destination = int(data[index])\n    \n    if uf.is_same(source, destination):\n        print(1)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()",
      "description": "Python实现寻找从源节点到目标节点路径的存在性"
    }
  ],
  "common_mistakes": [
    "忘记初始化father数组，导致逻辑错误。",
    "不正确地实现find或join方法，影响了并查集的功能。",
    "忽视边界条件，例如N和M的范围限制。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20240527104432.png",
      "description": "这张图片展示了一个包含四个节点（1, 2, 3, 4）的环形链表和一个孤立节点（5），适用于图论算法和数据结构分析。",
      "context": "该图片展示了如何使用并查集来解决从给定的起点到终点是否存在路径的问题。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20240527104432.png",
      "description": "GIF展示了从起始节点到目标节点寻找路径的过程，通过高亮显示相连的节点来逐步探索是否存在通路。",
      "context": "GIF动画展示了如何通过并查集算法逐步连接图中的节点，并最终判断起始节点与目标节点是否连通的过程。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\并查集\\寻找存在的路径.txt",
  "extracted_at": "2025-07-21T21:16:44.698010",
  "raw_content": "寻找存在的路径\n卡码网题目链接（ACM模式）(https://kamacoder.com/problempage.php?pid=1179)\n\n题目描述\n\n给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。\n\n你的任务是判断是否有一条从节点 source 出发到节点 destination 的路径存在。\n\n输入描述\n\n第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。\n\n后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t 之间有一条边。\n\n最后一行包含两个正整数，代表起始节点 source 和目标节点 destination。\n\n输出描述\n\n输出一个整数，代表是否存在从节点 source 到节点 destination 的路径。如果存在，输出 1；否则，输出 0。\n\n输入示例\n\n5 4\n1 2\n1 3\n2 4\n3 4\n1 4\n输出示例\n\n1\n\n提示信息\nhttps://file1.kamacoder.com/i/algo/20240527104432.png\n\n\n数据范围：\n\n1 <= M, N <= 100。\n\n#思路\n本题是并查集基础题目。 如果还不了解并查集，可以看这里：并查集理论基础(https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)\n\n并查集可以解决什么问题呢？\n\n主要就是集合问题，两个节点在不在一个集合，也可以将两个节点添加到一个集合中。\n\n这里整理出我的并查集模板如下：\n\nint n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好\nvector<int> father = vector<int> (n, 0); // C++里的一种数组结构\n\n// 并查集初始化\nvoid init() {\n    for (int i = 0; i < n; ++i) {\n        father[i] = i;\n    }\n}\n// 并查集里寻根的过程\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩\n}\n\n// 判断 u 和 v是否找到同一个根\nbool isSame(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\n\n// 将v->u 这条边加入并查集\nvoid join(int u, int v) {\n    u = find(u); // 寻找u的根\n    v = find(v); // 寻找v的根\n    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回\n    father[v] = u;\n}\n以上模板中，只要修改 n 大小就可以。\n\n并查集主要有三个功能：\n\n寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个\n将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上\n判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点\n简单介绍并查集之后，我们再来看一下这道题目。\n\n为什么说这道题目是并查集基础题目，题目中各个点是双向图链接，那么判断 一个顶点到另一个顶点有没有有效路径其实就是看这两个顶点是否在同一个集合里。\n\n如何算是同一个集合呢，有边连在一起，就算是一个集合。\n\n此时我们就可以直接套用并查集模板。\n\n使用 join(int u, int v)将每条边加入到并查集。\n\n最后 isSame(int u, int v) 判断是否是同一个根 就可以了。\n\nC++代码如下：\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n; // 节点数量\nvector<int> father = vector<int> (101, 0); // 按照节点大小定义数组大小\n\n// 并查集初始化\nvoid init() {\n    for (int i = 1; i <= n; i++)  father[i] = i;\n}\n// 并查集里寻根的过程\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]);\n}\n\n// 判断 u 和 v是否找到同一个根\nbool isSame(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\n\n// 将v->u 这条边加入并查集\nvoid join(int u, int v) {\n    u = find(u); // 寻找u的根\n    v = find(v); // 寻找v的根\n    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回\n    father[v] = u;\n}\n\nint main() {\n    int m, s, t, source, destination;\n    cin >> n >> m;\n    init();\n    while (m--) {\n        cin >> s >> t;\n        join(s, t);\n    }\n    cin >> source >> destination;\n    if (isSame(source, destination)) cout << 1 << endl;\n    else cout << 0 << endl;\n}\n#其他语言版本\n#Java\n\nimport java.util.*;\n \npublic class Main{\n    public static void main(String[] args) {\n        int N, M;\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n        DisJoint disJoint = new DisJoint(N + 1);\n        for (int i = 0; i < M; ++i) {\n            disJoint.join(scanner.nextInt(), scanner.nextInt());\n        }\n        if(disJoint.isSame(scanner.nextInt(), scanner.nextInt())) {\n            System.out.println(\"1\");\n        } else {\n            System.out.println(\"0\");\n        }\n    }\n \n}\n\n//并查集模板\nclass DisJoint{\n    private int[] father;\n \n    public DisJoint(int N) {\n        father = new int[N];\n        for (int i = 0; i < N; ++i){\n            father[i] = i;\n        }\n    }\n \n    public int find(int n) {\n        return n == father[n] ? n : (father[n] = find(father[n]));\n    }\n \n    public void join (int n, int m) {\n        n = find(n);\n        m = find(m);\n        if (n == m) return;\n        father[m] = n;\n    }\n \n    public boolean isSame(int n, int m){\n        n = find(n);\n        m = find(m);\n        return n == m;\n    }\n \n}\n\n#Python\n\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size + 1))  # 初始化并查集\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])  # 路径压缩\n        return self.parent[u]\n\n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            self.parent[root_v] = root_u\n\n    def is_same(self, u, v):\n        return self.find(u) == self.find(v)\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    uf = UnionFind(n)\n    \n    for _ in range(m):\n        s = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        uf.union(s, t)\n    \n    source = int(data[index])\n    index += 1\n    destination = int(data[index])\n    \n    if uf.is_same(source, destination):\n        print(1)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()"
}