{
  "id": "AP_a0cc2885",
  "title": "一和零",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/ones-and-zeroes/",
  "description": "一个二进制字符串数组 strs 和两个整数 m 和 n 。\n\n请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。\n\n如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划",
    "01背包"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "二维DP",
    "后向遍历"
  ],
  "difficulty": null,
  "solution_approach": "题目可以看作是一个二维01背包问题。给定一个二进制字符串数组，每个字符串代表一个物品，其中'0'和'1'的数量分别对应物品在两个维度上的重量。目标是在不超过给定的m个0和n个1的情况下，找到能够放入背包的最大数量的字符串（即最大子集）。通过动态规划来解决这个问题。",
  "key_insights": [
    {
      "content": "尽管初看起来像是多重背包问题，但实际上每个字符串作为一个独立的物品只能选择一次，因此更符合01背包问题的特点。不同之处在于这里的背包有两个容量限制：m个0和n个1。"
    },
    {
      "content": "定义dp[i][j]表示最多包含i个0和j个1时，可以从strs中挑选出的最大子集大小。通过遍历所有字符串，并基于当前字符串中的0和1的数量更新dp数组，最终得到结果。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "如果对背包问题不都熟悉先看这两篇：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findMaxForm(vector<string>& strs, int m, int n) { vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); for (string str : strs) { int oneNum = 0, zeroNum = 0; for (char c : str) { if (c == '0') zeroNum++; else oneNum++; } for (int i = m; i >= zeroNum; i--) { for (int j = n; j >= oneNum; j--) { dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); } } } return dp[m][n];}};",
          "description": "C++实现的二维DP数组版本"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findMaxForm(vector<string>& strs, int m, int n) { int num_of_str = strs.size(); vector<vector<vector<int>>> dp(num_of_str, vector<vector<int>>(m + 1,vector<int>(n + 1, 0))); vector<int> num_of_zeros; vector<int> num_of_ones; for (auto& str : strs){ int count_of_zero = 0; int count_of_one = 0; for (char &c : str){ if(c == '0') count_of_zero ++; else count_of_one ++; } num_of_zeros.push_back(count_of_zero); num_of_ones.push_back(count_of_one); } if(num_of_zeros[0] <= m && num_of_ones[0] <= n){ for(int j = num_of_zeros[0]; j <= m; j++){ for(int k = num_of_ones[0]; k <= n; k++){ dp[0][j][k] = 1; } } } for (int i = 1; i < num_of_str; i++){ int count_of_zeros = num_of_zeros[i]; int count_of_ones = num_of_ones[i]; for (int j = 0; j <= m; j++){ for (int k = 0; k <= n; k++){ if( j < count_of_zeros || k < count_of_ones){ dp[i][j][k] = dp[i-1][j][k]; }else{ dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - count_of_zeros][k - count_of_ones] + 1); } } } } return dp[num_of_str-1][m][n];}};",
          "description": "C++实现的三维DP数组版本"
        },
        {
          "language": "java",
          "code": "class Solution { public int findMaxForm(String[] strs, int m, int n) { int[][][] dpArr = new int[strs.length][m + 1][n + 1]; int zeroNum = 0; int oneNum = 0; for (char c : strs[0].toCharArray()) { if (c == '0') { zeroNum++; } else { oneNum++; } } for (int j = zeroNum; j <= m; j++) { for (int k = oneNum; k <= n; k++) { dpArr[0][j][k] = 1; } } for (int i = 1; i < strs.length; i++) { zeroNum = 0; oneNum = 0; for (char c : strs[i].toCharArray()) { if (c == '0') { zeroNum++; } else { oneNum++; } } for (int j = 0; j <= m; j++) { for (int k = 0; k <= n; k++) { if (j >= zeroNum && k >= oneNum) { dpArr[i][j][k] = Math.max(dpArr[i - 1][j][k], dpArr[i - 1][j - zeroNum][k - oneNum] + 1); } else { dpArr[i][j][k] = dpArr[i - 1][j][k]; } } } } return dpArr[dpArr.length - 1][m][n]; }}",
          "description": "Java实现的三维DP数组版本"
        },
        {
          "language": "java",
          "code": "class Solution { public int findMaxForm(String[] strs, int m, int n) { int[][] dp = new int[m + 1][n + 1]; int oneNum, zeroNum; for (String str : strs) { oneNum = 0; zeroNum = 0; for (char ch : str.toCharArray()) { if (ch == '0') { zeroNum++; } else { oneNum++; } } for (int i = m; i >= zeroNum; i--) { for (int j = n; j >= oneNum; j--) { dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); } } } return dp[m][n]; }}",
          "description": "Java实现的二维DP数组版本"
        },
        {
          "language": "python",
          "code": "class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: zeroNum = s.count('0') oneNum = len(s) - zeroNum for i in range(m, zeroNum - 1, -1): for j in range(n, oneNum - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1) return dp[m][n]",
          "description": "Python实现的二维DP数组版本（版本一）"
        },
        {
          "language": "python",
          "code": "class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: ones = s.count('1') zeros = s.count('0') for i in range(m, zeros - 1, -1): for j in range(n, ones - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1) return dp[m][n]",
          "description": "Python实现的二维DP数组版本（版本二）"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "不少同学刷过这道题，可能没有总结这究竟是什么背包。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findMaxForm(vector<string>& strs, int m, int n) { vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); for (string str : strs) { int oneNum = 0, zeroNum = 0; for (char c : str) { if (c == '0') zeroNum++; else oneNum++; } for (int i = m; i >= zeroNum; i--) { for (int j = n; j >= oneNum; j--) { dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); } } } return dp[m][n];}};",
          "description": "C++实现的二维动态规划解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findMaxForm(vector<string>& strs, int m, int n) { int num_of_str = strs.size(); vector<vector<vector<int>>> dp(num_of_str, vector<vector<int>>(m + 1,vector<int>(n + 1, 0))); vector<int> num_of_zeros; vector<int> num_of_ones; for (auto& str : strs){ int count_of_zero = 0; int count_of_one = 0; for (char &c : str){ if(c == '0') count_of_zero ++; else count_of_one ++; } num_of_zeros.push_back(count_of_zero); num_of_ones.push_back(count_of_one);} if(num_of_zeros[0] <= m && num_of_ones[0] <= n){ for(int j = num_of_zeros[0]; j <= m; j++){ for(int k = num_of_ones[0]; k <= n; k++){ dp[0][j][k] = 1; } }} for (int i = 1; i < num_of_str; i++){ int count_of_zeros = num_of_zeros[i]; int count_of_ones = num_of_ones[i]; for (int j = 0; j <= m; j++){ for (int k = 0; k <= n; k++){ if( j < count_of_zeros || k < count_of_ones){ dp[i][j][k] = dp[i-1][j][k]; }else{ dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - count_of_zeros][k - count_of_ones] + 1); }}}} return dp[num_of_str-1][m][n];}};",
          "description": "C++实现的三维动态规划解法"
        },
        {
          "language": "java",
          "code": "class Solution { public int findMaxForm(String[] strs, int m, int n) { int[][][] dpArr = new int[strs.length][m + 1][n + 1]; int zeroNum = 0; int oneNum = 0; for (char c : strs[0].toCharArray()) { if (c == '0') { zeroNum++; } else { oneNum++; } } for (int j = zeroNum; j <= m; j++) { for (int k = oneNum; k <= n; k++) { dpArr[0][j][k] = 1; } } for (int i = 1; i < strs.length; i++) { zeroNum = 0; oneNum = 0; for (char c : strs[i].toCharArray()) { if (c == '0') { zeroNum++; } else { oneNum++; } } for (int j = 0; j <= m; j++) { for (int k = 0; k <= n; k++) { if (j >= zeroNum && k >= oneNum) { dpArr[i][j][k] = Math.max(dpArr[i - 1][j][k], dpArr[i - 1][j - zeroNum][k - oneNum] + 1); } else { dpArr[i][j][k] = dpArr[i - 1][j][k]; } } } } return dpArr[dpArr.length - 1][m][n]; }}",
          "description": "Java实现的三维动态规划解法"
        },
        {
          "language": "java",
          "code": "class Solution { public int findMaxForm(String[] strs, int m, int n) { int[][] dp = new int[m + 1][n + 1]; int oneNum, zeroNum; for (String str : strs) { oneNum = 0; zeroNum = 0; for (char ch : str.toCharArray()) { if (ch == '0') { zeroNum++; } else { oneNum++; } } for (int i = m; i >= zeroNum; i--) { for (int j = n; j >= oneNum; j--) { dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); } } } return dp[m][n]; }}",
          "description": "Java实现的二维动态规划解法"
        },
        {
          "language": "python",
          "code": "class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: zeroNum = s.count('0') oneNum = len(s) - zeroNum for i in range(m, zeroNum - 1, -1): for j in range(n, oneNum - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1) return dp[m][n]",
          "description": "Python实现的二维动态规划解法（版本一）"
        },
        {
          "language": "python",
          "code": "class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: ones = s.count('1') zeros = s.count('0') for i in range(m, zeros - 1, -1): for j in range(n, ones - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1) return dp[m][n]",
          "description": "Python实现的二维动态规划解法（版本二）"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findMaxForm(vector<string>& strs, int m, int n) {vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); for (string str : strs) {int oneNum = 0, zeroNum = 0;for (char c : str) {if (c == '0') zeroNum++;else oneNum++;}for (int i = m; i >= zeroNum; i--) {for (int j = n; j >= oneNum; j--) {dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);}}}return dp[m][n];}};",
          "description": "使用二维动态规划数组实现的C++解决方案"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findMaxForm(vector<string>& strs, int m, int n) {int num_of_str = strs.size();vector<vector<vector<int>>> dp(num_of_str, vector<vector<int>>(m + 1,vector<int>(n + 1, 0)));vector<int> num_of_zeros;vector<int> num_of_ones;for (auto& str : strs){int count_of_zero = 0;int count_of_one = 0;for (char &c : str){if(c == '0') count_of_zero ++;else count_of_one ++;}num_of_zeros.push_back(count_of_zero);num_of_ones.push_back(count_of_one);}if(num_of_zeros[0] <= m && num_of_ones[0] <= n){for(int j = num_of_zeros[0]; j <= m; j++){for(int k = num_of_ones[0]; k <= n; k++){dp[0][j][k] = 1;}}}for (int i = 1; i < num_of_str; i++){int count_of_zeros = num_of_zeros[i];int count_of_ones = num_of_ones[i]; for (int j = 0; j <= m; j++){for (int k = 0; k <= n; k++){if( j < count_of_zeros || k < count_of_ones){dp[i][j][k] = dp[i-1][j][k];}else{dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - count_of_zeros][k - count_of_ones] + 1);}}}}return dp[num_of_str-1][m][n];}};",
          "description": "使用三维动态规划数组实现的C++解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public int findMaxForm(String[] strs, int m, int n) {int[][][] dpArr = new int[strs.length][m + 1][n + 1];int zeroNum = 0;int oneNum = 0;for (char c : strs[0].toCharArray()) {if (c == '0') {zeroNum++;} else {oneNum++;}}for (int j = zeroNum; j <= m; j++) {for (int k = oneNum; k <= n; k++) {dpArr[0][j][k] = 1;}}for (int i = 1; i < strs.length; i++) {zeroNum = 0;oneNum = 0;for (char c : strs[i].toCharArray()) {if (c == '0') {zeroNum++;} else {oneNum++;}}for (int j = 0; j <= m; j++) {for (int k = 0; k <= n; k++) {if (j >= zeroNum && k >= oneNum) {dpArr[i][j][k] = Math.max(dpArr[i - 1][j][k], dpArr[i - 1][j - zeroNum][k - oneNum] + 1);} else {dpArr[i][j][k] = dpArr[i - 1][j][k];}}}}return dpArr[dpArr.length - 1][m][n];}}",
          "description": "使用三维动态规划数组实现的Java解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public int findMaxForm(String[] strs, int m, int n) {int[][] dp = new int[m + 1][n + 1];int oneNum, zeroNum;for (String str : strs) {oneNum = 0;zeroNum = 0;for (char ch : str.toCharArray()) {if (ch == '0') {zeroNum++;} else {oneNum++;}}for (int i = m; i >= zeroNum; i--) {for (int j = n; j >= oneNum; j--) {dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);}}}return dp[m][n];}}",
          "description": "使用二维动态规划数组实现的Java解决方案"
        },
        {
          "language": "python",
          "code": "class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: zeroNum = s.count('0') oneNum = len(s) - zeroNum for i in range(m, zeroNum - 1, -1): for j in range(n, oneNum - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1) return dp[m][n]",
          "description": "使用二维动态规划数组实现的Python解决方案（版本一）"
        },
        {
          "language": "python",
          "code": "class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: ones = s.count('1') zeros = s.count('0') for i in range(m, zeros - 1, -1): for j in range(n, ones - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1) return dp[m][n]",
          "description": "使用二维动态规划数组实现的Python解决方案（版本二）"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java",
      "text": "三维DP数组实现",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findMaxForm(vector<string>& strs, int m, int n) {vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); for (string str : strs) {int oneNum = 0, zeroNum = 0;for (char c : str) {if (c == '0') zeroNum++; else oneNum++;}for (int i = m; i >= zeroNum; i--) {for (int j = n; j >= oneNum; j--) {dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);}}}return dp[m][n];}};",
          "description": "使用二维DP数组实现"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findMaxForm(vector<string>& strs, int m, int n) {int num_of_str = strs.size();vector<vector<vector<int>>> dp(num_of_str, vector<vector<int>>(m + 1,vector<int>(n + 1, 0)));vector<int> num_of_zeros;vector<int> num_of_ones;for (auto& str : strs){int count_of_zero = 0;int count_of_one = 0;for (char &c : str){if(c == '0') count_of_zero ++;else count_of_one ++;}num_of_zeros.push_back(count_of_zero);num_of_ones.push_back(count_of_one);}if(num_of_zeros[0] <= m && num_of_ones[0] <= n){for(int j = num_of_zeros[0]; j <= m; j++){for(int k = num_of_ones[0]; k <= n; k++){dp[0][j][k] = 1;}}}for (int i = 1; i < num_of_str; i++){int count_of_zeros = num_of_zeros[i];int count_of_ones = num_of_ones[i];for (int j = 0; j <= m; j++){for (int k = 0; k <= n; k++){if( j < count_of_zeros || k < count_of_ones){dp[i][j][k] = dp[i-1][j][k];}else{dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - count_of_zeros][k - count_of_ones] + 1);}}}}return dp[num_of_str-1][m][n];}};",
          "description": "使用三维DP数组实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int findMaxForm(String[] strs, int m, int n) {int[][][] dpArr = new int[strs.length][m + 1][n + 1];int zeroNum = 0;int oneNum = 0;for (char c : strs[0].toCharArray()) {if (c == '0') {zeroNum++;} else {oneNum++;}}for (int j = zeroNum; j <= m; j++) {for (int k = oneNum; k <= n; k++) {dpArr[0][j][k] = 1;}}for (int i = 1; i < strs.length; i++) {zeroNum = 0;oneNum = 0;for (char c : strs[i].toCharArray()) {if (c == '0') {zeroNum++;} else {oneNum++;}}for (int j = 0; j <= m; j++) {for (int k = 0; k <= n; k++) {if (j >= zeroNum && k >= oneNum) {dpArr[i][j][k] = Math.max(dpArr[i - 1][j][k], dpArr[i - 1][j - zeroNum][k - oneNum] + 1);} else {dpArr[i][j][k] = dpArr[i - 1][j][k];}}}}return dpArr[dpArr.length - 1][m][n];}}",
          "description": "Java版本，使用三维DP数组实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int findMaxForm(String[] strs, int m, int n) {int[][] dp = new int[m + 1][n + 1];int oneNum, zeroNum;for (String str : strs) {oneNum = 0;zeroNum = 0;for (char ch : str.toCharArray()) {if (ch == '0') {zeroNum++;} else {oneNum++;}}for (int i = m; i >= zeroNum; i--) {for (int j = n; j >= oneNum; j--) {dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);}}}return dp[m][n];}}",
          "description": "Java版本，使用二维DP数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: zeroNum = s.count('0') oneNum = len(s) - zeroNum for i in range(m, zeroNum - 1, -1): for j in range(n, oneNum - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1) return dp[m][n]",
          "description": "Python版本，使用二维DP数组实现（版本一）"
        },
        {
          "language": "python",
          "code": "class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: ones = s.count('1') zeros = s.count('0') for i in range(m, zeros - 1, -1): for j in range(n, ones - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1) return dp[m][n]",
          "description": "Python版本，使用二维DP数组实现（版本二）"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python",
      "text": "DP（版本一）",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int findMaxForm(vector<string>& strs, int m, int n) {vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); for (string str : strs) {int oneNum = 0, zeroNum = 0;for (char c : str) {if (c == '0') zeroNum++;else oneNum++;}for (int i = m; i >= zeroNum; i--) {for (int j = n; j >= oneNum; j--) {dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);}}}return dp[m][n];}};",
          "description": "C++实现的二维动态规划解法"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: int findMaxForm(vector<string>& strs, int m, int n) {int num_of_str = strs.size();vector<vector<vector<int>>> dp(num_of_str, vector<vector<int>>(m + 1,vector<int>(n + 1, 0)));vector<int> num_of_zeros;vector<int> num_of_ones;for (auto& str : strs){int count_of_zero = 0;int count_of_one = 0;for (char &c : str){if(c == '0') count_of_zero ++;else count_of_one ++;}num_of_zeros.push_back(count_of_zero);num_of_ones.push_back(count_of_one);}if(num_of_zeros[0] <= m && num_of_ones[0] <= n){for(int j = num_of_zeros[0]; j <= m; j++){for(int k = num_of_ones[0]; k <= n; k++){dp[0][j][k] = 1;}}}for (int i = 1; i < num_of_str; i++){int count_of_zeros = num_of_zeros[i];int count_of_ones = num_of_ones[i];for (int j = 0; j <= m; j++){for (int k = 0; k <= n; k++){if( j < count_of_zeros || k < count_of_ones){dp[i][j][k] = dp[i-1][j][k];}else{dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - count_of_zeros][k - count_of_ones] + 1);}}}}return dp[num_of_str-1][m][n];}};",
          "description": "C++实现的三维动态规划解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int findMaxForm(String[] strs, int m, int n) {int[][][] dpArr = new int[strs.length][m + 1][n + 1];int zeroNum = 0;int oneNum = 0;for (char c : strs[0].toCharArray()) {if (c == '0') {zeroNum++;} else {oneNum++;}}for (int j = zeroNum; j <= m; j++) {for (int k = oneNum; k <= n; k++) {dpArr[0][j][k] = 1;}}for (int i = 1; i < strs.length; i++) {zeroNum = 0;oneNum = 0;for (char c : strs[i].toCharArray()) {if (c == '0') {zeroNum++;} else {oneNum++;}}for (int j = 0; j <= m; j++) {for (int k = 0; k <= n; k++) {if (j >= zeroNum && k >= oneNum) {dpArr[i][j][k] = Math.max(dpArr[i - 1][j][k], dpArr[i - 1][j - zeroNum][k - oneNum] + 1);} else {dpArr[i][j][k] = dpArr[i - 1][j][k];}}}}return dpArr[dpArr.length - 1][m][n];}}",
          "description": "Java实现的三维动态规划解法"
        },
        {
          "language": "java",
          "code": "class Solution {public int findMaxForm(String[] strs, int m, int n) {int[][] dp = new int[m + 1][n + 1];int oneNum, zeroNum;for (String str : strs) {oneNum = 0;zeroNum = 0;for (char ch : str.toCharArray()) {if (ch == '0') {zeroNum++;} else {oneNum++;}}for (int i = m; i >= zeroNum; i--) {for (int j = n; j >= oneNum; j--) {dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);}}}return dp[m][n];}}",
          "description": "Java实现的二维动态规划解法"
        },
        {
          "language": "python",
          "code": "class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: zeroNum = s.count('0') oneNum = len(s) - zeroNum for i in range(m, zeroNum - 1, -1): for j in range(n, oneNum - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1) return dp[m][n]",
          "description": "Python实现的第一个版本的二维动态规划解法"
        },
        {
          "language": "python",
          "code": "class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: ones = s.count('1') zeros = s.count('0') for i in range(m, zeros - 1, -1): for j in range(n, ones - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1) return dp[m][n]",
          "description": "Python实现的第二个版本的二维动态规划解法"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(kmn)",
    "space_complexity": "O(mn)",
    "explanation": "k 为strs的长度"
  },
  "code_solutions": [
    {
      "language": "C++",
      "code": "class Solution {public: int findMaxForm(vector<string>& strs, int m, int n) {vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); for (string str : strs) {int oneNum = 0, zeroNum = 0;for (char c : str) {if (c == '0') zeroNum++;else oneNum++;}for (int i = m; i >= zeroNum; i--) {for (int j = n; j >= oneNum; j--) {dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);}}}return dp[m][n];}};",
      "description": "使用二维数组的动态规划解法"
    },
    {
      "language": "C++",
      "code": "class Solution {public: int findMaxForm(vector<string>& strs, int m, int n) {int num_of_str = strs.size();vector<vector<vector<int>>> dp(num_of_str, vector<vector<int>>(m + 1,vector<int>(n + 1, 0)));vector<int> num_of_zeros;vector<int> num_of_ones;for (auto& str : strs){int count_of_zero = 0;int count_of_one = 0;for (char &c : str){if(c == '0') count_of_zero ++;else count_of_one ++;}num_of_zeros.push_back(count_of_zero);num_of_ones.push_back(count_of_one);}if(num_of_zeros[0] <= m && num_of_ones[0] <= n){for(int j = num_of_zeros[0]; j <= m; j++){for(int k = num_of_ones[0]; k <= n; k++){dp[0][j][k] = 1;}}}for (int i = 1; i < num_of_str; i++){int count_of_zeros = num_of_zeros[i];int count_of_ones = num_of_ones[i];for (int j = 0; j <= m; j++){for (int k = 0; k <= n; k++){if( j < count_of_zeros || k < count_of_ones){dp[i][j][k] = dp[i-1][j][k];}else{dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - count_of_zeros][k - count_of_ones] + 1);}}}}return dp[num_of_str-1][m][n];}};",
      "description": "使用三维数组的动态规划解法"
    },
    {
      "language": "Java",
      "code": "class Solution {public int findMaxForm(String[] strs, int m, int n) {int[][][] dpArr = new int[strs.length][m + 1][n + 1];int zeroNum = 0;int oneNum = 0;for (char c : strs[0].toCharArray()) {if (c == '0') {zeroNum++;} else {oneNum++;}}for (int j = zeroNum; j <= m; j++) {for (int k = oneNum; k <= n; k++) {dpArr[0][j][k] = 1;}}for (int i = 1; i < strs.length; i++) {zeroNum = 0;oneNum = 0;for (char c : strs[i].toCharArray()) {if (c == '0') {zeroNum++;} else {oneNum++;}}for (int j = 0; j <= m; j++) {for (int k = 0; k <= n; k++) {if (j >= zeroNum && k >= oneNum) {dpArr[i][j][k] = Math.max(dpArr[i - 1][j][k], dpArr[i - 1][j - zeroNum][k - oneNum] + 1);} else {dpArr[i][j][k] = dpArr[i - 1][j][k];}}}}return dpArr[dpArr.length - 1][m][n];}}",
      "description": "三维DP数组实现"
    },
    {
      "language": "Java",
      "code": "class Solution {public int findMaxForm(String[] strs, int m, int n) {int[][] dp = new int[m + 1][n + 1];int oneNum, zeroNum;for (String str : strs) {oneNum = 0;zeroNum = 0;for (char ch : str.toCharArray()) {if (ch == '0') {zeroNum++;} else {oneNum++;}}for (int i = m; i >= zeroNum; i--) {for (int j = n; j >= oneNum; j--) {dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);}}}return dp[m][n];}}",
      "description": "二维DP数组实现"
    },
    {
      "language": "Python",
      "code": "class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: zeroNum = s.count('0') oneNum = len(s) - zeroNum for i in range(m, zeroNum - 1, -1): for j in range(n, oneNum - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1) return dp[m][n]",
      "description": "二维动态规划数组实现（版本一）"
    },
    {
      "language": "Python",
      "code": "class Solution: def findMaxForm(self, strs: List[str], m: int, n: int) -> int: dp = [[0] * (n + 1) for _ in range(m + 1)] for s in strs: ones = s.count('1') zeros = s.count('0') for i in range(m, zeros - 1, -1): for j in range(n, ones - 1, -1): dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1) return dp[m][n]",
      "description": "二维动态规划数组实现（版本二）"
    }
  ],
  "common_mistakes": [
    "错误地将此问题视为多重背包问题而不是01背包问题。",
    "初始化dp数组时不正确或遗漏。",
    "在遍历背包容量时未采用从后向前的方式，导致状态被覆盖。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210117171307407-20230310132423205.png",
      "description": "这张图片主要描述了背包问题的不同类型（01背包、完全背包、多重背包、分组背包）及其解题思路，重点关注算法分类和选择策略。",
      "context": "该图片展示了不同类型的背包问题关系，帮助理解为何本题属于01背包而非多重背包问题。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210120111201512.jpg",
      "description": "这张图片展示了使用动态规划（DP）算法解决特定问题的过程，其中 `dp[i][j]` 表示在给定输入和限制条件下的最优解。",
      "context": "该图片展示了以输入[\"10\",\"0001\",\"111001\",\"1\",\"0\"]，m=3，n=3为例推导出的dp数组最终状态。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210117171307407-20230310132423205.png",
      "description": "GIF展示了01背包问题中，随着不同长度字符串的加入，二维dp数组如何更新的过程。",
      "context": "该GIF动画展示了不同类型背包问题之间的关系，帮助理解为何此题应被归类为01背包而非多重背包问题。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210120111201512.jpg",
      "description": "GIF展示了动态规划数组dp在给定约束条件下随输入字符串处理而逐步更新的过程。",
      "context": "该GIF动画展示了给定示例中动态规划数组dp的最终状态，帮助理解算法如何通过填充dp表来找到满足条件的最大子集大小。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\一和零.txt",
  "extracted_at": "2025-07-20T11:56:57.594739",
  "raw_content": "一和零\n力扣题目链接(https://leetcode.cn/problems/ones-and-zeroes/)\n\n给你一个二进制字符串数组 strs 和两个整数 m 和 n 。\n\n请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。\n\n如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。\n\n示例 1：\n\n输入：strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3\n\n输出：4\n\n解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\"10\",\"0001\",\"1\",\"0\"} ，因此答案是 4 。 其他满足题意但较小的子集包括 {\"0001\",\"1\"} 和 {\"10\",\"1\",\"0\"} 。{\"111001\"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n\n示例 2：\n\n输入：strs = [\"10\", \"0\", \"1\"], m = 1, n = 1\n输出：2\n解释：最大的子集是 {\"0\", \"1\"} ，所以答案是 2 。\n提示：\n\n1 <= strs.length <= 600\n1 <= strs[i].length <= 100\nstrs[i] 仅由 '0' 和 '1' 组成\n1 <= m, n <= 100\n\n\n#思路\n如果对背包问题不都熟悉先看这两篇：\n\n动态规划：关于01背包问题，你该了解这些！(https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)\n动态规划：关于01背包问题，你该了解这些！（滚动数组）(https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)\n这道题目，还是比较难的，也有点像程序员自己给自己出个脑筋急转弯，程序员何苦为难程序员呢。\n\n来说题，本题不少同学会认为是多重背包，一些题解也是这么写的。\n\n其实本题并不是多重背包，再来看一下这个图，捋清几种背包的关系\n\nhttps://file1.kamacoder.com/i/algo/20210117171307407-20230310132423205.png\n\n多重背包是每个物品，数量不同的情况。\n\n本题中strs 数组里的元素就是物品，每个物品都是一个！\n\n而m 和 n相当于是一个背包，两个维度的背包。\n\n理解成多重背包的同学主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包。\n\n但本题其实是01背包问题！\n\n只不过这个背包有两个维度，一个是m 一个是n，而不同长度的字符串就是不同大小的待装物品。\n\n开始动规五部曲：\n\n确定dp数组（dp table）以及下标的含义\ndp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。\n\n确定递推公式\ndp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。\n\ndp[i][j] 就可以是 dp[i - zeroNum][j - oneNum] + 1。\n\n然后我们在遍历的过程中，取dp[i][j]的最大值。\n\n所以递推公式：dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);\n\n此时大家可以回想一下01背包的递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n\n对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。\n\n这就是一个典型的01背包！ 只不过物品的重量有了两个维度而已。\n\ndp数组如何初始化\n在动态规划：关于01背包问题，你该了解这些！（滚动数组） (https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)中已经讲解了，01背包的dp数组初始化为0就可以。\n\n因为物品价值不会是负数，初始为0，保证递推的时候dp[i][j]不会被初始值覆盖。\n\n确定遍历顺序\n在动态规划：关于01背包问题，你该了解这些！（滚动数组） (https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)中，我们讲到了01背包为什么一定是外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！\n\n那么本题也是，物品就是strs里的字符串，背包容量就是题目描述中的m和n。\n\n代码如下：\n\nfor (string str : strs) { // 遍历物品\n    int oneNum = 0, zeroNum = 0;\n    for (char c : str) {\n        if (c == '0') zeroNum++;\n        else oneNum++;\n    }\n    for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！\n        for (int j = n; j >= oneNum; j--) {\n            dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);\n        }\n    }\n}\n有同学可能想，那个遍历背包容量的两层for循环先后循序有没有什么讲究？\n\n没讲究，都是物品重量的一个维度，先遍历哪个都行！\n\n举例推导dp数组\n以输入：[\"10\",\"0001\",\"111001\",\"1\",\"0\"]，m = 3，n = 3为例\n\n最后dp数组的状态如下所示：\n\nhttps://file1.kamacoder.com/i/algo/20210120111201512.jpg\n\n以上动规五部曲分析完毕，C++代码如下：\n\nclass Solution {\npublic:\n    int findMaxForm(vector<string>& strs, int m, int n) {\n        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0\n        for (string str : strs) { // 遍历物品\n            int oneNum = 0, zeroNum = 0;\n            for (char c : str) {\n                if (c == '0') zeroNum++;\n                else oneNum++;\n            }\n            for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！\n                for (int j = n; j >= oneNum; j--) {\n                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n时间复杂度: O(kmn)，k 为strs的长度\n空间复杂度: O(mn)\nC++: 使用三维数组的版本\n\nclass Solution {\npublic:\n    int findMaxForm(vector<string>& strs, int m, int n) {\n        int num_of_str = strs.size();\n\n\t\tvector<vector<vector<int>>> dp(num_of_str, vector<vector<int>>(m + 1,vector<int>(n + 1, 0)));\n\n\t\t/* \tdp[i][j][k] represents, if choosing items among strs[0] to strs[i] to form a subset, \n\t\t\twhat is the maximum size of this subset such that there are no more than m 0's and n 1's in this subset. \n\t\t\tEach entry of dp[i][j][k] is initialized with 0\n\t\t\t\n\t\t\ttransition formula:\n\t\t\tusing x[i] to indicates the number of 0's in strs[i]\n\t\t\tusing y[i] to indicates the number of 1's in strs[i]\n\t\t\t\n\t\t\tdp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - x[i]][k - y[i]] + 1)\n\n\t\t*/\n\n\n\t\t// num_of_zeros records the number of 0's for each str\n\t\t// num_of_ones records the number of 1's for each str\n\t\t// find the number of 0's and the number of 1's for each str in strs\n\t\tvector<int> num_of_zeros;\n\t\tvector<int> num_of_ones;\n\t\tfor (auto& str : strs){\n\t\t\tint count_of_zero = 0;\n\t\t\tint count_of_one = 0;\n\t\t\tfor (char &c : str){\n\t\t\t\tif(c == '0') count_of_zero ++;\n\t\t\t\telse count_of_one ++;\n\t\t\t}\n\t\t\tnum_of_zeros.push_back(count_of_zero);\n\t\t\tnum_of_ones.push_back(count_of_one);\n\t\t\t\n\t\t}\n\n\t\t\n\t\t// num_of_zeros[0] indicates the number of 0's for str[0]\n\t\t// num_of_ones[0] indiates the number of 1's for str[1]\n\n\t\t// initialize the 1st plane of dp[i][j][k], i.e., dp[0][j][k]\n\t\t// if num_of_zeros[0] > m or num_of_ones[0] > n, no need to further initialize dp[0][j][k], \n\t\t// because they have been intialized to 0 previously\n\t\tif(num_of_zeros[0] <= m && num_of_ones[0] <= n){\n\t\t\t// for j < num_of_zeros[0] or k < num_of_ones[0], dp[0][j][k] = 0\n\t\t\tfor(int j = num_of_zeros[0]; j <= m; j++){\n\t\t\t\tfor(int k = num_of_ones[0]; k <= n; k++){\n\t\t\t\t\tdp[0][j][k] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\tif j - num_of_zeros[i] >= 0 and k - num_of_ones[i] >= 0:\n\t\t\t\tdp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - num_of_zeros[i]][k - num_of_ones[i]] + 1)  \n\t\t\telse:\n\t\t\t\tdp[i][j][k] = dp[i-1][j][k]\n\t\t*/\n\n\t\tfor (int i = 1; i < num_of_str; i++){\n\t\t\tint count_of_zeros = num_of_zeros[i];\n\t\t\tint count_of_ones = num_of_ones[i]; \n\t\t\tfor (int j = 0; j <= m; j++){\n\t\t\t\tfor (int k = 0; k <= n; k++){\n\t\t\t\t\tif( j < count_of_zeros || k < count_of_ones){\n\t\t\t\t\t\tdp[i][j][k] = dp[i-1][j][k];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j - count_of_zeros][k - count_of_ones] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\treturn dp[num_of_str-1][m][n];\n\n    }\n};\n#总结\n不少同学刷过这道题，可能没有总结这究竟是什么背包。\n\n此时我们讲解了0-1背包的多种应用，\n\n纯 0 - 1 背包 (https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)是求 给定背包容量 装满背包 的最大价值是多少。\n416. 分割等和子集 (https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html)是求 给定背包容量，能不能装满这个背包。\n1049. 最后一块石头的重量 II (https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html)是求 给定背包容量，尽可能装，最多能装多少\n494. 目标和 (https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)是求 给定背包容量，装满背包有多少种方法。\n本题是求 给定背包容量，装满背包最多有多少个物品。\n所以在代码随想录中所列举的题目，都是 0-1背包不同维度上的应用，大家可以细心体会！\n\n#其他语言版本\n#Java\n三维DP数组实现\n\nclass Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        /// 数组有三个维度\n        // 第一个维度：取前面的几个字符串\n        // 第二个维度：0的数量限制（背包维度 1 容量）\n        // 第三个维度：1的数量限制（背包维度 2 容量）\n        int[][][] dpArr = new int[strs.length][m + 1][n + 1];\n\n        /// 初始化dpArr数组\n        // 计算第一个字符串的零数量和1数量\n        int zeroNum = 0;\n        int oneNum = 0;\n        for (char c : strs[0].toCharArray()) {\n            if (c == '0') {\n                zeroNum++;\n            } else {\n                oneNum++;\n            }\n        }\n        // 当0数量、1数量都容得下第一个字符串时，将DP数组的相应位置初始化为1，因为当前的子集数量为1\n        for (int j = zeroNum; j <= m; j++) {\n            for (int k = oneNum; k <= n; k++) {\n                dpArr[0][j][k] = 1;\n            }\n        }\n        /// 依次填充加入第i个字符串之后的DP数组\n        for (int i = 1; i < strs.length; i++) {\n            zeroNum = 0;\n            oneNum = 0;\n            for (char c : strs[i].toCharArray()) {\n                if (c == '0') {\n                    zeroNum++;\n                } else {\n                    oneNum++;\n                }\n            }\n            for (int j = 0; j <= m; j++) {\n                for (int k = 0; k <= n; k++) {\n                    if (j >= zeroNum && k >= oneNum) {\n                        // --if-- 当0数量维度和1数量维度的容量都大于等于当前字符串的0数量和1数量时，才考虑是否将当前字符串放入背包\n                        // 不放入第i个字符串，子集数量仍为 dpArr[i - 1][j][k]\n                        // 放入第i个字符串，需要在0维度腾出 zeroNum 个容量，1维度腾出 oneNum 个容量，然后放入当前字符串，即 dpArr[i - 1][j - zeroNum][k - oneNum] + 1)\n                        dpArr[i][j][k] = Math.max(dpArr[i - 1][j][k], dpArr[i - 1][j - zeroNum][k - oneNum] + 1);\n                    } else {\n                        // --if--  无法放入第i个字符串，子集数量仍为 dpArr[i - 1][j][k]\n                        dpArr[i][j][k] = dpArr[i - 1][j][k];\n                    }\n                }\n            }\n        }\n        return dpArr[dpArr.length - 1][m][n];\n    }\n}\n二维DP数组实现\n\nclass Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        //dp[i][j]表示i个0和j个1时的最大子集\n        int[][] dp = new int[m + 1][n + 1];\n        int oneNum, zeroNum;\n        for (String str : strs) {\n            oneNum = 0;\n            zeroNum = 0;\n            for (char ch : str.toCharArray()) {\n                if (ch == '0') {\n                    zeroNum++;\n                } else {\n                    oneNum++;\n                }\n            }\n            //倒序遍历\n            for (int i = m; i >= zeroNum; i--) {\n                for (int j = n; j >= oneNum; j--) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n#Python\nDP（版本一）\n\nclass Solution:\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        dp = [[0] * (n + 1) for _ in range(m + 1)]  # 创建二维动态规划数组，初始化为0\n        for s in strs:  # 遍历物品\n            zeroNum = s.count('0')  # 统计0的个数\n            oneNum = len(s) - zeroNum  # 统计1的个数\n            for i in range(m, zeroNum - 1, -1):  # 遍历背包容量且从后向前遍历\n                for j in range(n, oneNum - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)  # 状态转移方程\n        return dp[m][n]\n\nDP（版本二）\n\nclass Solution:\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        dp = [[0] * (n + 1) for _ in range(m + 1)]  # 创建二维动态规划数组，初始化为0\n        # 遍历物品\n        for s in strs:\n            ones = s.count('1')  # 统计字符串中1的个数\n            zeros = s.count('0')  # 统计字符串中0的个数\n            # 遍历背包容量且从后向前遍历\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)  # 状态转移方程\n        return dp[m][n]"
}