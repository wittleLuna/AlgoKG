{
  "id": "AP_71e51601",
  "title": "最后一块石头的重量II",
  "alternative_titles": [],
  "platform": "leetcode",
  "url": "https://leetcode.cn/problems/last-stone-weight-ii/",
  "description": "题目难度：中等\n\n有一堆石头，每块石头的重量都是正整数。\n\n每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：\n\n如果 x == y，那么两块石头都会被完全粉碎；\n\n如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。\n\n最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "动态规划",
    "背包问题"
  ],
  "data_structure_tags": [
    "数组"
  ],
  "technique_tags": [
    "递归公式",
    "状态转移",
    "一维DP数组"
  ],
  "difficulty": null,
  "solution_approach": "通过将问题转化为01背包问题来解决，目标是找到总重量一半的子集，使得两组石头碰撞后剩余的最小重量。使用动态规划的方法确定能装入最大容量为sum/2背包的最大价值（重量），从而得到最优解。",
  "key_insights": [
    {
      "content": "把寻找最后一块石头最小重量的问题转化成了一个01背包问题，目的是尽可能地将石头分成两个重量相等或接近的集合。"
    },
    {
      "content": "利用动态规划计算出给定目标重量下可以达到的最大重量，这实际上是求解如何从一堆物品中选择一些放入固定容量的背包里以使总价值最大。在这个场景下，物品的价值等于其重量。"
    },
    {
      "content": "通过对dp数组的初始化和更新，能够有效地追踪在不同容量下的最大可装载重量，最终帮助我们找到最接近总重量一半的子集。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "思路",
      "text": "如果对背包问题不熟悉的话先看这两篇：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lastStoneWeightII(vector<int>& stones) {vector<int> dp(15001, 0);int sum = 0;for (int i = 0; i < stones.size(); i++) sum += stones[i];int target = sum / 2;for (int i = 0; i < stones.size(); i++) { for (int j = target; j >= stones[i]; j--) { dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - dp[target] - dp[target];}};",
          "description": "C++解法，使用一维数组实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int i : stones) {sum += i;}int target = sum >> 1;int[] dp = new int[target + 1];for (int i = 0; i < stones.length; i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - 2 * dp[target];}}",
          "description": "Java解法，使用一维数组实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int s : stones) {sum += s;}int target = sum / 2;int[][] dp = new int[stones.length][target + 1];for (int j = stones[0]; j <= target; j++) {dp[0][j] = stones[0];}for (int i = 1; i < stones.length; i++) {for (int j = 1; j <= target; j++) {if (j >= stones[i]) {dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);} else {dp[i][j] = dp[i - 1][j];}}}System.out.println(dp[stones.length - 1][target]);return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target];}}",
          "description": "Java解法，使用二维数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: dp = [0] * 15001 total_sum = sum(stones) target = total_sum // 2 for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - dp[target] - dp[target]",
          "description": "Python解法，使用一维数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [0] * (target + 1) for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - 2* dp[-1]",
          "description": "Python简化版，使用一维数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: total_sum = sum(stones) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(len(stones) + 1)] for i in range(len(stones) + 1): dp[i][0] = True for i in range(1, len(stones) + 1): for j in range(1, target + 1): if stones[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]] for i in range(target, -1, -1): if dp[len(stones)][i]: return total_sum - 2 * i return 0",
          "description": "Python解法，使用二维数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for stone in stones: for j in range(target, stone - 1, -1): dp[j] = dp[j] or dp[j - stone] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i return 0",
          "description": "Python简化版，使用一维数组实现"
        }
      ],
      "subsections": []
    },
    {
      "name": "1. 确定dp数组以及下标的含义",
      "text": "dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lastStoneWeightII(vector<int>& stones) {vector<int> dp(15001, 0);int sum = 0;for (int i = 0; i < stones.size(); i++) sum += stones[i];int target = sum / 2;for (int i = 0; i < stones.size(); i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - dp[target] - dp[target];}};",
          "description": "C++版本"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int i : stones) {sum += i;}int target = sum >> 1;int[] dp = new int[target + 1];for (int i = 0; i < stones.length; i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - 2 * dp[target];}}",
          "description": "Java一维数组版本"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int s : stones) {sum += s;}int target = sum / 2;int[][] dp = new int[stones.length][target + 1];for (int j = stones[0]; j <= target; j++) {dp[0][j] = stones[0];}for (int i = 1; i < stones.length; i++) {for (int j = 1; j <= target; j++) {if (j >= stones[i]) {dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);} else {dp[i][j] = dp[i - 1][j];}}}System.out.println(dp[stones.length - 1][target]);return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target];}}",
          "description": "Java二维数组版本"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: dp = [0] * 15001 total_sum = sum(stones) target = total_sum // 2 for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - dp[target] - dp[target]",
          "description": "Python卡哥版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [0] * (target + 1) for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - 2* dp[-1]",
          "description": "Python卡哥简化版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: total_sum = sum(stones) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(len(stones) + 1)] for i in range(len(stones) + 1): dp[i][0] = True for i in range(1, len(stones) + 1): for j in range(1, target + 1): if stones[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]] for i in range(target, -1, -1): if dp[len(stones)][i]: return total_sum - 2 * i return 0",
          "description": "Python二维DP版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for stone in stones: for j in range(target, stone - 1, -1): dp[j] = dp[j] or dp[j - stone] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i return 0",
          "description": "Python一维DP版"
        }
      ],
      "subsections": []
    },
    {
      "name": "2. 确定递推公式",
      "text": "01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lastStoneWeightII(vector<int>& stones) {vector<int> dp(15001, 0);int sum = 0;for (int i = 0; i < stones.size(); i++) sum += stones[i];int target = sum / 2;for (int i = 0; i < stones.size(); i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - dp[target] - dp[target];}};",
          "description": "C++实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int i : stones) {sum += i;}int target = sum >> 1;int[] dp = new int[target + 1];for (int i = 0; i < stones.length; i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - 2 * dp[target];}}",
          "description": "Java一维数组实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int s : stones) {sum += s;}int target = sum / 2;int[][] dp = new int[stones.length][target + 1];for (int j = stones[0]; j <= target; j++) {dp[0][j] = stones[0];}for (int i = 1; i < stones.length; i++) {for (int j = 1; j <= target; j++) {if (j >= stones[i]) {dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);} else {dp[i][j] = dp[i - 1][j];}}}return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target];}}",
          "description": "Java二维数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: dp = [0] * 15001 total_sum = sum(stones) target = total_sum // 2 for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - dp[target] - dp[target]",
          "description": "Python卡哥版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [0] * (target + 1) for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - 2* dp[-1]",
          "description": "Python卡哥简化版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: total_sum = sum(stones) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(len(stones) + 1)] for i in range(len(stones) + 1): dp[i][0] = True for i in range(1, len(stones) + 1): for j in range(1, target + 1): if stones[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]] for i in range(target, -1, -1): if dp[len(stones)][i]: return total_sum - 2 * i return 0",
          "description": "Python二维DP版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for stone in stones: for j in range(target, stone - 1, -1): dp[j] = dp[j] or dp[j - stone] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i return 0",
          "description": "Python一维DP版"
        }
      ],
      "subsections": []
    },
    {
      "name": "3. dp数组如何初始化",
      "text": "既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lastStoneWeightII(vector<int>& stones) {vector<int> dp(15001, 0);int sum = 0;for (int i = 0; i < stones.size(); i++) sum += stones[i];int target = sum / 2;for (int i = 0; i < stones.size(); i++) { for (int j = target; j >= stones[i]; j--) { dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); }}return sum - dp[target] - dp[target];}};",
          "description": "C++实现"
        },
        {
          "language": "java",
          "code": "class Solution { public int lastStoneWeightII(int[] stones) { int sum = 0; for (int i : stones) { sum += i; } int target = sum >> 1; int[] dp = new int[target + 1]; for (int i = 0; i < stones.length; i++) { for (int j = target; j >= stones[i]; j--) { dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]); } } return sum - 2 * dp[target]; }}",
          "description": "Java一维数组版本"
        },
        {
          "language": "java",
          "code": "class Solution { public int lastStoneWeightII(int[] stones) { int sum = 0; for (int s : stones) { sum += s; } int target = sum / 2; int[][] dp = new int[stones.length][target + 1]; for (int j = stones[0]; j <= target; j++) { dp[0][j] = stones[0]; } for (int i = 1; i < stones.length; i++) { for (int j = 1; j <= target; j++) { if (j >= stones[i]) { dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]); } else { dp[i][j] = dp[i - 1][j]; } } } return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target]; }}",
          "description": "Java二维数组版本"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: dp = [0] * 15001 total_sum = sum(stones) target = total_sum // 2 for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - dp[target] - dp[target]",
          "description": "Python卡哥版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [0] * (target + 1) for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - 2* dp[-1]",
          "description": "Python卡哥简化版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: total_sum = sum(stones) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(len(stones) + 1)] for i in range(len(stones) + 1): dp[i][0] = True for i in range(1, len(stones) + 1): for j in range(1, target + 1): if stones[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]] for i in range(target, -1, -1): if dp[len(stones)][i]: return total_sum - 2 * i return 0",
          "description": "Python二维DP版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for stone in stones: for j in range(target, stone - 1, -1): dp[j] = dp[j] or dp[j - stone] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i return 0",
          "description": "Python一维DP版"
        }
      ],
      "subsections": []
    },
    {
      "name": "4. 确定遍历顺序",
      "text": "在动态规划：关于01背包问题，你该了解这些！（滚动数组） (https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！",
      "resources": [],
      "code_snippets": [
        {
          "language": "C++",
          "code": "class Solution {public: int lastStoneWeightII(vector<int>& stones) {vector<int> dp(15001, 0);int sum = 0;for (int i = 0; i < stones.size(); i++) sum += stones[i];int target = sum / 2;for (int i = 0; i < stones.size(); i++) { for (int j = target; j >= stones[i]; j--) {dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - dp[target] - dp[target];}};",
          "description": "使用一维数组实现背包问题"
        },
        {
          "language": "Java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int i : stones) {sum += i;}int target = sum >> 1;int[] dp = new int[target + 1];for (int i = 0; i < stones.length; i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - 2 * dp[target];}}",
          "description": "使用一维数组实现背包问题"
        },
        {
          "language": "Java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int s : stones) {sum += s;}int target = sum / 2;int[][] dp = new int[stones.length][target + 1];for (int j = stones[0]; j <= target; j++) {dp[0][j] = stones[0];}for (int i = 1; i < stones.length; i++) {for (int j = 1; j <= target; j++) {if (j >= stones[i]) {dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);} else {dp[i][j] = dp[i - 1][j];}}}System.out.println(dp[stones.length - 1][target]);return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target];}}",
          "description": "使用二维数组实现背包问题"
        },
        {
          "language": "Python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: dp = [0] * 15001 total_sum = sum(stones) target = total_sum // 2 for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - dp[target] - dp[target]",
          "description": "使用一维数组实现背包问题"
        },
        {
          "language": "Python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [0] * (target + 1) for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - 2* dp[-1]",
          "description": "简化版，使用一维数组实现背包问题"
        },
        {
          "language": "Python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: total_sum = sum(stones) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(len(stones) + 1)] for i in range(len(stones) + 1): dp[i][0] = True for i in range(1, len(stones) + 1): for j in range(1, target + 1): if stones[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]] for i in range(target, -1, -1): if dp[len(stones)][i]: return total_sum - 2 * i return 0",
          "description": "使用二维数组实现背包问题"
        },
        {
          "language": "Python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for stone in stones: for j in range(target, stone - 1, -1): dp[j] = dp[j] or dp[j - stone] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i return 0",
          "description": "简化版，使用一维数组实现背包问题"
        }
      ],
      "subsections": []
    },
    {
      "name": "5. 举例推导dp数组",
      "text": "举例，输入：[2,4,1,1]，此时target = (2 + 4 + 1 + 1)/2 = 4 ，dp数组状态图如下：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lastStoneWeightII(vector<int>& stones) {vector<int> dp(15001, 0);int sum = 0;for (int i = 0; i < stones.size(); i++) sum += stones[i];int target = sum / 2;for (int i = 0; i < stones.size(); i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - dp[target] - dp[target];}};",
          "description": "C++实现，使用一维数组动态规划解决最后石头重量问题。"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int i : stones) {sum += i;}int target = sum >> 1;int[] dp = new int[target + 1];for (int i = 0; i < stones.length; i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - 2 * dp[target];}}",
          "description": "Java实现，使用一维数组动态规划解决最后石头重量问题。"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int s : stones) {sum += s;}int target = sum / 2;int[][] dp = new int[stones.length][target + 1];for (int j = stones[0]; j <= target; j++) {dp[0][j] = stones[0];}for (int i = 1; i < stones.length; i++) {for (int j = 1; j <= target; j++) {if (j >= stones[i]) {dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);} else {dp[i][j] = dp[i - 1][j];}}}System.out.println(dp[stones.length - 1][target]);return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target];}}",
          "description": "Java实现，使用二维数组动态规划解决最后石头重量问题。"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: dp = [0] * 15001 total_sum = sum(stones) target = total_sum // 2 for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - dp[target] - dp[target]",
          "description": "Python实现，基于一维数组的动态规划解决最后石头重量问题。"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [0] * (target + 1) for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - 2* dp[-1]",
          "description": "Python简化版实现，基于一维数组的动态规划解决最后石头重量问题。"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: total_sum = sum(stones) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(len(stones) + 1)] for i in range(len(stones) + 1): dp[i][0] = True for i in range(1, len(stones) + 1): for j in range(1, target + 1): if stones[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]] for i in range(target, -1, -1): if dp[len(stones)][i]: return total_sum - 2 * i return 0",
          "description": "Python实现，基于二维数组的动态规划解决最后石头重量问题。"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for stone in stones: for j in range(target, stone - 1, -1): dp[j] = dp[j] or dp[j - stone] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i return 0",
          "description": "Python一维DP实现，解决最后石头重量问题。"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "本题其实和416. 分割等和子集 (https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html)几乎是一样的，只是最后对dp[target]的处理方式不同。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lastStoneWeightII(vector<int>& stones) {vector<int> dp(15001, 0);int sum = 0;for (int i = 0; i < stones.size(); i++) sum += stones[i];int target = sum / 2;for (int i = 0; i < stones.size(); i++) { for (int j = target; j >= stones[i]; j--) {dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - dp[target] - dp[target];}};",
          "description": "C++解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int i : stones) {sum += i;}int target = sum >> 1;int[] dp = new int[target + 1];for (int i = 0; i < stones.length; i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - 2 * dp[target];}}",
          "description": "Java一维数组版本"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int s : stones) {sum += s;}int target = sum / 2;int[][] dp = new int[stones.length][target + 1];for (int j = stones[0]; j <= target; j++) {dp[0][j] = stones[0];}for (int i = 1; i < stones.length; i++) {for (int j = 1; j <= target; j++) {if (j >= stones[i]) {dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);} else {dp[i][j] = dp[i - 1][j];}}}System.out.println(dp[stones.length - 1][target]);return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target];}}",
          "description": "Java二维数组版本"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: dp = [0] * 15001 total_sum = sum(stones) target = total_sum // 2 for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - dp[target] - dp[target]",
          "description": "Python卡哥版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [0] * (target + 1) for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - 2* dp[-1]",
          "description": "Python卡哥简化版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: total_sum = sum(stones) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(len(stones) + 1)] for i in range(len(stones) + 1): dp[i][0] = True for i in range(1, len(stones) + 1): for j in range(1, target + 1): if stones[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]] for i in range(target, -1, -1): if dp[len(stones)][i]: return total_sum - 2 * i return 0",
          "description": "Python二维DP版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for stone in stones: for j in range(target, stone - 1, -1): dp[j] = dp[j] or dp[j - stone] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i return 0",
          "description": "Python一维DP版"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "java",
          "code": "class Solution { public int lastStoneWeightII(int[] stones) { int sum = 0; for (int i : stones) { sum += i; } int target = sum >> 1; //初始化dp数组 int[] dp = new int[target + 1]; for (int i = 0; i < stones.length; i++) { //采用倒序 for (int j = target; j >= stones[i]; j--) { //两种情况，要么放，要么不放 dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]); } } return sum - 2 * dp[target]; } }",
          "description": "Java一维数组版本"
        },
        {
          "language": "java",
          "code": "class Solution { public int lastStoneWeightII(int[] stones) { int sum = 0; for (int s : stones) { sum += s; } int target = sum / 2; //初始化，dp[i][j]为可以放0-i物品，背包容量为j的情况下背包中的最大价值 int[][] dp = new int[stones.length][target + 1]; //dp[i][0]默认初始化为0 //dp[0][j]取决于stones[0] for (int j = stones[0]; j <= target; j++) { dp[0][j] = stones[0]; } for (int i = 1; i < stones.length; i++) { for (int j = 1; j <= target; j++) { if (j >= stones[i]) { dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]); } else { dp[i][j] = dp[i - 1][j]; } } } System.out.println(dp[stones.length - 1][target]); return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target]; } }",
          "description": "Java二维数组版本"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: dp = [0] * 15001 total_sum = sum(stones) target = total_sum // 2 for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - dp[target] - dp[target]",
          "description": "Python卡哥版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [0] * (target + 1) for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - 2* dp[-1]",
          "description": "Python卡哥简化版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: total_sum = sum(stones) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(len(stones) + 1)] for i in range(len(stones) + 1): dp[i][0] = True for i in range(1, len(stones) + 1): for j in range(1, target + 1): if stones[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]] for i in range(target, -1, -1): if dp[len(stones)][i]: return total_sum - 2 * i return 0",
          "description": "Python二维DP版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for stone in stones: for j in range(target, stone - 1, -1): dp[j] = dp[j] or dp[j - stone] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i return 0",
          "description": "Python一维DP版"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "一维数组版本",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lastStoneWeightII(vector<int>& stones) {vector<int> dp(15001, 0);int sum = 0;for (int i = 0; i < stones.size(); i++) sum += stones[i];int target = sum / 2;for (int i = 0; i < stones.size(); i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - dp[target] - dp[target];}};",
          "description": "C++实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int i : stones) {sum += i;}int target = sum >> 1;int[] dp = new int[target + 1];for (int i = 0; i < stones.length; i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - 2 * dp[target];}}",
          "description": "Java一维数组实现"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int s : stones) {sum += s;}int target = sum / 2;int[][] dp = new int[stones.length][target + 1];for (int j = stones[0]; j <= target; j++) {dp[0][j] = stones[0];}for (int i = 1; i < stones.length; i++) {for (int j = 1; j <= target; j++) {if (j >= stones[i]) {dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);} else {dp[i][j] = dp[i - 1][j];}}}return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target];}}",
          "description": "Java二维数组实现"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: dp = [0] * 15001 total_sum = sum(stones) target = total_sum // 2 for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - dp[target] - dp[target]",
          "description": "Python卡哥版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [0] * (target + 1) for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - 2* dp[-1]",
          "description": "Python简化版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: total_sum = sum(stones) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(len(stones) + 1)] for i in range(len(stones) + 1): dp[i][0] = True for i in range(1, len(stones) + 1): for j in range(1, target + 1): if stones[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]] for i in range(target, -1, -1): if dp[len(stones)][i]: return total_sum - 2 * i return 0",
          "description": "Python二维DP版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for stone in stones: for j in range(target, stone - 1, -1): dp[j] = dp[j] or dp[j - stone] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i return 0",
          "description": "Python一维DP版"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "卡哥版",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: int lastStoneWeightII(vector<int>& stones) {vector<int> dp(15001, 0);int sum = 0;for (int i = 0; i < stones.size(); i++) sum += stones[i];int target = sum / 2;for (int i = 0; i < stones.size(); i++) { for (int j = target; j >= stones[i]; j--) { dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - dp[target] - dp[target];}};",
          "description": "C++实现的解决方案"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int i : stones) {sum += i;}int target = sum >> 1;int[] dp = new int[target + 1];for (int i = 0; i < stones.length; i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - 2 * dp[target];}}",
          "description": "Java实现的一维数组版本"
        },
        {
          "language": "java",
          "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int s : stones) {sum += s;}int target = sum / 2;int[][] dp = new int[stones.length][target + 1];for (int j = stones[0]; j <= target; j++) {dp[0][j] = stones[0];}for (int i = 1; i < stones.length; i++) {for (int j = 1; j <= target; j++) {if (j >= stones[i]) {dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);} else {dp[i][j] = dp[i - 1][j];}}}return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target];}}",
          "description": "Java实现的二维数组版本"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: dp = [0] * 15001 total_sum = sum(stones) target = total_sum // 2 for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - dp[target] - dp[target]",
          "description": "Python实现的卡哥版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [0] * (target + 1) for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - 2* dp[-1]",
          "description": "Python实现的简化版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: total_sum = sum(stones) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(len(stones) + 1)] for i in range(len(stones) + 1): dp[i][0] = True for i in range(1, len(stones) + 1): for j in range(1, target + 1): if stones[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]] for i in range(target, -1, -1): if dp[len(stones)][i]: return total_sum - 2 * i return 0",
          "description": "Python实现的二维DP版"
        },
        {
          "language": "python",
          "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for stone in stones: for j in range(target, stone - 1, -1): dp[j] = dp[j] or dp[j - stone] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i return 0",
          "description": "Python实现的一维DP版"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": {
    "time_complexity": "O(m × n)",
    "space_complexity": "O(m)",
    "explanation": "m是石头总重量（准确的说是总重量的一半），n为石头块数"
  },
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: int lastStoneWeightII(vector<int>& stones) {vector<int> dp(15001, 0);int sum = 0;for (int i = 0; i < stones.size(); i++) sum += stones[i];int target = sum / 2;for (int i = 0; i < stones.size(); i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - dp[target] - dp[target];}};",
      "description": "C++实现的解决方案"
    },
    {
      "language": "java",
      "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int i : stones) {sum += i;}int target = sum >> 1;int[] dp = new int[target + 1];for (int i = 0; i < stones.length; i++) {for (int j = target; j >= stones[i]; j--) {dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);}}return sum - 2 * dp[target];}}",
      "description": "Java实现的一维数组版本解决方案"
    },
    {
      "language": "java",
      "code": "class Solution {public int lastStoneWeightII(int[] stones) {int sum = 0;for (int s : stones) {sum += s;}int target = sum / 2;int[][] dp = new int[stones.length][target + 1];for (int j = stones[0]; j <= target; j++) {dp[0][j] = stones[0];}for (int i = 1; i < stones.length; i++) {for (int j = 1; j <= target; j++) {if (j >= stones[i]) {dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);} else {dp[i][j] = dp[i - 1][j];}}}return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target];}}",
      "description": "Java实现的二维数组版本解决方案"
    },
    {
      "language": "python",
      "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: dp = [0] * 15001 total_sum = sum(stones) target = total_sum // 2 for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - dp[target] - dp[target]",
      "description": "Python实现的卡哥版解决方案"
    },
    {
      "language": "python",
      "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [0] * (target + 1) for stone in stones: for j in range(target, stone - 1, -1): dp[j] = max(dp[j], dp[j - stone] + stone) return total_sum - 2* dp[-1]",
      "description": "Python实现的简化版解决方案"
    },
    {
      "language": "python",
      "code": "class Solution: def lastStoneWeightII(self, stones: List[int]) -> int: total_sum = sum(stones) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(len(stones) + 1)] for i in range(len(stones) + 1): dp[i][0] = True for i in range(1, len(stones) + 1): for j in range(1, target + 1): if stones[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]] for i in range(target, -1, -1): if dp[len(stones)][i]: return total_sum - 2 * i return 0",
      "description": "Python实现的二维DP版解决方案"
    },
    {
      "language": "python",
      "code": "class Solution: def lastStoneWeightII(self, stones): total_sum = sum(stones) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for stone in stones: for j in range(target, stone - 1, -1): dp[j] = dp[j] or dp[j - stone] for i in range(target, -1, -1): if dp[i]: return total_sum - 2 * i return 0",
      "description": "Python实现的一维DP版解决方案"
    }
  ],
  "common_mistakes": [
    "忽略了背包容量需要初始化为总重量的一半。",
    "在遍历物品与背包时没有正确设置循环顺序，导致结果不正确。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/20210121115805904.jpg",
      "description": "这张图片展示了使用动态规划算法解决背包问题的过程，通过逐步更新状态数组来找到达到目标值的组合。",
      "context": "该图片展示了当输入数组为[2,4,1,1]时，根据给定算法推导出的dp数组状态变化过程，帮助理解如何通过动态规划方法找到背包能装载的最大石头重量。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/20210121115805904.jpg",
      "description": "GIF展示了通过动态规划方法填充背包过程中dp数组的变化情况。",
      "context": "GIF动画展示了给定石头数组[2,4,1,1]时，动态规划dp数组如何随着算法执行而逐步更新的过程，直至找到容量为target的背包能够装载的最大重量。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\动态规划\\最后一块石头的重量II.txt",
  "extracted_at": "2025-07-20T20:42:48.491839",
  "raw_content": "最后一块石头的重量II\n力扣题目链接(https://leetcode.cn/problems/last-stone-weight-ii/)\n\n题目难度：中等\n\n有一堆石头，每块石头的重量都是正整数。\n\n每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：\n\n如果 x == y，那么两块石头都会被完全粉碎；\n\n如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。\n\n最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。\n\n示例：\n\n输入：[2,7,4,1,8,1]\n输出：1\n解释：\n\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n提示：\n\n1 <= stones.length <= 30\n1 <= stones[i] <= 1000\n\n#思路\n如果对背包问题不熟悉的话先看这两篇：\n\n01背包理论基础（二维数组）(https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)\n01背包理论基础（一维数组）(https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)\n本题其实是尽量让石头分成重量相同的两堆（尽可能相同），相撞之后剩下的石头就是最小的。\n\n一堆的石头重量是sum，那么我们就尽可能拼成 重量为 sum / 2 的石头堆。 这样剩下的石头堆也是 尽可能接近 sum/2 的重量。 那么此时问题就是有一堆石头，每个石头都有自己的重量，是否可以 装满 最大重量为 sum / 2的背包。\n\n看到这里，大家是否感觉和昨天讲解的 416. 分割等和子集 (https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html)非常像了，简直就是同一道题。\n\n本题这样就化解成01背包问题了。\n\n416. 分割等和子集 (https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html)是求背包是否正好装满，而本题是求背包最多能装多少。\n\n物品就是石头，物品的重量为stones[i]，物品的价值也为stones[i]。\n\n接下来进行动规五步曲：\n\n#1. 确定dp数组以及下标的含义\ndp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]。\n\n相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] 。\n\n“最多可以装的价值为 dp[j]” 等同于 “最多可以背的重量为dp[j]”\n\n#2. 确定递推公式\n01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n\n本题则是：dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);\n\n#3. dp数组如何初始化\n既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。\n\n因为提示中给出1 <= stones.length <= 30，1 <= stones[i] <= 1000，所以最大重量就是30 * 1000 。\n\n而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。\n\n当然也可以把石头遍历一遍，计算出石头总重量 然后除2，得到dp数组的大小。\n\n我这里就直接用15000了。\n\n接下来就是如何初始化dp[j]呢，因为重量都不会是负数，所以dp[j]都初始化为0就可以了，这样在递归公式dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);中dp[j]才不会初始值所覆盖。\n\n代码为：\n\nvector<int> dp(15001, 0);\n#4. 确定遍历顺序\n在动态规划：关于01背包问题，你该了解这些！（滚动数组） (https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！\n\n代码如下：\n\nfor (int i = 0; i < stones.size(); i++) { // 遍历物品\n    for (int j = target; j >= stones[i]; j--) { // 遍历背包\n        dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);\n    }\n}\n\n#5. 举例推导dp数组\n举例，输入：[2,4,1,1]，此时target = (2 + 4 + 1 + 1)/2 = 4 ，dp数组状态图如下：\n\nhttps://file1.kamacoder.com/i/algo/20210121115805904.jpg\n\n最后dp[target]里是容量为target的背包所能背的最大重量。\n\n那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。\n\n在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的。\n\n那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。\n\n以上分析完毕，C++代码如下：\n\nclass Solution {\npublic:\n    int lastStoneWeightII(vector<int>& stones) {\n        vector<int> dp(15001, 0);\n        int sum = 0;\n        for (int i = 0; i < stones.size(); i++) sum += stones[i];\n        int target = sum / 2;\n        for (int i = 0; i < stones.size(); i++) { // 遍历物品\n            for (int j = target; j >= stones[i]; j--) { // 遍历背包\n                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);\n            }\n        }\n        return sum - dp[target] - dp[target];\n    }\n};\n\n时间复杂度：O(m × n) , m是石头总重量（准确的说是总重量的一半），n为石头块数\n空间复杂度：O(m)\n#总结\n本题其实和416. 分割等和子集 (https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html)几乎是一样的，只是最后对dp[target]的处理方式不同。\n\n416. 分割等和子集 (https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html)相当于是求背包是否正好装满，而本题是求背包最多能装多少。\n\n#其他语言版本\n#Java：\n一维数组版本\n\nclass Solution {\n    public int lastStoneWeightII(int[] stones) {\n        int sum = 0;\n        for (int i : stones) {\n            sum += i;\n        }\n        int target = sum >> 1;\n        //初始化dp数组\n        int[] dp = new int[target + 1];\n        for (int i = 0; i < stones.length; i++) {\n            //采用倒序\n            for (int j = target; j >= stones[i]; j--) {\n                //两种情况，要么放，要么不放\n                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);\n            }\n        }\n        return sum - 2 * dp[target];\n    }\n}\n二维数组版本（便于理解）\n\nclass Solution {\n    public int lastStoneWeightII(int[] stones) {\n        int sum = 0;\n        for (int s : stones) {\n            sum += s;\n        }\n\n        int target = sum / 2;\n        //初始化，dp[i][j]为可以放0-i物品，背包容量为j的情况下背包中的最大价值\n        int[][] dp = new int[stones.length][target + 1];\n        //dp[i][0]默认初始化为0\n        //dp[0][j]取决于stones[0]\n        for (int j = stones[0]; j <= target; j++) {\n            dp[0][j] = stones[0];\n        }\n\n        for (int i = 1; i < stones.length; i++) {\n            for (int j = 1; j <= target; j++) {//注意是等于\n                if (j >= stones[i]) {\n                    //不放:dp[i - 1][j] 放:dp[i - 1][j - stones[i]] + stones[i]\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n\n        System.out.println(dp[stones.length - 1][target]);\n        return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target];\n    }\n}\n\n#Python：\n卡哥版\n\nclass Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        dp = [0] * 15001\n        total_sum = sum(stones)\n        target = total_sum // 2\n\n        for stone in stones:  # 遍历物品\n            for j in range(target, stone - 1, -1):  # 遍历背包\n                dp[j] = max(dp[j], dp[j - stone] + stone)\n\n        return total_sum - dp[target] - dp[target]\n\n卡哥版（简化版）\n\nclass Solution:\n    def lastStoneWeightII(self, stones):\n        total_sum = sum(stones)\n        target = total_sum // 2\n        dp = [0] * (target + 1)\n        for stone in stones:\n            for j in range(target, stone - 1, -1):\n                dp[j] = max(dp[j], dp[j - stone] + stone)\n        return total_sum - 2* dp[-1]\n\n\n二维DP版\n\nclass Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        total_sum = sum(stones)\n        target = total_sum // 2\n        \n        # 创建二维dp数组，行数为石头的数量加1，列数为target加1\n        # dp[i][j]表示前i个石头能否组成总重量为j\n        dp = [[False] * (target + 1) for _ in range(len(stones) + 1)]\n        \n        # 初始化第一列，表示总重量为0时，前i个石头都能组成\n        for i in range(len(stones) + 1):\n            dp[i][0] = True\n        \n        for i in range(1, len(stones) + 1):\n            for j in range(1, target + 1):\n                # 如果当前石头重量大于当前目标重量j，则无法选择该石头\n                if stones[i - 1] > j:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    # 可选择该石头或不选择该石头\n                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - stones[i - 1]]\n        \n        # 找到最大的重量i，使得dp[len(stones)][i]为True\n        # 返回总重量减去两倍的最接近总重量一半的重量\n        for i in range(target, -1, -1):\n            if dp[len(stones)][i]:\n                return total_sum - 2 * i\n        \n        return 0\n\n\n一维DP版\n\nclass Solution:\n    def lastStoneWeightII(self, stones):\n        total_sum = sum(stones)\n        target = total_sum // 2\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for stone in stones:\n            for j in range(target, stone - 1, -1):\n                # 判断当前重量是否可以通过选择之前的石头得到或选择当前石头和之前的石头得到\n                dp[j] = dp[j] or dp[j - stone]\n\n        for i in range(target, -1, -1):\n            if dp[i]:\n                # 返回剩余石头的重量，即总重量减去两倍的最接近总重量一半的重量\n                return total_sum - 2 * i\n\n        return 0"
}