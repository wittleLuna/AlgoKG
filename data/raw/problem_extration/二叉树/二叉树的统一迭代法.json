{
  "id": "AP_cc72ed74",
  "title": "二叉树的统一迭代法",
  "alternative_titles": [],
  "platform": "custom",
  "url": "https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html",
  "description": "",
  "examples": [],
  "constraints": [],
  "algorithm_tags": [
    "二叉树",
    "深度优先搜索"
  ],
  "data_structure_tags": [
    "栈"
  ],
  "technique_tags": [
    "迭代",
    "标记技术"
  ],
  "difficulty": null,
  "solution_approach": "通过使用栈和标记法（空指针标记或布尔值标记）实现二叉树遍历的统一迭代方法。这种方法允许在不改变基本框架的情况下灵活地调整遍历顺序。",
  "key_insights": [
    {
      "content": "为了区分访问节点（即需要进一步探索其子节点的节点）和处理节点（即需要将其值加入结果集的节点），我们为每个节点添加一个标记。这使得即使在相同的遍历过程中，也能清晰地区分何时应该访问节点、何时应该处理节点。"
    },
    {
      "content": "通过引入标记机制，可以创建一种既适用于前序、中序也适用于后序遍历的通用代码模板。只需要简单调整几个步骤的顺序即可轻松转换不同类型的遍历。"
    }
  ],
  "step_by_step_explanation": [
    {
      "name": "迭代法中序遍历",
      "text": "中序遍历（空指针标记法）代码如下：（详细注释）",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);st.push(node);st.push(NULL);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "中序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr) st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}if (node->right) st.push(make_pair(node->right, false));st.push(make_pair(node, true));if (node->left) st.push(make_pair(node->left, false));}return result;}};",
          "description": "中序遍历（boolean 标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> preorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);if (node->left) st.push(node->left);st.push(node);st.push(NULL);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "前序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();st.push(node);st.push(NULL);if (node->right) st.push(node->right);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "后序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr) st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}st.push(make_pair(node, true));if (node->right) st.push(make_pair(node->right, false));if (node->left) st.push(make_pair(node->left, false));}return result;}};",
          "description": "后序遍历（boolean 标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> preorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);st.push(node);st.push(null);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "前序遍历（空指针标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> inorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);st.push(node);st.push(null);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "中序遍历（空指针标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> postorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();st.push(node);st.push(null);if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "后序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def preorderTraversal(self, root: TreeNode) -> List[int]: result = [] st= [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: st.append(node.right) if node.left: st.append(node.left) st.append(node) st.append(None) else: node = st.pop() result.append(node.val) return result",
          "description": "前序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def inorderTraversal(self, root: TreeNode) -> List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: st.append(node.right) st.append(node) st.append(None) if node.left: st.append(node.left) else: node = st.pop() result.append(node.val) return result",
          "description": "中序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def postorderTraversal(self, root: TreeNode) -> List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: st.append(node) st.append(None) if node.right: st.append(node.right) if node.left: st.append(node.left) else: node = st.pop() result.append(node.val) return result",
          "description": "后序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: values = [] stack = [(root, False)] if root else [] while stack: node, visited = stack.pop() if visited: values.append(node.val) continue if node.right: stack.append((node.right, False)) stack.append((node, True)) if node.left: stack.append((node.left, False)) return values",
          "description": "中序遍历（boolean 标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]: values = [] stack = [(root, False)] if root else [] while stack: node, visited = stack.pop() if visited: values.append(node.val) continue stack.append((node, True)) if node.right: stack.append((node.right, False)) if node.left: stack.append((node.left, False)) return values",
          "description": "后序遍历（boolean 标记法）"
        }
      ],
      "subsections": []
    },
    {
      "name": "迭代法前序遍历",
      "text": "迭代法前序遍历代码如下： (注意此时我们和中序遍历相比仅仅改变了两行代码的顺序)",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);st.push(node);st.push(NULL);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "C++ 中序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}if (node->right)st.push(make_pair(node->right, false));st.push(make_pair(node, true));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
          "description": "C++ 中序遍历（boolean 标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> preorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);if (node->left) st.push(node->left);st.push(node);st.push(NULL);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "C++ 前序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();st.push(node);st.push(NULL);if (node->right) st.push(node->right);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "C++ 后序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}st.push(make_pair(node, true));if (node->right)st.push(make_pair(node->right, false));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
          "description": "C++ 后序遍历（boolean 标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> preorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);st.push(node);st.push(null);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "Java 前序遍历（空指针标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> inorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);st.push(node);st.push(null);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "Java 中序遍历（空指针标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> postorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();st.push(node);st.push(null);if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "Java 后序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def preorderTraversal(self, root: TreeNode) -> List[int]: result = [] st= [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: st.append(node.right) if node.left: st.append(node.left) st.append(node) st.append(None) else: node = st.pop() result.append(node.val) return result",
          "description": "Python 前序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def inorderTraversal(self, root: TreeNode) -> List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: st.append(node.right) st.append(node) st.append(None) if node.left: st.append(node.left) else: node = st.pop() result.append(node.val) return result",
          "description": "Python 中序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def postorderTraversal(self, root: TreeNode) -> List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: st.append(node) st.append(None) if node.right: st.append(node.right) if node.left: st.append(node.left) else: node = st.pop() result.append(node.val) return result",
          "description": "Python 后序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: values = [] stack = [(root, False)] if root else [] while stack: node, visited = stack.pop() if visited: values.append(node.val) continue if node.right: stack.append((node.right, False)) stack.append((node, True)) if node.left: stack.append((node.left, False)) return values",
          "description": "Python 中序遍历（boolean 标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]: values = [] stack = [(root, False)] if root else [] while stack: node, visited = stack.pop() if visited: values.append(node.val) continue stack.append((node, True)) if node.right: stack.append((node.right, False)) if node.left: stack.append((node.left, False)) return values",
          "description": "Python 后序遍历（boolean 标记法）"
        }
      ],
      "subsections": []
    },
    {
      "name": "迭代法后序遍历",
      "text": "后续遍历代码如下： (注意此时我们和中序遍历相比仅仅改变了两行代码的顺序)",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);st.push(node);st.push(NULL);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "中序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}if (node->right)st.push(make_pair(node->right, false));st.push(make_pair(node, true));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
          "description": "中序遍历（boolean 标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> preorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);if (node->left) st.push(node->left);st.push(node);st.push(NULL);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "前序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();st.push(node);st.push(NULL);if (node->right) st.push(node->right);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "后序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}st.push(make_pair(node, true));if (node->right)st.push(make_pair(node->right, false));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
          "description": "后序遍历（boolean 标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> preorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);st.push(node);st.push(null);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "Java 前序遍历（空指针标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> inorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);st.push(node);st.push(null);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "Java 中序遍历（空指针标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> postorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();st.push(node);st.push(null);if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "Java 后序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution:def preorderTraversal(self, root: TreeNode) -> List[int]:result = []st= []if root:st.append(root)while st:node = st.pop()if node != None:if node.right:st.append(node.right)if node.left:st.append(node.left)st.append(node)st.append(None)else:node = st.pop()result.append(node.val)return result",
          "description": "Python 前序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution:def inorderTraversal(self, root: TreeNode) -> List[int]:result = []st = []if root:st.append(root)while st:node = st.pop()if node != None:if node.right:st.append(node.right)st.append(node)st.append(None)if node.left:st.append(node.left)else:node = st.pop()result.append(node.val)return result",
          "description": "Python 中序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution:def postorderTraversal(self, root: TreeNode) -> List[int]:result = []st = []if root:st.append(root)while st:node = st.pop()if node != None:st.append(node)st.append(None)if node.right:st.append(node.right)if node.left:st.append(node.left)else:node = st.pop()result.append(node.val)return result",
          "description": "Python 后序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution:def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:values = []stack = [(root, False)] if root else []while stack:node, visited = stack.pop()if visited:values.append(node.val)continueif node.right:stack.append((node.right, False))stack.append((node, True))if node.left:stack.append((node.left, False))return values",
          "description": "Python 中序遍历（boolean 标记法）"
        },
        {
          "language": "python",
          "code": "class Solution:def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:values = []stack = [(root, False)] if root else []while stack:node, visited = stack.pop()if visited:values.append(node.val)continuestack.append((node, True))if node.right:stack.append((node.right, False))if node.left:stack.append((node.left, False))return values",
          "description": "Python 后序遍历（boolean 标记法）"
        }
      ],
      "subsections": []
    },
    {
      "name": "总结",
      "text": "此时我们写出了统一风格的迭代法，不用在纠结于前序写出来了，中序写不出来的情况了。",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);st.push(node);st.push(NULL);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "中序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}if (node->right)st.push(make_pair(node->right, false));st.push(make_pair(node, true));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
          "description": "中序遍历（boolean 标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> preorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);if (node->left) st.push(node->left);st.push(node);st.push(NULL);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "前序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();st.push(node);st.push(NULL);if (node->right) st.push(node->right);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "后序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}st.push(make_pair(node, true));if (node->right)st.push(make_pair(node->right, false));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
          "description": "后序遍历（boolean 标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> preorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);st.push(node);st.push(null);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "Java 前序遍历（空指针标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> inorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);st.push(node);st.push(null);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "Java 中序遍历（空指针标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> postorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();st.push(node);st.push(null);if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "Java 后序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def preorderTraversal(self, root: TreeNode) -> List[int]: result = [] st= [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: st.append(node.right) if node.left: st.append(node.left) st.append(node) st.append(None) else: node = st.pop() result.append(node.val) return result",
          "description": "Python 前序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def inorderTraversal(self, root: TreeNode) -> List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: st.append(node.right) st.append(node) st.append(None) if node.left: st.append(node.left) else: node = st.pop() result.append(node.val) return result",
          "description": "Python 中序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def postorderTraversal(self, root: TreeNode) -> List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: st.append(node) st.append(None) if node.right: st.append(node.right) if node.left: st.append(node.left) else: node = st.pop() result.append(node.val) return result",
          "description": "Python 后序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: values = [] stack = [(root, False)] if root else [] while stack: node, visited = stack.pop() if visited: values.append(node.val) continue if node.right: stack.append((node.right, False)) stack.append((node, True)) if node.left: stack.append((node.left, False)) return values",
          "description": "Python 中序遍历（boolean 标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]: values = [] stack = [(root, False)] if root else [] while stack: node, visited = stack.pop() if visited: values.append(node.val) continue stack.append((node, True)) if node.right: stack.append((node.right, False)) if node.left: stack.append((node.left, False)) return values",
          "description": "Python 后序遍历（boolean 标记法）"
        }
      ],
      "subsections": []
    },
    {
      "name": "其他语言版本",
      "text": "#Java：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);st.push(node);st.push(NULL);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "中序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}if (node->right)st.push(make_pair(node->right, false));st.push(make_pair(node, true));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
          "description": "中序遍历（boolean 标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> preorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);if (node->left) st.push(node->left);st.push(node);st.push(NULL);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "前序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();st.push(node);st.push(NULL);if (node->right) st.push(node->right);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "后序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}st.push(make_pair(node, true));if (node->right)st.push(make_pair(node->right, false));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
          "description": "后序遍历（boolean 标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> preorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);st.push(node);st.push(null);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "迭代法前序遍历"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> inorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);st.push(node);st.push(null);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "迭代法中序遍历"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> postorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();st.push(node);st.push(null);if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "迭代法后序遍历"
        },
        {
          "language": "python",
          "code": "class Solution: def preorderTraversal(self, root: TreeNode) -> List[int]: result = [] st= [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: st.append(node.right) if node.left: st.append(node.left) st.append(node) st.append(None) else: node = st.pop() result.append(node.val) return result",
          "description": "迭代法前序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def inorderTraversal(self, root: TreeNode) -> List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: st.append(node.right) st.append(node) st.append(None) if node.left: st.append(node.left) else: node = st.pop() result.append(node.val) return result",
          "description": "迭代法中序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def postorderTraversal(self, root: TreeNode) -> List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: st.append(node) st.append(None) if node.right: st.append(node.right) if node.left: st.append(node.left) else: node = st.pop() result.append(node.val) return result",
          "description": "迭代法后序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: values = [] stack = [(root, False)] if root else [] while stack: node, visited = stack.pop() if visited: values.append(node.val) continue if node.right: stack.append((node.right, False)) stack.append((node, True)) if node.left: stack.append((node.left, False)) return values",
          "description": "中序遍历，统一迭代（boolean 标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]: values = [] stack = [(root, False)] if root else [] while stack: node, visited = stack.pop() if visited: values.append(node.val) continue stack.append((node, True)) if node.right: stack.append((node.right, False)) if node.left: stack.append((node.left, False)) return values",
          "description": "后序遍历，统一迭代（boolean 标记法）"
        }
      ],
      "subsections": []
    },
    {
      "name": "Java：",
      "text": "迭代法前序遍历代码如下:",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);st.push(node);st.push(NULL);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "中序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}if (node->right)st.push(make_pair(node->right, false));st.push(make_pair(node, true));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
          "description": "中序遍历（boolean 标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> preorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);if (node->left) st.push(node->left);st.push(node);st.push(NULL);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "前序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();st.push(node);st.push(NULL);if (node->right) st.push(node->right);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "后序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}st.push(make_pair(node, true));if (node->right)st.push(make_pair(node->right, false));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
          "description": "后序遍历（boolean 标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> preorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);st.push(node);st.push(null);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "前序遍历（空指针标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> inorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);st.push(node);st.push(null);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "中序遍历（空指针标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> postorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();st.push(node);st.push(null);if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "后序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def preorderTraversal(self, root: TreeNode) -> List[int]: result = [] st= [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: st.append(node.right) if node.left: st.append(node.left) st.append(node) st.append(None) else: node = st.pop() result.append(node.val) return result",
          "description": "前序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def inorderTraversal(self, root: TreeNode) -> List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: st.append(node.right) st.append(node) st.append(None) if node.left: st.append(node.left) else: node = st.pop() result.append(node.val) return result",
          "description": "中序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def postorderTraversal(self, root: TreeNode) -> List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: st.append(node) st.append(None) if node.right: st.append(node.right) if node.left: st.append(node.left) else: node = st.pop() result.append(node.val) return result",
          "description": "后序遍历（空指针标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: values = [] stack = [(root, False)] if root else [] while stack: node, visited = stack.pop() if visited: values.append(node.val) continue if node.right: stack.append((node.right, False)) stack.append((node, True)) if node.left: stack.append((node.left, False)) return values",
          "description": "中序遍历，统一迭代（boolean 标记法）"
        },
        {
          "language": "python",
          "code": "class Solution: def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]: values = [] stack = [(root, False)] if root else [] while stack: node, visited = stack.pop() if visited: values.append(node.val) continue stack.append((node, True)) if node.right: stack.append((node.right, False)) if node.left: stack.append((node.left, False)) return values",
          "description": "后序遍历，统一迭代（boolean 标记法）"
        }
      ],
      "subsections": []
    },
    {
      "name": "Python：",
      "text": "迭代法前序遍历（空指针标记法）：",
      "resources": [],
      "code_snippets": [
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);st.push(node);st.push(NULL);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "中序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}if (node->right)st.push(make_pair(node->right, false));st.push(make_pair(node, true));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
          "description": "中序遍历（boolean 标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> preorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);if (node->left) st.push(node->left);st.push(node);st.push(NULL);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "前序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();st.push(node);st.push(NULL);if (node->right) st.push(node->right);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
          "description": "后序遍历（空指针标记法）"
        },
        {
          "language": "cpp",
          "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}st.push(make_pair(node, true));if (node->right)st.push(make_pair(node->right, false));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
          "description": "后序遍历（boolean 标记法）"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> preorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);st.push(node);st.push(null);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "迭代法前序遍历(Java)"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> inorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);st.push(node);st.push(null);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "迭代法中序遍历(Java)"
        },
        {
          "language": "java",
          "code": "class Solution {public List<Integer> postorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();st.push(node);st.push(null);if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
          "description": "迭代法后序遍历(Java)"
        },
        {
          "language": "python",
          "code": "class Solution:def preorderTraversal(self, root: TreeNode) -> List[int]:result = []st= []if root:st.append(root)while st:node = st.pop()if node != None:if node.right:st.append(node.right)if node.left:st.append(node.left)st.append(node)st.append(None)else:node = st.pop()result.append(node.val)return result",
          "description": "迭代法前序遍历（空指针标记法，Python）"
        },
        {
          "language": "python",
          "code": "class Solution:def inorderTraversal(self, root: TreeNode) -> List[int]:result = []st = []if root:st.append(root)while st:node = st.pop()if node != None:if node.right:st.append(node.right)st.append(node)st.append(None)if node.left:st.append(node.left)else:node = st.pop()result.append(node.val)return result",
          "description": "迭代法中序遍历（空指针标记法，Python）"
        },
        {
          "language": "python",
          "code": "class Solution:def postorderTraversal(self, root: TreeNode) -> List[int]:result = []st = []if root:st.append(root)while st:node = st.pop()if node != None:st.append(node)st.append(None)if node.right:st.append(node.right)if node.left:st.append(node.left)else:node = st.pop()result.append(node.val)return result",
          "description": "迭代法后序遍历（空指针标记法，Python）"
        },
        {
          "language": "python",
          "code": "class Solution:def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:values = []stack = [(root, False)] if root else []while stack:node, visited = stack.pop()if visited:values.append(node.val)continueif node.right:stack.append((node.right, False))stack.append((node, True))if node.left:stack.append((node.left, False))return values",
          "description": "中序遍历，统一迭代（boolean 标记法，Python）"
        },
        {
          "language": "python",
          "code": "class Solution:def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:values = []stack = [(root, False)] if root else []while stack:node, visited = stack.pop()if visited:values.append(node.val)continuestack.append((node, True))if node.right:stack.append((node.right, False))if node.left:stack.append((node.left, False))return values",
          "description": "后序遍历，统一迭代（boolean 标记法，Python）"
        }
      ],
      "subsections": []
    }
  ],
  "complexity_analysis": null,
  "code_solutions": [
    {
      "language": "cpp",
      "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);st.push(node);st.push(NULL);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
      "description": "C++中序遍历（空指针标记法）"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: vector<int> inorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}if (node->right)st.push(make_pair(node->right, false));st.push(make_pair(node, true));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
      "description": "C++中序遍历（boolean 标记法）"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: vector<int> preorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();if (node->right) st.push(node->right);if (node->left) st.push(node->left);st.push(node);st.push(NULL);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
      "description": "C++前序遍历"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<TreeNode*> st;if (root != NULL) st.push(root);while (!st.empty()) {TreeNode* node = st.top();if (node != NULL) {st.pop();st.push(node);st.push(NULL);if (node->right) st.push(node->right);if (node->left) st.push(node->left);} else {st.pop();node = st.top();st.pop();result.push_back(node->val);}}return result;}};",
      "description": "C++后序遍历"
    },
    {
      "language": "cpp",
      "code": "class Solution {public: vector<int> postorderTraversal(TreeNode* root) {vector<int> result;stack<pair<TreeNode*, bool>> st;if (root != nullptr)st.push(make_pair(root, false));while (!st.empty()) {auto node = st.top().first;auto visited = st.top().second;st.pop();if (visited) {result.push_back(node->val);continue;}st.push(make_pair(node, true));if (node->right)st.push(make_pair(node->right, false));if (node->left)st.push(make_pair(node->left, false));}return result;}};",
      "description": "C++后序遍历（boolean 标记法）"
    },
    {
      "language": "java",
      "code": "class Solution {public List<Integer> preorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);st.push(node);st.push(null);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
      "description": "Java前序遍历"
    },
    {
      "language": "java",
      "code": "class Solution {public List<Integer> inorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();if (node.right!=null) st.push(node.right);st.push(node);st.push(null);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
      "description": "Java中序遍历"
    },
    {
      "language": "java",
      "code": "class Solution {public List<Integer> postorderTraversal(TreeNode root) {List<Integer> result = new LinkedList<>();Stack<TreeNode> st = new Stack<>();if (root != null) st.push(root);while (!st.empty()) {TreeNode node = st.peek();if (node != null) {st.pop();st.push(node);st.push(null);if (node.right!=null) st.push(node.right);if (node.left!=null) st.push(node.left);} else {st.pop();node = st.peek();st.pop();result.add(node.val);}}return result;}}",
      "description": "Java后序遍历"
    },
    {
      "language": "python",
      "code": "class Solution: def preorderTraversal(self, root: TreeNode) -> List[int]: result = [] st= [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: st.append(node.right) if node.left: st.append(node.left) st.append(node) st.append(None) else: node = st.pop() result.append(node.val) return result",
      "description": "Python前序遍历（空指针标记法）"
    },
    {
      "language": "python",
      "code": "class Solution: def inorderTraversal(self, root: TreeNode) -> List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: st.append(node.right) st.append(node) st.append(None) if node.left: st.append(node.left) else: node = st.pop() result.append(node.val) return result",
      "description": "Python中序遍历（空指针标记法）"
    },
    {
      "language": "python",
      "code": "class Solution: def postorderTraversal(self, root: TreeNode) -> List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: st.append(node) st.append(None) if node.right: st.append(node.right) if node.left: st.append(node.left) else: node = st.pop() result.append(node.val) return result",
      "description": "Python后序遍历（空指针标记法）"
    },
    {
      "language": "python",
      "code": "class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]: values = [] stack = [(root, False)] if root else [] while stack: node, visited = stack.pop() if visited: values.append(node.val) continue if node.right: stack.append((node.right, False)) stack.append((node, True)) if node.left: stack.append((node.left, False)) return values",
      "description": "Python中序遍历（boolean 标记法）"
    },
    {
      "language": "python",
      "code": "class Solution: def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]: values = [] stack = [(root, False)] if root else [] while stack: node, visited = stack.pop() if visited: values.append(node.val) continue stack.append((node, True)) if node.right: stack.append((node.right, False)) if node.left: stack.append((node.left, False)) return values",
      "description": "Python后序遍历（boolean 标记法）"
    }
  ],
  "common_mistakes": [
    "未正确处理访问与处理节点之间的区别可能导致逻辑错误。",
    "在构造栈时忘记考虑空节点的情况可能会导致程序崩溃。",
    "忽略对特定遍历时节点插入顺序的重要性可能影响最终输出结果。"
  ],
  "similar_problems": [],
  "follow_up_questions": [],
  "all_resources": [
    {
      "type": "image",
      "content": "https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html",
      "description": "图片链接: https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html",
      "context": "该图片展示了使用递归方法实现的二叉树前中后序遍历过程，帮助读者直观理解相关算法。"
    },
    {
      "type": "image",
      "content": "https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html",
      "description": "图片链接: https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html",
      "context": "该图片展示了使用迭代法统一实现二叉树先中后序遍历的方法，辅助说明了如何通过一致的风格来简化非递归遍历代码的编写。"
    },
    {
      "type": "image",
      "content": "https://file1.kamacoder.com/i/algo/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%EF%BC%88%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95%EF%BC%89.gif",
      "description": "图片链接: https://file1.kamacoder.com/i/algo/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%EF%BC%88%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95%EF%BC%89.gif",
      "context": "动画展示了中序遍历过程中节点如何被访问和加入到结果集的步骤。"
    },
    {
      "type": "gif",
      "content": "https://file1.kamacoder.com/i/algo/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%EF%BC%88%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95%EF%BC%89.gif",
      "description": "GIF展示了中序遍历算法执行过程，特别地，通过使用栈来处理节点，并在遇到空节点时将实际节点值加入结果集中。",
      "context": "该GIF动画展示了中序遍历过程中节点如何被加入栈以及何时被添加到结果集的具体步骤。"
    }
  ],
  "source_file": "F:\\My_project\\programmercarl_articles\\problems\\二叉树\\二叉树的统一迭代法.txt",
  "extracted_at": "2025-07-19T17:56:09.980215",
  "raw_content": "二叉树的统一迭代法\n\n思路\n此时我们在二叉树：一入递归深似海，从此offer是路人 (https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html)中用递归的方式，实现了二叉树前中后序的遍历。\n\n在二叉树：听说递归能做的，栈也能做！ (https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html)中用栈实现了二叉树前后中序的迭代遍历（非递归）。\n\n之后我们发现迭代法实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。\n\n实践过的同学，也会发现使用迭代法实现先中后序遍历，很难写出统一的代码，不像是递归法，实现了其中的一种遍历方式，其他两种只要稍稍改一下节点顺序就可以了。\n\n其实针对三种遍历方式，使用迭代法是可以写出统一风格的代码！\n\n重头戏来了，接下来介绍一下统一写法。\n\n我们以中序遍历为例，在二叉树：听说递归能做的，栈也能做！ (https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html)中提到说使用栈的话，无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况。\n\n那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。\n\n如何标记呢？\n\n方法一：就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法可以叫做空指针标记法。\n\n方法二：加一个 boolean 值跟随每个节点，false (默认值) 表示需要为该节点和它的左右儿子安排在栈中的位次，true 表示该节点的位次之前已经安排过了，可以收割节点了。 这种方法可以叫做boolean 标记法，样例代码见下文C++ 和 Python 的 boolean 标记法。 这种方法更容易理解，在面试中更容易写出来。\n\n#迭代法中序遍历\n中序遍历（空指针标记法）代码如下：（详细注释）\n\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> result;\n        stack<TreeNode*> st;\n        if (root != NULL) st.push(root);\n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            if (node != NULL) {\n                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中\n                if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）\n\n                st.push(node);                          // 添加中节点\n                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。\n\n                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）\n            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集\n                st.pop();           // 将空节点弹出\n                node = st.top();    // 重新取出栈中元素\n                st.pop();\n                result.push_back(node->val); // 加入到结果集\n            }\n        }\n        return result;\n    }\n};\n看代码有点抽象我们来看一下动画(中序遍历)：\n\nhttps://file1.kamacoder.com/i/algo/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%EF%BC%88%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95%EF%BC%89.gif\n\n动画中，result数组就是最终结果集。\n\n可以看出我们将访问的节点直接加入到栈中，但如果是处理的节点则后面放入一个空节点， 这样只有空节点弹出的时候，才将下一个节点放进结果集。\n\n中序遍历（boolean 标记法）：\n\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> result;\n        stack<pair<TreeNode*, bool>> st;\n        if (root != nullptr)\n            st.push(make_pair(root, false)); // 多加一个参数，false 为默认值，含义见下文注释\n\n        while (!st.empty()) {\n            auto node = st.top().first;\n            auto visited = st.top().second; //多加一个 visited 参数，使“迭代统一写法”成为一件简单的事\n            st.pop();\n\n            if (visited) { // visited 为 True，表示该节点和两个儿子位次之前已经安排过了，现在可以收割节点了\n                result.push_back(node->val);\n                continue;\n            }\n\n            // visited 当前为 false, 表示初次访问本节点，此次访问的目的是“把自己和两个儿子在栈中安排好位次”。\n            \n            // 中序遍历是'左中右'，右儿子最先入栈，最后出栈。\n            if (node->right)\n                st.push(make_pair(node->right, false));\n            \n            // 把自己加回到栈中，位置居中。\n            // 同时，设置 visited 为 true，表示下次再访问本节点时，允许收割。\n            st.push(make_pair(node, true));\n\n            if (node->left)\n                st.push(make_pair(node->left, false)); // 左儿子最后入栈，最先出栈\n        }\n        \n        return result;\n    }\n};\n此时我们再来看前序遍历代码。\n\n#迭代法前序遍历\n迭代法前序遍历代码如下： (注意此时我们和中序遍历相比仅仅改变了两行代码的顺序)\n\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> result;\n        stack<TreeNode*> st;\n        if (root != NULL) st.push(root);\n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            if (node != NULL) {\n                st.pop();\n                if (node->right) st.push(node->right);  // 右\n                if (node->left) st.push(node->left);    // 左\n                st.push(node);                          // 中\n                st.push(NULL);\n            } else {\n                st.pop();\n                node = st.top();\n                st.pop();\n                result.push_back(node->val);\n            }\n        }\n        return result;\n    }\n};\n#迭代法后序遍历\n后续遍历代码如下： (注意此时我们和中序遍历相比仅仅改变了两行代码的顺序)\n\nclass Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        vector<int> result;\n        stack<TreeNode*> st;\n        if (root != NULL) st.push(root);\n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            if (node != NULL) {\n                st.pop();\n                st.push(node);                          // 中\n                st.push(NULL);\n\n                if (node->right) st.push(node->right);  // 右\n                if (node->left) st.push(node->left);    // 左\n\n            } else {\n                st.pop();\n                node = st.top();\n                st.pop();\n                result.push_back(node->val);\n            }\n        }\n        return result;\n    }\n};\n迭代法后序遍历（boolean 标记法）：\n\nclass Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        vector<int> result;\n        stack<pair<TreeNode*, bool>> st;\n        if (root != nullptr)\n            st.push(make_pair(root, false)); // 多加一个参数，false 为默认值，含义见下文\n\n        while (!st.empty()) {\n            auto node = st.top().first;\n            auto visited = st.top().second; //多加一个 visited 参数，使“迭代统一写法”成为一件简单的事\n            st.pop();\n\n            if (visited) { // visited 为 True，表示该节点和两个儿子位次之前已经安排过了，现在可以收割节点了\n                result.push_back(node->val);\n                continue;\n            }\n\n            // visited 当前为 false, 表示初次访问本节点，此次访问的目的是“把自己和两个儿子在栈中安排好位次”。\n            // 后序遍历是'左右中'，节点自己最先入栈，最后出栈。\n            // 同时，设置 visited 为 true，表示下次再访问本节点时，允许收割。\n            st.push(make_pair(node, true));\n\n            if (node->right)\n                st.push(make_pair(node->right, false)); // 右儿子位置居中\n\n            if (node->left)\n                st.push(make_pair(node->left, false)); // 左儿子最后入栈，最先出栈\n        }\n        \n        return result;\n    }\n};\n#总结\n此时我们写出了统一风格的迭代法，不用在纠结于前序写出来了，中序写不出来的情况了。\n\n但是统一风格的迭代法并不好理解，而且想在面试直接写出来还有难度的。\n\n所以大家根据自己的个人喜好，对于二叉树的前中后序遍历，选择一种自己容易理解的递归和迭代法。\n\n#其他语言版本\n#Java：\n迭代法前序遍历代码如下:\n\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> result = new LinkedList<>();\n        Stack<TreeNode> st = new Stack<>();\n        if (root != null) st.push(root);\n        while (!st.empty()) {\n            TreeNode node = st.peek();\n            if (node != null) {\n                st.pop(); // 将该节点弹出，避免重复操作，下面再将右左中节点添加到栈中（前序遍历-中左右，入栈顺序右左中）\n                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）\n                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）\n                st.push(node);                          // 添加中节点\n                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。\n                \n            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集\n                st.pop();           // 将空节点弹出\n                node = st.peek();    // 重新取出栈中元素\n                st.pop();\n                result.add(node.val); // 加入到结果集\n            }\n        }\n        return result;\n    }\n}\n迭代法中序遍历代码如下:\n\nclass Solution {\npublic List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result = new LinkedList<>();\n    Stack<TreeNode> st = new Stack<>();\n    if (root != null) st.push(root);\n    while (!st.empty()) {\n        TreeNode node = st.peek();\n        if (node != null) {\n            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中（中序遍历-左中右，入栈顺序右中左）\n            if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）\n            st.push(node);                          // 添加中节点\n            st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。\n            if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）\n        } else { // 只有遇到空节点的时候，才将下一个节点放进结果集\n            st.pop();           // 将空节点弹出\n            node = st.peek();    // 重新取出栈中元素\n            st.pop();\n            result.add(node.val); // 加入到结果集\n        }\n    }\n    return result;\n}\n}\n迭代法后序遍历代码如下:\n\nclass Solution {\n   public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> result = new LinkedList<>();\n        Stack<TreeNode> st = new Stack<>();\n        if (root != null) st.push(root);\n        while (!st.empty()) {\n            TreeNode node = st.peek();\n            if (node != null) {\n                st.pop(); // 将该节点弹出，避免重复操作，下面再将中右左节点添加到栈中（后序遍历-左右中，入栈顺序中右左）\n                st.push(node);                          // 添加中节点\n                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。\n                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）\n                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）         \n                               \n            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集\n                st.pop();           // 将空节点弹出\n                node = st.peek();    // 重新取出栈中元素\n                st.pop();\n                result.add(node.val); // 加入到结果集\n            }\n        }\n        return result;\n   }\n}\n#Python：\n迭代法前序遍历（空指针标记法）：\n\nclass Solution:\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\n        result = []\n        st= []\n        if root:\n            st.append(root)\n        while st:\n            node = st.pop()\n            if node != None:\n                if node.right: #右\n                    st.append(node.right)\n                if node.left: #左\n                    st.append(node.left)\n                st.append(node) #中\n                st.append(None)\n            else:\n                node = st.pop()\n                result.append(node.val)\n        return result\n迭代法中序遍历（空指针标记法）：\n\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        result = []\n        st = []\n        if root:\n            st.append(root)\n        while st:\n            node = st.pop()\n            if node != None:\n                if node.right: #添加右节点（空节点不入栈）\n                    st.append(node.right)\n                \n                st.append(node) #添加中节点\n                st.append(None) #中节点访问过，但是还没有处理，加入空节点做为标记。\n                \n                if node.left: #添加左节点（空节点不入栈）\n                    st.append(node.left)\n            else: #只有遇到空节点的时候，才将下一个节点放进结果集\n                node = st.pop() #重新取出栈中元素\n                result.append(node.val) #加入到结果集\n        return result\n迭代法后序遍历（空指针标记法）：\n\nclass Solution:\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\n        result = []\n        st = []\n        if root:\n            st.append(root)\n        while st:\n            node = st.pop()\n            if node != None:\n                st.append(node) #中\n                st.append(None)\n                \n                if node.right: #右\n                    st.append(node.right)\n                if node.left: #左\n                    st.append(node.left)\n            else:\n                node = st.pop()\n                result.append(node.val)\n        return result\n中序遍历，统一迭代（boolean 标记法）：\n\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        values = []\n        stack = [(root, False)] if root else [] # 多加一个参数，False 为默认值，含义见下文\n\n        while stack:\n            node, visited = stack.pop() # 多加一个 visited 参数，使“迭代统一写法”成为一件简单的事\n            \n            if visited: # visited 为 True，表示该节点和两个儿子的位次之前已经安排过了，现在可以收割节点了\n                values.append(node.val)\n                continue\n\n            # visited 当前为 False, 表示初次访问本节点，此次访问的目的是“把自己和两个儿子在栈中安排好位次”。\n            # 中序遍历是'左中右'，右儿子最先入栈，最后出栈。\n            if node.right:\n                stack.append((node.right, False))\n\n            stack.append((node, True)) # 把自己加回到栈中，位置居中。同时，设置 visited 为 True，表示下次再访问本节点时，允许收割\n\n            if node.left:\n                stack.append((node.left, False)) # 左儿子最后入栈，最先出栈\n\n        return values\n后序遍历，统一迭代（boolean 标记法）：\n\nclass Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        values = []\n        stack = [(root, False)] if root else [] # 多加一个参数，False 为默认值，含义见下文\n\n        while stack:\n            node, visited = stack.pop() # 多加一个 visited 参数，使“迭代统一写法”成为一件简单的事\n\n            if visited: # visited 为 True，表示该节点和两个儿子位次之前已经安排过了，现在可以收割节点了\n                values.append(node.val)\n                continue\n\n            # visited 当前为 False, 表示初次访问本节点，此次访问的目的是“把自己和两个儿子在栈中安排好位次”\n            # 后序遍历是'左右中'，节点自己最先入栈，最后出栈。\n            # 同时，设置 visited 为 True，表示下次再访问本节点时，允许收割。\n            stack.append((node, True))\n\n            if node.right:\n                stack.append((node.right, False)) # 右儿子位置居中\n\n            if node.left:\n                stack.append((node.left, False)) # 左儿子最后入栈，最先出栈\n        \n        return values"
}